#include "AES.h"

AES::AES(const AESKeyLength keyLength) {
  switch (keyLength) {
    case AESKeyLength::AES_128:
      this->Nk = 4;
      this->Nr = 10;
      break;
    case AESKeyLength::AES_192:
      this->Nk = 6;
      this->Nr = 12;
      break;
    case AESKeyLength::AES_256:
      this->Nk = 8;
      this->Nr = 14;
      break;
  }
}

unsigned char *AES::EncryptECB(const unsigned char in[], unsigned int inLen,
                               const unsigned char key[]) {
  CheckLength(inLen);
  unsigned char *out = new unsigned char[inLen];
  unsigned char *roundKeys = new unsigned char[4 * Nb * (Nr + 1)];
  KeyExpansion(key, roundKeys);
  for (unsigned int i = 0; i < inLen; i += blockBytesLen) {
    EncryptBlock(in + i, out + i, roundKeys);
  }

  delete[] roundKeys;

  return out;
}

unsigned char *AES::DecryptECB(const unsigned char in[], unsigned int inLen,
                               const unsigned char key[]) {
  CheckLength(inLen);
  unsigned char *out = new unsigned char[inLen];
  unsigned char *roundKeys = new unsigned char[4 * Nb * (Nr + 1)];
  KeyExpansion(key, roundKeys);
  for (unsigned int i = 0; i < inLen; i += blockBytesLen) {
    DecryptBlock(in + i, out + i, roundKeys);
  }

  delete[] roundKeys;

  return out;
}

unsigned char *AES::EncryptCBC(const unsigned char in[], unsigned int inLen,
                               const unsigned char key[],
                               const unsigned char *iv) {
  CheckLength(inLen);
  unsigned char *out = new unsigned char[inLen];
  unsigned char block[blockBytesLen];
  unsigned char *roundKeys = new unsigned char[4 * Nb * (Nr + 1)];
  KeyExpansion(key, roundKeys);
  memcpy(block, iv, blockBytesLen);
  for (unsigned int i = 0; i < inLen; i += blockBytesLen) {
    XorBlocks(block, in + i, block, blockBytesLen);
    EncryptBlock(block, out + i, roundKeys);
    memcpy(block, out + i, blockBytesLen);
  }

  delete[] roundKeys;

  return out;
}

unsigned char *AES::DecryptCBC(const unsigned char in[], unsigned int inLen,
                               const unsigned char key[],
                               const unsigned char *iv) {
  CheckLength(inLen);
  unsigned char *out = new unsigned char[inLen];
  unsigned char block[blockBytesLen];
  unsigned char *roundKeys = new unsigned char[4 * Nb * (Nr + 1)];
  KeyExpansion(key, roundKeys);
  memcpy(block, iv, blockBytesLen);
  for (unsigned int i = 0; i < inLen; i += blockBytesLen) {
    DecryptBlock(in + i, out + i, roundKeys);
    XorBlocks(block, out + i, out + i, blockBytesLen);
    memcpy(block, in + i, blockBytesLen);
  }

  delete[] roundKeys;

  return out;
}

unsigned char *AES::EncryptCFB(const unsigned char in[], unsigned int inLen,
                               const unsigned char key[],
                               const unsigned char *iv) {
  CheckLength(inLen);
  unsigned char *out = new unsigned char[inLen];
  unsigned char block[blockBytesLen];
  unsigned char encryptedBlock[blockBytesLen];
  unsigned char *roundKeys = new unsigned char[4 * Nb * (Nr + 1)];
  KeyExpansion(key, roundKeys);
  memcpy(block, iv, blockBytesLen);
  for (unsigned int i = 0; i < inLen; i += blockBytesLen) {
    EncryptBlock(block, encryptedBlock, roundKeys);
    XorBlocks(in + i, encryptedBlock, out + i, blockBytesLen);
    memcpy(block, out + i, blockBytesLen);
  }

  delete[] roundKeys;

  return out;
}

unsigned char *AES::DecryptCFB(const unsigned char in[], unsigned int inLen,
                               const unsigned char key[],
                               const unsigned char *iv) {
  CheckLength(inLen);
  unsigned char *out = new unsigned char[inLen];
  unsigned char block[blockBytesLen];
  unsigned char encryptedBlock[blockBytesLen];
  unsigned char *roundKeys = new unsigned char[4 * Nb * (Nr + 1)];
  KeyExpansion(key, roundKeys);
  memcpy(block, iv, blockBytesLen);
  for (unsigned int i = 0; i < inLen; i += blockBytesLen) {
    EncryptBlock(block, encryptedBlock, roundKeys);
    XorBlocks(in + i, encryptedBlock, out + i, blockBytesLen);
    memcpy(block, in + i, blockBytesLen);
  }

  delete[] roundKeys;

  return out;
}

void AES::CheckLength(unsigned int len) {
  if (len % blockBytesLen != 0) {
    throw std::length_error("Plaintext length must be divisible by " +
                            std::to_string(blockBytesLen));
  }
}

void AES::EncryptBlock(const unsigned char in[], unsigned char out[],
                       unsigned char *roundKeys) {
  unsigned char state[4][Nb];
  unsigned int i, j, round;

  for (i = 0; i < 4; i++) {
    for (j = 0; j < Nb; j++) {
      state[i][j] = in[i + 4 * j];
    }
  }

  AddRoundKey(state, roundKeys);

  for (round = 1; round <= Nr - 1; round++) {
    SubBytes(state);
    ShiftRows(state);
    MixColumns(state);
    AddRoundKey(state, roundKeys + round * 4 * Nb);
  }

  SubBytes(state);
  ShiftRows(state);
  AddRoundKey(state, roundKeys + Nr * 4 * Nb);

  for (i = 0; i < 4; i++) {
    for (j = 0; j < Nb; j++) {
      out[i + 4 * j] = state[i][j];
    }
  }
}

void AES::DecryptBlock(const unsigned char in[], unsigned char out[],
                       unsigned char *roundKeys) {
  unsigned char state[4][Nb];
  unsigned int i, j, round;

  for (i = 0; i < 4; i++) {
    for (j = 0; j < Nb; j++) {
      state[i][j] = in[i + 4 * j];
    }
  }

  AddRoundKey(state, roundKeys + Nr * 4 * Nb);

  for (round = Nr - 1; round >= 1; round--) {
    InvSubBytes(state);
    InvShiftRows(state);
    AddRoundKey(state, roundKeys + round * 4 * Nb);
    InvMixColumns(state);
  }

  InvSubBytes(state);
  InvShiftRows(state);
  AddRoundKey(state, roundKeys);

  for (i = 0; i < 4; i++) {
    for (j = 0; j < Nb; j++) {
      out[i + 4 * j] = state[i][j];
    }
  }
}

void AES::SubBytes(unsigned char state[4][Nb]) {
  unsigned int i, j;
  unsigned char t;
  for (i = 0; i < 4; i++) {
    for (j = 0; j < Nb; j++) {
      t = state[i][j];
      state[i][j] = sbox[t / 16][t % 16];
    }
  }
}

void AES::ShiftRow(unsigned char state[4][Nb], unsigned int i,
                   unsigned int n)  // shift row i on n positions
{
  unsigned char tmp[Nb];
  for (unsigned int j = 0; j < Nb; j++) {
    tmp[j] = state[i][(j + n) % Nb];
  }
  memcpy(state[i], tmp, Nb * sizeof(unsigned char));
}

void AES::ShiftRows(unsigned char state[4][Nb]) {
  ShiftRow(state, 1, 1);
  ShiftRow(state, 2, 2);
  ShiftRow(state, 3, 3);
}

unsigned char AES::xtime(unsigned char b)  // multiply on x
{
  return (b << 1) ^ (((b >> 7) & 1) * 0x1b);
}

void AES::MixColumns(unsigned char state[4][Nb]) {
  unsigned char temp_state[4][Nb];

  for (size_t i = 0; i < 4; ++i) {
    memset(temp_state[i], 0, 4);
  }

  for (size_t i = 0; i < 4; ++i) {
    for (size_t k = 0; k < 4; ++k) {
      for (size_t j = 0; j < 4; ++j) {
        if (CMDS[i][k] == 1)
          temp_state[i][j] ^= state[k][j];
        else
          temp_state[i][j] ^= GF_MUL_TABLE[CMDS[i][k]][state[k][j]];
      }
    }
  }

  for (size_t i = 0; i < 4; ++i) {
    memcpy(state[i], temp_state[i], 4);
  }
}

void AES::AddRoundKey(unsigned char state[4][Nb], unsigned char *key) {
  unsigned int i, j;
  for (i = 0; i < 4; i++) {
    for (j = 0; j < Nb; j++) {
      state[i][j] = state[i][j] ^ key[i + 4 * j];
    }
  }
}

void AES::SubWord(unsigned char *a) {
  int i;
  for (i = 0; i < 4; i++) {
    a[i] = sbox[a[i] / 16][a[i] % 16];
  }
}

void AES::RotWord(unsigned char *a) {
  unsigned char c = a[0];
  a[0] = a[1];
  a[1] = a[2];
  a[2] = a[3];
  a[3] = c;
}

void AES::XorWords(unsigned char *a, unsigned char *b, unsigned char *c) {
  int i;
  for (i = 0; i < 4; i++) {
    c[i] = a[i] ^ b[i];
  }
}

void AES::Rcon(unsigned char *a, unsigned int n) {
  unsigned int i;
  unsigned char c = 1;
  for (i = 0; i < n - 1; i++) {
    c = xtime(c);
  }

  a[0] = c;
  a[1] = a[2] = a[3] = 0;
}

void AES::KeyExpansion(const unsigned char key[], unsigned char w[]) {
  unsigned char temp[4];
  unsigned char rcon[4];

  unsigned int i = 0;
  while (i < 4 * Nk) {
    w[i] = key[i];
    i++;
  }

  i = 4 * Nk;
  while (i < 4 * Nb * (Nr + 1)) {
    temp[0] = w[i - 4 + 0];
    temp[1] = w[i - 4 + 1];
    temp[2] = w[i - 4 + 2];
    temp[3] = w[i - 4 + 3];

    if (i / 4 % Nk == 0) {
      RotWord(temp);
      SubWord(temp);
      Rcon(rcon, i / (Nk * 4));
      XorWords(temp, rcon, temp);
    } else if (Nk > 6 && i / 4 % Nk == 4) {
      SubWord(temp);
    }

    w[i + 0] = w[i - 4 * Nk] ^ temp[0];
    w[i + 1] = w[i + 1 - 4 * Nk] ^ temp[1];
    w[i + 2] = w[i + 2 - 4 * Nk] ^ temp[2];
    w[i + 3] = w[i + 3 - 4 * Nk] ^ temp[3];
    i += 4;
  }
}

void AES::InvSubBytes(unsigned char state[4][Nb]) {
  unsigned int i, j;
  unsigned char t;
  for (i = 0; i < 4; i++) {
    for (j = 0; j < Nb; j++) {
      t = state[i][j];
      state[i][j] = inv_sbox[t / 16][t % 16];
    }
  }
}

void AES::InvMixColumns(unsigned char state[4][Nb]) {
  unsigned char temp_state[4][Nb];

  for (size_t i = 0; i < 4; ++i) {
    memset(temp_state[i], 0, 4);
  }

  for (size_t i = 0; i < 4; ++i) {
    for (size_t k = 0; k < 4; ++k) {
      for (size_t j = 0; j < 4; ++j) {
        temp_state[i][j] ^= GF_MUL_TABLE[INV_CMDS[i][k]][state[k][j]];
      }
    }
  }

  for (size_t i = 0; i < 4; ++i) {
    memcpy(state[i], temp_state[i], 4);
  }
}

void AES::InvShiftRows(unsigned char state[4][Nb]) {
  ShiftRow(state, 1, Nb - 1);
  ShiftRow(state, 2, Nb - 2);
  ShiftRow(state, 3, Nb - 3);
}

void AES::XorBlocks(const unsigned char *a, const unsigned char *b,
                    unsigned char *c, unsigned int len) {
  for (unsigned int i = 0; i < len; i++) {
    c[i] = a[i] ^ b[i];
  }
}

void AES::printHexArray(unsigned char a[], unsigned int n) {
  for (unsigned int i = 0; i < n; i++) {
    printf("%02x ", a[i]);
  }
}

void AES::printHexVector(std::vector<unsigned char> a) {
  for (unsigned int i = 0; i < a.size(); i++) {
    printf("%02x ", a[i]);
  }
}

std::vector<unsigned char> AES::ArrayToVector(unsigned char *a,
                                              unsigned int len) {
  std::vector<unsigned char> v(a, a + len * sizeof(unsigned char));
  return v;
}

unsigned char *AES::VectorToArray(std::vector<unsigned char> &a) {
  return a.data();
}

std::vector<unsigned char> AES::EncryptECB(std::vector<unsigned char> in,
                                           std::vector<unsigned char> key) {
  unsigned char *out = EncryptECB(VectorToArray(in), (unsigned int)in.size(),
                                  VectorToArray(key));
  std::vector<unsigned char> v = ArrayToVector(out, in.size());
  delete[] out;
  return v;
}

std::vector<unsigned char> AES::DecryptECB(std::vector<unsigned char> in,
                                           std::vector<unsigned char> key) {
  unsigned char *out = DecryptECB(VectorToArray(in), (unsigned int)in.size(),
                                  VectorToArray(key));
  std::vector<unsigned char> v = ArrayToVector(out, (unsigned int)in.size());
  delete[] out;
  return v;
}

std::vector<unsigned char> AES::EncryptCBC(std::vector<unsigned char> in,
                                           std::vector<unsigned char> key,
                                           std::vector<unsigned char> iv) {
  unsigned char *out = EncryptCBC(VectorToArray(in), (unsigned int)in.size(),
                                  VectorToArray(key), VectorToArray(iv));
  std::vector<unsigned char> v = ArrayToVector(out, in.size());
  delete[] out;
  return v;
}

std::vector<unsigned char> AES::DecryptCBC(std::vector<unsigned char> in,
                                           std::vector<unsigned char> key,
                                           std::vector<unsigned char> iv) {
  unsigned char *out = DecryptCBC(VectorToArray(in), (unsigned int)in.size(),
                                  VectorToArray(key), VectorToArray(iv));
  std::vector<unsigned char> v = ArrayToVector(out, (unsigned int)in.size());
  delete[] out;
  return v;
}

std::vector<unsigned char> AES::EncryptCFB(std::vector<unsigned char> in,
                                           std::vector<unsigned char> key,
                                           std::vector<unsigned char> iv) {
  unsigned char *out = EncryptCFB(VectorToArray(in), (unsigned int)in.size(),
                                  VectorToArray(key), VectorToArray(iv));
  std::vector<unsigned char> v = ArrayToVector(out, in.size());
  delete[] out;
  return v;
}

std::vector<unsigned char> AES::DecryptCFB(std::vector<unsigned char> in,
                                           std::vector<unsigned char> key,
                                           std::vector<unsigned char> iv) {
  unsigned char *out = DecryptCFB(VectorToArray(in), (unsigned int)in.size(),
                                  VectorToArray(key), VectorToArray(iv));
  std::vector<unsigned char> v = ArrayToVector(out, (unsigned int)in.size());
  delete[] out;
  return v;
}
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_HPP
#define ELFIO_HPP

#include <string>
#include <iostream>
#include <fstream>
#include <functional>
#include <algorithm>
#include <array>
#include <vector>
#include <deque>
#include <memory>

#include <elfio/elf_types.hpp>
#include <elfio/elfio_version.hpp>
#include <elfio/elfio_utils.hpp>
#include <elfio/elfio_header.hpp>
#include <elfio/elfio_section.hpp>
#include <elfio/elfio_segment.hpp>
#include <elfio/elfio_strings.hpp>

#define ELFIO_HEADER_ACCESS_GET( TYPE, FNAME ) \
    TYPE get_##FNAME() const { return header ? ( header->get_##FNAME() ) : 0; }

#define ELFIO_HEADER_ACCESS_GET_SET( TYPE, FNAME )     \
    TYPE get_##FNAME() const                           \
    {                                                  \
        return header ? ( header->get_##FNAME() ) : 0; \
    }                                                  \
    void set_##FNAME( TYPE val )                       \
    {                                                  \
        if ( header ) {                                \
            header->set_##FNAME( val );                \
        }                                              \
    }

namespace ELFIO {

//------------------------------------------------------------------------------
class elfio
{
  public:
    //------------------------------------------------------------------------------
    elfio() noexcept : sections( this ), segments( this )
    {
        create( ELFCLASS32, ELFDATA2LSB );
    }

    explicit elfio( compression_interface* compression ) noexcept
        : sections( this ), segments( this ),
          compression( std::shared_ptr<compression_interface>( compression ) )
    {
        elfio();
    }

    elfio( elfio&& other ) noexcept
        : sections( this ), segments( this ),
          current_file_pos( other.current_file_pos )
    {
        header          = std::move( other.header );
        sections_       = std::move( other.sections_ );
        segments_       = std::move( other.segments_ );
        convertor       = std::move( other.convertor );
        addr_translator = std::move( other.addr_translator );
        compression     = std::move( other.compression );

        other.header = nullptr;
        other.sections_.clear();
        other.segments_.clear();
        other.compression = nullptr;
    }

    elfio& operator=( elfio&& other ) noexcept
    {
        if ( this != &other ) {
            header           = std::move( other.header );
            sections_        = std::move( other.sections_ );
            segments_        = std::move( other.segments_ );
            convertor        = std::move( other.convertor );
            addr_translator  = std::move( other.addr_translator );
            current_file_pos = other.current_file_pos;
            compression      = std::move( other.compression );

            other.current_file_pos = 0;
            other.header           = nullptr;
            other.compression      = nullptr;
            other.sections_.clear();
            other.segments_.clear();
        }
        return *this;
    }

    //------------------------------------------------------------------------------
    // clang-format off
    elfio( const elfio& )            = delete;
    elfio& operator=( const elfio& ) = delete;
    ~elfio()                         = default;
    // clang-format on

    //------------------------------------------------------------------------------
    void create( unsigned char file_class, unsigned char encoding )
    {
        sections_.clear();
        segments_.clear();
        convertor.setup( encoding );
        header = create_header( file_class, encoding );
        create_mandatory_sections();
    }

    void set_address_translation( std::vector<address_translation>& addr_trans )
    {
        addr_translator.set_address_translation( addr_trans );
    }

    //------------------------------------------------------------------------------
    bool load( const std::string& file_name, bool is_lazy = false )
    {
        pstream = std::make_unique<std::ifstream>();
        pstream->open( file_name.c_str(), std::ios::in | std::ios::binary );
        if ( pstream == nullptr || !*pstream ) {
            return false;
        }

        bool ret = load( *pstream, is_lazy );

        if ( !is_lazy ) {
            pstream.reset();
        }

        return ret;
    }

    //------------------------------------------------------------------------------
    bool load( std::istream& stream, bool is_lazy = false )
    {
        sections_.clear();
        segments_.clear();

        std::array<char, EI_NIDENT> e_ident = { 0 };
        // Read ELF file signature
        stream.seekg( addr_translator[0] );
        stream.read( e_ident.data(), sizeof( e_ident ) );

        // Is it ELF file?
        if ( stream.gcount() != sizeof( e_ident ) ||
             e_ident[EI_MAG0] != ELFMAG0 || e_ident[EI_MAG1] != ELFMAG1 ||
             e_ident[EI_MAG2] != ELFMAG2 || e_ident[EI_MAG3] != ELFMAG3 ) {
            return false;
        }

        if ( ( e_ident[EI_CLASS] != ELFCLASS64 ) &&
             ( e_ident[EI_CLASS] != ELFCLASS32 ) ) {
            return false;
        }

        if ( ( e_ident[EI_DATA] != ELFDATA2LSB ) &&
             ( e_ident[EI_DATA] != ELFDATA2MSB ) ) {
            return false;
        }

        convertor.setup( e_ident[EI_DATA] );
        header = create_header( e_ident[EI_CLASS], e_ident[EI_DATA] );
        if ( nullptr == header ) {
            return false;
        }
        if ( !header->load( stream ) ) {
            return false;
        }

        load_sections( stream, is_lazy );
        bool is_still_good = load_segments( stream, is_lazy );
        return is_still_good;
    }

    //------------------------------------------------------------------------------
    bool save( const std::string& file_name )
    {
        std::ofstream stream;
        stream.open( file_name.c_str(), std::ios::out | std::ios::binary );
        if ( !stream ) {
            return false;
        }

        return save( stream );
    }

    //------------------------------------------------------------------------------
    bool save( std::ostream& stream )
    {
        if ( !stream || header == nullptr ) {
            return false;
        }

        // Define layout specific header fields
        // The position of the segment table is fixed after the header.
        // The position of the section table is variable and needs to be fixed
        // before saving.
        header->set_segments_num( segments.size() );
        header->set_segments_offset(
            segments.size() > 0 ? header->get_header_size() : 0 );
        header->set_sections_num( sections.size() );
        header->set_sections_offset( 0 );

        // Layout the first section right after the segment table
        current_file_pos =
            header->get_header_size() +
            header->get_segment_entry_size() *
                static_cast<Elf_Xword>( header->get_segments_num() );

        calc_segment_alignment();

        bool is_still_good = layout_segments_and_their_sections();
        is_still_good = is_still_good && layout_sections_without_segments();
        is_still_good = is_still_good && layout_section_table();

        is_still_good = is_still_good && save_header( stream );
        is_still_good = is_still_good && save_sections( stream );
        is_still_good = is_still_good && save_segments( stream );

        return is_still_good;
    }

    //------------------------------------------------------------------------------
    // ELF header access functions
    ELFIO_HEADER_ACCESS_GET( unsigned char, class );
    ELFIO_HEADER_ACCESS_GET( unsigned char, elf_version );
    ELFIO_HEADER_ACCESS_GET( unsigned char, encoding );
    ELFIO_HEADER_ACCESS_GET( Elf_Word, version );
    ELFIO_HEADER_ACCESS_GET( Elf_Half, header_size );
    ELFIO_HEADER_ACCESS_GET( Elf_Half, section_entry_size );
    ELFIO_HEADER_ACCESS_GET( Elf_Half, segment_entry_size );

    ELFIO_HEADER_ACCESS_GET_SET( unsigned char, os_abi );
    ELFIO_HEADER_ACCESS_GET_SET( unsigned char, abi_version );
    ELFIO_HEADER_ACCESS_GET_SET( Elf_Half, type );
    ELFIO_HEADER_ACCESS_GET_SET( Elf_Half, machine );
    ELFIO_HEADER_ACCESS_GET_SET( Elf_Word, flags );
    ELFIO_HEADER_ACCESS_GET_SET( Elf64_Addr, entry );
    ELFIO_HEADER_ACCESS_GET_SET( Elf64_Off, sections_offset );
    ELFIO_HEADER_ACCESS_GET_SET( Elf64_Off, segments_offset );
    ELFIO_HEADER_ACCESS_GET_SET( Elf_Half, section_name_str_index );

    //------------------------------------------------------------------------------
    const endianess_convertor& get_convertor() const { return convertor; }

    //------------------------------------------------------------------------------
    Elf_Xword get_default_entry_size( Elf_Word section_type ) const
    {
        switch ( section_type ) {
        case SHT_RELA:
            if ( header->get_class() == ELFCLASS64 ) {
                return sizeof( Elf64_Rela );
            }
            else {
                return sizeof( Elf32_Rela );
            }
        case SHT_REL:
            if ( header->get_class() == ELFCLASS64 ) {
                return sizeof( Elf64_Rel );
            }
            else {
                return sizeof( Elf32_Rel );
            }
        case SHT_SYMTAB:
            if ( header->get_class() == ELFCLASS64 ) {
                return sizeof( Elf64_Sym );
            }
            else {
                return sizeof( Elf32_Sym );
            }
        case SHT_DYNAMIC:
            if ( header->get_class() == ELFCLASS64 ) {
                return sizeof( Elf64_Dyn );
            }
            else {
                return sizeof( Elf32_Dyn );
            }
        default:
            return 0;
        }
    }

    //------------------------------------------------------------------------------
    //! returns an empty string if no problems are detected,
    //! or a string containing an error message if problems are found,
    //! with one error per line.
    std::string validate() const
    {
        // clang-format off

        std::string errors;
        // Check for overlapping sections in the file
        // This is explicitly forbidden by ELF specification
        for ( int i = 0; i < sections.size(); ++i) {
            for ( int j = i+1; j < sections.size(); ++j ) {
                const section* a = sections[i];
                const section* b = sections[j];
                if (   ( ( a->get_type() & SHT_NOBITS) == 0 )
                    && ( ( b->get_type() & SHT_NOBITS) == 0 )
                    && ( a->get_size() > 0 )
                    && ( b->get_size() > 0 )
                    && ( a->get_offset() > 0 )
                    && ( b->get_offset() > 0 )
                    && ( is_offset_in_section( a->get_offset(), b )
                      || is_offset_in_section( a->get_offset()+a->get_size()-1, b )
                      || is_offset_in_section( b->get_offset(), a )
                      || is_offset_in_section( b->get_offset()+b->get_size()-1, a ) ) ) {
                        errors += "Sections " + a->get_name() + " and " + b->get_name() + " overlap in file\n";
                }
            }
        }
        // clang-format on

        // Check for conflicting section / program header tables, where
        // the same offset has different vaddresses in section table and
        // program header table.
        // This doesn't seem to be  explicitly forbidden by ELF specification,
        // but:
        // - it doesn't make any sense
        // - ELFIO relies on this being consistent when writing ELF files,
        //   since offsets are re-calculated from vaddress
        for ( int h = 0; h < segments.size(); ++h ) {
            const segment* seg = segments[h];
            const section* sec =
                find_prog_section_for_offset( seg->get_offset() );
            if ( seg->get_type() == PT_LOAD && seg->get_file_size() > 0 &&
                 sec != nullptr ) {
                Elf64_Addr sec_addr =
                    get_virtual_addr( seg->get_offset(), sec );
                if ( sec_addr != seg->get_virtual_address() ) {
                    errors += "Virtual address of segment " +
                              std::to_string( h ) + " (" +
                              to_hex_string( seg->get_virtual_address() ) +
                              ")" + " conflicts with address of section " +
                              sec->get_name() + " (" +
                              to_hex_string( sec_addr ) + ")" + " at offset " +
                              to_hex_string( seg->get_offset() ) + "\n";
                }
            }
        }

        // more checks to be added here...

        return errors;
    }

  private:
    //------------------------------------------------------------------------------
    static bool is_offset_in_section( Elf64_Off offset, const section* sec )
    {
        return ( offset >= sec->get_offset() ) &&
               ( offset < ( sec->get_offset() + sec->get_size() ) );
    }

    //------------------------------------------------------------------------------
    static Elf64_Addr get_virtual_addr( Elf64_Off offset, const section* sec )
    {
        return sec->get_address() + offset - sec->get_offset();
    }

    //------------------------------------------------------------------------------
    const section* find_prog_section_for_offset( Elf64_Off offset ) const
    {
        for ( const auto& sec : sections ) {
            if ( sec->get_type() == SHT_PROGBITS &&
                 is_offset_in_section( offset, sec.get() ) ) {
                return sec.get();
            }
        }
        return nullptr;
    }

    //------------------------------------------------------------------------------
    std::unique_ptr<elf_header> create_header( unsigned char file_class,
                                               unsigned char encoding )
    {
        std::unique_ptr<elf_header> new_header;

        if ( file_class == ELFCLASS64 ) {
            new_header = std::unique_ptr<elf_header>(
                new ( std::nothrow ) elf_header_impl<Elf64_Ehdr>(
                    &convertor, encoding, &addr_translator ) );
        }
        else if ( file_class == ELFCLASS32 ) {
            new_header = std::unique_ptr<elf_header>(
                new ( std::nothrow ) elf_header_impl<Elf32_Ehdr>(
                    &convertor, encoding, &addr_translator ) );
        }
        else {
            return nullptr;
        }

        return new_header;
    }

    //------------------------------------------------------------------------------
    section* create_section()
    {
        if ( auto file_class = get_class(); file_class == ELFCLASS64 ) {
            sections_.emplace_back(
                new ( std::nothrow ) section_impl<Elf64_Shdr>(
                    &convertor, &addr_translator, compression ) );
        }
        else if ( file_class == ELFCLASS32 ) {
            sections_.emplace_back(
                new ( std::nothrow ) section_impl<Elf32_Shdr>(
                    &convertor, &addr_translator, compression ) );
        }
        else {
            sections_.pop_back();
            return nullptr;
        }

        section* new_section = sections_.back().get();
        new_section->set_index( static_cast<Elf_Half>( sections_.size() - 1 ) );

        return new_section;
    }

    //------------------------------------------------------------------------------
    segment* create_segment()
    {
        if ( auto file_class = header->get_class(); file_class == ELFCLASS64 ) {
            segments_.emplace_back(
                new ( std::nothrow )
                    segment_impl<Elf64_Phdr>( &convertor, &addr_translator ) );
        }
        else if ( file_class == ELFCLASS32 ) {
            segments_.emplace_back(
                new ( std::nothrow )
                    segment_impl<Elf32_Phdr>( &convertor, &addr_translator ) );
        }
        else {
            segments_.pop_back();
            return nullptr;
        }

        segment* new_segment = segments_.back().get();
        new_segment->set_index( static_cast<Elf_Half>( segments_.size() - 1 ) );

        return new_segment;
    }

    //------------------------------------------------------------------------------
    void create_mandatory_sections()
    {
        // Create null section without calling to 'add_section' as no string
        // section containing section names exists yet
        section* sec0 = create_section();
        sec0->set_index( 0 );
        sec0->set_name( "" );
        sec0->set_name_string_offset( 0 );

        set_section_name_str_index( 1 );
        section* shstrtab = sections.add( ".shstrtab" );
        shstrtab->set_type( SHT_STRTAB );
        shstrtab->set_addr_align( 1 );
    }

    //------------------------------------------------------------------------------
    bool load_sections( std::istream& stream, bool is_lazy )
    {
        unsigned char file_class = header->get_class();
        Elf_Half      entry_size = header->get_section_entry_size();
        Elf_Half      num        = header->get_sections_num();
        Elf64_Off     offset     = header->get_sections_offset();

        if ( ( num != 0 && file_class == ELFCLASS64 &&
               entry_size < sizeof( Elf64_Shdr ) ) ||
             ( num != 0 && file_class == ELFCLASS32 &&
               entry_size < sizeof( Elf32_Shdr ) ) ) {
            return false;
        }

        for ( Elf_Half i = 0; i < num; ++i ) {
            section* sec = create_section();
            sec->load( stream,
                       static_cast<std::streamoff>( offset ) +
                           static_cast<std::streampos>( i ) * entry_size,
                       is_lazy );
            // To mark that the section is not permitted to reassign address
            // during layout calculation
            sec->set_address( sec->get_address() );
        }

        if ( Elf_Half shstrndx = get_section_name_str_index();
             SHN_UNDEF != shstrndx ) {
            string_section_accessor str_reader( sections[shstrndx] );
            for ( Elf_Half i = 0; i < num; ++i ) {
                Elf_Word section_offset = sections[i]->get_name_string_offset();
                const char* p = str_reader.get_string( section_offset );
                if ( p != nullptr ) {
                    sections[i]->set_name( p );
                }
            }
        }

        return true;
    }

    //------------------------------------------------------------------------------
    //! Checks whether the addresses of the section entirely fall within the given segment.
    //! It doesn't matter if the addresses are memory addresses, or file offsets,
    //!  they just need to be in the same address space
    static bool is_sect_in_seg( Elf64_Off sect_begin,
                                Elf_Xword sect_size,
                                Elf64_Off seg_begin,
                                Elf64_Off seg_end )
    {
        return ( seg_begin <= sect_begin ) &&
               ( sect_begin + sect_size <= seg_end ) &&
               ( sect_begin <
                 seg_end ); // this is important criteria when sect_size == 0
        // Example:  seg_begin=10, seg_end=12 (-> covering the bytes 10 and 11)
        //           sect_begin=12, sect_size=0  -> shall return false!
    }

    //------------------------------------------------------------------------------
    bool load_segments( std::istream& stream, bool is_lazy )
    {
        unsigned char file_class = header->get_class();
        Elf_Half      entry_size = header->get_segment_entry_size();
        Elf_Half      num        = header->get_segments_num();
        Elf64_Off     offset     = header->get_segments_offset();

        if ( ( num != 0 && file_class == ELFCLASS64 &&
               entry_size < sizeof( Elf64_Phdr ) ) ||
             ( num != 0 && file_class == ELFCLASS32 &&
               entry_size < sizeof( Elf32_Phdr ) ) ) {
            return false;
        }

        for ( Elf_Half i = 0; i < num; ++i ) {
            if ( file_class == ELFCLASS64 ) {
                segments_.emplace_back(
                    new ( std::nothrow ) segment_impl<Elf64_Phdr>(
                        &convertor, &addr_translator ) );
            }
            else if ( file_class == ELFCLASS32 ) {
                segments_.emplace_back(
                    new ( std::nothrow ) segment_impl<Elf32_Phdr>(
                        &convertor, &addr_translator ) );
            }
            else {
                segments_.pop_back();
                return false;
            }

            segment* seg = segments_.back().get();

            if ( !seg->load( stream,
                             static_cast<std::streamoff>( offset ) +
                                 static_cast<std::streampos>( i ) * entry_size,
                             is_lazy ) ||
                 stream.fail() ) {
                segments_.pop_back();
                return false;
            }

            seg->set_index( i );

            // Add sections to the segments (similar to readelfs algorithm)
            Elf64_Off segBaseOffset = seg->get_offset();
            Elf64_Off segEndOffset  = segBaseOffset + seg->get_file_size();
            Elf64_Off segVBaseAddr  = seg->get_virtual_address();
            Elf64_Off segVEndAddr   = segVBaseAddr + seg->get_memory_size();
            for ( const auto& psec : sections ) {
                // SHF_ALLOC sections are matched based on the virtual address
                // otherwise the file offset is matched
                if ( ( ( psec->get_flags() & SHF_ALLOC ) == SHF_ALLOC )
                         ? is_sect_in_seg( psec->get_address(),
                                           psec->get_size(), segVBaseAddr,
                                           segVEndAddr )
                         : is_sect_in_seg( psec->get_offset(), psec->get_size(),
                                           segBaseOffset, segEndOffset ) ) {
                    // Alignment of segment shall not be updated, to preserve original value
                    // It will be re-calculated on saving.
                    seg->add_section_index( psec->get_index(), 0 );
                }
            }
        }

        return true;
    }

    //------------------------------------------------------------------------------
    bool save_header( std::ostream& stream ) const
    {
        return header->save( stream );
    }

    //------------------------------------------------------------------------------
    bool save_sections( std::ostream& stream ) const
    {
        for ( const auto& sec : sections_ ) {
            std::streampos headerPosition =
                static_cast<std::streamoff>( header->get_sections_offset() ) +
                static_cast<std::streampos>(
                    header->get_section_entry_size() ) *
                    sec->get_index();

            sec->save( stream, headerPosition, sec->get_offset() );
        }
        return true;
    }

    //------------------------------------------------------------------------------
    bool save_segments( std::ostream& stream ) const
    {
        for ( const auto& seg : segments_ ) {
            std::streampos headerPosition =
                static_cast<std::streamoff>( header->get_segments_offset() ) +
                static_cast<std::streampos>(
                    header->get_segment_entry_size() ) *
                    seg->get_index();

            seg->save( stream, headerPosition, seg->get_offset() );
        }
        return true;
    }

    //------------------------------------------------------------------------------
    bool is_section_without_segment( unsigned int section_index ) const
    {
        bool found = false;

        for ( unsigned int j = 0; !found && ( j < segments.size() ); ++j ) {
            for ( Elf_Half k = 0;
                  !found && ( k < segments[j]->get_sections_num() ); ++k ) {
                found = segments[j]->get_section_index_at( k ) == section_index;
            }
        }

        return !found;
    }

    //------------------------------------------------------------------------------
    static bool is_subsequence_of( const segment* seg1, const segment* seg2 )
    {
        // Return 'true' if sections of seg1 are a subset of sections in seg2
        const std::vector<Elf_Half>& sections1 = seg1->get_sections();
        const std::vector<Elf_Half>& sections2 = seg2->get_sections();

        bool found = false;
        if ( sections1.size() < sections2.size() ) {
            found = std::includes( sections2.begin(), sections2.end(),
                                   sections1.begin(), sections1.end() );
        }

        return found;
    }

    //------------------------------------------------------------------------------
    std::vector<segment*> get_ordered_segments() const
    {
        std::vector<segment*> res;
        std::deque<segment*>  worklist;

        res.reserve( segments.size() );
        for ( const auto& seg : segments ) {
            worklist.emplace_back( seg.get() );
        }

        // Bring the segments which start at address 0 to the front
        size_t nextSlot = 0;
        for ( size_t i = 0; i < worklist.size(); ++i ) {
            if ( i != nextSlot && worklist[i]->is_offset_initialized() &&
                 worklist[i]->get_offset() == 0 ) {
                if ( worklist[nextSlot]->get_offset() == 0 ) {
                    ++nextSlot;
                }
                std::swap( worklist[i], worklist[nextSlot] );
                ++nextSlot;
            }
        }

        while ( !worklist.empty() ) {
            segment* seg = worklist.front();
            worklist.pop_front();

            size_t i = 0;
            for ( ; i < worklist.size(); ++i ) {
                if ( is_subsequence_of( seg, worklist[i] ) ) {
                    break;
                }
            }

            if ( i < worklist.size() ) {
                worklist.emplace_back( seg );
            }
            else {
                res.emplace_back( seg );
            }
        }

        return res;
    }

    //------------------------------------------------------------------------------
    bool layout_sections_without_segments()
    {
        for ( unsigned int i = 0; i < sections_.size(); ++i ) {
            if ( is_section_without_segment( i ) ) {
                const auto& sec = sections_[i];

                if ( Elf_Xword section_align = sec->get_addr_align();
                     section_align > 1 &&
                     current_file_pos % section_align != 0 ) {
                    current_file_pos +=
                        section_align - current_file_pos % section_align;
                }

                if ( 0 != sec->get_index() ) {
                    sec->set_offset( current_file_pos );
                }

                if ( SHT_NOBITS != sec->get_type() &&
                     SHT_NULL != sec->get_type() ) {
                    current_file_pos += sec->get_size();
                }
            }
        }

        return true;
    }

    //------------------------------------------------------------------------------
    void calc_segment_alignment() const
    {
        for ( const auto& seg : segments_ ) {
            for ( Elf_Half i = 0; i < seg->get_sections_num(); ++i ) {
                const auto& sect = sections_[seg->get_section_index_at( i )];
                if ( sect->get_addr_align() > seg->get_align() ) {
                    seg->set_align( sect->get_addr_align() );
                }
            }
        }
    }

    //------------------------------------------------------------------------------
    bool layout_segments_and_their_sections()
    {
        std::vector<segment*> worklist;
        std::vector<bool>     section_generated( sections.size(), false );

        // Get segments in a order in where segments which contain a
        // sub sequence of other segments are located at the end
        worklist = get_ordered_segments();

        for ( auto* seg : worklist ) {
            Elf_Xword segment_memory   = 0;
            Elf_Xword segment_filesize = 0;
            Elf_Xword seg_start_pos    = current_file_pos;
            // Special case: PHDR segment
            // This segment contains the program headers but no sections
            if ( seg->get_type() == PT_PHDR && seg->get_sections_num() == 0 ) {
                seg_start_pos  = header->get_segments_offset();
                segment_memory = segment_filesize =
                    header->get_segment_entry_size() *
                    static_cast<Elf_Xword>( header->get_segments_num() );
            }
            // Special case:
            else if ( seg->is_offset_initialized() && seg->get_offset() == 0 ) {
                seg_start_pos = 0;
                if ( seg->get_sections_num() > 0 ) {
                    segment_memory = segment_filesize = current_file_pos;
                }
            }
            // New segments with not generated sections
            // have to be aligned
            else if ( seg->get_sections_num() > 0 &&
                      !section_generated[seg->get_section_index_at( 0 )] ) {
                Elf_Xword align = seg->get_align() > 0 ? seg->get_align() : 1;
                Elf64_Off cur_page_alignment = current_file_pos % align;
                Elf64_Off req_page_alignment =
                    seg->get_virtual_address() % align;
                Elf64_Off error = req_page_alignment - cur_page_alignment;

                current_file_pos += ( seg->get_align() + error ) % align;
                seg_start_pos = current_file_pos;
            }
            else if ( seg->get_sections_num() > 0 ) {
                seg_start_pos =
                    sections[seg->get_section_index_at( 0 )]->get_offset();
            }

            // Write segment's data
            if ( !write_segment_data( seg, section_generated, segment_memory,
                                      segment_filesize, seg_start_pos ) ) {
                return false;
            }

            seg->set_file_size( segment_filesize );

            // If we already have a memory size from loading an elf file (value > 0),
            // it must not shrink!
            // Memory size may be bigger than file size and it is the loader's job to do something
            // with the surplus bytes in memory, like initializing them with a defined value.
            if ( seg->get_memory_size() < segment_memory ) {
                seg->set_memory_size( segment_memory );
            }

            seg->set_offset( seg_start_pos );
        }

        return true;
    }

    //------------------------------------------------------------------------------
    bool layout_section_table()
    {
        // Simply place the section table at the end for now
        Elf64_Off alignmentError = current_file_pos % 16;
        current_file_pos += 16 - alignmentError;
        header->set_sections_offset( current_file_pos );
        return true;
    }

    //------------------------------------------------------------------------------
    bool write_segment_data( const segment*     seg,
                             std::vector<bool>& section_generated,
                             Elf_Xword&         segment_memory,
                             Elf_Xword&         segment_filesize,
                             const Elf_Xword&   seg_start_pos )
    {
        for ( Elf_Half j = 0; j < seg->get_sections_num(); ++j ) {
            Elf_Half index = seg->get_section_index_at( j );

            section* sec = sections[index];

            // The NULL section is always generated
            if ( SHT_NULL == sec->get_type() ) {
                section_generated[index] = true;
                continue;
            }

            Elf_Xword section_align = 0;
            // Fix up the alignment
            if ( !section_generated[index] && sec->is_address_initialized() &&
                 SHT_NOBITS != sec->get_type() && SHT_NULL != sec->get_type() &&
                 0 != sec->get_size() ) {
                // Align the sections based on the virtual addresses
                // when possible (this is what matters for execution)
                Elf64_Off req_offset =
                    sec->get_address() - seg->get_virtual_address();
                Elf64_Off cur_offset = current_file_pos - seg_start_pos;
                if ( req_offset < cur_offset ) {
                    // something has gone awfully wrong, abort!
                    // section_align would turn out negative, seeking backwards and overwriting previous data
                    return false;
                }
                section_align = req_offset - cur_offset;
            }
            else if ( !section_generated[index] &&
                      !sec->is_address_initialized() ) {
                // If no address has been specified then only the section
                // alignment constraint has to be matched
                Elf_Xword align = sec->get_addr_align();
                if ( align == 0 ) {
                    align = 1;
                }
                Elf64_Off error = current_file_pos % align;
                section_align   = ( align - error ) % align;
            }
            else if ( section_generated[index] ) {
                // Alignment for already generated sections
                section_align =
                    sec->get_offset() - seg_start_pos - segment_filesize;
            }

            // Determine the segment file and memory sizes
            // Special case .tbss section (NOBITS) in non TLS segment
            if ( ( ( sec->get_flags() & SHF_ALLOC ) == SHF_ALLOC ) &&
                 !( ( ( sec->get_flags() & SHF_TLS ) == SHF_TLS ) &&
                    ( seg->get_type() != PT_TLS ) &&
                    ( SHT_NOBITS == sec->get_type() ) ) ) {
                segment_memory += sec->get_size() + section_align;
            }

            if ( SHT_NOBITS != sec->get_type() ) {
                segment_filesize += sec->get_size() + section_align;
            }

            // Nothing to be done when generating nested segments
            if ( section_generated[index] ) {
                continue;
            }

            current_file_pos += section_align;

            // Set the section addresses when missing
            if ( !sec->is_address_initialized() ) {
                sec->set_address( seg->get_virtual_address() +
                                  current_file_pos - seg_start_pos );
            }

            if ( 0 != sec->get_index() ) {
                sec->set_offset( current_file_pos );
            }

            if ( SHT_NOBITS != sec->get_type() ) {
                current_file_pos += sec->get_size();
            }

            section_generated[index] = true;
        }

        return true;
    }

    //------------------------------------------------------------------------------
  public:
    friend class Sections;
    class Sections
    {
      public:
        //------------------------------------------------------------------------------
        explicit Sections( elfio* parent ) : parent( parent ) {}

        //------------------------------------------------------------------------------
        Elf_Half size() const
        {
            return static_cast<Elf_Half>( parent->sections_.size() );
        }

        //------------------------------------------------------------------------------
        section* operator[]( unsigned int index ) const
        {
            section* sec = nullptr;

            if ( index < parent->sections_.size() ) {
                sec = parent->sections_[index].get();
            }

            return sec;
        }

        //------------------------------------------------------------------------------
        section* operator[]( const std::string_view& name ) const
        {
            section* sec = nullptr;

            for ( const auto& it : parent->sections_ ) {
                if ( it->get_name() == name ) {
                    sec = it.get();
                    break;
                }
            }

            return sec;
        }

        //------------------------------------------------------------------------------
        section* add( const std::string& name ) const
        {
            section* new_section = parent->create_section();
            new_section->set_name( name );

            Elf_Half str_index = parent->get_section_name_str_index();
            section* string_table( parent->sections_[str_index].get() );
            string_section_accessor str_writer( string_table );
            Elf_Word                pos = str_writer.add_string( name );
            new_section->set_name_string_offset( pos );

            return new_section;
        }

        //------------------------------------------------------------------------------
        std::vector<std::unique_ptr<section>>::iterator begin()
        {
            return parent->sections_.begin();
        }

        //------------------------------------------------------------------------------
        std::vector<std::unique_ptr<section>>::iterator end()
        {
            return parent->sections_.end();
        }

        //------------------------------------------------------------------------------
        std::vector<std::unique_ptr<section>>::const_iterator begin() const
        {
            return parent->sections_.cbegin();
        }

        //------------------------------------------------------------------------------
        std::vector<std::unique_ptr<section>>::const_iterator end() const
        {
            return parent->sections_.cend();
        }

        //------------------------------------------------------------------------------
      private:
        elfio* parent;
    };
    Sections sections;

    //------------------------------------------------------------------------------
    friend class Segments;
    class Segments
    {
      public:
        //------------------------------------------------------------------------------
        explicit Segments( elfio* parent ) : parent( parent ) {}

        //------------------------------------------------------------------------------
        Elf_Half size() const
        {
            return static_cast<Elf_Half>( parent->segments_.size() );
        }

        //------------------------------------------------------------------------------
        segment* operator[]( unsigned int index ) const
        {
            return parent->segments_[index].get();
        }

        //------------------------------------------------------------------------------
        segment* add() { return parent->create_segment(); }

        //------------------------------------------------------------------------------
        std::vector<std::unique_ptr<segment>>::iterator begin()
        {
            return parent->segments_.begin();
        }

        //------------------------------------------------------------------------------
        std::vector<std::unique_ptr<segment>>::iterator end()
        {
            return parent->segments_.end();
        }

        //------------------------------------------------------------------------------
        std::vector<std::unique_ptr<segment>>::const_iterator begin() const
        {
            return parent->segments_.cbegin();
        }

        //------------------------------------------------------------------------------
        std::vector<std::unique_ptr<segment>>::const_iterator end() const
        {
            return parent->segments_.cend();
        }

        //------------------------------------------------------------------------------
      private:
        elfio* parent;
    };
    Segments segments;

    //------------------------------------------------------------------------------
  private:
    std::unique_ptr<std::ifstream>         pstream = nullptr;
    std::unique_ptr<elf_header>            header  = nullptr;
    std::vector<std::unique_ptr<section>>  sections_;
    std::vector<std::unique_ptr<segment>>  segments_;
    endianess_convertor                    convertor;
    address_translator                     addr_translator;
    std::shared_ptr<compression_interface> compression = nullptr;

    Elf_Xword current_file_pos = 0;
};

} // namespace ELFIO

#include <elfio/elfio_symbols.hpp>
#include <elfio/elfio_note.hpp>
#include <elfio/elfio_relocation.hpp>
#include <elfio/elfio_dynamic.hpp>
#include <elfio/elfio_array.hpp>
#include <elfio/elfio_modinfo.hpp>
#include <elfio/elfio_versym.hpp>

#endif // ELFIO_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_ARRAY_HPP
#define ELFIO_ARRAY_HPP

#include <algorithm>

namespace ELFIO {

//------------------------------------------------------------------------------
template <class S, typename T> class array_section_accessor_template
{
  public:
    //------------------------------------------------------------------------------
    explicit array_section_accessor_template( const elfio& elf_file,
                                              S*           section )
        : elf_file( elf_file ), array_section( section )
    {
    }

    //------------------------------------------------------------------------------
    Elf_Xword get_entries_num() const
    {
        Elf_Xword entry_size = sizeof( T );
        return array_section->get_size() / entry_size;
    }

    //------------------------------------------------------------------------------
    bool get_entry( Elf_Xword index, Elf64_Addr& address ) const
    {
        if ( index >= get_entries_num() ) { // Is index valid
            return false;
        }

        const endianess_convertor& convertor = elf_file.get_convertor();

        const T temp = *reinterpret_cast<const T*>( array_section->get_data() +
                                                    index * sizeof( T ) );
        address      = convertor( temp );

        return true;
    }

    //------------------------------------------------------------------------------
    void add_entry( Elf64_Addr address )
    {
        const endianess_convertor& convertor = elf_file.get_convertor();

        T temp = convertor( (T)address );
        array_section->append_data( reinterpret_cast<char*>( &temp ),
                                    sizeof( temp ) );
    }

  private:
    //------------------------------------------------------------------------------
    const elfio& elf_file;
    S*           array_section;
};

template <typename T = Elf32_Word>
using array_section_accessor = array_section_accessor_template<section, T>;
template <typename T = Elf32_Word>
using const_array_section_accessor =
    array_section_accessor_template<const section, T>;

} // namespace ELFIO

#endif // ELFIO_ARRAY_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_DUMP_HPP
#define ELFIO_DUMP_HPP

#include <algorithm>
#include <string>
#include <ostream>
#include <sstream>
#include <iomanip>
#include <elfio/elfio.hpp>

namespace ELFIO {

static const struct class_table_t
{
    const char  key;
    const char* str;
} class_table[] = {
    { ELFCLASS32, "ELF32" },
    { ELFCLASS64, "ELF64" },
};

static const struct endian_table_t
{
    const char  key;
    const char* str;
} endian_table[] = {
    { ELFDATANONE, "None" },
    { ELFDATA2LSB, "Little endian" },
    { ELFDATA2MSB, "Big endian" },
};

static const struct os_abi_table_t
{
    const unsigned char key;
    const char*         str;
} os_abi_table[] = {
    { ELFOSABI_NONE, "UNIX System V" },
    { ELFOSABI_HPUX, "Hewlett-Packard HP-UX" },
    { ELFOSABI_NETBSD, "NetBSD" },
    { ELFOSABI_LINUX, "Linux" },
    { ELFOSABI_HURD, "GNU Hurd" },
    { ELFOSABI_SOLARIS, "Sun Solaris" },
    { ELFOSABI_AIX, "AIX" },
    { ELFOSABI_IRIX, "IRIX" },
    { ELFOSABI_FREEBSD, "FreeBSD" },
    { ELFOSABI_TRU64, "Compaq TRU64 UNIX" },
    { ELFOSABI_MODESTO, "Novell Modesto" },
    { ELFOSABI_OPENBSD, "Open BSD" },
    { ELFOSABI_OPENVMS, "Open VMS" },
    { ELFOSABI_NSK, "Hewlett-Packard Non-Stop Kernel" },
    { ELFOSABI_AROS, "Amiga Research OS" },
    { ELFOSABI_FENIXOS, "FenixOS" },
    { ELFOSABI_NUXI, "Nuxi CloudABI" },
    { ELFOSABI_OPENVOS, "OpenVOS" },
    { ELFOSABI_ARM, "ARM" },
    { ELFOSABI_STANDALONE, "Standalone (embedded)" },
};

static const struct version_table_t
{
    const Elf64_Word key;
    const char*      str;
} version_table[] = {
    { EV_NONE, "None" },
    { EV_CURRENT, "Current" },
};

static const struct type_table_t
{
    const Elf32_Half key;
    const char*      str;
} type_table[] = {
    { ET_NONE, "No file type" },    { ET_REL, "Relocatable file" },
    { ET_EXEC, "Executable file" }, { ET_DYN, "Shared object file" },
    { ET_CORE, "Core file" },
};

static const struct machine_table_t
{
    const Elf64_Half key;
    const char*      str;
} machine_table[] = {
    { EM_NONE, "No machine" },
    { EM_M32, "AT&T WE 32100" },
    { EM_SPARC, "SUN SPARC" },
    { EM_386, "Intel 80386" },
    { EM_68K, "Motorola m68k family" },
    { EM_88K, "Motorola m88k family" },
    { EM_486, "Intel 80486// Reserved for future use" },
    { EM_860, "Intel 80860" },
    { EM_MIPS, "MIPS R3000 (officially, big-endian only)" },
    { EM_S370, "IBM System/370" },
    { EM_MIPS_RS3_LE,
      "MIPS R3000 little-endian (Oct 4 1999 Draft) Deprecated" },
    { EM_res011, "Reserved" },
    { EM_res012, "Reserved" },
    { EM_res013, "Reserved" },
    { EM_res014, "Reserved" },
    { EM_PARISC, "HPPA" },
    { EM_res016, "Reserved" },
    { EM_VPP550, "Fujitsu VPP500" },
    { EM_SPARC32PLUS, "Sun's v8plus" },
    { EM_960, "Intel 80960" },
    { EM_PPC, "PowerPC" },
    { EM_PPC64, "64-bit PowerPC" },
    { EM_S390, "IBM S/390" },
    { EM_SPU, "Sony/Toshiba/IBM SPU" },
    { EM_res024, "Reserved" },
    { EM_res025, "Reserved" },
    { EM_res026, "Reserved" },
    { EM_res027, "Reserved" },
    { EM_res028, "Reserved" },
    { EM_res029, "Reserved" },
    { EM_res030, "Reserved" },
    { EM_res031, "Reserved" },
    { EM_res032, "Reserved" },
    { EM_res033, "Reserved" },
    { EM_res034, "Reserved" },
    { EM_res035, "Reserved" },
    { EM_V800, "NEC V800 series" },
    { EM_FR20, "Fujitsu FR20" },
    { EM_RH32, "TRW RH32" },
    { EM_MCORE, "Motorola M*Core // May also be taken by Fujitsu MMA" },
    { EM_RCE, "Old name for MCore" },
    { EM_ARM, "ARM" },
    { EM_OLD_ALPHA, "Digital Alpha" },
    { EM_SH, "Renesas (formerly Hitachi) / SuperH SH" },
    { EM_SPARCV9, "SPARC v9 64-bit" },
    { EM_TRICORE, "Siemens Tricore embedded processor" },
    { EM_ARC, "ARC Cores" },
    { EM_H8_300, "Renesas (formerly Hitachi) H8/300" },
    { EM_H8_300H, "Renesas (formerly Hitachi) H8/300H" },
    { EM_H8S, "Renesas (formerly Hitachi) H8S" },
    { EM_H8_500, "Renesas (formerly Hitachi) H8/500" },
    { EM_IA_64, "Intel IA-64 Processor" },
    { EM_MIPS_X, "Stanford MIPS-X" },
    { EM_COLDFIRE, "Motorola Coldfire" },
    { EM_68HC12, "Motorola M68HC12" },
    { EM_MMA, "Fujitsu Multimedia Accelerator" },
    { EM_PCP, "Siemens PCP" },
    { EM_NCPU, "Sony nCPU embedded RISC processor" },
    { EM_NDR1, "Denso NDR1 microprocesspr" },
    { EM_STARCORE, "Motorola Star*Core processor" },
    { EM_ME16, "Toyota ME16 processor" },
    { EM_ST100, "STMicroelectronics ST100 processor" },
    { EM_TINYJ, "Advanced Logic Corp. TinyJ embedded processor" },
    { EM_X86_64, "Advanced Micro Devices X86-64 processor" },
    { EM_PDSP, "Sony DSP Processor" },
    { EM_PDP10, "Digital Equipment Corp. PDP-10" },
    { EM_PDP11, "Digital Equipment Corp. PDP-11" },
    { EM_FX66, "Siemens FX66 microcontroller" },
    { EM_ST9PLUS, "STMicroelectronics ST9+ 8/16 bit microcontroller" },
    { EM_ST7, "STMicroelectronics ST7 8-bit microcontroller" },
    { EM_68HC16, "Motorola MC68HC16 Microcontroller" },
    { EM_68HC11, "Motorola MC68HC11 Microcontroller" },
    { EM_68HC08, "Motorola MC68HC08 Microcontroller" },
    { EM_68HC05, "Motorola MC68HC05 Microcontroller" },
    { EM_SVX, "Silicon Graphics SVx" },
    { EM_ST19, "STMicroelectronics ST19 8-bit cpu" },
    { EM_VAX, "Digital VAX" },
    { EM_CRIS, "Axis Communications 32-bit embedded processor" },
    { EM_JAVELIN, "Infineon Technologies 32-bit embedded cpu" },
    { EM_FIREPATH, "Element 14 64-bit DSP processor" },
    { EM_ZSP, "LSI Logic's 16-bit DSP processor" },
    { EM_MMIX, "Donald Knuth's educational 64-bit processor" },
    { EM_HUANY, "Harvard's machine-independent format" },
    { EM_PRISM, "SiTera Prism" },
    { EM_AVR, "Atmel AVR 8-bit microcontroller" },
    { EM_FR30, "Fujitsu FR30" },
    { EM_D10V, "Mitsubishi D10V" },
    { EM_D30V, "Mitsubishi D30V" },
    { EM_V850, "NEC v850" },
    { EM_M32R, "Renesas M32R (formerly Mitsubishi M32R)" },
    { EM_MN10300, "Matsushita MN10300" },
    { EM_MN10200, "Matsushita MN10200" },
    { EM_PJ, "picoJava" },
    { EM_OPENRISC, "OpenRISC 32-bit embedded processor" },
    { EM_ARC_A5, "ARC Cores Tangent-A5" },
    { EM_XTENSA, "Tensilica Xtensa Architecture" },
    { EM_VIDEOCORE, "Alphamosaic VideoCore processor" },
    { EM_TMM_GPP, "Thompson Multimedia General Purpose Processor" },
    { EM_NS32K, "National Semiconductor 32000 series" },
    { EM_TPC, "Tenor Network TPC processor" },
    { EM_SNP1K, "Trebia SNP 1000 processor" },
    { EM_ST200, "STMicroelectronics ST200 microcontroller" },
    { EM_IP2K, "Ubicom IP2022 micro controller" },
    { EM_MAX, "MAX Processor" },
    { EM_CR, "National Semiconductor CompactRISC" },
    { EM_F2MC16, "Fujitsu F2MC16" },
    { EM_MSP430, "TI msp430 micro controller" },
    { EM_BLACKFIN, "ADI Blackfin" },
    { EM_SE_C33, "S1C33 Family of Seiko Epson processors" },
    { EM_SEP, "Sharp embedded microprocessor" },
    { EM_ARCA, "Arca RISC Microprocessor" },
    { EM_UNICORE, "Microprocessor series from PKU-Unity Ltd. and MPRC of "
                  "Peking University" },
    { EM_EXCESS, "eXcess: 16/32/64-bit configurable embedded CPU" },
    { EM_DXP, "Icera Semiconductor Inc. Deep Execution Processor" },
    { EM_ALTERA_NIOS2, "Altera Nios II soft-core processor" },
    { EM_CRX, "National Semiconductor CRX" },
    { EM_XGATE, "Motorola XGATE embedded processor" },
    { EM_C166, "Infineon C16x/XC16x processor" },
    { EM_M16C, "Renesas M16C series microprocessors" },
    { EM_DSPIC30F, "Microchip Technology dsPIC30F Digital Signal Controller" },
    { EM_CE, "Freescale Communication Engine RISC core" },
    { EM_M32C, "Renesas M32C series microprocessors" },
    { EM_res121, "Reserved" },
    { EM_res122, "Reserved" },
    { EM_res123, "Reserved" },
    { EM_res124, "Reserved" },
    { EM_res125, "Reserved" },
    { EM_res126, "Reserved" },
    { EM_res127, "Reserved" },
    { EM_res128, "Reserved" },
    { EM_res129, "Reserved" },
    { EM_res130, "Reserved" },
    { EM_TSK3000, "Altium TSK3000 core" },
    { EM_RS08, "Freescale RS08 embedded processor" },
    { EM_res133, "Reserved" },
    { EM_ECOG2, "Cyan Technology eCOG2 microprocessor" },
    { EM_SCORE, "Sunplus Score" },
    { EM_SCORE7, "Sunplus S+core7 RISC processor" },
    { EM_DSP24, "New Japan Radio (NJR) 24-bit DSP Processor" },
    { EM_VIDEOCORE3, "Broadcom VideoCore III processor" },
    { EM_LATTICEMICO32, "RISC processor for Lattice FPGA architecture" },
    { EM_SE_C17, "Seiko Epson C17 family" },
    { EM_TI_C6000, "Texas Instruments TMS320C6000 DSP family" },
    { EM_TI_C2000, "Texas Instruments TMS320C2000 DSP family" },
    { EM_TI_C5500, "Texas Instruments TMS320C55x DSP family" },
    { EM_res143, "Reserved" },
    { EM_res144, "Reserved" },
    { EM_res145, "Reserved" },
    { EM_res146, "Reserved" },
    { EM_res147, "Reserved" },
    { EM_res148, "Reserved" },
    { EM_res149, "Reserved" },
    { EM_res150, "Reserved" },
    { EM_res151, "Reserved" },
    { EM_res152, "Reserved" },
    { EM_res153, "Reserved" },
    { EM_res154, "Reserved" },
    { EM_res155, "Reserved" },
    { EM_res156, "Reserved" },
    { EM_res157, "Reserved" },
    { EM_res158, "Reserved" },
    { EM_res159, "Reserved" },
    { EM_MMDSP_PLUS, "STMicroelectronics 64bit VLIW Data Signal Processor" },
    { EM_CYPRESS_M8C, "Cypress M8C microprocessor" },
    { EM_R32C, "Renesas R32C series microprocessors" },
    { EM_TRIMEDIA, "NXP Semiconductors TriMedia architecture family" },
    { EM_QDSP6, "QUALCOMM DSP6 Processor" },
    { EM_8051, "Intel 8051 and variants" },
    { EM_STXP7X, "STMicroelectronics STxP7x family" },
    { EM_NDS32,
      "Andes Technology compact code size embedded RISC processor family" },
    { EM_ECOG1, "Cyan Technology eCOG1X family" },
    { EM_ECOG1X, "Cyan Technology eCOG1X family" },
    { EM_MAXQ30, "Dallas Semiconductor MAXQ30 Core Micro-controllers" },
    { EM_XIMO16, "New Japan Radio (NJR) 16-bit DSP Processor" },
    { EM_MANIK, "M2000 Reconfigurable RISC Microprocessor" },
    { EM_CRAYNV2, "Cray Inc. NV2 vector architecture" },
    { EM_RX, "Renesas RX family" },
    { EM_METAG, "Imagination Technologies META processor architecture" },
    { EM_MCST_ELBRUS, "MCST Elbrus general purpose hardware architecture" },
    { EM_ECOG16, "Cyan Technology eCOG16 family" },
    { EM_CR16, "National Semiconductor CompactRISC 16-bit processor" },
    { EM_ETPU, "Freescale Extended Time Processing Unit" },
    { EM_SLE9X, "Infineon Technologies SLE9X core" },
    { EM_L1OM, "Intel L1OM" },
    { EM_INTEL181, "Reserved by Intel" },
    { EM_INTEL182, "Reserved by Intel" },
    { EM_AARCH64, "ARM AArch64" },
    { EM_res184, "Reserved by ARM" },
    { EM_AVR32, "Atmel Corporation 32-bit microprocessor family" },
    { EM_STM8, "STMicroeletronics STM8 8-bit microcontroller" },
    { EM_TILE64, "Tilera TILE64 multicore architecture family" },
    { EM_TILEPRO, "Tilera TILEPro multicore architecture family" },
    { EM_MICROBLAZE, "Xilinx MicroBlaze 32-bit RISC soft processor core" },
    { EM_CUDA, "NVIDIA CUDA architecture " },
    { EM_TILEGX, "Tilera TILE-Gx multicore architecture family" },
    { EM_CLOUDSHIELD, "CloudShield architecture family" },
    { EM_COREA_1ST, "KIPO-KAIST Core-A 1st generation processor family" },
    { EM_COREA_2ND, "KIPO-KAIST Core-A 2nd generation processor family" },
    { EM_ARC_COMPACT2, "Synopsys ARCompact V2" },
    { EM_OPEN8, "Open8 8-bit RISC soft processor core" },
    { EM_RL78, "Renesas RL78 family" },
    { EM_VIDEOCORE5, "Broadcom VideoCore V processor" },
    { EM_78KOR, "Renesas 78KOR family" },
    { EM_56800EX, "Freescale 56800EX Digital Signal Controller (DSC)" },
    { EM_BA1, "Beyond BA1 CPU architecture" },
    { EM_BA2, "Beyond BA2 CPU architecture" },
    { EM_XCORE, "XMOS xCORE processor family" },
    { EM_MCHP_PIC, "Microchip 8-bit PIC(r) family" },
    { EM_INTEL205, "Reserved by Intel" },
    { EM_INTEL206, "Reserved by Intel" },
    { EM_INTEL207, "Reserved by Intel" },
    { EM_INTEL208, "Reserved by Intel" },
    { EM_INTEL209, "Reserved by Intel" },
    { EM_KM32, "KM211 KM32 32-bit processor" },
    { EM_KMX32, "KM211 KMX32 32-bit processor" },
    { EM_KMX16, "KM211 KMX16 16-bit processor" },
    { EM_KMX8, "KM211 KMX8 8-bit processor" },
    { EM_KVARC, "KM211 KVARC processor" },
    { EM_CDP, "Paneve CDP architecture family" },
    { EM_COGE, "Cognitive Smart Memory Processor" },
    { EM_COOL, "iCelero CoolEngine" },
    { EM_NORC, "Nanoradio Optimized RISC" },
    { EM_CSR_KALIMBA, "CSR Kalimba architecture family" },
    { EM_Z80, "Zilog Z80" },
    { EM_VISIUM, "Controls and Data Services VISIUMcore processor" },
    { EM_FT32, "FTDI Chip FT32 high performance 32-bit RISC architecture" },
    { EM_MOXIE, "Moxie processor family" },
    { EM_AMDGPU, "AMD GPU architecture" },
    { EM_RISCV, "RISC-V" },
    { EM_LANAI, "Lanai processor" },
    { EM_CEVA, "CEVA Processor Architecture Family" },
    { EM_CEVA_X2, "CEVA X2 Processor Family" },
    { EM_BPF, "Linux BPF  in-kernel virtual machine" },
    { EM_GRAPHCORE_IPU, "Graphcore Intelligent Processing Unit" },
    { EM_IMG1, "Imagination Technologies" },
    { EM_NFP, "Netronome Flow Processor (P)" },
    { EM_CSKY, "C-SKY processor family" },
    { EM_ARC_COMPACT3_64, "Synopsys ARCv2.3 64-bit" },
    { EM_MCS6502, "MOS Technology MCS 6502 processor" },
    { EM_ARC_COMPACT3, "Synopsys ARCv2.3 32-bit" },
    { EM_KVX, "Kalray VLIW core of the MPPA processor family" },
    { EM_65816, "WDC 65816/65C816" },
    { EM_LOONGARCH, "Loongson Loongarch" },
    { EM_KF32, "ChipON KungFu32" },
    { EM_MT, "Morpho Techologies MT processor" },
    { EM_ALPHA, "Alpha" },
    { EM_WEBASSEMBLY, "Web Assembly" },
    { EM_DLX, "OpenDLX" },
    { EM_XSTORMY16, "Sanyo XStormy16 CPU core" },
    { EM_IQ2000, "Vitesse IQ2000" },
    { EM_M32C_OLD, "M32C_OLD" },
    { EM_NIOS32, "Altera Nios" },
    { EM_CYGNUS_MEP, "Toshiba MeP Media Engine" },
    { EM_ADAPTEVA_EPIPHANY, "Adapteva EPIPHANY" },
    { EM_CYGNUS_FRV, "Fujitsu FR-V" },
    { EM_S12Z, "Freescale S12Z" },
};

static const struct section_type_table_t
{
    const Elf64_Word key;
    const char*      str;
} section_type_table[] = {
    { SHT_NULL, "NULL" },
    { SHT_PROGBITS, "PROGBITS" },
    { SHT_SYMTAB, "SYMTAB" },
    { SHT_STRTAB, "STRTAB" },
    { SHT_RELA, "RELA" },
    { SHT_HASH, "HASH" },
    { SHT_DYNAMIC, "DYNAMIC" },
    { SHT_NOTE, "NOTE" },
    { SHT_NOBITS, "NOBITS" },
    { SHT_REL, "REL" },
    { SHT_SHLIB, "SHLIB" },
    { SHT_DYNSYM, "DYNSYM" },
    { SHT_INIT_ARRAY, "INIT_ARRAY" },
    { SHT_FINI_ARRAY, "FINI_ARRAY" },
    { SHT_PREINIT_ARRAY, "PREINIT_ARRAY" },
    { SHT_GROUP, "GROUP" },
    { SHT_SYMTAB_SHNDX, "SYMTAB_SHNDX" },
    { SHT_GNU_ATTRIBUTES, "GNU_ATTRIBUTES" },
    { SHT_GNU_HASH, "GNU_HASH" },
    { SHT_GNU_LIBLIST, "GNU_LIBLIST" },
    { SHT_CHECKSUM, "CHECKSUM" },
    { SHT_LOSUNW, "LOSUNW" },
    { SHT_SUNW_move, "SUNW_move" },
    { SHT_SUNW_COMDAT, "SUNW_COMDAT" },
    { SHT_SUNW_syminfo, "SUNW_syminfo" },
    { SHT_GNU_verdef, "GNU_verdef" },
    { SHT_GNU_verneed, "GNU_verneed" },
    { SHT_GNU_versym, "GNU_versym" },
    { SHT_ARM_EXIDX, "ARM_EXIDX" },
    { SHT_ARM_PREEMPTMAP, "ARM_PREEMPTMAP" },
    { SHT_ARM_ATTRIBUTES, "ARM_ATTRIBUTES" },
    { SHT_ARM_DEBUGOVERLAY, "ARM_DEBUGOVERLAY" },
    { SHT_ARM_OVERLAYSECTION, "ARM_OVERLAYSECTION" },

};

static const struct segment_type_table_t
{
    const Elf_Word key;
    const char*    str;
} segment_type_table[] = {
    { PT_NULL, "NULL" },
    { PT_LOAD, "LOAD" },
    { PT_DYNAMIC, "DYNAMIC" },
    { PT_INTERP, "INTERP" },
    { PT_NOTE, "NOTE" },
    { PT_SHLIB, "SHLIB" },
    { PT_PHDR, "PHDR" },
    { PT_TLS, "TLS" },
    { PT_GNU_EH_FRAME, "GNU_EH_FRAME" },
    { PT_GNU_STACK, "GNU_STACK" },
    { PT_GNU_RELRO, "GNU_RELRO" },
    { PT_GNU_PROPERTY, "GNU_PROPERTY" },
    { PT_GNU_MBIND_LO, "GNU_MBIND_LO" },
    { PT_GNU_MBIND_HI, "GNU_MBIND_HI" },
    { PT_PAX_FLAGS, "PAX_FLAGS" },
    { PT_OPENBSD_RANDOMIZE, "OPENBSD_RANDOMIZE" },
    { PT_OPENBSD_WXNEEDED, "OPENBSD_WXNEEDED " },
    { PT_OPENBSD_BOOTDATA, "OPENBSD_BOOTDATA " },
    { PT_SUNWBSS, "PT_SUNWBSS" },
    { PT_SUNWSTACK, "SUNWSTACK" },
};

static const struct segment_flag_table_t
{
    const Elf_Word key;
    const char*    str;
} segment_flag_table[] = {
    { 0, "   " }, { 1, "  E" }, { 2, " W " }, { 3, " WE" },
    { 4, "R  " }, { 5, "R E" }, { 6, "RW " }, { 7, "RWE" },
};

static const struct symbol_bind_t
{
    const Elf_Word key;
    const char*    str;
} symbol_bind_table[] = {
    { STB_LOCAL, "LOCAL" },   { STB_GLOBAL, "GLOBAL" },
    { STB_WEAK, "WEAK" },     { STB_LOOS, "LOOS" },
    { STB_HIOS, "HIOS" },     { STB_MULTIDEF, "MULTIDEF" },
    { STB_LOPROC, "LOPROC" }, { STB_HIPROC, "HIPROC" },
};

static const struct symbol_type_t
{
    const Elf_Word key;
    const char*    str;
} symbol_type_table[] = {
    { STT_NOTYPE, "NOTYPE" }, { STT_OBJECT, "OBJECT" },
    { STT_FUNC, "FUNC" },     { STT_SECTION, "SECTION" },
    { STT_FILE, "FILE" },     { STT_COMMON, "COMMON" },
    { STT_TLS, "TLS" },       { STT_LOOS, "LOOS" },
    { STT_HIOS, "HIOS" },     { STT_LOPROC, "LOPROC" },
    { STT_HIPROC, "HIPROC" },
};

static const struct dynamic_tag_t
{
    const Elf_Word key;
    const char*    str;
} dynamic_tag_table[] = {
    { DT_NULL, "NULL" },
    { DT_NEEDED, "NEEDED" },
    { DT_PLTRELSZ, "PLTRELSZ" },
    { DT_PLTGOT, "PLTGOT" },
    { DT_HASH, "HASH" },
    { DT_STRTAB, "STRTAB" },
    { DT_SYMTAB, "SYMTAB" },
    { DT_RELA, "RELA" },
    { DT_RELASZ, "RELASZ" },
    { DT_RELAENT, "RELAENT" },
    { DT_STRSZ, "STRSZ" },
    { DT_SYMENT, "SYMENT" },
    { DT_INIT, "INIT" },
    { DT_FINI, "FINI" },
    { DT_SONAME, "SONAME" },
    { DT_RPATH, "RPATH" },
    { DT_SYMBOLIC, "SYMBOLIC" },
    { DT_REL, "REL" },
    { DT_RELSZ, "RELSZ" },
    { DT_RELENT, "RELENT" },
    { DT_PLTREL, "PLTREL" },
    { DT_DEBUG, "DEBUG" },
    { DT_TEXTREL, "TEXTREL" },
    { DT_JMPREL, "JMPREL" },
    { DT_BIND_NOW, "BIND_NOW" },
    { DT_INIT_ARRAY, "INIT_ARRAY" },
    { DT_FINI_ARRAY, "FINI_ARRAY" },
    { DT_INIT_ARRAYSZ, "INIT_ARRAYSZ" },
    { DT_FINI_ARRAYSZ, "FINI_ARRAYSZ" },
    { DT_RUNPATH, "RUNPATH" },
    { DT_FLAGS, "FLAGS" },
    { DT_ENCODING, "ENCODING" },
    { DT_PREINIT_ARRAY, "PREINIT_ARRAY" },
    { DT_PREINIT_ARRAYSZ, "PREINIT_ARRAYSZ" },
    { DT_MAXPOSTAGS, "MAXPOSTAGS" },
    { DT_GNU_HASH, "GNU_HASH" },
    { DT_TLSDESC_PLT, "TLSDESC_PLT" },
    { DT_TLSDESC_GOT, "TLSDESC_GOT" },
    { DT_GNU_CONFLICT, "GNU_CONFLICT" },
    { DT_GNU_LIBLIST, "GNU_LIBLIST" },
    { DT_CONFIG, "CONFIG" },
    { DT_DEPAUDIT, "DEPAUDIT" },
    { DT_AUDIT, "AUDIT" },
    { DT_PLTPAD, "PLTPAD" },
    { DT_MOVETAB, "MOVETAB" },
    { DT_SYMINFO, "SYMINFO" },
    { DT_ADDRRNGHI, "ADDRRNGHI" },
    { DT_VERSYM, "VERSYM" },
    { DT_RELACOUNT, "RELACOUNT" },
    { DT_RELCOUNT, "RELCOUNT" },
    { DT_FLAGS_1, "FLAGS_1" },
    { DT_VERDEF, "VERDEF" },
    { DT_VERDEFNUM, "VERDEFNUM" },
    { DT_VERNEED, "VERNEED" },
    { DT_VERNEEDNUM, "VERNEEDNUM" },
};

// clang-format off
static const struct note_tag_t
{
    struct note_values_t
    {
        Elf64_Word  type;
        std::string type_str;
        std::string description;
    };
    std::string                name;
    std::vector<note_values_t> values;
} note_tag_table[] = {
    { "",
      { { NT_PRSTATUS,     "NT_PRSTATUS",     "prstatus struct" },
        { NT_FPREGSET,     "NT_FPREGSET",     "fpregset struct" },
        { NT_PRPSINFO,     "NT_PRPSINFO",     "prpsinfo struct" },
        { NT_TASKSTRUCT,   "NT_TASKSTRUCT",   "task struct" },
        { NT_AUXV,         "NT_AUXV",         "Elfxx_auxv_t" },
        { NT_PSTATUS,      "NT_PSTATUS",      "pstatus struct" },
        { NT_FPREGS,       "NT_FPREGS",       "fpregset struct" },
        { NT_PSINFO,       "NT_PSINFO",       "psinfo struct" },
        { NT_LWPSTATUS,    "NT_LWPSTATUS",    "lwpstatus_t struct" },
        { NT_LWPSINFO,     "NT_LWPSINFO",     "lwpsinfo_t struct" },
        { NT_WIN32PSTATUS, "NT_WIN32PSTATUS", "win32_pstatus struct" },
      } },
    { "LINUX",
      { { NT_PRXFPREG,             "NT_PRXFPREG", "Contains a user_xfpregs_struct;" },
        { NT_PPC_VMX,              "NT_PPC_VMX", "PowerPC Altivec/VMX registers" },
        { NT_PPC_VSX,              "NT_PPC_VSX", "PowerPC VSX registers" },
        { NT_PPC_TAR,              "NT_PPC_TAR", "PowerPC Target Address Register" },
        { NT_PPC_PPR,              "NT_PPC_PPR", "PowerPC Program Priority Register" },
        { NT_PPC_DSCR,             "NT_PPC_DSCR", "PowerPC Data Stream Control Register" },
        { NT_PPC_EBB,              "NT_PPC_EBB", "PowerPC Event Based Branch Registers" },
        { NT_PPC_PMU,              "NT_PPC_PMU", "PowerPC Performance Monitor Registers" },
        { NT_PPC_TM_CGPR,          "NT_PPC_TM_CGPR", "PowerPC TM checkpointed GPR Registers" },
        { NT_PPC_TM_CFPR,          "NT_PPC_TM_CFPR", "PowerPC TM checkpointed FPR Registers" },
        { NT_PPC_TM_CVMX,          "NT_PPC_TM_CVMX", "PowerPC TM checkpointed VMX Registers" },
        { NT_PPC_TM_CVSX,          "NT_PPC_TM_CVSX", "PowerPC TM checkpointed VSX Registers" },
        { NT_PPC_TM_SPR,           "NT_PPC_TM_SPR",   "PowerPC TM Special Purpose Registers" },
        { NT_PPC_TM_CTAR,          "NT_PPC_TM_CTAR", "PowerPC TM checkpointed TAR" },
        { NT_PPC_TM_CPPR,          "NT_PPC_TM_CPPR", "PowerPC TM checkpointed PPR" },
        { NT_PPC_TM_CDSCR,         "NT_PPC_TM_CDSCR", "PowerPC TM checkpointed Data SCR" },
        { NT_386_TLS,              "NT_386_TLS", "x86 TLS information" },
        { NT_386_IOPERM,           "NT_386_IOPERM", "x86 io permissions" },
        { NT_X86_XSTATE,           "NT_X86_XSTATE", "x86 XSAVE extended state" },
        { NT_X86_CET,              "NT_X86_CET", "x86 CET state" },
        { NT_S390_HIGH_GPRS,       "NT_S390_HIGH_GPRS", "S/390 upper halves of GPRs " },
        { NT_S390_TIMER,           "NT_S390_TIMER", "S390 timer" },
        { NT_S390_TODCMP,          "NT_S390_TODCMP", "S390 TOD clock comparator" },
        { NT_S390_TODPREG,         "NT_S390_TODPREG", "S390 TOD programmable register" },
        { NT_S390_CTRS,            "NT_S390_CTRS", "S390 control registers" },
        { NT_S390_PREFIX,          "NT_S390_PREFIX", "S390 prefix register" },
        { NT_S390_LAST_BREAK,      "NT_S390_LAST_BREAK", "S390 breaking event address" },
        { NT_S390_SYSTEM_CALL,     "NT_S390_SYSTEM_CALL", "S390 system call restart data" },
        { NT_S390_TDB,             "NT_S390_TDB", "S390 transaction diagnostic block" },
        { NT_S390_VXRS_LOW,        "NT_S390_VXRS_LOW", "S390 vector registers 0-15 upper half" },
        { NT_S390_VXRS_HIGH,       "NT_S390_VXRS_HIGH", "S390 vector registers 16-31" },
        { NT_S390_GS_CB,           "NT_S390_GS_CB", "s390 guarded storage registers" },
        { NT_S390_GS_BC,           "NT_S390_GS_BC", "s390 guarded storage broadcast control block" },
        { NT_ARM_VFP,              "NT_ARM_VFP", "ARM VFP registers" },
        { NT_ARM_TLS,              "NT_ARM_TLS", "AArch TLS registers" },
        { NT_ARM_HW_BREAK,         "NT_ARM_HW_BREAK", "AArch hardware breakpoint registers" },
        { NT_ARM_HW_WATCH,         "NT_ARM_HW_WATCH", "AArch hardware watchpoint registers" },
        { NT_ARM_SVE,              "NT_ARM_SVE", "AArch SVE registers. " },
        { NT_ARM_PAC_MASK,         "NT_ARM_PAC_MASK", "AArch pointer authentication code masks" },
        { NT_ARM_PACA_KEYS,        "NT_ARM_PACA_KEYS", "ARM pointer authentication address keys" },
        { NT_ARM_PACG_KEYS,        "NT_ARM_PACG_KEYS", "ARM pointer authentication generic keys" },
        { NT_ARM_TAGGED_ADDR_CTRL, "NT_ARM_TAGGED_ADDR_CTRL", "AArch64 tagged address control (prctl())" },
        { NT_ARM_PAC_ENABLED_KEYS, "NT_ARM_PAC_ENABLED_KEYS", "AArch64 pointer authentication enabled keys (prctl())" },
        { NT_ARC_V2,               "NT_ARC_V2", "ARC HS accumulator/extra registers. " },
        { NT_LARCH_CPUCFG,         "NT_LARCH_CPUCFG", "LoongArch CPU config registers" },
        { NT_LARCH_CSR,            "NT_LARCH_CSR", "LoongArch Control State Registers" },
        { NT_LARCH_LSX,            "NT_LARCH_LSX", "LoongArch SIMD eXtension registers" },
        { NT_LARCH_LASX,           "NT_LARCH_LASX", "LoongArch Advanced SIMD eXtension registers" },
        { NT_RISCV_CSR,            "NT_RISCV_CSR", "RISC-V Control and Status Registers" },
      } },
    { "CORE",
      { { NT_LARCH_LBT, "NT_LARCH_LBT", "LoongArch Binary Translation registers" }
      } },
    { "FreeBSD",
      { { NT_FREEBSD_THRMISC,            "NT_FREEBSD_THRMISC",            "Thread miscellaneous info." },
        { NT_FREEBSD_PROCSTAT_PROC,      "NT_FREEBSD_PROCSTAT_PROC",      "Procstat proc data." },
        { NT_FREEBSD_PROCSTAT_FILES,     "NT_FREEBSD_PROCSTAT_FILES",     "Procstat files data." },
        { NT_FREEBSD_PROCSTAT_VMMAP,     "NT_FREEBSD_PROCSTAT_VMMAP",     "Procstat vmmap data." },
        { NT_FREEBSD_PROCSTAT_GROUPS,    "NT_FREEBSD_PROCSTAT_GROUPS",    "Procstat groups data." },
        { NT_FREEBSD_PROCSTAT_UMASK,     "NT_FREEBSD_PROCSTAT_UMASK",     "Procstat umask data." },
        { NT_FREEBSD_PROCSTAT_RLIMIT,    "NT_FREEBSD_PROCSTAT_RLIMIT",    "Procstat rlimit data." },
        { NT_FREEBSD_PROCSTAT_OSREL,     "NT_FREEBSD_PROCSTAT_OSREL",     "Procstat osreldate data." },
        { NT_FREEBSD_PROCSTAT_PSSTRINGS, "NT_FREEBSD_PROCSTAT_PSSTRINGS", "Procstat ps_strings data." },
        { NT_FREEBSD_PROCSTAT_AUXV,      "NT_FREEBSD_PROCSTAT_AUXV",      "Procstat auxv data." },
        { NT_FREEBSD_PTLWPINFO,          "NT_FREEBSD_PTLWPINFO",          "Thread ptrace miscellaneous info." },
      } },
    { "NetBSD-CORE",
      { { NT_NETBSDCORE_PROCINFO,  "NT_NETBSDCORE_PROCINFO",  "Has a struct procinfo" },
        { NT_NETBSDCORE_AUXV,      "NT_NETBSDCORE_AUXV",      "Has auxv data" },
        { NT_NETBSDCORE_LWPSTATUS, "NT_NETBSDCORE_LWPSTATUS", "Has LWPSTATUS data" },
        { NT_NETBSDCORE_FIRSTMACH, "NT_NETBSDCORE_FIRSTMACH", "start of machdep note types" },
      } },
    { "OpenBSD",
      { { NT_OPENBSD_PROCINFO, "NT_OPENBSD_PROCINFO", "" },
        { NT_OPENBSD_AUXV,     "NT_OPENBSD_AUXV",     "" },
        { NT_OPENBSD_REGS,     "NT_OPENBSD_REGS",     "" },
        { NT_OPENBSD_FPREGS,   "NT_OPENBSD_FPREGS",   "" },
        { NT_OPENBSD_XFPREGS,  "NT_OPENBSD_XFPREGS",  "" },
        { NT_OPENBSD_WCOOKIE,  "NT_OPENBSD_WCOOKIE",  "" },
      } },
    { "SPU",
      { { NT_SPU, "NT_SPU", "" }
      } },
    { "GNU",
      { 
        { NT_GNU_ABI_TAG,          "NT_GNU_ABI_TAG",         "GNU ABI tag" },
        { NT_GNU_HWCAP,            "NT_GNU_HWCAP",           "Used by ld.so and kernel vDSO" },
        { NT_GNU_BUILD_ID,         "NT_GNU_BUILD_ID",        "Build ID of the binary" },
        { NT_GNU_GOLD_VERSION,     "NT_GNU_GOLD_VERSION",    "Version of GNU gold used to link the binary" },
        { NT_GNU_PROPERTY_TYPE_0,  "NT_GNU_PROPERTY_TYPE_0", "Property type 0" },
        // { NT_GNU_PROPERTY_TYPE_1,  "NT_GNU_PROPERTY_TYPE_1",  "Property type 1" },
        // { NT_GNU_PROPERTY_TYPE_2,  "NT_GNU_PROPERTY_TYPE_2",  "Property type 2" },
        // { NT_GNU_PROPERTY_TYPE_3,  "NT_GNU_PROPERTY_TYPE_3",  "Property type 3" },
        // { NT_GNU_PROPERTY_TYPE_4,  "NT_GNU_PROPERTY_TYPE_4",  "Property type 4" },
        // { NT_GNU_PROPERTY_TYPE_5,  "NT_GNU_PROPERTY_TYPE_5",  "Property type 5" },
        // { NT_GNU_PROPERTY_TYPE_6,  "NT_GNU_PROPERTY_TYPE_6",  "Property type 6" },
        // { NT_GNU_PROPERTY_TYPE_7,  "NT_GNU_PROPERTY_TYPE_7",  "Property type 7" },
        // { NT_GNU_PROPERTY_TYPE_8,  "NT_GNU_PROPERTY_TYPE_8",  "Property type 8" },
        // { NT_GNU_PROPERTY_TYPE_9,  "NT_GNU_PROPERTY_TYPE_9",  "Property type 9" },
        // { NT_GNU_PROPERTY_TYPE_10, "NT_GNU_PROPERTY_TYPE_10", "Property type 10" },
        // { NT_GNU_PROPERTY_TYPE_11, "NT_GNU_PROPERTY_TYPE_11", "Property type 11" },
        // { NT_GNU_PROPERTY_TYPE_12, "NT_GNU_PROPERTY_TYPE_12", "Property type 12" },
        // { NT_GNU_PROPERTY_TYPE_13, "NT_GNU_PROPERTY_TYPE_13", "Property type 13" },
        // { NT_GNU_PROPERTY_TYPE_14, "NT_GNU_PROPERTY_TYPE_14", "Property type 14" },
      } },
    // { "SOLARIS",
    //   { { NT_SOLARIS_AUXV, "NT_SOLARIS_AUXV", "" }
    //   } },
    // { "AIX",
    //   { { NT_AIX_AUXV, "NT_AIX_AUXV", "" }
    //   } },
    // { "IRIX",
    //   { { NT_IRIX_FPREGS, "NT_IRIX_FPREGS", "" }
    //   } },
};
// clang-format on

static const ELFIO::Elf_Xword MAX_DATA_ENTRIES = 64;

//------------------------------------------------------------------------------
class dump
{
#define DUMP_DEC_FORMAT( width ) \
    std::setw( width ) << std::setfill( ' ' ) << std::dec << std::right
#define DUMP_HEX0x_FORMAT( width ) \
    "0x" << std::setw( width ) << std::setfill( '0' ) << std::hex << std::right
#define DUMP_HEX_FORMAT( width ) \
    std::setw( width ) << std::setfill( '0' ) << std::hex << std::right
#define DUMP_STR_FORMAT( width ) \
    std::setw( width ) << std::setfill( ' ' ) << std::hex << std::left

  public:
    //------------------------------------------------------------------------------
    static void header( std::ostream& out, const elfio& reader )
    {
        if ( !reader.get_header_size() ) {
            return;
        }
        out << "ELF Header" << std::endl
            << std::endl
            << "  Class:      " << str_class( reader.get_class() ) << std::endl
            << "  Encoding:   " << str_endian( reader.get_encoding() )
            << std::endl
            << "  ELFVersion: " << str_version( reader.get_elf_version() )
            << std::endl
            << "  OS/ABI:     " << str_os_abi( reader.get_os_abi() )
            << std::endl
            << "  ABI Version:" << (int)reader.get_abi_version() << std::endl
            << "  Type:       " << str_type( reader.get_type() ) << std::endl
            << "  Machine:    " << str_machine( reader.get_machine() )
            << std::endl
            << "  Version:    " << str_version( reader.get_version() )
            << std::endl
            << "  Entry:      "
            << "0x" << std::hex << reader.get_entry() << std::endl
            << "  Flags:      "
            << "0x" << std::hex << reader.get_flags() << std::endl
            << std::endl;
    }

    //------------------------------------------------------------------------------
    static void section_headers( std::ostream& out, const elfio& reader )
    {
        Elf_Half n = reader.sections.size();

        if ( n == 0 ) {
            return;
        }

        out << "Section Headers:" << std::endl;
        if ( reader.get_class() == ELFCLASS32 ) { // Output for 32-bit
            out << "[  Nr ] Type              Addr       Size       ES   Flg "
                   "Lk   Inf   Al   Name"
                << std::endl;
        }
        else { // Output for 64-bit
            out << "[  Nr ] Type              Addr               Size          "
                   "     Offset     Flg"
                << std::endl
                << "        ES     Lk     Inf    Al       Name" << std::endl;
        }

        for ( Elf_Half i = 0; i < n; ++i ) { // For all sections
            const section* sec = reader.sections[i];
            section_header( out, i, sec, reader.get_class() );
        }

        out << "Key to Flags: W (write), A (alloc), X (execute), " << std::endl;
        out << "              M (merge), S (strings), I (info)," << std::endl;
        out << "              L (link order), O (extra OS processing required),"
            << std::endl;
        out << "              G (group), T (TLS), C (compressed), E (exclude)"
            << std::endl;
    }

    //------------------------------------------------------------------------------
    static void section_header( std::ostream&  out,
                                Elf_Half       no,
                                const section* sec,
                                unsigned char  elf_class )
    {
        std::ios_base::fmtflags original_flags = out.flags();

        // clang-format off
        if ( elf_class == ELFCLASS32 ) { // Output for 32-bit
            out << "[" << DUMP_DEC_FORMAT( 5 ) << no << "] "
                << DUMP_STR_FORMAT( 17 ) << str_section_type( sec->get_type() )
                << " " << DUMP_HEX0x_FORMAT( 8 ) << sec->get_address() << " "
                << DUMP_HEX0x_FORMAT( 8 ) << sec->get_size() << " "
                << DUMP_HEX0x_FORMAT( 2 ) << sec->get_entry_size() << " "
                << DUMP_STR_FORMAT( 3 ) << section_flags( sec->get_flags() )
                << " " << DUMP_HEX0x_FORMAT( 2 ) << sec->get_link() << " "
                << DUMP_HEX0x_FORMAT( 3 ) << sec->get_info() << " "
                << DUMP_HEX0x_FORMAT( 2 ) << sec->get_addr_align() << " "
                << DUMP_STR_FORMAT( 17 ) << sec->get_name() << " " << std::endl;
        }
        else { // Output for 64-bit
            out << "[" << DUMP_DEC_FORMAT( 5 ) << no << "] "
                << DUMP_STR_FORMAT( 17 ) << str_section_type( sec->get_type() ) << " "
                << DUMP_HEX0x_FORMAT( 16 ) << sec->get_address()                  << " "
                << DUMP_HEX0x_FORMAT( 16 ) << sec->get_size()                     << " "
                << DUMP_HEX0x_FORMAT(  8 ) << sec->get_offset()                   << " "
                << DUMP_STR_FORMAT(  3) << section_flags( sec->get_flags() )
                << std::endl
                << DUMP_STR_FORMAT( 8 ) << " "
                << DUMP_HEX0x_FORMAT( 4 ) << sec->get_entry_size() << " "
                << DUMP_HEX0x_FORMAT( 4 ) << sec->get_link()       << " "
                << DUMP_HEX0x_FORMAT( 4 ) << sec->get_info()       << " "
                << DUMP_HEX0x_FORMAT( 4 ) << sec->get_addr_align() << "   "
                << DUMP_STR_FORMAT( 17 ) << sec->get_name()
                << std::endl;
        }
        // clang-format on

        out.flags( original_flags );

        return;
    }

    //------------------------------------------------------------------------------
    static void segment_headers( std::ostream& out, const elfio& reader )
    {
        Elf_Half n = reader.segments.size();
        if ( n == 0 ) {
            return;
        }

        out << "Program Headers:" << std::endl;
        if ( reader.get_class() == ELFCLASS32 ) { // Output for 32-bit
            out << "[  Nr ] Type           VirtAddr   PhysAddr   FileSize   "
                   "Mem.Size   Flags    Align"
                << std::endl;
        }
        else { // Output for 64-bit
            out << "[  Nr ] Type           Offset             VirtAddr         "
                   "  PhysAddr"

                << std::endl
                << "                       FileSize           MemSize          "
                   "   Flags  Align"
                << std::endl;
        }

        for ( Elf_Half i = 0; i < n; ++i ) {
            const segment* seg = reader.segments[i];
            segment_header( out, i, seg, reader.get_class() );
        }

        out << std::endl;
    }

    //------------------------------------------------------------------------------
    static void segment_header( std::ostream&  out,
                                Elf_Half       no,
                                const segment* seg,
                                unsigned int   elf_class )
    {
        std::ios_base::fmtflags original_flags = out.flags();
        // clang-format off
        if ( elf_class == ELFCLASS32 ) { // Output for 32-bit
            out << "[" << DUMP_DEC_FORMAT( 5 ) << no << "] "
                << DUMP_STR_FORMAT( 14 ) << str_segment_type( seg->get_type() )
                << " " << DUMP_HEX0x_FORMAT( 8 ) << seg->get_virtual_address()
                << " " << DUMP_HEX0x_FORMAT( 8 ) << seg->get_physical_address()
                << " " << DUMP_HEX0x_FORMAT( 8 ) << seg->get_file_size() << " "
                << DUMP_HEX0x_FORMAT( 8 ) << seg->get_memory_size() << " "
                << DUMP_STR_FORMAT( 8 ) << str_segment_flag( seg->get_flags() )
                << " " << DUMP_HEX0x_FORMAT( 8 ) << seg->get_align() << " "
                << std::endl;
        }
        else { // Output for 64-bit
            out << "[" << DUMP_DEC_FORMAT( 5 ) << no << "] "
                << DUMP_STR_FORMAT( 14 ) << str_segment_type( seg->get_type() ) << " " 
                << DUMP_HEX0x_FORMAT( 16 ) << seg->get_offset()           << " "
                << DUMP_HEX0x_FORMAT( 16 ) << seg->get_virtual_address()  << " "
                << DUMP_HEX0x_FORMAT( 16 ) << seg->get_physical_address()
                << std::endl
                << DUMP_STR_FORMAT( 23 ) << " "
                << DUMP_HEX0x_FORMAT( 16 ) << seg->get_file_size()         << " "
                << DUMP_HEX0x_FORMAT( 16 ) << seg->get_memory_size()       << "  "
                << DUMP_STR_FORMAT(  3 ) << str_segment_flag( seg->get_flags() ) << "    "
                << DUMP_HEX0x_FORMAT(  1 ) << seg->get_align() 
                << std::endl;
        }
        // clang-format on

        out.flags( original_flags );
    }

    //------------------------------------------------------------------------------
    static void symbol_tables( std::ostream& out, const elfio& reader )
    {
        for ( const auto& sec : reader.sections ) { // For all sections
            if ( SHT_SYMTAB == sec->get_type() ||
                 SHT_DYNSYM == sec->get_type() ) {
                const_symbol_section_accessor symbols( reader, sec.get() );

                Elf_Xword sym_no = symbols.get_symbols_num();
                if ( sym_no == 0 ) {
                    continue;
                }

                out << "Symbol table (" << sec->get_name() << ")" << std::endl;
                if ( reader.get_class() == ELFCLASS32 ) { // Output for 32-bit
                    out << "[  Nr ] Value      Size       Type    Bind     "
                           " Sect Name"
                        << std::endl;
                }
                else { // Output for 64-bit
                    out << "[  Nr ] Value              Size               "
                           "Type    Bind      Sect"
                        << std::endl
                        << "        Name" << std::endl;
                }
                for ( Elf_Xword i = 0; i < sym_no; ++i ) {
                    std::string   name;
                    Elf64_Addr    value   = 0;
                    Elf_Xword     size    = 0;
                    unsigned char bind    = 0;
                    unsigned char type    = 0;
                    Elf_Half      section = 0;
                    unsigned char other   = 0;
                    symbols.get_symbol( i, name, value, size, bind, type,
                                        section, other );
                    symbol_table( out, i, name, value, size, bind, type,
                                  section, reader.get_class() );
                }

                out << std::endl;
            }
        }
    }

    //------------------------------------------------------------------------------
    static void symbol_table( std::ostream&      out,
                              Elf_Xword          no,
                              const std::string& name,
                              Elf64_Addr         value,
                              Elf_Xword          size,
                              unsigned char      bind,
                              unsigned char      type,
                              Elf_Half           section,
                              unsigned int       elf_class )
    {
        std::ios_base::fmtflags original_flags = out.flags();

        if ( elf_class == ELFCLASS32 ) { // Output for 32-bit
            out << "[" << DUMP_DEC_FORMAT( 5 ) << no << "] "
                << DUMP_HEX0x_FORMAT( 8 ) << value << " "
                << DUMP_HEX0x_FORMAT( 8 ) << size << " " << DUMP_STR_FORMAT( 7 )
                << str_symbol_type( type ) << " " << DUMP_STR_FORMAT( 8 )
                << str_symbol_bind( bind ) << " " << DUMP_DEC_FORMAT( 5 )
                << section << " " << DUMP_STR_FORMAT( 1 ) << name << " "
                << std::endl;
        }
        else { // Output for 64-bit
            out << "[" << DUMP_DEC_FORMAT( 5 ) << no << "] "
                << DUMP_HEX0x_FORMAT( 16 ) << value << " "
                << DUMP_HEX0x_FORMAT( 16 ) << size << " "
                << DUMP_STR_FORMAT( 7 ) << str_symbol_type( type ) << " "
                << DUMP_STR_FORMAT( 8 ) << str_symbol_bind( bind ) << " "
                << DUMP_DEC_FORMAT( 5 ) << section << " " << std::endl
                << "        " << DUMP_STR_FORMAT( 1 ) << name << " "
                << std::endl;
        }

        out.flags( original_flags );
    }

    //------------------------------------------------------------------------------
    static void notes( std::ostream& out, const elfio& reader )
    {
        for ( const auto& sec : reader.sections ) { // For all sections
            if ( SHT_NOTE == sec->get_type() ) {    // Look at notes
                note_section_accessor notes( reader, sec.get() );
                Elf_Word              no_notes = notes.get_notes_num();

                if ( no_notes == 0 )
                    continue;

                out << "Note section (" << sec->get_name() << ")" << std::endl
                    << "    No Name         Data size  Description"
                    << std::endl;
                for ( Elf_Word j = 0; j < no_notes; ++j ) { // For all notes
                    Elf_Word    type;
                    std::string name;
                    char*       desc;
                    Elf_Word    descsz;

                    if ( notes.get_note( j, type, name, desc, descsz ) ) {
                        // 'name' usually contains \0 at the end. Remove it
                        name = name.c_str();
                        note( out, j, type, name, desc, descsz );
                        out << std::endl;
                    }
                }

                out << std::endl;
            }
        }

        Elf_Half no = reader.segments.size();
        for ( Elf_Half i = 0; i < no; ++i ) { // For all segments
            segment* seg = reader.segments[i];
            if ( PT_NOTE == seg->get_type() ) { // Look at notes
                note_segment_accessor notes( reader, seg );
                Elf_Word              no_notes = notes.get_notes_num();

                if ( no_notes == 0 )
                    continue;

                out << "Note segment (" << i << ")" << std::endl
                    << "    No Name         Data size  Description"
                    << std::endl;
                for ( Elf_Word j = 0; j < no_notes; ++j ) { // For all notes
                    Elf_Word    type;
                    std::string name;
                    char*       desc;
                    Elf_Word    descsz;

                    if ( notes.get_note( j, type, name, desc, descsz ) ) {
                        // 'name' usually contains \0 at the end. Remove it
                        name = name.c_str();
                        note( out, j, type, name, desc, descsz );
                        out << std::endl;
                    }
                }

                out << std::endl;
            }
        }
    }

    //------------------------------------------------------------------------------
    static void note( std::ostream&      out,
                      int                no,
                      Elf_Word           type,
                      const std::string& name,
                      void*              desc,
                      Elf_Word           descsz )
    {
        out << "  [" << DUMP_DEC_FORMAT( 2 ) << no << "] ";

        const auto name_group = std::find_if(
            std::begin( note_tag_table ), std::end( note_tag_table ),
            [&name]( const note_tag_t& entry ) { return entry.name == name; } );

        std::vector<note_tag_t::note_values_t>::const_iterator type_value;
        if ( name_group != std::end( note_tag_table ) ) {
            type_value = std::find_if(
                name_group->values.begin(), name_group->values.end(),
                [&type]( const note_tag_t::note_values_t& e ) {
                    return e.type == type;
                } );
        }

        if ( name_group != std::end( note_tag_table ) &&
             type_value != name_group->values.end() ) {
            out << DUMP_STR_FORMAT( 12 ) << name_group->name << " "
                << DUMP_HEX0x_FORMAT( 8 ) << descsz << " "
                << type_value->type_str << " (" << type_value->description
                << ")";
        }
        else {
            out << DUMP_STR_FORMAT( 12 ) << name << " "
                << DUMP_HEX0x_FORMAT( 8 ) << descsz << " "
                << DUMP_HEX0x_FORMAT( 8 ) << type;
        }

        if ( descsz != 0 ) {
            for ( Elf_Word i = 0; i < descsz; ++i ) {
                if ( i % 16 == 0 ) {
                    out << std::endl << "         ";
                }
                out << DUMP_HEX_FORMAT( 2 )
                    << (uint32_t)( (uint8_t*)( desc ) )[i];
            }
        }
    }

    //------------------------------------------------------------------------------
    static void modinfo( std::ostream& out, const elfio& reader )
    {
        for ( const auto& sec : reader.sections ) { // For all sections
            if ( ".modinfo" == sec->get_name() ) {  // Look for the section
                out << "Section .modinfo" << std::endl;

                const_modinfo_section_accessor modinfo( sec.get() );
                for ( Elf_Word i = 0; i < modinfo.get_attribute_num(); i++ ) {
                    std::string field;
                    std::string value;
                    if ( modinfo.get_attribute( i, field, value ) ) {
                        out << "  " << std::setw( 20 ) << field
                            << std::setw( 0 ) << " = " << value << std::endl;
                    }
                }

                out << std::endl;
                break;
            }
        }
    }

    //------------------------------------------------------------------------------
    static void dynamic_tags( std::ostream& out, const elfio& reader )
    {
        for ( const auto& sec : reader.sections ) { // For all sections
            if ( SHT_DYNAMIC == sec->get_type() ) {
                dynamic_section_accessor dynamic( reader, sec.get() );

                Elf_Xword dyn_no = dynamic.get_entries_num();
                if ( dyn_no == 0 )
                    continue;

                out << "Dynamic section (" << sec->get_name() << ")"
                    << std::endl;
                out << "[  Nr ] Tag              Name/Value" << std::endl;
                for ( Elf_Xword i = 0; i < dyn_no; ++i ) {
                    Elf_Xword   tag   = 0;
                    Elf_Xword   value = 0;
                    std::string str;
                    dynamic.get_entry( i, tag, value, str );
                    dynamic_tag( out, i, tag, value, str, reader.get_class() );
                    if ( DT_NULL == tag ) {
                        break;
                    }
                }

                out << std::endl;
            }
        }
    }

    //------------------------------------------------------------------------------
    static void dynamic_tag( std::ostream&      out,
                             Elf_Xword          no,
                             Elf_Xword          tag,
                             Elf_Xword          value,
                             const std::string& str,
                             unsigned int /*elf_class*/ )
    {
        out << "[" << DUMP_DEC_FORMAT( 5 ) << no << "] "
            << DUMP_STR_FORMAT( 16 ) << str_dynamic_tag( tag ) << " ";
        if ( str.empty() ) {
            out << DUMP_HEX0x_FORMAT( 16 ) << value << " ";
        }
        else {
            out << DUMP_STR_FORMAT( 32 ) << str << " ";
        }
        out << std::endl;
    }

    //------------------------------------------------------------------------------
    static void section_data( std::ostream& out, const section* sec )
    {
        std::ios_base::fmtflags original_flags = out.flags();

        out << sec->get_name() << std::endl;
        const char* pdata = sec->get_data();
        if ( pdata ) {
            ELFIO::Elf_Xword i;
            for ( i = 0; i < std::min( sec->get_size(), MAX_DATA_ENTRIES );
                  ++i ) {
                if ( i % 16 == 0 ) {
                    out << "[" << DUMP_HEX0x_FORMAT( 8 ) << i << "]";
                }

                out << " " << DUMP_HEX0x_FORMAT( 2 )
                    << ( pdata[i] & 0x000000FF );

                if ( i % 16 == 15 ) {
                    out << std::endl;
                }
            }
            if ( i % 16 != 0 ) {
                out << std::endl;
            }

            out.flags( original_flags );
        }

        return;
    }

    //------------------------------------------------------------------------------
    static void section_datas( std::ostream& out, const elfio& reader )
    {
        Elf_Half n = reader.sections.size();

        if ( n == 0 ) {
            return;
        }

        out << "Section Data:" << std::endl;

        for ( Elf_Half i = 1; i < n; ++i ) { // For all sections
            const section* sec = reader.sections[i];
            if ( sec->get_type() == SHT_NOBITS ) {
                continue;
            }
            section_data( out, sec );
        }

        out << std::endl;
    }

    //------------------------------------------------------------------------------
    static void
    segment_data( std::ostream& out, Elf_Half no, const segment* seg )
    {
        std::ios_base::fmtflags original_flags = out.flags();

        out << "Segment # " << no << std::endl;
        const char* pdata = seg->get_data();
        if ( pdata ) {
            ELFIO::Elf_Xword i;
            for ( i = 0; i < std::min( seg->get_file_size(), MAX_DATA_ENTRIES );
                  ++i ) {
                if ( i % 16 == 0 ) {
                    out << "[" << DUMP_HEX0x_FORMAT( 8 ) << i << "]";
                }

                out << " " << DUMP_HEX0x_FORMAT( 2 )
                    << ( pdata[i] & 0x000000FF );

                if ( i % 16 == 15 ) {
                    out << std::endl;
                }
            }
            if ( i % 16 != 0 ) {
                out << std::endl;
            }

            out.flags( original_flags );
        }

        return;
    }

    //------------------------------------------------------------------------------
    static void segment_datas( std::ostream& out, const elfio& reader )
    {
        Elf_Half n = reader.segments.size();

        if ( n == 0 ) {
            return;
        }

        out << "Segment Data:" << std::endl;

        for ( Elf_Half i = 0; i < n; ++i ) { // For all sections
            const segment* seg = reader.segments[i];
            segment_data( out, i, seg );
        }

        out << std::endl;
    }

//------------------------------------------------------------------------------
#define STR_FUNC_TABLE( name )                                         \
    template <typename T> static std::string str_##name( const T key ) \
    {                                                                  \
        return format_assoc( name##_table, key );                      \
    }

    STR_FUNC_TABLE( class )
    STR_FUNC_TABLE( endian )
    STR_FUNC_TABLE( version )
    STR_FUNC_TABLE( os_abi )
    STR_FUNC_TABLE( type )
    STR_FUNC_TABLE( machine )
    STR_FUNC_TABLE( section_type )
    STR_FUNC_TABLE( segment_type )
    STR_FUNC_TABLE( segment_flag )
    STR_FUNC_TABLE( symbol_bind )
    STR_FUNC_TABLE( symbol_type )
    STR_FUNC_TABLE( dynamic_tag )

#undef STR_FUNC_TABLE

  private:
    //------------------------------------------------------------------------------
    template <typename T, typename K>
    std::string static find_value_in_table( const T& table, const K& key )
    {
        std::string res = "?";
        for ( unsigned int i = 0; i < sizeof( table ) / sizeof( table[0] );
              ++i ) {
            if ( table[i].key == key ) {
                res = table[i].str;
                break;
            }
        }

        return res;
    }

    //------------------------------------------------------------------------------
    template <typename T, typename K>
    static std::string format_assoc( const T& table, const K& key )
    {
        std::string str = find_value_in_table( table, key );
        if ( str == "?" ) {
            std::ostringstream oss;
            oss << str << " (0x" << std::hex << key << ")";
            str = oss.str();
        }

        return str;
    }

    //------------------------------------------------------------------------------
    template <typename T>
    static std::string format_assoc( const T& table, const char key )
    {
        return format_assoc( table, (const int)key );
    }

    //------------------------------------------------------------------------------
    static std::string section_flags( Elf_Xword flags )
    {
        std::string ret = "";
        if ( flags & SHF_WRITE ) {
            ret += "W";
        }
        if ( flags & SHF_ALLOC ) {
            ret += "A";
        }
        if ( flags & SHF_EXECINSTR ) {
            ret += "X";
        }
        if ( flags & SHF_MERGE ) {
            ret += "M";
        }
        if ( flags & SHF_STRINGS ) {
            ret += "S";
        }
        if ( flags & SHF_INFO_LINK ) {
            ret += "I";
        }
        if ( flags & SHF_LINK_ORDER ) {
            ret += "L";
        }
        if ( flags & SHF_OS_NONCONFORMING ) {
            ret += "O";
        }
        if ( flags & SHF_GROUP ) {
            ret += "G";
        }
        if ( flags & SHF_TLS ) {
            ret += "T";
        }
        if ( flags & SHF_COMPRESSED ) {
            ret += "C";
        }
        if ( flags & SHF_EXCLUDE ) {
            ret += "E";
        }
        if ( flags & SHF_GNU_MBIND ) {
            ret += "D";
        }

        return ret;
    }

#undef DUMP_DEC_FORMAT
#undef DUMP_HEX0x_FORMAT
#undef DUMP_STR_FORMAT
}; // class dump
} // namespace ELFIO

#endif // ELFIO_DUMP_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_DYNAMIC_HPP
#define ELFIO_DYNAMIC_HPP

#include <algorithm>

namespace ELFIO {

//------------------------------------------------------------------------------
template <class S> class dynamic_section_accessor_template
{
  public:
    //------------------------------------------------------------------------------
    explicit dynamic_section_accessor_template( const elfio& elf_file,
                                                S*           section )
        : elf_file( elf_file ), dynamic_section( section ), entries_num( 0 )
    {
    }

    //------------------------------------------------------------------------------
    Elf_Xword get_entries_num() const
    {
        size_t needed_entry_size = -1;
        if ( elf_file.get_class() == ELFCLASS32 ) {
            needed_entry_size = sizeof( Elf32_Dyn );
        }
        else {
            needed_entry_size = sizeof( Elf64_Dyn );
        }

        if ( ( 0 == entries_num ) &&
             ( 0 != dynamic_section->get_entry_size() &&
               dynamic_section->get_entry_size() >= needed_entry_size ) ) {
            entries_num =
                dynamic_section->get_size() / dynamic_section->get_entry_size();
            Elf_Xword   i;
            Elf_Xword   tag   = DT_NULL;
            Elf_Xword   value = 0;
            std::string str;
            for ( i = 0; i < entries_num; i++ ) {
                get_entry( i, tag, value, str );
                if ( tag == DT_NULL )
                    break;
            }
            entries_num = std::min<Elf_Xword>( entries_num, i + 1 );
        }

        return entries_num;
    }

    //------------------------------------------------------------------------------
    bool get_entry( Elf_Xword    index,
                    Elf_Xword&   tag,
                    Elf_Xword&   value,
                    std::string& str ) const
    {
        if ( index >= get_entries_num() ) { // Is index valid
            return false;
        }

        if ( elf_file.get_class() == ELFCLASS32 ) {
            generic_get_entry_dyn<Elf32_Dyn>( index, tag, value );
        }
        else {
            generic_get_entry_dyn<Elf64_Dyn>( index, tag, value );
        }

        // If the tag has a string table reference - prepare the string
        if ( tag == DT_NEEDED || tag == DT_SONAME || tag == DT_RPATH ||
             tag == DT_RUNPATH ) {
            string_section_accessor strsec(
                elf_file.sections[get_string_table_index()] );
            const char* result = strsec.get_string( (Elf_Word)value );
            if ( nullptr == result ) {
                str.clear();
                return false;
            }
            str = result;
        }
        else {
            str.clear();
        }

        return true;
    }

    //------------------------------------------------------------------------------
    void add_entry( Elf_Xword tag, Elf_Xword value )
    {
        if ( elf_file.get_class() == ELFCLASS32 ) {
            generic_add_entry_dyn<Elf32_Dyn>( tag, value );
        }
        else {
            generic_add_entry_dyn<Elf64_Dyn>( tag, value );
        }
    }

    //------------------------------------------------------------------------------
    void add_entry( Elf_Xword tag, const std::string& str )
    {
        string_section_accessor strsec(
            elf_file.sections[get_string_table_index()] );
        Elf_Xword value = strsec.add_string( str );
        add_entry( tag, value );
    }

    //------------------------------------------------------------------------------
  private:
    //------------------------------------------------------------------------------
    Elf_Half get_string_table_index() const
    {
        return (Elf_Half)dynamic_section->get_link();
    }

    //------------------------------------------------------------------------------
    template <class T>
    void generic_get_entry_dyn( Elf_Xword  index,
                                Elf_Xword& tag,
                                Elf_Xword& value ) const
    {
        const endianess_convertor& convertor = elf_file.get_convertor();

        // Check unusual case when dynamic section has no data
        if ( dynamic_section->get_data() == nullptr ||
             ( index + 1 ) * dynamic_section->get_entry_size() >
                 dynamic_section->get_size() ||
             dynamic_section->get_entry_size() < sizeof( T ) ) {
            tag   = DT_NULL;
            value = 0;
            return;
        }

        const T* pEntry = reinterpret_cast<const T*>(
            dynamic_section->get_data() +
            index * dynamic_section->get_entry_size() );
        tag = convertor( pEntry->d_tag );
        switch ( tag ) {
        case DT_NULL:
        case DT_SYMBOLIC:
        case DT_TEXTREL:
        case DT_BIND_NOW:
            value = 0;
            break;
        case DT_NEEDED:
        case DT_PLTRELSZ:
        case DT_RELASZ:
        case DT_RELAENT:
        case DT_STRSZ:
        case DT_SYMENT:
        case DT_SONAME:
        case DT_RPATH:
        case DT_RELSZ:
        case DT_RELENT:
        case DT_PLTREL:
        case DT_INIT_ARRAYSZ:
        case DT_FINI_ARRAYSZ:
        case DT_RUNPATH:
        case DT_FLAGS:
        case DT_PREINIT_ARRAYSZ:
            value = convertor( pEntry->d_un.d_val );
            break;
        case DT_PLTGOT:
        case DT_HASH:
        case DT_STRTAB:
        case DT_SYMTAB:
        case DT_RELA:
        case DT_INIT:
        case DT_FINI:
        case DT_REL:
        case DT_DEBUG:
        case DT_JMPREL:
        case DT_INIT_ARRAY:
        case DT_FINI_ARRAY:
        case DT_PREINIT_ARRAY:
        default:
            value = convertor( pEntry->d_un.d_ptr );
            break;
        }
    }

    //------------------------------------------------------------------------------
    template <class T>
    void generic_add_entry_dyn( Elf_Xword tag, Elf_Xword value )
    {
        const endianess_convertor& convertor = elf_file.get_convertor();

        T entry;

        switch ( tag ) {
        case DT_NULL:
        case DT_SYMBOLIC:
        case DT_TEXTREL:
        case DT_BIND_NOW:
            entry.d_un.d_val = convertor( decltype( entry.d_un.d_val )( 0 ) );
            break;
        case DT_NEEDED:
        case DT_PLTRELSZ:
        case DT_RELASZ:
        case DT_RELAENT:
        case DT_STRSZ:
        case DT_SYMENT:
        case DT_SONAME:
        case DT_RPATH:
        case DT_RELSZ:
        case DT_RELENT:
        case DT_PLTREL:
        case DT_INIT_ARRAYSZ:
        case DT_FINI_ARRAYSZ:
        case DT_RUNPATH:
        case DT_FLAGS:
        case DT_PREINIT_ARRAYSZ:
            entry.d_un.d_val =
                convertor( decltype( entry.d_un.d_val )( value ) );
            break;
        case DT_PLTGOT:
        case DT_HASH:
        case DT_STRTAB:
        case DT_SYMTAB:
        case DT_RELA:
        case DT_INIT:
        case DT_FINI:
        case DT_REL:
        case DT_DEBUG:
        case DT_JMPREL:
        case DT_INIT_ARRAY:
        case DT_FINI_ARRAY:
        case DT_PREINIT_ARRAY:
        default:
            entry.d_un.d_ptr =
                convertor( decltype( entry.d_un.d_val )( value ) );
            break;
        }

        entry.d_tag = convertor( decltype( entry.d_tag )( tag ) );

        dynamic_section->append_data( reinterpret_cast<char*>( &entry ),
                                      sizeof( entry ) );
    }

    //------------------------------------------------------------------------------
  private:
    const elfio&      elf_file;
    S*                dynamic_section;
    mutable Elf_Xword entries_num;
};

using dynamic_section_accessor = dynamic_section_accessor_template<section>;
using const_dynamic_section_accessor =
    dynamic_section_accessor_template<const section>;

} // namespace ELFIO

#endif // ELFIO_DYNAMIC_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELF_HEADER_HPP
#define ELF_HEADER_HPP

#include <iostream>

namespace ELFIO {

class elf_header
{
  public:
    virtual ~elf_header() = default;

    virtual bool load( std::istream& stream )       = 0;
    virtual bool save( std::ostream& stream ) const = 0;

    // ELF header functions
    ELFIO_GET_ACCESS_DECL( unsigned char, class );
    ELFIO_GET_ACCESS_DECL( unsigned char, elf_version );
    ELFIO_GET_ACCESS_DECL( unsigned char, encoding );
    ELFIO_GET_ACCESS_DECL( Elf_Half, header_size );
    ELFIO_GET_ACCESS_DECL( Elf_Half, section_entry_size );
    ELFIO_GET_ACCESS_DECL( Elf_Half, segment_entry_size );

    ELFIO_GET_SET_ACCESS_DECL( Elf_Word, version );
    ELFIO_GET_SET_ACCESS_DECL( unsigned char, os_abi );
    ELFIO_GET_SET_ACCESS_DECL( unsigned char, abi_version );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Half, type );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Half, machine );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Word, flags );
    ELFIO_GET_SET_ACCESS_DECL( Elf64_Addr, entry );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Half, sections_num );
    ELFIO_GET_SET_ACCESS_DECL( Elf64_Off, sections_offset );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Half, segments_num );
    ELFIO_GET_SET_ACCESS_DECL( Elf64_Off, segments_offset );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Half, section_name_str_index );
};

template <class T> struct elf_header_impl_types;
template <> struct elf_header_impl_types<Elf32_Ehdr>
{
    using Phdr_type                       = Elf32_Phdr;
    using Shdr_type                       = Elf32_Shdr;
    static const unsigned char file_class = ELFCLASS32;
};
template <> struct elf_header_impl_types<Elf64_Ehdr>
{
    using Phdr_type                       = Elf64_Phdr;
    using Shdr_type                       = Elf64_Shdr;
    static const unsigned char file_class = ELFCLASS64;
};

template <class T> class elf_header_impl : public elf_header
{
  public:
    //------------------------------------------------------------------------------
    elf_header_impl( endianess_convertor*      convertor,
                     unsigned char             encoding,
                     const address_translator* translator )
        : convertor( convertor ), translator( translator )
    {
        header.e_ident[EI_MAG0]    = ELFMAG0;
        header.e_ident[EI_MAG1]    = ELFMAG1;
        header.e_ident[EI_MAG2]    = ELFMAG2;
        header.e_ident[EI_MAG3]    = ELFMAG3;
        header.e_ident[EI_CLASS]   = elf_header_impl_types<T>::file_class;
        header.e_ident[EI_DATA]    = encoding;
        header.e_ident[EI_VERSION] = EV_CURRENT;
        header.e_version           = ( *convertor )( (Elf_Word)EV_CURRENT );
        header.e_ehsize            = ( sizeof( header ) );
        header.e_ehsize            = ( *convertor )( header.e_ehsize );
        header.e_shstrndx          = ( *convertor )( (Elf_Half)1 );
        header.e_phentsize =
            sizeof( typename elf_header_impl_types<T>::Phdr_type );
        header.e_shentsize =
            sizeof( typename elf_header_impl_types<T>::Shdr_type );
        header.e_phentsize = ( *convertor )( header.e_phentsize );
        header.e_shentsize = ( *convertor )( header.e_shentsize );
    }

    //------------------------------------------------------------------------------
    bool load( std::istream& stream ) override
    {
        stream.seekg( ( *translator )[0] );
        stream.read( reinterpret_cast<char*>( &header ), sizeof( header ) );

        return ( stream.gcount() == sizeof( header ) );
    }

    //------------------------------------------------------------------------------
    bool save( std::ostream& stream ) const override
    {
        stream.seekp( ( *translator )[0] );
        stream.write( reinterpret_cast<const char*>( &header ),
                      sizeof( header ) );

        return stream.good();
    }

    //------------------------------------------------------------------------------
    // ELF header functions
    ELFIO_GET_ACCESS( unsigned char, class, header.e_ident[EI_CLASS] );
    ELFIO_GET_ACCESS( unsigned char, elf_version, header.e_ident[EI_VERSION] );
    ELFIO_GET_ACCESS( unsigned char, encoding, header.e_ident[EI_DATA] );
    ELFIO_GET_ACCESS( Elf_Half, header_size, header.e_ehsize );
    ELFIO_GET_ACCESS( Elf_Half, section_entry_size, header.e_shentsize );
    ELFIO_GET_ACCESS( Elf_Half, segment_entry_size, header.e_phentsize );

    ELFIO_GET_SET_ACCESS( Elf_Word, version, header.e_version );
    ELFIO_GET_SET_ACCESS( unsigned char, os_abi, header.e_ident[EI_OSABI] );
    ELFIO_GET_SET_ACCESS( unsigned char,
                          abi_version,
                          header.e_ident[EI_ABIVERSION] );
    ELFIO_GET_SET_ACCESS( Elf_Half, type, header.e_type );
    ELFIO_GET_SET_ACCESS( Elf_Half, machine, header.e_machine );
    ELFIO_GET_SET_ACCESS( Elf_Word, flags, header.e_flags );
    ELFIO_GET_SET_ACCESS( Elf_Half, section_name_str_index, header.e_shstrndx );
    ELFIO_GET_SET_ACCESS( Elf64_Addr, entry, header.e_entry );
    ELFIO_GET_SET_ACCESS( Elf_Half, sections_num, header.e_shnum );
    ELFIO_GET_SET_ACCESS( Elf64_Off, sections_offset, header.e_shoff );
    ELFIO_GET_SET_ACCESS( Elf_Half, segments_num, header.e_phnum );
    ELFIO_GET_SET_ACCESS( Elf64_Off, segments_offset, header.e_phoff );

  private:
    T                         header     = {};
    endianess_convertor*      convertor  = nullptr;
    const address_translator* translator = nullptr;
};

} // namespace ELFIO

#endif // ELF_HEADER_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_MODINFO_HPP
#define ELFIO_MODINFO_HPP

#include <string_view>
#include <vector>

namespace ELFIO {

//------------------------------------------------------------------------------
template <class S> class modinfo_section_accessor_template
{
  public:
    //------------------------------------------------------------------------------
    explicit modinfo_section_accessor_template( S* section )
        : modinfo_section( section )
    {
        process_section();
    }

    //------------------------------------------------------------------------------
    Elf_Word get_attribute_num() const { return (Elf_Word)content.size(); }

    //------------------------------------------------------------------------------
    bool
    get_attribute( Elf_Word no, std::string& field, std::string& value ) const
    {
        if ( no < content.size() ) {
            field = content[no].first;
            value = content[no].second;
            return true;
        }

        return false;
    }

    //------------------------------------------------------------------------------
    bool get_attribute( const std::string_view& field_name,
                        std::string&            value ) const
    {
        for ( const auto [first, second] : content ) {
            if ( field_name == first ) {
                value = second;
                return true;
            }
        }

        return false;
    }

    //------------------------------------------------------------------------------
    Elf_Word add_attribute( const std::string& field, const std::string& value )
    {
        Elf_Word current_position = 0;

        if ( modinfo_section ) {
            // Strings are addeded to the end of the current section data
            current_position = (Elf_Word)modinfo_section->get_size();

            std::string attribute = field + "=" + value;

            modinfo_section->append_data( attribute + '\0' );
            content.emplace_back( field, value );
        }

        return current_position;
    }

    //------------------------------------------------------------------------------
  private:
    void process_section()
    {
        const char* pdata = modinfo_section->get_data();
        if ( pdata ) {
            ELFIO::Elf_Xword i = 0;
            while ( i < modinfo_section->get_size() ) {
                while ( i < modinfo_section->get_size() && !pdata[i] )
                    i++;
                if ( i < modinfo_section->get_size() ) {
                    std::string info = pdata + i;
                    size_t      loc  = info.find( '=' );
                    content.emplace_back( info.substr( 0, loc ),
                                          info.substr( loc + 1 ) );

                    i += info.length();
                }
            }
        }
    }

    //------------------------------------------------------------------------------
  private:
    S*                                               modinfo_section;
    std::vector<std::pair<std::string, std::string>> content;
};

using modinfo_section_accessor = modinfo_section_accessor_template<section>;
using const_modinfo_section_accessor =
    modinfo_section_accessor_template<const section>;

} // namespace ELFIO

#endif // ELFIO_MODINFO_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_NOTE_HPP
#define ELFIO_NOTE_HPP

namespace ELFIO {

//------------------------------------------------------------------------------
// There are discrepancies in documentations. SCO documentation
// (http://www.sco.com/developers/gabi/latest/ch5.pheader.html#note_section)
// requires 8 byte entries alignment for 64-bit ELF file,
// but Oracle's definition uses the same structure
// for 32-bit and 64-bit formats.
// (https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-18048.html)
//
// It looks like EM_X86_64 Linux implementation is similar to Oracle's
// definition. Therefore, the same alignment works for both formats
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
template <class S, Elf_Xword ( S::*F_get_size )() const>
class note_section_accessor_template
{
  public:
    //------------------------------------------------------------------------------
    explicit note_section_accessor_template( const elfio& elf_file, S* section )
        : elf_file( elf_file ), notes( section )
    {
        process_section();
    }

    //------------------------------------------------------------------------------
    Elf_Word get_notes_num() const
    {
        return (Elf_Word)note_start_positions.size();
    }

    //------------------------------------------------------------------------------
    bool get_note( Elf_Word     index,
                   Elf_Word&    type,
                   std::string& name,
                   char*&       desc,
                   Elf_Word&    descSize ) const
    {
        if ( index >= ( notes->*F_get_size )() ) {
            return false;
        }

        const char* pData = notes->get_data() + note_start_positions[index];
        int         align = sizeof( Elf_Word );

        const endianess_convertor& convertor = elf_file.get_convertor();
        type = convertor( *(const Elf_Word*)( pData + 2 * (size_t)align ) );
        Elf_Word namesz = convertor( *(const Elf_Word*)( pData ) );
        descSize = convertor( *(const Elf_Word*)( pData + sizeof( namesz ) ) );

        Elf_Xword max_name_size =
            ( notes->*F_get_size )() - note_start_positions[index];
        if ( namesz < 1 || namesz > max_name_size ||
             (Elf_Xword)namesz + descSize > max_name_size ) {
            return false;
        }
        name.assign( pData + 3 * (size_t)align, namesz - 1 );
        if ( 0 == descSize ) {
            desc = nullptr;
        }
        else {
            desc = const_cast<char*>( pData + 3 * (size_t)align +
                                      ( ( namesz + align - 1 ) / align ) *
                                          (size_t)align );
        }

        return true;
    }

    //------------------------------------------------------------------------------
    void add_note( Elf_Word           type,
                   const std::string& name,
                   const char*        desc,
                   Elf_Word           descSize )
    {
        const endianess_convertor& convertor = elf_file.get_convertor();

        int         align       = sizeof( Elf_Word );
        Elf_Word    nameLen     = (Elf_Word)name.size() + 1;
        Elf_Word    nameLenConv = convertor( nameLen );
        std::string buffer( reinterpret_cast<char*>( &nameLenConv ), align );
        Elf_Word    descSizeConv = convertor( descSize );

        buffer.append( reinterpret_cast<char*>( &descSizeConv ), align );
        type = convertor( type );
        buffer.append( reinterpret_cast<char*>( &type ), align );
        buffer.append( name );
        buffer.append( 1, '\x00' );
        const char pad[] = { '\0', '\0', '\0', '\0' };
        if ( nameLen % align != 0 ) {
            buffer.append( pad, (size_t)align - nameLen % align );
        }
        if ( desc != nullptr && descSize != 0 ) {
            buffer.append( desc, descSize );
            if ( descSize % align != 0 ) {
                buffer.append( pad, (size_t)align - descSize % align );
            }
        }

        note_start_positions.emplace_back( ( notes->*F_get_size )() );
        notes->append_data( buffer );
    }

  private:
    //------------------------------------------------------------------------------
    void process_section()
    {
        const endianess_convertor& convertor = elf_file.get_convertor();
        const char*                data      = notes->get_data();
        Elf_Xword                  size      = ( notes->*F_get_size )();
        Elf_Xword                  current   = 0;

        note_start_positions.clear();

        // Is it empty?
        if ( nullptr == data || 0 == size ) {
            return;
        }

        Elf_Word align = sizeof( Elf_Word );
        while ( current + (Elf_Xword)3 * align <= size ) {
            Elf_Word namesz = convertor( *(const Elf_Word*)( data + current ) );
            Elf_Word descsz = convertor(
                *(const Elf_Word*)( data + current + sizeof( namesz ) ) );
            Elf_Word advance =
                (Elf_Xword)3 * sizeof( Elf_Word ) +
                ( ( namesz + align - 1 ) / align ) * (Elf_Xword)align +
                ( ( descsz + align - 1 ) / align ) * (Elf_Xword)align;
            if ( namesz < size && descsz < size && current + advance <= size ) {
                note_start_positions.emplace_back( current );
            }
            else {
                break;
            }

            current += advance;
        }
    }

    //------------------------------------------------------------------------------
  private:
    const elfio&           elf_file;
    S*                     notes;
    std::vector<Elf_Xword> note_start_positions;
};

using note_section_accessor =
    note_section_accessor_template<section, &section::get_size>;
using const_note_section_accessor =
    note_section_accessor_template<const section, &section::get_size>;
using note_segment_accessor =
    note_section_accessor_template<segment, &segment::get_file_size>;
using const_note_segment_accessor =
    note_section_accessor_template<const segment, &segment::get_file_size>;

} // namespace ELFIO

#endif // ELFIO_NOTE_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_RELOCATION_HPP
#define ELFIO_RELOCATION_HPP

namespace ELFIO {

template <typename T> struct get_sym_and_type;
template <> struct get_sym_and_type<Elf32_Rel>
{
    static int get_r_sym( Elf_Xword info )
    {
        return ELF32_R_SYM( (Elf_Word)info );
    }
    static int get_r_type( Elf_Xword info )
    {
        return ELF32_R_TYPE( (Elf_Word)info );
    }
};
template <> struct get_sym_and_type<Elf32_Rela>
{
    static int get_r_sym( Elf_Xword info )
    {
        return ELF32_R_SYM( (Elf_Word)info );
    }
    static int get_r_type( Elf_Xword info )
    {
        return ELF32_R_TYPE( (Elf_Word)info );
    }
};
template <> struct get_sym_and_type<Elf64_Rel>
{
    static int get_r_sym( Elf_Xword info ) { return ELF64_R_SYM( info ); }
    static int get_r_type( Elf_Xword info ) { return ELF64_R_TYPE( info ); }
};
template <> struct get_sym_and_type<Elf64_Rela>
{
    static int get_r_sym( Elf_Xword info ) { return ELF64_R_SYM( info ); }
    static int get_r_type( Elf_Xword info ) { return ELF64_R_TYPE( info ); }
};

//------------------------------------------------------------------------------
template <class S> class relocation_section_accessor_template
{
  public:
    //------------------------------------------------------------------------------
    explicit relocation_section_accessor_template( const elfio& elf_file,
                                                   S*           section )
        : elf_file( elf_file ), relocation_section( section )
    {
    }

    //------------------------------------------------------------------------------
    Elf_Xword get_entries_num() const
    {
        Elf_Xword nRet = 0;

        if ( 0 != relocation_section->get_entry_size() ) {
            nRet = relocation_section->get_size() /
                   relocation_section->get_entry_size();
        }

        return nRet;
    }

    //------------------------------------------------------------------------------
    bool get_entry( Elf_Xword   index,
                    Elf64_Addr& offset,
                    Elf_Word&   symbol,
                    unsigned&   type,
                    Elf_Sxword& addend ) const
    {
        if ( index >= get_entries_num() ) { // Is index valid
            return false;
        }

        if ( elf_file.get_class() == ELFCLASS32 ) {
            if ( SHT_REL == relocation_section->get_type() ) {
                generic_get_entry_rel<Elf32_Rel>( index, offset, symbol, type,
                                                  addend );
            }
            else if ( SHT_RELA == relocation_section->get_type() ) {
                generic_get_entry_rela<Elf32_Rela>( index, offset, symbol, type,
                                                    addend );
            }
        }
        else {
            if ( SHT_REL == relocation_section->get_type() ) {
                generic_get_entry_rel<Elf64_Rel>( index, offset, symbol, type,
                                                  addend );
            }
            else if ( SHT_RELA == relocation_section->get_type() ) {
                generic_get_entry_rela<Elf64_Rela>( index, offset, symbol, type,
                                                    addend );
            }
        }

        return true;
    }

    //------------------------------------------------------------------------------
    bool get_entry( Elf_Xword    index,
                    Elf64_Addr&  offset,
                    Elf64_Addr&  symbolValue,
                    std::string& symbolName,
                    unsigned&    type,
                    Elf_Sxword&  addend,
                    Elf_Sxword&  calcValue ) const
    {
        // Do regular job
        Elf_Word symbol = 0;
        bool     ret    = get_entry( index, offset, symbol, type, addend );

        // Find the symbol
        Elf_Xword     size;
        unsigned char bind;
        unsigned char symbolType;
        Elf_Half      section;
        unsigned char other;

        symbol_section_accessor symbols(
            elf_file, elf_file.sections[get_symbol_table_index()] );
        ret = ret && symbols.get_symbol( symbol, symbolName, symbolValue, size,
                                         bind, symbolType, section, other );

        if ( ret ) { // Was it successful?
            switch ( type ) {
            case R_386_NONE: // none
                calcValue = 0;
                break;
            case R_386_32: // S + A
                calcValue = symbolValue + addend;
                break;
            case R_386_PC32: // S + A - P
                calcValue = symbolValue + addend - offset;
                break;
            case R_386_GOT32: // G + A - P
                calcValue = 0;
                break;
            case R_386_PLT32: // L + A - P
                calcValue = 0;
                break;
            case R_386_COPY: // none
                calcValue = 0;
                break;
            case R_386_GLOB_DAT: // S
            case R_386_JMP_SLOT: // S
                calcValue = symbolValue;
                break;
            case R_386_RELATIVE: // B + A
                calcValue = addend;
                break;
            case R_386_GOTOFF: // S + A - GOT
                calcValue = 0;
                break;
            case R_386_GOTPC: // GOT + A - P
                calcValue = 0;
                break;
            default: // Not recognized symbol!
                calcValue = 0;
                break;
            }
        }

        return ret;
    }

    //------------------------------------------------------------------------------
    bool set_entry( Elf_Xword  index,
                    Elf64_Addr offset,
                    Elf_Word   symbol,
                    unsigned   type,
                    Elf_Sxword addend )
    {
        if ( index >= get_entries_num() ) { // Is index valid
            return false;
        }

        if ( elf_file.get_class() == ELFCLASS32 ) {
            if ( SHT_REL == relocation_section->get_type() ) {
                generic_set_entry_rel<Elf32_Rel>( index, offset, symbol, type,
                                                  addend );
            }
            else if ( SHT_RELA == relocation_section->get_type() ) {
                generic_set_entry_rela<Elf32_Rela>( index, offset, symbol, type,
                                                    addend );
            }
        }
        else {
            if ( SHT_REL == relocation_section->get_type() ) {
                generic_set_entry_rel<Elf64_Rel>( index, offset, symbol, type,
                                                  addend );
            }
            else if ( SHT_RELA == relocation_section->get_type() ) {
                generic_set_entry_rela<Elf64_Rela>( index, offset, symbol, type,
                                                    addend );
            }
        }

        return true;
    }

    //------------------------------------------------------------------------------
    void add_entry( Elf64_Addr offset, Elf_Xword info )
    {
        if ( elf_file.get_class() == ELFCLASS32 ) {
            generic_add_entry<Elf32_Rel>( offset, info );
        }
        else {
            generic_add_entry<Elf64_Rel>( offset, info );
        }
    }

    //------------------------------------------------------------------------------
    void add_entry( Elf64_Addr offset, Elf_Word symbol, unsigned type )
    {
        Elf_Xword info;
        if ( elf_file.get_class() == ELFCLASS32 ) {
            info = ELF32_R_INFO( (Elf_Xword)symbol, type );
        }
        else {
            info = ELF64_R_INFO( (Elf_Xword)symbol, type );
        }

        add_entry( offset, info );
    }

    //------------------------------------------------------------------------------
    void add_entry( Elf64_Addr offset, Elf_Xword info, Elf_Sxword addend )
    {
        if ( elf_file.get_class() == ELFCLASS32 ) {
            generic_add_entry<Elf32_Rela>( offset, info, addend );
        }
        else {
            generic_add_entry<Elf64_Rela>( offset, info, addend );
        }
    }

    //------------------------------------------------------------------------------
    void add_entry( Elf64_Addr offset,
                    Elf_Word   symbol,
                    unsigned   type,
                    Elf_Sxword addend )
    {
        Elf_Xword info;
        if ( elf_file.get_class() == ELFCLASS32 ) {
            info = ELF32_R_INFO( (Elf_Xword)symbol, type );
        }
        else {
            info = ELF64_R_INFO( (Elf_Xword)symbol, type );
        }

        add_entry( offset, info, addend );
    }

    //------------------------------------------------------------------------------
    void add_entry( string_section_accessor str_writer,
                    const char*             str,
                    symbol_section_accessor sym_writer,
                    Elf64_Addr              value,
                    Elf_Word                size,
                    unsigned char           sym_info,
                    unsigned char           other,
                    Elf_Half                shndx,
                    Elf64_Addr              offset,
                    unsigned                type )
    {
        Elf_Word str_index = str_writer.add_string( str );
        Elf_Word sym_index = sym_writer.add_symbol( str_index, value, size,
                                                    sym_info, other, shndx );
        add_entry( offset, sym_index, type );
    }

    //------------------------------------------------------------------------------
    void swap_symbols( Elf_Xword first, Elf_Xword second )
    {
        Elf64_Addr offset = 0;
        Elf_Word   symbol = 0;
        unsigned   rtype  = 0;
        Elf_Sxword addend = 0;
        for ( Elf_Word i = 0; i < get_entries_num(); i++ ) {
            get_entry( i, offset, symbol, rtype, addend );
            if ( symbol == first ) {
                set_entry( i, offset, (Elf_Word)second, rtype, addend );
            }
            if ( symbol == second ) {
                set_entry( i, offset, (Elf_Word)first, rtype, addend );
            }
        }
    }

    //------------------------------------------------------------------------------
  private:
    //------------------------------------------------------------------------------
    Elf_Half get_symbol_table_index() const
    {
        return (Elf_Half)relocation_section->get_link();
    }

    //------------------------------------------------------------------------------
    template <class T>
    void generic_get_entry_rel( Elf_Xword   index,
                                Elf64_Addr& offset,
                                Elf_Word&   symbol,
                                unsigned&   type,
                                Elf_Sxword& addend ) const
    {
        const endianess_convertor& convertor = elf_file.get_convertor();

        const T* pEntry = reinterpret_cast<const T*>(
            relocation_section->get_data() +
            index * relocation_section->get_entry_size() );
        offset        = convertor( pEntry->r_offset );
        Elf_Xword tmp = convertor( pEntry->r_info );
        symbol        = get_sym_and_type<T>::get_r_sym( tmp );
        type          = get_sym_and_type<T>::get_r_type( tmp );
        addend        = 0;
    }

    //------------------------------------------------------------------------------
    template <class T>
    void generic_get_entry_rela( Elf_Xword   index,
                                 Elf64_Addr& offset,
                                 Elf_Word&   symbol,
                                 unsigned&   type,
                                 Elf_Sxword& addend ) const
    {
        const endianess_convertor& convertor = elf_file.get_convertor();

        const T* pEntry = reinterpret_cast<const T*>(
            relocation_section->get_data() +
            index * relocation_section->get_entry_size() );
        offset        = convertor( pEntry->r_offset );
        Elf_Xword tmp = convertor( pEntry->r_info );
        symbol        = get_sym_and_type<T>::get_r_sym( tmp );
        type          = get_sym_and_type<T>::get_r_type( tmp );
        addend        = convertor( pEntry->r_addend );
    }

    //------------------------------------------------------------------------------
    template <class T>
    void generic_set_entry_rel( Elf_Xword  index,
                                Elf64_Addr offset,
                                Elf_Word   symbol,
                                unsigned   type,
                                Elf_Sxword )
    {
        const endianess_convertor& convertor = elf_file.get_convertor();

        T* pEntry = const_cast<T*>( reinterpret_cast<const T*>(
            relocation_section->get_data() +
            index * relocation_section->get_entry_size() ) );

        if ( elf_file.get_class() == ELFCLASS32 ) {
            pEntry->r_info = ELF32_R_INFO( (Elf_Xword)symbol, type );
        }
        else {
            pEntry->r_info = ELF64_R_INFO( (Elf_Xword)symbol, type );
        }
        pEntry->r_offset = decltype( pEntry->r_offset )( offset );
        pEntry->r_offset = convertor( pEntry->r_offset );
        pEntry->r_info   = convertor( pEntry->r_info );
    }

    //------------------------------------------------------------------------------
    template <class T>
    void generic_set_entry_rela( Elf_Xword  index,
                                 Elf64_Addr offset,
                                 Elf_Word   symbol,
                                 unsigned   type,
                                 Elf_Sxword addend )
    {
        const endianess_convertor& convertor = elf_file.get_convertor();

        T* pEntry = const_cast<T*>( reinterpret_cast<const T*>(
            relocation_section->get_data() +
            index * relocation_section->get_entry_size() ) );

        if ( elf_file.get_class() == ELFCLASS32 ) {
            pEntry->r_info = ELF32_R_INFO( (Elf_Xword)symbol, type );
        }
        else {
            pEntry->r_info = ELF64_R_INFO( (Elf_Xword)symbol, type );
        }
        pEntry->r_offset = decltype( pEntry->r_offset )( offset );
        pEntry->r_addend = decltype( pEntry->r_addend )( addend );
        pEntry->r_offset = convertor( pEntry->r_offset );
        pEntry->r_info   = convertor( pEntry->r_info );
        pEntry->r_addend = convertor( pEntry->r_addend );
    }

    //------------------------------------------------------------------------------
    template <class T>
    void generic_add_entry( Elf64_Addr offset, Elf_Xword info )
    {
        const endianess_convertor& convertor = elf_file.get_convertor();

        T entry;
        entry.r_offset = decltype( entry.r_offset )( offset );
        entry.r_info   = decltype( entry.r_info )( info );
        entry.r_offset = convertor( entry.r_offset );
        entry.r_info   = convertor( entry.r_info );

        relocation_section->append_data( reinterpret_cast<char*>( &entry ),
                                         sizeof( entry ) );
    }

    //------------------------------------------------------------------------------
    template <class T>
    void
    generic_add_entry( Elf64_Addr offset, Elf_Xword info, Elf_Sxword addend )
    {
        const endianess_convertor& convertor = elf_file.get_convertor();

        T entry;
        entry.r_offset = offset;
        entry.r_info   = info;
        entry.r_addend = addend;
        entry.r_offset = convertor( entry.r_offset );
        entry.r_info   = convertor( entry.r_info );
        entry.r_addend = convertor( entry.r_addend );

        relocation_section->append_data( reinterpret_cast<char*>( &entry ),
                                         sizeof( entry ) );
    }

    //------------------------------------------------------------------------------
  private:
    const elfio& elf_file;
    S*           relocation_section = nullptr;
};

using relocation_section_accessor =
    relocation_section_accessor_template<section>;
using const_relocation_section_accessor =
    relocation_section_accessor_template<const section>;

} // namespace ELFIO

#endif // ELFIO_RELOCATION_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_SECTION_HPP
#define ELFIO_SECTION_HPP

#include <string>
#include <iostream>
#include <new>
#include <limits>

namespace ELFIO {

class section
{
    friend class elfio;

  public:
    virtual ~section() = default;

    ELFIO_GET_ACCESS_DECL( Elf_Half, index );
    ELFIO_GET_SET_ACCESS_DECL( std::string, name );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Word, type );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Xword, flags );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Word, info );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Word, link );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Xword, addr_align );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Xword, entry_size );
    ELFIO_GET_SET_ACCESS_DECL( Elf64_Addr, address );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Xword, size );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Word, name_string_offset );
    ELFIO_GET_ACCESS_DECL( Elf64_Off, offset );

    virtual const char* get_data() const                                   = 0;
    virtual void        free_data() const                                  = 0;
    virtual void        set_data( const char* raw_data, Elf_Word size )    = 0;
    virtual void        set_data( const std::string& data )                = 0;
    virtual void        append_data( const char* raw_data, Elf_Word size ) = 0;
    virtual void        append_data( const std::string& data )             = 0;
    virtual void
    insert_data( Elf_Xword pos, const char* raw_data, Elf_Word size )    = 0;
    virtual void   insert_data( Elf_Xword pos, const std::string& data ) = 0;
    virtual size_t get_stream_size() const                               = 0;
    virtual void   set_stream_size( size_t value )                       = 0;

  protected:
    ELFIO_SET_ACCESS_DECL( Elf64_Off, offset );
    ELFIO_SET_ACCESS_DECL( Elf_Half, index );

    virtual bool load( std::istream&  stream,
                       std::streampos header_offset,
                       bool           is_lazy )               = 0;
    virtual void save( std::ostream&  stream,
                       std::streampos header_offset,
                       std::streampos data_offset ) = 0;
    virtual bool is_address_initialized() const     = 0;
};

template <class T> class section_impl : public section
{
  public:
    //------------------------------------------------------------------------------
    section_impl( const endianess_convertor*                    convertor,
                  const address_translator*                     translator,
                  const std::shared_ptr<compression_interface>& compression )
        : convertor( convertor ), translator( translator ),
          compression( compression )
    {
    }

    //------------------------------------------------------------------------------
    // Section info functions
    ELFIO_GET_SET_ACCESS( Elf_Word, type, header.sh_type );
    ELFIO_GET_SET_ACCESS( Elf_Xword, flags, header.sh_flags );
    ELFIO_GET_SET_ACCESS( Elf_Xword, size, header.sh_size );
    ELFIO_GET_SET_ACCESS( Elf_Word, link, header.sh_link );
    ELFIO_GET_SET_ACCESS( Elf_Word, info, header.sh_info );
    ELFIO_GET_SET_ACCESS( Elf_Xword, addr_align, header.sh_addralign );
    ELFIO_GET_SET_ACCESS( Elf_Xword, entry_size, header.sh_entsize );
    ELFIO_GET_SET_ACCESS( Elf_Word, name_string_offset, header.sh_name );
    ELFIO_GET_ACCESS( Elf64_Addr, address, header.sh_addr );
    //------------------------------------------------------------------------------
    Elf_Half get_index() const override { return index; }

    //------------------------------------------------------------------------------
    std::string get_name() const override { return name; }

    //------------------------------------------------------------------------------
    void set_name( const std::string& name_prm ) override
    {
        this->name = name_prm;
    }

    //------------------------------------------------------------------------------
    void set_address( const Elf64_Addr& value ) override
    {
        header.sh_addr = decltype( header.sh_addr )( value );
        header.sh_addr = ( *convertor )( header.sh_addr );
        is_address_set = true;
    }

    //------------------------------------------------------------------------------
    bool is_address_initialized() const override { return is_address_set; }

    //------------------------------------------------------------------------------
    const char* get_data() const override
    {
        if ( !is_loaded ) {
            load_data();
        }
        return data.get();
    }

    //------------------------------------------------------------------------------
    void free_data() const override
    {
        if ( is_lazy ) {
            data.reset( nullptr );
            is_loaded = false;
        }
    }

    //------------------------------------------------------------------------------
    void set_data( const char* raw_data, Elf_Word size ) override
    {
        if ( get_type() != SHT_NOBITS ) {
            data = std::unique_ptr<char[]>( new ( std::nothrow ) char[size] );
            if ( nullptr != data.get() && nullptr != raw_data ) {
                data_size = size;
                std::copy( raw_data, raw_data + size, data.get() );
            }
            else {
                data_size = 0;
            }
        }

        set_size( data_size );
        if ( translator->empty() ) {
            set_stream_size( data_size );
        }
    }

    //------------------------------------------------------------------------------
    void set_data( const std::string& str_data ) override
    {
        return set_data( str_data.c_str(), (Elf_Word)str_data.size() );
    }

    //------------------------------------------------------------------------------
    void append_data( const char* raw_data, Elf_Word size ) override
    {
        insert_data( get_size(), raw_data, size );
    }

    //------------------------------------------------------------------------------
    void append_data( const std::string& str_data ) override
    {
        return append_data( str_data.c_str(), (Elf_Word)str_data.size() );
    }

    //------------------------------------------------------------------------------
    void
    insert_data( Elf_Xword pos, const char* raw_data, Elf_Word size ) override
    {
        if ( get_type() != SHT_NOBITS ) {
            if ( get_size() + size < data_size ) {
                char* d = data.get();
                std::copy_backward( d + pos, d + get_size(),
                                    d + get_size() + size );
                std::copy( raw_data, raw_data + size, d + pos );
            }
            else {
                data_size = 2 * ( data_size + size );
                std::unique_ptr<char[]> new_data(
                    new ( std::nothrow ) char[data_size] );

                if ( nullptr != new_data ) {
                    char* d = data.get();
                    std::copy( d, d + pos, new_data.get() );
                    std::copy( raw_data, raw_data + size,
                               new_data.get() + pos );
                    std::copy( d + pos, d + get_size(),
                               new_data.get() + pos + size );
                    data = std::move( new_data );
                }
                else {
                    size = 0;
                }
            }
            set_size( get_size() + size );
            if ( translator->empty() ) {
                set_stream_size( get_stream_size() + size );
            }
        }
    }

    //------------------------------------------------------------------------------
    void insert_data( Elf_Xword pos, const std::string& str_data ) override
    {
        return insert_data( pos, str_data.c_str(), (Elf_Word)str_data.size() );
    }

    size_t get_stream_size() const override { return stream_size; }

    //------------------------------------------------------------------------------
    void set_stream_size( size_t value ) override { stream_size = value; }

    //------------------------------------------------------------------------------
  protected:
    //------------------------------------------------------------------------------
    ELFIO_GET_SET_ACCESS( Elf64_Off, offset, header.sh_offset );

    //------------------------------------------------------------------------------
    void set_index( const Elf_Half& value ) override { index = value; }

    bool is_compressed() const
    {
        return ( ( get_flags() & SHF_RPX_DEFLATE ) ||
                 ( get_flags() & SHF_COMPRESSED ) ) &&
               compression != nullptr;
    }

    //------------------------------------------------------------------------------
    bool load( std::istream&  stream,
               std::streampos header_offset,
               bool           is_lazy_ ) override
    {
        pstream = &stream;
        is_lazy = is_lazy_;

        if ( translator->empty() ) {
            stream.seekg( 0, std::istream::end );
            set_stream_size( size_t( stream.tellg() ) );
        }
        else {
            set_stream_size( std::numeric_limits<size_t>::max() );
        }

        stream.seekg( ( *translator )[header_offset] );
        stream.read( reinterpret_cast<char*>( &header ), sizeof( header ) );

        if ( !( is_lazy || is_loaded ) ) {
            bool ret = load_data();

            if ( is_compressed() ) {
                Elf_Xword size              = get_size();
                Elf_Xword uncompressed_size = 0;
                auto      decompressed_data = compression->inflate(
                    data.get(), convertor, size, uncompressed_size );
                if ( decompressed_data != nullptr ) {
                    set_size( uncompressed_size );
                    data = std::move( decompressed_data );
                }
            }

            return ret;
        }

        return true;
    }

    bool load_data() const
    {
        Elf_Xword size = get_size();
        if ( nullptr == data && SHT_NULL != get_type() &&
             SHT_NOBITS != get_type() && size < get_stream_size() ) {
            data.reset( new ( std::nothrow ) char[size_t( size ) + 1] );

            if ( ( 0 != size ) && ( nullptr != data ) ) {
                pstream->seekg(
                    ( *translator )[( *convertor )( header.sh_offset )] );
                pstream->read( data.get(), size );
                if ( static_cast<Elf_Xword>( pstream->gcount() ) != size ) {
                    data = nullptr;
                    return false;
                }

                // refresh size because it may have changed if we had to decompress data
                size = get_size();
                data.get()[size] =
                    0; // Ensure data is ended with 0 to avoid oob read
                data_size = decltype( data_size )( size );
            }
            else {
                data_size = 0;
            }
        }

        is_loaded = true;

        return true;
    }

    //------------------------------------------------------------------------------
    void save( std::ostream&  stream,
               std::streampos header_offset,
               std::streampos data_offset ) override
    {
        if ( 0 != get_index() ) {
            header.sh_offset = decltype( header.sh_offset )( data_offset );
            header.sh_offset = ( *convertor )( header.sh_offset );
        }

        save_header( stream, header_offset );
        if ( get_type() != SHT_NOBITS && get_type() != SHT_NULL &&
             get_size() != 0 && data != nullptr ) {
            save_data( stream, data_offset );
        }
    }

    //------------------------------------------------------------------------------
  private:
    //------------------------------------------------------------------------------
    void save_header( std::ostream& stream, std::streampos header_offset ) const
    {
        adjust_stream_size( stream, header_offset );
        stream.write( reinterpret_cast<const char*>( &header ),
                      sizeof( header ) );
    }

    //------------------------------------------------------------------------------
    void save_data( std::ostream& stream, std::streampos data_offset )
    {
        adjust_stream_size( stream, data_offset );

        if ( ( ( get_flags() & SHF_COMPRESSED ) ||
               ( get_flags() & SHF_RPX_DEFLATE ) ) &&
             compression != nullptr ) {
            Elf_Xword decompressed_size = get_size();
            Elf_Xword compressed_size   = 0;
            auto      compressed_ptr    = compression->deflate(
                data.get(), convertor, decompressed_size, compressed_size );
            stream.write( compressed_ptr.get(), compressed_size );
        }
        else {
            stream.write( get_data(), get_size() );
        }
    }

    //------------------------------------------------------------------------------
  private:
    mutable std::istream*                        pstream = nullptr;
    T                                            header  = {};
    Elf_Half                                     index   = 0;
    std::string                                  name;
    mutable std::unique_ptr<char[]>              data;
    mutable Elf_Word                             data_size      = 0;
    const endianess_convertor*                   convertor      = nullptr;
    const address_translator*                    translator     = nullptr;
    const std::shared_ptr<compression_interface> compression    = nullptr;
    bool                                         is_address_set = false;
    size_t                                       stream_size    = 0;
    mutable bool                                 is_lazy        = false;
    mutable bool                                 is_loaded      = false;
};

} // namespace ELFIO

#endif // ELFIO_SECTION_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_SEGMENT_HPP
#define ELFIO_SEGMENT_HPP

#include <iostream>
#include <vector>
#include <new>
#include <limits>

namespace ELFIO {

class segment
{
    friend class elfio;

  public:
    virtual ~segment() = default;

    ELFIO_GET_ACCESS_DECL( Elf_Half, index );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Word, type );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Word, flags );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Xword, align );
    ELFIO_GET_SET_ACCESS_DECL( Elf64_Addr, virtual_address );
    ELFIO_GET_SET_ACCESS_DECL( Elf64_Addr, physical_address );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Xword, file_size );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Xword, memory_size );
    ELFIO_GET_ACCESS_DECL( Elf64_Off, offset );

    virtual const char* get_data() const  = 0;
    virtual void        free_data() const = 0;

    virtual Elf_Half add_section( section* psec, Elf_Xword addr_align ) = 0;
    virtual Elf_Half add_section_index( Elf_Half  index,
                                        Elf_Xword addr_align )          = 0;
    virtual Elf_Half get_sections_num() const                           = 0;
    virtual Elf_Half get_section_index_at( Elf_Half num ) const         = 0;
    virtual bool     is_offset_initialized() const                      = 0;

  protected:
    ELFIO_SET_ACCESS_DECL( Elf64_Off, offset );
    ELFIO_SET_ACCESS_DECL( Elf_Half, index );

    virtual const std::vector<Elf_Half>& get_sections() const = 0;

    virtual bool load( std::istream&  stream,
                       std::streampos header_offset,
                       bool           is_lazy )               = 0;
    virtual void save( std::ostream&  stream,
                       std::streampos header_offset,
                       std::streampos data_offset ) = 0;
};

//------------------------------------------------------------------------------
template <class T> class segment_impl : public segment
{
  public:
    //------------------------------------------------------------------------------
    segment_impl( const endianess_convertor* convertor,
                  const address_translator*  translator )
        : convertor( convertor ), translator( translator )
    {
    }

    //------------------------------------------------------------------------------
    // Section info functions
    ELFIO_GET_SET_ACCESS( Elf_Word, type, ph.p_type );
    ELFIO_GET_SET_ACCESS( Elf_Word, flags, ph.p_flags );
    ELFIO_GET_SET_ACCESS( Elf_Xword, align, ph.p_align );
    ELFIO_GET_SET_ACCESS( Elf64_Addr, virtual_address, ph.p_vaddr );
    ELFIO_GET_SET_ACCESS( Elf64_Addr, physical_address, ph.p_paddr );
    ELFIO_GET_SET_ACCESS( Elf_Xword, file_size, ph.p_filesz );
    ELFIO_GET_SET_ACCESS( Elf_Xword, memory_size, ph.p_memsz );
    ELFIO_GET_ACCESS( Elf64_Off, offset, ph.p_offset );

    //------------------------------------------------------------------------------
    Elf_Half get_index() const override { return index; }

    //------------------------------------------------------------------------------
    const char* get_data() const override
    {
        if ( !is_loaded ) {
            load_data();
        }
        return data.get();
    }

    //------------------------------------------------------------------------------
    void free_data() const override
    {
        if ( is_lazy ) {
            data.reset( nullptr );
            is_loaded = false;
        }
    }

    //------------------------------------------------------------------------------
    Elf_Half add_section_index( Elf_Half  sec_index,
                                Elf_Xword addr_align ) override
    {
        sections.emplace_back( sec_index );
        if ( addr_align > get_align() ) {
            set_align( addr_align );
        }

        return (Elf_Half)sections.size();
    }

    //------------------------------------------------------------------------------
    Elf_Half add_section( section* psec, Elf_Xword addr_align ) override
    {
        return add_section_index( psec->get_index(), addr_align );
    }

    //------------------------------------------------------------------------------
    Elf_Half get_sections_num() const override
    {
        return (Elf_Half)sections.size();
    }

    //------------------------------------------------------------------------------
    Elf_Half get_section_index_at( Elf_Half num ) const override
    {
        if ( num < sections.size() ) {
            return sections[num];
        }

        return Elf_Half( -1 );
    }

    //------------------------------------------------------------------------------
  protected:
    //------------------------------------------------------------------------------

    //------------------------------------------------------------------------------
    void set_offset( const Elf64_Off& value ) override
    {
        ph.p_offset   = decltype( ph.p_offset )( value );
        ph.p_offset   = ( *convertor )( ph.p_offset );
        is_offset_set = true;
    }

    //------------------------------------------------------------------------------
    bool is_offset_initialized() const override { return is_offset_set; }

    //------------------------------------------------------------------------------
    const std::vector<Elf_Half>& get_sections() const override
    {
        return sections;
    }

    //------------------------------------------------------------------------------
    void set_index( const Elf_Half& value ) override { index = value; }

    //------------------------------------------------------------------------------
    bool load( std::istream&  stream,
               std::streampos header_offset,
               bool           is_lazy_ ) override
    {
        pstream = &stream;
        is_lazy = is_lazy_;

        if ( translator->empty() ) {
            stream.seekg( 0, std::istream::end );
            set_stream_size( size_t( stream.tellg() ) );
        }
        else {
            set_stream_size( std::numeric_limits<size_t>::max() );
        }

        stream.seekg( ( *translator )[header_offset] );
        stream.read( reinterpret_cast<char*>( &ph ), sizeof( ph ) );
        is_offset_set = true;

        if ( !( is_lazy || is_loaded ) ) {
            return load_data();
        }

        return true;
    }

    //------------------------------------------------------------------------------
    bool load_data() const
    {
        if ( PT_NULL == get_type() || 0 == get_file_size() ) {
            return true;
        }

        pstream->seekg( ( *translator )[( *convertor )( ph.p_offset )] );
        Elf_Xword size = get_file_size();

        if ( size > get_stream_size() ) {
            data = nullptr;
        }
        else {
            data.reset( new ( std::nothrow ) char[(size_t)size + 1] );

            if ( nullptr != data.get() && pstream->read( data.get(), size ) ) {
                data.get()[size] = 0;
            }
            else {
                data = nullptr;
                return false;
            }
        }

        is_loaded = true;

        return true;
    }

    //------------------------------------------------------------------------------
    void save( std::ostream&  stream,
               std::streampos header_offset,
               std::streampos data_offset ) override
    {
        ph.p_offset = decltype( ph.p_offset )( data_offset );
        ph.p_offset = ( *convertor )( ph.p_offset );
        adjust_stream_size( stream, header_offset );
        stream.write( reinterpret_cast<const char*>( &ph ), sizeof( ph ) );
    }

    //------------------------------------------------------------------------------
    size_t get_stream_size() const { return stream_size; }

    //------------------------------------------------------------------------------
    void set_stream_size( size_t value ) { stream_size = value; }

    //------------------------------------------------------------------------------
  private:
    mutable std::istream*           pstream = nullptr;
    T                               ph      = {};
    Elf_Half                        index   = 0;
    mutable std::unique_ptr<char[]> data;
    std::vector<Elf_Half>           sections;
    const endianess_convertor*      convertor     = nullptr;
    const address_translator*       translator    = nullptr;
    size_t                          stream_size   = 0;
    bool                            is_offset_set = false;
    mutable bool                    is_lazy       = false;
    mutable bool                    is_loaded     = false;
};

} // namespace ELFIO

#endif // ELFIO_SEGMENT_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_STRINGS_HPP
#define ELFIO_STRINGS_HPP

#include <cstdlib>
#include <cstring>
#include <string>

namespace ELFIO {

//------------------------------------------------------------------------------
template <class S> class string_section_accessor_template
{
  public:
    //------------------------------------------------------------------------------
    explicit string_section_accessor_template( S* section )
        : string_section( section )
    {
    }

    //------------------------------------------------------------------------------
    const char* get_string( Elf_Word index ) const
    {
        if ( string_section ) {
            const char* data = string_section->get_data();
            if ( index < string_section->get_size() && nullptr != data ) {
                size_t string_length = strnlength(
                    data + index, string_section->get_size() - index );
                if ( string_length < ( string_section->get_size() - index ) )
                    return data + index;
            }
        }

        return nullptr;
    }

    //------------------------------------------------------------------------------
    Elf_Word add_string( const char* str )
    {
        Elf_Word current_position = 0;

        if ( string_section ) {
            // Strings are addeded to the end of the current section data
            current_position =
                static_cast<Elf_Word>( string_section->get_size() );

            if ( current_position == 0 ) {
                char empty_string = '\0';
                string_section->append_data( &empty_string, 1 );
                current_position++;
            }
            string_section->append_data(
                str, static_cast<Elf_Word>( std::strlen( str ) + 1 ) );
        }

        return current_position;
    }

    //------------------------------------------------------------------------------
    Elf_Word add_string( const std::string& str )
    {
        return add_string( str.c_str() );
    }

    //------------------------------------------------------------------------------
  private:
    S* string_section;
};

using string_section_accessor = string_section_accessor_template<section>;
using const_string_section_accessor =
    string_section_accessor_template<const section>;

} // namespace ELFIO

#endif // ELFIO_STRINGS_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_SYMBOLS_HPP
#define ELFIO_SYMBOLS_HPP

namespace ELFIO {

//------------------------------------------------------------------------------
template <class S> class symbol_section_accessor_template
{
  public:
    //------------------------------------------------------------------------------
    explicit symbol_section_accessor_template( const elfio& elf_file,
                                               S*           symbol_section )
        : elf_file( elf_file ), symbol_section( symbol_section )
    {
        find_hash_section();
    }

    //------------------------------------------------------------------------------
    Elf_Xword get_symbols_num() const
    {
        Elf_Xword nRet = 0;

        size_t minimum_symbol_size;
        switch ( elf_file.get_class() ) {
        case ELFCLASS32:
            minimum_symbol_size = sizeof( Elf32_Sym );
            break;
        case ELFCLASS64:
            minimum_symbol_size = sizeof( Elf64_Sym );
            break;
        default:
            return nRet;
        }

        if ( symbol_section->get_entry_size() >= minimum_symbol_size &&
             symbol_section->get_size() <= symbol_section->get_stream_size() ) {
            nRet =
                symbol_section->get_size() / symbol_section->get_entry_size();
        }

        return nRet;
    }

    //------------------------------------------------------------------------------
    bool get_symbol( Elf_Xword      index,
                     std::string&   name,
                     Elf64_Addr&    value,
                     Elf_Xword&     size,
                     unsigned char& bind,
                     unsigned char& type,
                     Elf_Half&      section_index,
                     unsigned char& other ) const
    {
        bool ret = false;

        if ( elf_file.get_class() == ELFCLASS32 ) {
            ret = generic_get_symbol<Elf32_Sym>( index, name, value, size, bind,
                                                 type, section_index, other );
        }
        else {
            ret = generic_get_symbol<Elf64_Sym>( index, name, value, size, bind,
                                                 type, section_index, other );
        }

        return ret;
    }

    //------------------------------------------------------------------------------
    bool get_symbol( const std::string& name,
                     Elf64_Addr&        value,
                     Elf_Xword&         size,
                     unsigned char&     bind,
                     unsigned char&     type,
                     Elf_Half&          section_index,
                     unsigned char&     other ) const
    {
        bool ret = false;

        if ( 0 != get_hash_table_index() ) {
            if ( hash_section->get_type() == SHT_HASH ) {
                ret = hash_lookup( name, value, size, bind, type, section_index,
                                   other );
            }
            if ( hash_section->get_type() == SHT_GNU_HASH ||
                 hash_section->get_type() == DT_GNU_HASH ) {
                if ( elf_file.get_class() == ELFCLASS32 ) {
                    ret = gnu_hash_lookup<uint32_t>(
                        name, value, size, bind, type, section_index, other );
                }
                else {
                    ret = gnu_hash_lookup<uint64_t>(
                        name, value, size, bind, type, section_index, other );
                }
            }
        }

        if ( !ret ) {
            for ( Elf_Xword i = 0; !ret && i < get_symbols_num(); i++ ) {
                std::string symbol_name;
                if ( get_symbol( i, symbol_name, value, size, bind, type,
                                 section_index, other ) ) {
                    if ( symbol_name == name ) {
                        ret = true;
                    }
                }
            }
        }

        return ret;
    }

    //------------------------------------------------------------------------------
    bool get_symbol( const Elf64_Addr& value,
                     std::string&      name,
                     Elf_Xword&        size,
                     unsigned char&    bind,
                     unsigned char&    type,
                     Elf_Half&         section_index,
                     unsigned char&    other ) const
    {

        const endianess_convertor& convertor = elf_file.get_convertor();

        Elf_Xword  idx   = 0;
        bool       match = false;
        Elf64_Addr v     = 0;

        if ( elf_file.get_class() == ELFCLASS32 ) {
            match = generic_search_symbols<Elf32_Sym>(
                [&]( const Elf32_Sym* sym ) {
                    return convertor( sym->st_value ) == value;
                },
                idx );
        }
        else {
            match = generic_search_symbols<Elf64_Sym>(
                [&]( const Elf64_Sym* sym ) {
                    return convertor( sym->st_value ) == value;
                },
                idx );
        }

        if ( match ) {
            return get_symbol( idx, name, v, size, bind, type, section_index,
                               other );
        }

        return false;
    }

    //------------------------------------------------------------------------------
    Elf_Word add_symbol( Elf_Word      name,
                         Elf64_Addr    value,
                         Elf_Xword     size,
                         unsigned char info,
                         unsigned char other,
                         Elf_Half      shndx )
    {
        Elf_Word nRet;

        if ( symbol_section->get_size() == 0 ) {
            if ( elf_file.get_class() == ELFCLASS32 ) {
                nRet = generic_add_symbol<Elf32_Sym>( 0, 0, 0, 0, 0, 0 );
            }
            else {
                nRet = generic_add_symbol<Elf64_Sym>( 0, 0, 0, 0, 0, 0 );
            }
        }

        if ( elf_file.get_class() == ELFCLASS32 ) {
            nRet = generic_add_symbol<Elf32_Sym>( name, value, size, info,
                                                  other, shndx );
        }
        else {
            nRet = generic_add_symbol<Elf64_Sym>( name, value, size, info,
                                                  other, shndx );
        }

        return nRet;
    }

    //------------------------------------------------------------------------------
    Elf_Word add_symbol( Elf_Word      name,
                         Elf64_Addr    value,
                         Elf_Xword     size,
                         unsigned char bind,
                         unsigned char type,
                         unsigned char other,
                         Elf_Half      shndx )
    {
        return add_symbol( name, value, size, ELF_ST_INFO( bind, type ), other,
                           shndx );
    }

    //------------------------------------------------------------------------------
    Elf_Word add_symbol( string_section_accessor& pStrWriter,
                         const char*              str,
                         Elf64_Addr               value,
                         Elf_Xword                size,
                         unsigned char            info,
                         unsigned char            other,
                         Elf_Half                 shndx )
    {
        Elf_Word index = pStrWriter.add_string( str );
        return add_symbol( index, value, size, info, other, shndx );
    }

    //------------------------------------------------------------------------------
    Elf_Word add_symbol( string_section_accessor& pStrWriter,
                         const char*              str,
                         Elf64_Addr               value,
                         Elf_Xword                size,
                         unsigned char            bind,
                         unsigned char            type,
                         unsigned char            other,
                         Elf_Half                 shndx )
    {
        return add_symbol( pStrWriter, str, value, size,
                           ELF_ST_INFO( bind, type ), other, shndx );
    }

    //------------------------------------------------------------------------------
    Elf_Xword arrange_local_symbols(
        std::function<void( Elf_Xword first, Elf_Xword second )> func =
            nullptr )
    {
        Elf_Xword nRet = 0;

        if ( elf_file.get_class() == ELFCLASS32 ) {
            nRet = generic_arrange_local_symbols<Elf32_Sym>( func );
        }
        else {
            nRet = generic_arrange_local_symbols<Elf64_Sym>( func );
        }

        return nRet;
    }

    //------------------------------------------------------------------------------
  private:
    //------------------------------------------------------------------------------
    void find_hash_section()
    {
        Elf_Half nSecNo = elf_file.sections.size();
        for ( Elf_Half i = 0; i < nSecNo; ++i ) {
            const section* sec = elf_file.sections[i];
            if ( sec->get_link() == symbol_section->get_index() &&
                 ( sec->get_type() == SHT_HASH ||
                   sec->get_type() == SHT_GNU_HASH ||
                   sec->get_type() == DT_GNU_HASH ) ) {
                hash_section       = sec;
                hash_section_index = i;
                break;
            }
        }
    }

    //------------------------------------------------------------------------------
    Elf_Half get_string_table_index() const
    {
        return (Elf_Half)symbol_section->get_link();
    }

    //------------------------------------------------------------------------------
    Elf_Half get_hash_table_index() const { return hash_section_index; }

    //------------------------------------------------------------------------------
    bool hash_lookup( const std::string& name,
                      Elf64_Addr&        value,
                      Elf_Xword&         size,
                      unsigned char&     bind,
                      unsigned char&     type,
                      Elf_Half&          section_index,
                      unsigned char&     other ) const
    {
        bool                       ret       = false;
        const endianess_convertor& convertor = elf_file.get_convertor();

        Elf_Word nbucket = *(const Elf_Word*)hash_section->get_data();
        nbucket          = convertor( nbucket );
        Elf_Word nchain =
            *(const Elf_Word*)( hash_section->get_data() + sizeof( Elf_Word ) );
        nchain       = convertor( nchain );
        Elf_Word val = elf_hash( (const unsigned char*)name.c_str() );
        Elf_Word y =
            *(const Elf_Word*)( hash_section->get_data() +
                                ( 2 + val % nbucket ) * sizeof( Elf_Word ) );
        y = convertor( y );
        std::string str;
        get_symbol( y, str, value, size, bind, type, section_index, other );
        while ( str != name && STN_UNDEF != y && y < nchain ) {
            y = *(const Elf_Word*)( hash_section->get_data() +
                                    ( 2 + nbucket + y ) * sizeof( Elf_Word ) );
            y = convertor( y );
            get_symbol( y, str, value, size, bind, type, section_index, other );
        }

        if ( str == name ) {
            ret = true;
        }

        return ret;
    }

    //------------------------------------------------------------------------------
    template <class T>
    bool gnu_hash_lookup( const std::string& name,
                          Elf64_Addr&        value,
                          Elf_Xword&         size,
                          unsigned char&     bind,
                          unsigned char&     type,
                          Elf_Half&          section_index,
                          unsigned char&     other ) const
    {
        bool                       ret       = false;
        const endianess_convertor& convertor = elf_file.get_convertor();

        uint32_t nbuckets    = *( (uint32_t*)hash_section->get_data() + 0 );
        uint32_t symoffset   = *( (uint32_t*)hash_section->get_data() + 1 );
        uint32_t bloom_size  = *( (uint32_t*)hash_section->get_data() + 2 );
        uint32_t bloom_shift = *( (uint32_t*)hash_section->get_data() + 3 );
        nbuckets             = convertor( nbuckets );
        symoffset            = convertor( symoffset );
        bloom_size           = convertor( bloom_size );
        bloom_shift          = convertor( bloom_shift );

        T* bloom_filter =
            (T*)( hash_section->get_data() + 4 * sizeof( uint32_t ) );

        uint32_t hash = elf_gnu_hash( (const unsigned char*)name.c_str() );
        uint32_t bloom_index = ( hash / ( 8 * sizeof( T ) ) ) % bloom_size;
        T        bloom_bits =
            ( (T)1 << ( hash % ( 8 * sizeof( T ) ) ) ) |
            ( (T)1 << ( ( hash >> bloom_shift ) % ( 8 * sizeof( T ) ) ) );

        if ( ( convertor( bloom_filter[bloom_index] ) & bloom_bits ) !=
             bloom_bits )
            return ret;

        uint32_t bucket = hash % nbuckets;
        auto*    buckets =
            (uint32_t*)( hash_section->get_data() + 4 * sizeof( uint32_t ) +
                         bloom_size * sizeof( T ) );
        auto* chains =
            (uint32_t*)( hash_section->get_data() + 4 * sizeof( uint32_t ) +
                         bloom_size * sizeof( T ) +
                         nbuckets * sizeof( uint32_t ) );

        if ( convertor( buckets[bucket] ) >= symoffset ) {
            uint32_t    chain_index = convertor( buckets[bucket] ) - symoffset;
            uint32_t    chain_hash  = convertor( chains[chain_index] );
            std::string symname;

            while ( true ) {
                if ( ( chain_hash >> 1 ) == ( hash >> 1 ) &&
                     get_symbol( chain_index + symoffset, symname, value, size,
                                 bind, type, section_index, other ) &&
                     name == symname ) {
                    ret = true;
                    break;
                }

                if ( chain_hash & 1 )
                    break;
                chain_hash = convertor( chains[++chain_index] );
            }
        }

        return ret;
    }

    //------------------------------------------------------------------------------
    template <class T> const T* generic_get_symbol_ptr( Elf_Xword index ) const
    {
        if ( 0 != symbol_section->get_data() && index < get_symbols_num() ) {
            const T* pSym = reinterpret_cast<const T*>(
                symbol_section->get_data() +
                index * symbol_section->get_entry_size() );

            return pSym;
        }

        return nullptr;
    }

    //------------------------------------------------------------------------------
    template <class T>
    bool generic_search_symbols( std::function<bool( const T* )> match,
                                 Elf_Xword&                      idx ) const
    {
        for ( Elf_Xword i = 0; i < get_symbols_num(); i++ ) {
            const T* symPtr = generic_get_symbol_ptr<T>( i );

            if ( symPtr == nullptr )
                return false;

            if ( match( symPtr ) ) {
                idx = i;
                return true;
            }
        }

        return false;
    }

    //------------------------------------------------------------------------------
    template <class T>
    bool generic_get_symbol( Elf_Xword      index,
                             std::string&   name,
                             Elf64_Addr&    value,
                             Elf_Xword&     size,
                             unsigned char& bind,
                             unsigned char& type,
                             Elf_Half&      section_index,
                             unsigned char& other ) const
    {
        bool ret = false;

        if ( nullptr != symbol_section->get_data() &&
             index < get_symbols_num() ) {
            const T* pSym = reinterpret_cast<const T*>(
                symbol_section->get_data() +
                index * symbol_section->get_entry_size() );

            const endianess_convertor& convertor = elf_file.get_convertor();

            section* string_section =
                elf_file.sections[get_string_table_index()];
            string_section_accessor str_reader( string_section );
            const char*             pStr =
                str_reader.get_string( convertor( pSym->st_name ) );
            if ( nullptr != pStr ) {
                name = pStr;
            }
            value         = convertor( pSym->st_value );
            size          = convertor( pSym->st_size );
            bind          = ELF_ST_BIND( pSym->st_info );
            type          = ELF_ST_TYPE( pSym->st_info );
            section_index = convertor( pSym->st_shndx );
            other         = pSym->st_other;

            ret = true;
        }

        return ret;
    }

    //------------------------------------------------------------------------------
    template <class T>
    Elf_Word generic_add_symbol( Elf_Word      name,
                                 Elf64_Addr    value,
                                 Elf_Xword     size,
                                 unsigned char info,
                                 unsigned char other,
                                 Elf_Half      shndx )
    {
        const endianess_convertor& convertor = elf_file.get_convertor();

        T entry;
        entry.st_name  = convertor( name );
        entry.st_value = decltype( entry.st_value )( value );
        entry.st_value = convertor( entry.st_value );
        entry.st_size  = decltype( entry.st_size )( size );
        entry.st_size  = convertor( entry.st_size );
        entry.st_info  = convertor( info );
        entry.st_other = convertor( other );
        entry.st_shndx = convertor( shndx );

        symbol_section->append_data( reinterpret_cast<char*>( &entry ),
                                     sizeof( entry ) );

        Elf_Word nRet =
            Elf_Word( symbol_section->get_size() / sizeof( entry ) - 1 );

        return nRet;
    }

    //------------------------------------------------------------------------------
    template <class T>
    Elf_Xword generic_arrange_local_symbols(
        std::function<void( Elf_Xword first, Elf_Xword second )> func )
    {
        const endianess_convertor& convertor = elf_file.get_convertor();

        Elf_Word first_not_local =
            1; // Skip the first entry. It is always NOTYPE
        Elf_Xword current = 0;
        Elf_Xword count   = get_symbols_num();

        while ( true ) {
            T* p1 = nullptr;
            T* p2 = nullptr;

            while ( first_not_local < count ) {
                p1 = const_cast<T*>(
                    generic_get_symbol_ptr<T>( first_not_local ) );
                if ( ELF_ST_BIND( convertor( p1->st_info ) ) != STB_LOCAL )
                    break;
                ++first_not_local;
            }

            current = first_not_local + 1;
            while ( current < count ) {
                p2 = const_cast<T*>( generic_get_symbol_ptr<T>( current ) );
                if ( ELF_ST_BIND( convertor( p2->st_info ) ) == STB_LOCAL )
                    break;
                ++current;
            }

            if ( first_not_local < count && current < count ) {
                if ( func )
                    func( first_not_local, current );

                std::swap( *p1, *p2 );
            }
            else {
                // Update 'info' field of the section
                symbol_section->set_info( first_not_local );
                break;
            }
        }

        return first_not_local;
    }

    //------------------------------------------------------------------------------
  private:
    const elfio&   elf_file;
    S*             symbol_section;
    Elf_Half       hash_section_index{ 0 };
    const section* hash_section{ nullptr };
};

using symbol_section_accessor = symbol_section_accessor_template<section>;
using const_symbol_section_accessor =
    symbol_section_accessor_template<const section>;

} // namespace ELFIO

#endif // ELFIO_SYMBOLS_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_UTILS_HPP
#define ELFIO_UTILS_HPP

#include <cstdint>
#include <ostream>
#include <cstring>

#define ELFIO_GET_ACCESS_DECL( TYPE, NAME ) virtual TYPE get_##NAME() const = 0

#define ELFIO_SET_ACCESS_DECL( TYPE, NAME ) \
    virtual void set_##NAME( const TYPE& value ) = 0

#define ELFIO_GET_SET_ACCESS_DECL( TYPE, NAME )       \
    virtual TYPE get_##NAME() const              = 0; \
    virtual void set_##NAME( const TYPE& value ) = 0

#define ELFIO_GET_ACCESS( TYPE, NAME, FIELD ) \
    TYPE get_##NAME() const override { return ( *convertor )( FIELD ); }

#define ELFIO_SET_ACCESS( TYPE, NAME, FIELD )     \
    void set_##NAME( const TYPE& value ) override \
    {                                             \
        FIELD = decltype( FIELD )( value );       \
        FIELD = ( *convertor )( FIELD );          \
    }
#define ELFIO_GET_SET_ACCESS( TYPE, NAME, FIELD )                        \
    TYPE get_##NAME() const override { return ( *convertor )( FIELD ); } \
    void set_##NAME( const TYPE& value ) override                        \
    {                                                                    \
        FIELD = decltype( FIELD )( value );                              \
        FIELD = ( *convertor )( FIELD );                                 \
    }

namespace ELFIO {

//------------------------------------------------------------------------------
class endianess_convertor
{
  public:
    //------------------------------------------------------------------------------
    void setup( unsigned char elf_file_encoding )
    {
        need_conversion = ( elf_file_encoding != get_host_encoding() );
    }

    //------------------------------------------------------------------------------
    uint64_t operator()( uint64_t value ) const
    {
        if ( !need_conversion ) {
            return value;
        }
        value = ( ( value & 0x00000000000000FFuLL ) << 56 ) |
                ( ( value & 0x000000000000FF00uLL ) << 40 ) |
                ( ( value & 0x0000000000FF0000uLL ) << 24 ) |
                ( ( value & 0x00000000FF000000uLL ) << 8 ) |
                ( ( value & 0x000000FF00000000uLL ) >> 8 ) |
                ( ( value & 0x0000FF0000000000uLL ) >> 24 ) |
                ( ( value & 0x00FF000000000000uLL ) >> 40 ) |
                ( ( value & 0xFF00000000000000uLL ) >> 56 );

        return value;
    }

    //------------------------------------------------------------------------------
    int64_t operator()( int64_t value ) const
    {
        if ( !need_conversion ) {
            return value;
        }
        return (int64_t)( *this )( (uint64_t)value );
    }

    //------------------------------------------------------------------------------
    uint32_t operator()( uint32_t value ) const
    {
        if ( !need_conversion ) {
            return value;
        }
        value =
            ( ( value & 0x000000FF ) << 24 ) | ( ( value & 0x0000FF00 ) << 8 ) |
            ( ( value & 0x00FF0000 ) >> 8 ) | ( ( value & 0xFF000000 ) >> 24 );

        return value;
    }

    //------------------------------------------------------------------------------
    int32_t operator()( int32_t value ) const
    {
        if ( !need_conversion ) {
            return value;
        }
        return (int32_t)( *this )( (uint32_t)value );
    }

    //------------------------------------------------------------------------------
    uint16_t operator()( uint16_t value ) const
    {
        if ( !need_conversion ) {
            return value;
        }
        value =
            (uint16_t)( ( value & 0x00FF ) << 8 ) | ( ( value & 0xFF00 ) >> 8 );

        return value;
    }

    //------------------------------------------------------------------------------
    int16_t operator()( int16_t value ) const
    {
        if ( !need_conversion ) {
            return value;
        }
        return (int16_t)( *this )( (uint16_t)value );
    }

    //------------------------------------------------------------------------------
    int8_t operator()( int8_t value ) const { return value; }

    //------------------------------------------------------------------------------
    uint8_t operator()( uint8_t value ) const { return value; }

    //------------------------------------------------------------------------------
  private:
    //------------------------------------------------------------------------------
    unsigned char get_host_encoding() const
    {
        static const int tmp = 1;
        if ( 1 == *reinterpret_cast<const char*>( &tmp ) ) {
            return ELFDATA2LSB;
        }
        else {
            return ELFDATA2MSB;
        }
    }

    //------------------------------------------------------------------------------
    bool need_conversion = false;
};

//------------------------------------------------------------------------------
struct address_translation
{
    address_translation( uint64_t start, uint64_t size, uint64_t mapped_to )
        : start( start ), size( size ), mapped_to( mapped_to ){};
    std::streampos start;
    std::streampos size;
    std::streampos mapped_to;
};

//------------------------------------------------------------------------------
class address_translator
{
  public:
    //------------------------------------------------------------------------------
    void set_address_translation( std::vector<address_translation>& addr_trans )
    {
        addr_translations = addr_trans;

        std::sort( addr_translations.begin(), addr_translations.end(),
                   []( const address_translation& a,
                       const address_translation& b ) -> bool {
                       return a.start < b.start;
                   } );
    }

    //------------------------------------------------------------------------------
    std::streampos operator[]( std::streampos value ) const
    {
        if ( addr_translations.empty() ) {
            return value;
        }

        for ( auto& t : addr_translations ) {
            if ( ( t.start <= value ) && ( ( value - t.start ) < t.size ) ) {
                return value - t.start + t.mapped_to;
            }
        }

        return value;
    }

    bool empty() const { return addr_translations.empty(); }

  private:
    std::vector<address_translation> addr_translations;
};

//------------------------------------------------------------------------------
inline uint32_t elf_hash( const unsigned char* name )
{
    uint32_t h = 0;
    uint32_t g = 0;
    while ( *name != '\0' ) {
        h = ( h << 4 ) + *name++;
        g = h & 0xf0000000;
        if ( g != 0 )
            h ^= g >> 24;
        h &= ~g;
    }
    return h;
}

//------------------------------------------------------------------------------
inline uint32_t elf_gnu_hash( const unsigned char* s )
{
    uint32_t h = 0x1505;
    for ( unsigned char c = *s; c != '\0'; c = *++s )
        h = ( h << 5 ) + h + c;
    return h;
}

//------------------------------------------------------------------------------
inline std::string to_hex_string( uint64_t value )
{
    std::string str;

    while ( value ) {
        if ( auto digit = value & 0xF; digit < 0xA ) {
            str = char( '0' + digit ) + str;
        }
        else {
            str = char( 'A' + digit - 0xA ) + str;
        }
        value >>= 4;
    }

    return "0x" + str;
}

//------------------------------------------------------------------------------
inline void adjust_stream_size( std::ostream& stream, std::streamsize offset )
{
    stream.seekp( 0, std::ios_base::end );
    if ( stream.tellp() < offset ) {
        std::streamsize size = offset - stream.tellp();
        stream.write( std::string( size_t( size ), '\0' ).c_str(), size );
    }
    stream.seekp( offset );
}

//------------------------------------------------------------------------------
inline static size_t strnlength( const char* s, size_t n )
{
    auto found = (const char*)std::memchr( s, '\0', n );
    return found ? (size_t)( found - s ) : n;
}

/**
 * Consumers should write an implementation of this class and pass an instance of it to the ELFIO::elfio constructor.
 */
class compression_interface
{
  public:
    virtual ~compression_interface() = default;
    /**
     * decompresses a compressed section
     *
     * @param data the buffer of compressed data
     * @param endianness_convertor pointer to an endianness_convertor instance, used to convert numbers to/from the target endianness.
     * @param compressed_size the size of the data buffer, in bytes
     * @param decompressed_size a reference to a variable where the decompressed buffer size will be stored.
     * @returns a smart pointer to the decompressed data.
     */
    virtual std::unique_ptr<char[]>
    inflate( const char*                data,
             const endianess_convertor* convertor,
             Elf_Xword                  compressed_size,
             Elf_Xword&                 uncompressed_size ) const = 0;

    /**
     * compresses a section
     *
     * @param data the buffer of uncompressed data
     * @param endianness_convertor pointer to an endianness_convertor instance, used to convert numbers to/from the target endianness.
     * @param decompressed_size the size of the data buffer, in bytes
     * @param compressed_size a reference to a variable where the compressed buffer size will be stored.
     * @returns a smart pointer to the compressed data.
     */
    virtual std::unique_ptr<char[]>
    deflate( const char*                data,
             const endianess_convertor* convertor,
             Elf_Xword                  decompressed_size,
             Elf_Xword&                 compressed_size ) const = 0;
};

} // namespace ELFIO

#endif // ELFIO_UTILS_HPP
#define ELFIO_VERSION "3.12"
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_VERSYM_HPP
#define ELFIO_VERSYM_HPP

namespace ELFIO {

//------------------------------------------------------------------------------
template <class S> class versym_section_accessor_template
{
  public:
    //------------------------------------------------------------------------------
    explicit versym_section_accessor_template( S* section )
        : versym_section( section )
    {
        if ( section != nullptr ) {
            entries_num = decltype( entries_num )( section->get_size() /
                                                   sizeof( Elf_Half ) );
        }
    }

    //------------------------------------------------------------------------------
    Elf_Word get_entries_num() const
    {
        if ( versym_section ) {
            return entries_num;
        }
        return 0;
    }

    //------------------------------------------------------------------------------
    bool get_entry( Elf_Word no, Elf_Half& value ) const
    {
        if ( versym_section && ( no < get_entries_num() ) ) {
            value = ( (Elf_Half*)versym_section->get_data() )[no];
            return true;
        }

        return false;
    }

    //------------------------------------------------------------------------------
    bool modify_entry( Elf_Word no, Elf_Half value )
    {
        if ( versym_section && ( no < get_entries_num() ) ) {
            ( (Elf_Half*)versym_section->get_data() )[no] = value;
            return true;
        }

        return false;
    }

    //------------------------------------------------------------------------------
    bool add_entry( Elf_Half value )
    {
        if ( !versym_section ) {
            return false;
        }

        versym_section->append_data( (const char*)&value, sizeof( Elf_Half ) );
        ++entries_num;

        return true;
    }

    //------------------------------------------------------------------------------
  private:
    S*       versym_section = nullptr;
    Elf_Word entries_num    = 0;
};

using versym_section_accessor = versym_section_accessor_template<section>;
using const_versym_section_accessor =
    versym_section_accessor_template<const section>;

//------------------------------------------------------------------------------
template <class S> class versym_r_section_accessor_template
{
  public:
    //------------------------------------------------------------------------------
    versym_r_section_accessor_template( const elfio& elf_file,
                                        S*           versym_r_section )
        : elf_file( elf_file ), versym_r_section( versym_r_section ),
          entries_num( 0 )
    {
        // Find .dynamic section
        const section* dynamic_section = elf_file.sections[".dynamic"];

        if ( dynamic_section == nullptr ) {
            return;
        }

        const_dynamic_section_accessor dynamic_section_acc( elf_file,
                                                            dynamic_section );
        Elf_Xword dyn_sec_num = dynamic_section_acc.get_entries_num();
        for ( Elf_Xword i = 0; i < dyn_sec_num; ++i ) {
            Elf_Xword   tag;
            Elf_Xword   value;
            std::string str;

            if ( dynamic_section_acc.get_entry( i, tag, value, str ) &&
                 tag == DT_VERNEEDNUM ) {
                entries_num = (Elf_Word)value;
                break;
            }
        }
    }

    //------------------------------------------------------------------------------
    Elf_Word get_entries_num() const { return entries_num; }

    //------------------------------------------------------------------------------
    bool get_entry( Elf_Word     no,
                    Elf_Half&    version,
                    std::string& file_name,
                    Elf_Word&    hash,
                    Elf_Half&    flags,
                    Elf_Half&    other,
                    std::string& dep_name ) const
    {
        if ( versym_r_section == nullptr || ( no >= get_entries_num() ) ) {
            return false;
        }

        const_string_section_accessor string_section_acc(
            elf_file.sections[versym_r_section->get_link()] );

        Elfxx_Verneed* verneed = (Elfxx_Verneed*)versym_r_section->get_data();
        Elfxx_Vernaux* veraux =
            (Elfxx_Vernaux*)( (char*)verneed + verneed->vn_aux );
        for ( Elf_Word i = 0; i < no; ++i ) {
            verneed = (Elfxx_Verneed*)( (char*)verneed + verneed->vn_next );
            veraux  = (Elfxx_Vernaux*)( (char*)verneed + verneed->vn_aux );
        }

        version   = verneed->vn_version;
        file_name = string_section_acc.get_string( verneed->vn_file );
        hash      = veraux->vna_hash;
        flags     = veraux->vna_flags;
        other     = veraux->vna_other;
        dep_name  = string_section_acc.get_string( veraux->vna_name );

        return true;
    }

    //------------------------------------------------------------------------------
  private:
    const elfio& elf_file;
    S*           versym_r_section = nullptr;
    Elf_Word     entries_num      = 0;
};

using versym_r_section_accessor = versym_r_section_accessor_template<section>;
using const_versym_r_section_accessor =
    versym_r_section_accessor_template<const section>;

} // namespace ELFIO

#endif // ELFIO_VERSYM_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFTYPES_H
#define ELFTYPES_H

#ifdef __cplusplus
namespace ELFIO {
#endif

using Elf_Half   = uint16_t;
using Elf_Word   = uint32_t;
using Elf_Sword  = int32_t;
using Elf_Xword  = uint64_t;
using Elf_Sxword = int64_t;

using Elf32_Addr = uint32_t;
using Elf32_Off  = uint32_t;
using Elf64_Addr = uint64_t;
using Elf64_Off  = uint64_t;

using Elf32_Half  = Elf_Half;
using Elf64_Half  = Elf_Half;
using Elf32_Word  = Elf_Word;
using Elf64_Word  = Elf_Word;
using Elf32_Sword = Elf_Sword;
using Elf64_Sword = Elf_Sword;

///////////////////////
// ELF Header Constants

// File type
constexpr Elf_Half ET_NONE   = 0;
constexpr Elf_Half ET_REL    = 1;
constexpr Elf_Half ET_EXEC   = 2;
constexpr Elf_Half ET_DYN    = 3;
constexpr Elf_Half ET_CORE   = 4;
constexpr Elf_Half ET_LOOS   = 0xFE00;
constexpr Elf_Half ET_HIOS   = 0xFEFF;
constexpr Elf_Half ET_LOPROC = 0xFF00;
constexpr Elf_Half ET_HIPROC = 0xFFFF;

// clang-format off
// Machine number
constexpr Elf_Half EM_NONE            = 0 ; // No machine
constexpr Elf_Half EM_M32             = 1 ; // AT&T WE 32100
constexpr Elf_Half EM_SPARC           = 2 ; // SUN SPARC
constexpr Elf_Half EM_386             = 3 ; // Intel 80386
constexpr Elf_Half EM_68K             = 4 ; // Motorola m68k family
constexpr Elf_Half EM_88K             = 5 ; // Motorola m88k family
constexpr Elf_Half EM_486             = 6 ; // Intel 80486// Reserved for future use
constexpr Elf_Half EM_860             = 7 ; // Intel 80860
constexpr Elf_Half EM_MIPS            = 8 ; // MIPS R3000 (officially, big-endian only)
constexpr Elf_Half EM_S370            = 9 ; // IBM System/370
constexpr Elf_Half EM_MIPS_RS3_LE     = 10; // MIPS R3000 little-endian (Deprecated)
constexpr Elf_Half EM_res011          = 11; // Reserved
constexpr Elf_Half EM_res012          = 12; // Reserved
constexpr Elf_Half EM_res013          = 13; // Reserved
constexpr Elf_Half EM_res014          = 14; // Reserved
constexpr Elf_Half EM_PARISC          = 15; // HPPA
constexpr Elf_Half EM_res016          = 16; // Reserved
constexpr Elf_Half EM_VPP550          = 17; // Fujitsu VPP500
constexpr Elf_Half EM_SPARC32PLUS     = 18; // Sun's "v8plus"
constexpr Elf_Half EM_960             = 19; // Intel 80960
constexpr Elf_Half EM_PPC             = 20; // PowerPC
constexpr Elf_Half EM_PPC64           = 21; // 64-bit PowerPC
constexpr Elf_Half EM_S390            = 22; // IBM S/390
constexpr Elf_Half EM_SPU             = 23; // Sony/Toshiba/IBM SPU
constexpr Elf_Half EM_res024          = 24; // Reserved
constexpr Elf_Half EM_res025          = 25; // Reserved
constexpr Elf_Half EM_res026          = 26; // Reserved
constexpr Elf_Half EM_res027          = 27; // Reserved
constexpr Elf_Half EM_res028          = 28; // Reserved
constexpr Elf_Half EM_res029          = 29; // Reserved
constexpr Elf_Half EM_res030          = 30; // Reserved
constexpr Elf_Half EM_res031          = 31; // Reserved
constexpr Elf_Half EM_res032          = 32; // Reserved
constexpr Elf_Half EM_res033          = 33; // Reserved
constexpr Elf_Half EM_res034          = 34; // Reserved
constexpr Elf_Half EM_res035          = 35; // Reserved
constexpr Elf_Half EM_V800            = 36; // NEC V800 series
constexpr Elf_Half EM_FR20            = 37; // Fujitsu FR20
constexpr Elf_Half EM_RH32            = 38; // TRW RH32
constexpr Elf_Half EM_MCORE           = 39; // Motorola M*Core // May also be taken by Fujitsu MMA
constexpr Elf_Half EM_RCE             = 39; // Old name for MCore
constexpr Elf_Half EM_ARM             = 40; // ARM
constexpr Elf_Half EM_OLD_ALPHA       = 41; // Digital Alpha
constexpr Elf_Half EM_SH              = 42; // Renesas (formerly Hitachi) / SuperH SH
constexpr Elf_Half EM_SPARCV9         = 43; // SPARC v9 64-bit
constexpr Elf_Half EM_TRICORE         = 44; // Siemens Tricore embedded processor
constexpr Elf_Half EM_ARC             = 45; // ARC Cores
constexpr Elf_Half EM_H8_300          = 46; // Renesas (formerly Hitachi) H8/300
constexpr Elf_Half EM_H8_300H         = 47; // Renesas (formerly Hitachi) H8/300H
constexpr Elf_Half EM_H8S             = 48; // Renesas (formerly Hitachi) H8S
constexpr Elf_Half EM_H8_500          = 49; // Renesas (formerly Hitachi) H8/500
constexpr Elf_Half EM_IA_64           = 50; // Intel IA-64 Processor
constexpr Elf_Half EM_MIPS_X          = 51; // Stanford MIPS-X
constexpr Elf_Half EM_COLDFIRE        = 52; // Motorola Coldfire
constexpr Elf_Half EM_68HC12          = 53; // Motorola M68HC12
constexpr Elf_Half EM_MMA             = 54; // Fujitsu Multimedia Accelerator
constexpr Elf_Half EM_PCP             = 55; // Siemens PCP
constexpr Elf_Half EM_NCPU            = 56; // Sony nCPU embedded RISC processor
constexpr Elf_Half EM_NDR1            = 57; // Denso NDR1 microprocesspr
constexpr Elf_Half EM_STARCORE        = 58; // Motorola Star*Core processor
constexpr Elf_Half EM_ME16            = 59; // Toyota ME16 processor
constexpr Elf_Half EM_ST100           = 60; // STMicroelectronics ST100 processor
constexpr Elf_Half EM_TINYJ           = 61; // Advanced Logic Corp. TinyJ embedded processor
constexpr Elf_Half EM_X86_64          = 62; // Advanced Micro Devices X86-64 processor
constexpr Elf_Half EM_PDSP            = 63; // Sony DSP Processor
constexpr Elf_Half EM_PDP10           = 64; // Digital Equipment Corp. PDP-10
constexpr Elf_Half EM_PDP11           = 65; // Digital Equipment Corp. PDP-11
constexpr Elf_Half EM_FX66            = 66; // Siemens FX66 microcontroller
constexpr Elf_Half EM_ST9PLUS         = 67; // STMicroelectronics ST9+ 8/16 bit microcontroller
constexpr Elf_Half EM_ST7             = 68 ; // STMicroelectronics ST7 8-bit microcontroller
constexpr Elf_Half EM_68HC16          = 69 ; // Motorola MC68HC16 Microcontroller
constexpr Elf_Half EM_68HC11          = 70 ; // Motorola MC68HC11 Microcontroller
constexpr Elf_Half EM_68HC08          = 71 ; // Motorola MC68HC08 Microcontroller
constexpr Elf_Half EM_68HC05          = 72 ; // Motorola MC68HC05 Microcontroller
constexpr Elf_Half EM_SVX             = 73 ; // Silicon Graphics SVx
constexpr Elf_Half EM_ST19            = 74 ; // STMicroelectronics ST19 8-bit cpu
constexpr Elf_Half EM_VAX             = 75 ; // Digital VAX
constexpr Elf_Half EM_CRIS            = 76 ; // Axis Communications 32-bit embedded processor
constexpr Elf_Half EM_JAVELIN         = 77 ; // Infineon Technologies 32-bit embedded cpu
constexpr Elf_Half EM_FIREPATH        = 78 ; // Element 14 64-bit DSP processor
constexpr Elf_Half EM_ZSP             = 79 ; // LSI Logic's 16-bit DSP processor
constexpr Elf_Half EM_MMIX            = 80 ; // Donald Knuth's educational 64-bit processor
constexpr Elf_Half EM_HUANY           = 81 ; // Harvard's machine-independent format
constexpr Elf_Half EM_PRISM           = 82 ; // SiTera Prism
constexpr Elf_Half EM_AVR             = 83 ; // Atmel AVR 8-bit microcontroller
constexpr Elf_Half EM_FR30            = 84 ; // Fujitsu FR30
constexpr Elf_Half EM_D10V            = 85 ; // Mitsubishi D10V
constexpr Elf_Half EM_D30V            = 86 ; // Mitsubishi D30V
constexpr Elf_Half EM_V850            = 87 ; // NEC v850
constexpr Elf_Half EM_M32R            = 88 ; // Renesas M32R (formerly Mitsubishi M32R)
constexpr Elf_Half EM_MN10300         = 89 ; // Matsushita MN10300
constexpr Elf_Half EM_MN10200         = 90 ; // Matsushita MN10200
constexpr Elf_Half EM_PJ              = 91 ; // picoJava
constexpr Elf_Half EM_OPENRISC        = 92 ; // OpenRISC 32-bit embedded processor
constexpr Elf_Half EM_ARC_A5          = 93 ; // ARC Cores Tangent-A5
constexpr Elf_Half EM_XTENSA          = 94 ; // Tensilica Xtensa Architecture
constexpr Elf_Half EM_VIDEOCORE       = 95 ; // Alphamosaic VideoCore processor
constexpr Elf_Half EM_TMM_GPP         = 96 ; // Thompson Multimedia General Purpose Processor
constexpr Elf_Half EM_NS32K           = 97 ; // National Semiconductor 32000 series
constexpr Elf_Half EM_TPC             = 98 ; // Tenor Network TPC processor
constexpr Elf_Half EM_SNP1K           = 99 ; // Trebia SNP 1000 processor
constexpr Elf_Half EM_ST200           = 100; // STMicroelectronics ST200 microcontroller
constexpr Elf_Half EM_IP2K            = 101; // Ubicom IP2022 micro controller
constexpr Elf_Half EM_MAX             = 102; // MAX Processor
constexpr Elf_Half EM_CR              = 103; // National Semiconductor CompactRISC
constexpr Elf_Half EM_F2MC16          = 104; // Fujitsu F2MC16
constexpr Elf_Half EM_MSP430          = 105; // TI msp430 micro controller
constexpr Elf_Half EM_BLACKFIN        = 106; // ADI Blackfin
constexpr Elf_Half EM_SE_C33          = 107; // S1C33 Family of Seiko Epson processors
constexpr Elf_Half EM_SEP             = 108; // Sharp embedded microprocessor
constexpr Elf_Half EM_ARCA            = 109; // Arca RISC Microprocessor
constexpr Elf_Half EM_UNICORE         = 110; // Microprocessor series from PKU-Unity Ltd.
constexpr Elf_Half EM_EXCESS          = 111; // eXcess: 16/32/64-bit configurable embedded CPU
constexpr Elf_Half EM_DXP             = 112; // Icera Semiconductor Inc. Deep Execution Processor
constexpr Elf_Half EM_ALTERA_NIOS2    = 113; // Altera Nios II soft-core processor
constexpr Elf_Half EM_CRX             = 114; // National Semiconductor CRX
constexpr Elf_Half EM_XGATE           = 115; // Motorola XGATE embedded processor
constexpr Elf_Half EM_C166            = 116; // Infineon C16x/XC16x processor
constexpr Elf_Half EM_M16C            = 117; // Renesas M16C series microprocessors
constexpr Elf_Half EM_DSPIC30F        = 118; // Microchip Technology dsPIC30F DSignal Controller
constexpr Elf_Half EM_CE              = 119; // Freescale Communication Engine RISC core
constexpr Elf_Half EM_M32C            = 120; // Renesas M32C series microprocessors
constexpr Elf_Half EM_res121          = 121; // Reserved
constexpr Elf_Half EM_res122          = 122; // Reserved
constexpr Elf_Half EM_res123          = 123; // Reserved
constexpr Elf_Half EM_res124          = 124; // Reserved
constexpr Elf_Half EM_res125          = 125; // Reserved
constexpr Elf_Half EM_res126          = 126; // Reserved
constexpr Elf_Half EM_res127          = 127; // Reserved
constexpr Elf_Half EM_res128          = 128; // Reserved
constexpr Elf_Half EM_res129          = 129; // Reserved
constexpr Elf_Half EM_res130          = 130; // Reserved
constexpr Elf_Half EM_TSK3000         = 131; // Altium TSK3000 core
constexpr Elf_Half EM_RS08            = 132; // Freescale RS08 embedded processor
constexpr Elf_Half EM_res133          = 133; // Reserved
constexpr Elf_Half EM_ECOG2           = 134; // Cyan Technology eCOG2 microprocessor
constexpr Elf_Half EM_SCORE           = 135; // Sunplus Score
constexpr Elf_Half EM_SCORE7          = 135; // Sunplus S+core7 RISC processor
constexpr Elf_Half EM_DSP24           = 136; // New Japan Radio (NJR) 24-bit DSP Processor
constexpr Elf_Half EM_VIDEOCORE3      = 137; // Broadcom VideoCore III processor
constexpr Elf_Half EM_LATTICEMICO32   = 138; // RISC processor for Lattice FPGA architecture
constexpr Elf_Half EM_SE_C17          = 139; // Seiko Epson C17 family
constexpr Elf_Half EM_TI_C6000        = 140; // Texas Instruments TMS320C6000 DSP family
constexpr Elf_Half EM_TI_C2000        = 141; // Texas Instruments TMS320C2000 DSP family
constexpr Elf_Half EM_TI_C5500        = 142; // Texas Instruments TMS320C55x DSP family
constexpr Elf_Half EM_res143          = 143; // Reserved
constexpr Elf_Half EM_res144          = 144; // Reserved
constexpr Elf_Half EM_res145          = 145; // Reserved
constexpr Elf_Half EM_res146          = 146; // Reserved
constexpr Elf_Half EM_res147          = 147; // Reserved
constexpr Elf_Half EM_res148          = 148; // Reserved
constexpr Elf_Half EM_res149          = 149; // Reserved
constexpr Elf_Half EM_res150          = 150; // Reserved
constexpr Elf_Half EM_res151          = 151; // Reserved
constexpr Elf_Half EM_res152          = 152; // Reserved
constexpr Elf_Half EM_res153          = 153; // Reserved
constexpr Elf_Half EM_res154          = 154; // Reserved
constexpr Elf_Half EM_res155          = 155; // Reserved
constexpr Elf_Half EM_res156          = 156; // Reserved
constexpr Elf_Half EM_res157          = 157; // Reserved
constexpr Elf_Half EM_res158          = 158; // Reserved
constexpr Elf_Half EM_res159          = 159; // Reserved
constexpr Elf_Half EM_MMDSP_PLUS      = 160; // STMicroelectronics 64bit VLIW Data Signal Processor
constexpr Elf_Half EM_CYPRESS_M8C     = 161; // Cypress M8C microprocessor
constexpr Elf_Half EM_R32C            = 162; // Renesas R32C series microprocessors
constexpr Elf_Half EM_TRIMEDIA        = 163; // NXP Semiconductors TriMedia architecture family
constexpr Elf_Half EM_QDSP6           = 164; // QUALCOMM DSP6 Processor
constexpr Elf_Half EM_8051            = 165; // Intel 8051 and variants
constexpr Elf_Half EM_STXP7X          = 166; // STMicroelectronics STxP7x family
constexpr Elf_Half EM_NDS32           = 167; // Andes Technology embedded RISC processor family
constexpr Elf_Half EM_ECOG1           = 168; // Cyan Technology eCOG1X family
constexpr Elf_Half EM_ECOG1X          = 168; // Cyan Technology eCOG1X family
constexpr Elf_Half EM_MAXQ30          = 169; // Dallas Semiconductor MAXQ30 Core Micro-controllers
constexpr Elf_Half EM_XIMO16          = 170; // New Japan Radio (NJR) 16-bit DSP Processor
constexpr Elf_Half EM_MANIK           = 171; // M2000 Reconfigurable RISC Microprocessor
constexpr Elf_Half EM_CRAYNV2         = 172; // Cray Inc. NV2 vector architecture
constexpr Elf_Half EM_RX              = 173; // Renesas RX family
constexpr Elf_Half EM_METAG           = 174; // Imagination Technologies META processor architecture
constexpr Elf_Half EM_MCST_ELBRUS     = 175; // MCST Elbrus general purpose hardware architecture
constexpr Elf_Half EM_ECOG16          = 176; // Cyan Technology eCOG16 family
constexpr Elf_Half EM_CR16            = 177; // National Semiconductor CompactRISC 16-bit processor
constexpr Elf_Half EM_ETPU            = 178; // Freescale Extended Time Processing Unit
constexpr Elf_Half EM_SLE9X           = 179; // Infineon Technologies SLE9X core
constexpr Elf_Half EM_L1OM            = 180; // Intel L1OM
constexpr Elf_Half EM_INTEL181        = 181; // Reserved by Intel
constexpr Elf_Half EM_INTEL182        = 182; // Reserved by Intel
constexpr Elf_Half EM_AARCH64         = 183; // ARM AArch64
constexpr Elf_Half EM_res184          = 184; // Reserved by ARM
constexpr Elf_Half EM_AVR32           = 185; // Atmel Corporation 32-bit microprocessor family
constexpr Elf_Half EM_STM8            = 186; // STMicroeletronics STM8 8-bit microcontroller
constexpr Elf_Half EM_TILE64          = 187; // Tilera TILE64 multicore architecture family
constexpr Elf_Half EM_TILEPRO         = 188; // Tilera TILEPro multicore architecture family
constexpr Elf_Half EM_MICROBLAZE      = 189; // Xilinx MicroBlaze 32-bit RISC soft processor core
constexpr Elf_Half EM_CUDA            = 190; // NVIDIA CUDA architecture
constexpr Elf_Half EM_TILEGX          = 191; // Tilera TILE-Gx multicore architecture family
constexpr Elf_Half EM_CLOUDSHIELD     = 192; // CloudShield architecture family
constexpr Elf_Half EM_COREA_1ST       = 193; // KIPO-KAIST Core-A 1st generation processor family
constexpr Elf_Half EM_COREA_2ND       = 194; // KIPO-KAIST Core-A 2nd generation processor family
constexpr Elf_Half EM_ARC_COMPACT2    = 195; // Synopsys ARCompact V2
constexpr Elf_Half EM_OPEN8           = 196; // Open8 8-bit RISC soft processor core
constexpr Elf_Half EM_RL78            = 197; // Renesas RL78 family
constexpr Elf_Half EM_VIDEOCORE5      = 198; // Broadcom VideoCore V processor
constexpr Elf_Half EM_78KOR           = 199; // Renesas 78KOR family
constexpr Elf_Half EM_56800EX         = 200; // Freescale 56800EX Digital Signal Controller (DSC)
constexpr Elf_Half EM_BA1             = 201; // Beyond BA1 CPU architecture
constexpr Elf_Half EM_BA2             = 202; // Beyond BA2 CPU architecture
constexpr Elf_Half EM_XCORE           = 203; // XMOS xCORE processor family
constexpr Elf_Half EM_MCHP_PIC        = 204; // Microchip 8-bit PIC(r) family
constexpr Elf_Half EM_INTEL205        = 205; // Reserved by Intel
constexpr Elf_Half EM_INTEL206        = 206; // Reserved by Intel
constexpr Elf_Half EM_INTEL207        = 207; // Reserved by Intel
constexpr Elf_Half EM_INTEL208        = 208; // Reserved by Intel
constexpr Elf_Half EM_INTEL209        = 209; // Reserved by Intel
constexpr Elf_Half EM_KM32            = 210; // KM211 KM32 32-bit processor
constexpr Elf_Half EM_KMX32           = 211; // KM211 KMX32 32-bit processor
constexpr Elf_Half EM_KMX16           = 212; // KM211 KMX16 16-bit processor
constexpr Elf_Half EM_KMX8            = 213; // KM211 KMX8 8-bit processor
constexpr Elf_Half EM_KVARC           = 214; // KM211 KVARC processor
constexpr Elf_Half EM_CDP             = 215; // Paneve CDP architecture family
constexpr Elf_Half EM_COGE            = 216; // Cognitive Smart Memory Processor
constexpr Elf_Half EM_COOL            = 217; // iCelero CoolEngine
constexpr Elf_Half EM_NORC            = 218; // Nanoradio Optimized RISC
constexpr Elf_Half EM_CSR_KALIMBA     = 219; // CSR Kalimba architecture family
constexpr Elf_Half EM_Z80             = 220; // Zilog Z80
constexpr Elf_Half EM_VISIUM          = 221; // Controls and Data Services VISIUMcore processor
constexpr Elf_Half EM_FT32            = 222; // FTDI Chip FT32 high performance 32-bit RISC architecture
constexpr Elf_Half EM_MOXIE           = 223; // Moxie processor family
constexpr Elf_Half EM_AMDGPU          = 224; // AMD GPU architecture
constexpr Elf_Half EM_RISCV           = 243; // RISC-V
constexpr Elf_Half EM_LANAI           = 244; // Lanai processor
constexpr Elf_Half EM_CEVA            = 245; // CEVA Processor Architecture Family
constexpr Elf_Half EM_CEVA_X2         = 246; // CEVA X2 Processor Family
constexpr Elf_Half EM_BPF             = 247; // Linux BPF  in-kernel virtual machine
constexpr Elf_Half EM_GRAPHCORE_IPU   = 248; // Graphcore Intelligent Processing Unit
constexpr Elf_Half EM_IMG1            = 249; // Imagination Technologies
constexpr Elf_Half EM_NFP             = 250; // Netronome Flow Processor (P)
constexpr Elf_Half EM_CSKY            = 252; // C-SKY processor family
constexpr Elf_Half EM_ARC_COMPACT3_64 = 253; // Synopsys ARCv2.3 64-bit
constexpr Elf_Half EM_MCS6502         = 254; // MOS Technology MCS 6502 processor
constexpr Elf_Half EM_ARC_COMPACT3    = 255; // Synopsys ARCv2.3 32-bit
constexpr Elf_Half EM_KVX             = 256; // Kalray VLIW core of the MPPA processor family
constexpr Elf_Half EM_65816           = 257; // WDC 65816/65C816
constexpr Elf_Half EM_LOONGARCH       = 258; // Loongson Loongarch
constexpr Elf_Half EM_KF32            = 259; // ChipON KungFu32

constexpr Elf_Half EM_MT                = 0x2530; // Morpho Techologies MT processor
constexpr Elf_Half EM_ALPHA             = 0x9026; // Alpha
constexpr Elf_Half EM_WEBASSEMBLY       = 0x4157; // Web Assembly
constexpr Elf_Half EM_DLX               = 0x5aa5; // OpenDLX
constexpr Elf_Half EM_XSTORMY16         = 0xad45; // Sanyo XStormy16 CPU core
constexpr Elf_Half EM_IQ2000            = 0xFEBA; // Vitesse IQ2000
constexpr Elf_Half EM_M32C_OLD          = 0xFEB;
constexpr Elf_Half EM_NIOS32            = 0xFEBB; // Altera Nios
constexpr Elf_Half EM_CYGNUS_MEP        = 0xF00D; // Toshiba MeP Media Engine
constexpr Elf_Half EM_ADAPTEVA_EPIPHANY = 0x1223; // Adapteva EPIPHANY
constexpr Elf_Half EM_CYGNUS_FRV        = 0x5441; // Fujitsu FR-V
constexpr Elf_Half EM_S12Z              = 0x4DEF; // Freescale S12Z
// clang-format on

// File version
constexpr unsigned char EV_NONE    = 0;
constexpr unsigned char EV_CURRENT = 1;

// Identification index
constexpr unsigned char EI_MAG0       = 0;
constexpr unsigned char EI_MAG1       = 1;
constexpr unsigned char EI_MAG2       = 2;
constexpr unsigned char EI_MAG3       = 3;
constexpr unsigned char EI_CLASS      = 4;
constexpr unsigned char EI_DATA       = 5;
constexpr unsigned char EI_VERSION    = 6;
constexpr unsigned char EI_OSABI      = 7;
constexpr unsigned char EI_ABIVERSION = 8;
constexpr unsigned char EI_PAD        = 9;
constexpr unsigned char EI_NIDENT     = 16;

// Magic number
constexpr unsigned char ELFMAG0 = 0x7F;
constexpr unsigned char ELFMAG1 = 'E';
constexpr unsigned char ELFMAG2 = 'L';
constexpr unsigned char ELFMAG3 = 'F';

// File class
constexpr unsigned char ELFCLASSNONE = 0;
constexpr unsigned char ELFCLASS32   = 1;
constexpr unsigned char ELFCLASS64   = 2;

// Encoding
constexpr unsigned char ELFDATANONE = 0;
constexpr unsigned char ELFDATA2LSB = 1;
constexpr unsigned char ELFDATA2MSB = 2;

// clang-format off
// OS extensions
constexpr unsigned char ELFOSABI_NONE    = 0;  // No extensions or unspecified
constexpr unsigned char ELFOSABI_HPUX    = 1;  // Hewlett-Packard HP-UX
constexpr unsigned char ELFOSABI_NETBSD  = 2;  // NetBSD
constexpr unsigned char ELFOSABI_LINUX   = 3;  // Linux
constexpr unsigned char ELFOSABI_HURD    = 4;  // GNU Hurd
constexpr unsigned char ELFOSABI_SOLARIS = 6;  // Sun Solaris
constexpr unsigned char ELFOSABI_AIX     = 7;  // AIX
constexpr unsigned char ELFOSABI_IRIX    = 8;  // IRIX
constexpr unsigned char ELFOSABI_FREEBSD = 9;  // FreeBSD
constexpr unsigned char ELFOSABI_TRU64   = 10; // Compaq TRU64 UNIX
constexpr unsigned char ELFOSABI_MODESTO = 11; // Novell Modesto
constexpr unsigned char ELFOSABI_OPENBSD = 12; // Open BSD
constexpr unsigned char ELFOSABI_OPENVMS = 13; // Open VMS
constexpr unsigned char ELFOSABI_NSK     = 14; // Hewlett-Packard Non-Stop Kernel
constexpr unsigned char ELFOSABI_AROS    = 15; // Amiga Research OS
constexpr unsigned char ELFOSABI_FENIXOS = 16; // The FenixOS highly scalable multi-core OS
constexpr unsigned char ELFOSABI_NUXI    = 17; // Nuxi CloudABI
constexpr unsigned char ELFOSABI_OPENVOS = 18; // Stratus Technologies OpenVOS
constexpr unsigned char ELFOSABI_ARM     = 97; // ARM
constexpr unsigned char ELFOSABI_STANDALONE	= 255; // Standalone (embedded) application

// 64-255 Architecture-specific value range
// AMDGPU OS for HSA compatible compute kernels
constexpr unsigned char ELFOSABI_AMDGPU_HSA = 64;
// AMDGPU OS for AMD PAL compatible graphics
// shaders and compute kernels
constexpr unsigned char ELFOSABI_AMDGPU_PAL = 65;
// AMDGPU OS for Mesa3D compatible graphics
// shaders and compute kernels
constexpr unsigned char ELFOSABI_AMDGPU_MESA3D = 66;
// clang-format on

constexpr unsigned char ELFABIVERSION_AMDGPU_HSA_V2 = 0;
constexpr unsigned char ELFABIVERSION_AMDGPU_HSA_V3 = 1;
constexpr unsigned char ELFABIVERSION_AMDGPU_HSA_V4 = 2;

// AMDGPU specific e_flags
constexpr Elf_Word EF_AMDGPU_MACH = 0x0ff; // AMDGPU processor selection mask.
// Indicates if the XNACK target feature is
// enabled for all code contained in the ELF.
constexpr Elf_Word EF_AMDGPU_XNACK = 0x100;

constexpr Elf_Word EF_AMDGPU_FEATURE_XNACK_V2               = 0x01;
constexpr Elf_Word EF_AMDGPU_FEATURE_TRAP_HANDLER_V2        = 0x02;
constexpr Elf_Word EF_AMDGPU_FEATURE_XNACK_V3               = 0x100;
constexpr Elf_Word EF_AMDGPU_FEATURE_SRAMECC_V3             = 0x200;
constexpr Elf_Word EF_AMDGPU_FEATURE_XNACK_V4               = 0x300;
constexpr Elf_Word EF_AMDGPU_FEATURE_XNACK_UNSUPPORTED_V4   = 0x000;
constexpr Elf_Word EF_AMDGPU_FEATURE_XNACK_ANY_V4           = 0x100;
constexpr Elf_Word EF_AMDGPU_FEATURE_XNACK_OFF_V4           = 0x200;
constexpr Elf_Word EF_AMDGPU_FEATURE_XNACK_ON_V4            = 0x300;
constexpr Elf_Word EF_AMDGPU_FEATURE_SRAMECC_V4             = 0xc00;
constexpr Elf_Word EF_AMDGPU_FEATURE_SRAMECC_UNSUPPORTED_V4 = 0x000;
constexpr Elf_Word EF_AMDGPU_FEATURE_SRAMECC_ANY_V4         = 0x400;
constexpr Elf_Word EF_AMDGPU_FEATURE_SRAMECC_OFF_V4         = 0x800;
constexpr Elf_Word EF_AMDGPU_FEATURE_SRAMECC_ON_V4          = 0xc00;

// AMDGPU processors
constexpr Elf_Word EF_AMDGPU_MACH_NONE       = 0x000; // Unspecified processor.
constexpr Elf_Word EF_AMDGPU_MACH_R600_R600  = 0x001;
constexpr Elf_Word EF_AMDGPU_MACH_R600_R630  = 0x002;
constexpr Elf_Word EF_AMDGPU_MACH_R600_RS880 = 0x003;
constexpr Elf_Word EF_AMDGPU_MACH_R600_RV670 = 0x004;
constexpr Elf_Word EF_AMDGPU_MACH_R600_RV710 = 0x005;
constexpr Elf_Word EF_AMDGPU_MACH_R600_RV730 = 0x006;
constexpr Elf_Word EF_AMDGPU_MACH_R600_RV770 = 0x007;
constexpr Elf_Word EF_AMDGPU_MACH_R600_CEDAR = 0x008;
constexpr Elf_Word EF_AMDGPU_MACH_R600_CYPRESS        = 0x009;
constexpr Elf_Word EF_AMDGPU_MACH_R600_JUNIPER        = 0x00a;
constexpr Elf_Word EF_AMDGPU_MACH_R600_REDWOOD        = 0x00b;
constexpr Elf_Word EF_AMDGPU_MACH_R600_SUMO           = 0x00c;
constexpr Elf_Word EF_AMDGPU_MACH_R600_BARTS          = 0x00d;
constexpr Elf_Word EF_AMDGPU_MACH_R600_CAICOS         = 0x00e;
constexpr Elf_Word EF_AMDGPU_MACH_R600_CAYMAN         = 0x00f;
constexpr Elf_Word EF_AMDGPU_MACH_R600_TURKS          = 0x010;
constexpr Elf_Word EF_AMDGPU_MACH_R600_RESERVED_FIRST = 0x011;
constexpr Elf_Word EF_AMDGPU_MACH_R600_RESERVED_LAST  = 0x01f;
constexpr Elf_Word EF_AMDGPU_MACH_R600_FIRST = EF_AMDGPU_MACH_R600_R600;
constexpr Elf_Word EF_AMDGPU_MACH_R600_LAST  = EF_AMDGPU_MACH_R600_TURKS;

// AMDGCN-based processors.
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX600        = 0x020;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX601        = 0x021;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX700        = 0x022;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX701        = 0x023;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX702        = 0x024;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX703        = 0x025;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX704        = 0x026;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_RESERVED_0X27 = 0x027;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX801        = 0x028;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX802        = 0x029;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX803        = 0x02a;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX810        = 0x02b;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX900        = 0x02c;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX902        = 0x02d;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX904        = 0x02e;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX906        = 0x02f;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX908        = 0x030;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX909        = 0x031;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX90C        = 0x032;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX1010       = 0x033;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX1011       = 0x034;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX1012       = 0x035;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX1030       = 0x036;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX1031       = 0x037;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX1032       = 0x038;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX1033       = 0x039;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX602        = 0x03a;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX705        = 0x03b;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX805        = 0x03c;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_RESERVED_0X3D = 0x03d;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX1034       = 0x03e;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX90A        = 0x03f;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_RESERVED_0X40 = 0x040;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_RESERVED_0X41 = 0x041;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX1013       = 0x042;
// First/last AMDGCN-based processors.
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_FIRST = EF_AMDGPU_MACH_AMDGCN_GFX600;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_LAST  = EF_AMDGPU_MACH_AMDGCN_GFX1013;

/////////////////////
// Sections constants

// Section indexes
constexpr Elf_Word SHN_UNDEF     = 0;
constexpr Elf_Word SHN_LORESERVE = 0xFF00;
constexpr Elf_Word SHN_LOPROC    = 0xFF00;
constexpr Elf_Word SHN_HIPROC    = 0xFF1F;
constexpr Elf_Word SHN_LOOS      = 0xFF20;
constexpr Elf_Word SHN_HIOS      = 0xFF3F;
constexpr Elf_Word SHN_ABS       = 0xFFF1;
constexpr Elf_Word SHN_COMMON    = 0xFFF2;
constexpr Elf_Word SHN_XINDEX    = 0xFFFF;
constexpr Elf_Word SHN_HIRESERVE = 0xFFFF;

// Section types
constexpr Elf_Word SHT_NULL               = 0;
constexpr Elf_Word SHT_PROGBITS           = 1;
constexpr Elf_Word SHT_SYMTAB             = 2;
constexpr Elf_Word SHT_STRTAB             = 3;
constexpr Elf_Word SHT_RELA               = 4;
constexpr Elf_Word SHT_HASH               = 5;
constexpr Elf_Word SHT_DYNAMIC            = 6;
constexpr Elf_Word SHT_NOTE               = 7;
constexpr Elf_Word SHT_NOBITS             = 8;
constexpr Elf_Word SHT_REL                = 9;
constexpr Elf_Word SHT_SHLIB              = 10;
constexpr Elf_Word SHT_DYNSYM             = 11;
constexpr Elf_Word SHT_INIT_ARRAY         = 14;
constexpr Elf_Word SHT_FINI_ARRAY         = 15;
constexpr Elf_Word SHT_PREINIT_ARRAY      = 16;
constexpr Elf_Word SHT_GROUP              = 17;
constexpr Elf_Word SHT_SYMTAB_SHNDX       = 18;
constexpr Elf_Word SHT_GNU_ATTRIBUTES     = 0x6ffffff5;
constexpr Elf_Word SHT_GNU_HASH           = 0x6ffffff6;
constexpr Elf_Word SHT_GNU_LIBLIST        = 0x6ffffff7;
constexpr Elf_Word SHT_CHECKSUM           = 0x6ffffff8;
constexpr Elf_Word SHT_LOSUNW             = 0x6ffffffa;
constexpr Elf_Word SHT_SUNW_move          = 0x6ffffffa;
constexpr Elf_Word SHT_SUNW_COMDAT        = 0x6ffffffb;
constexpr Elf_Word SHT_SUNW_syminfo       = 0x6ffffffc;
constexpr Elf_Word SHT_GNU_verdef         = 0x6ffffffd;
constexpr Elf_Word SHT_GNU_verneed        = 0x6ffffffe;
constexpr Elf_Word SHT_GNU_versym         = 0x6fffffff;
constexpr Elf_Word SHT_LOOS               = 0x60000000;
constexpr Elf_Word SHT_HIOS               = 0x6fffffff;
constexpr Elf_Word SHT_LOPROC             = 0x70000000;
constexpr Elf_Word SHT_ARM_EXIDX          = 0x70000001;
constexpr Elf_Word SHT_ARM_PREEMPTMAP     = 0x70000002;
constexpr Elf_Word SHT_ARM_ATTRIBUTES     = 0x70000003;
constexpr Elf_Word SHT_ARM_DEBUGOVERLAY   = 0x70000004;
constexpr Elf_Word SHT_ARM_OVERLAYSECTION = 0x70000005;
constexpr Elf_Word SHT_HIPROC             = 0x7FFFFFFF;
constexpr Elf_Word SHT_LOUSER             = 0x80000000;
// Used by Nintendo Wii U
constexpr Elf_Word SHT_RPL_EXPORTS  = 0x80000001;
constexpr Elf_Word SHT_RPL_IMPORTS  = 0x80000002;
constexpr Elf_Word SHT_RPL_CRCS     = 0x80000003;
constexpr Elf_Word SHT_RPL_FILEINFO = 0x80000004;
constexpr Elf_Word SHT_HIUSER       = 0xFFFFFFFF;

// Section attribute flags
constexpr Elf_Xword SHF_WRITE            = 0x1;
constexpr Elf_Xword SHF_ALLOC            = 0x2;
constexpr Elf_Xword SHF_EXECINSTR        = 0x4;
constexpr Elf_Xword SHF_MERGE            = 0x10;
constexpr Elf_Xword SHF_STRINGS          = 0x20;
constexpr Elf_Xword SHF_INFO_LINK        = 0x40;
constexpr Elf_Xword SHF_LINK_ORDER       = 0x80;
constexpr Elf_Xword SHF_OS_NONCONFORMING = 0x100;
constexpr Elf_Xword SHF_GROUP            = 0x200;
constexpr Elf_Xword SHF_TLS              = 0x400;
constexpr Elf_Xword SHF_COMPRESSED       = 0x800;
constexpr Elf_Xword SHF_GNU_RETAIN       = 0x200000;
constexpr Elf_Xword SHF_GNU_MBIND        = 0x01000000;
// flag used in Nintendo RPX/RPL to indicate section data is compressed
constexpr Elf_Xword SHF_RPX_DEFLATE = 0x08000000;
constexpr Elf_Xword SHF_MASKOS      = 0x0FF00000;
constexpr Elf_Xword SHF_MIPS_GPREL  = 0x10000000;
constexpr Elf_Xword SHF_ORDERED     = 0x40000000;
constexpr Elf_Xword SHF_EXCLUDE     = 0x80000000;
constexpr Elf_Xword SHF_MASKPROC    = 0xF0000000;

// Section group flags
constexpr Elf_Word GRP_COMDAT   = 0x1;
constexpr Elf_Word GRP_MASKOS   = 0x0ff00000;
constexpr Elf_Word GRP_MASKPROC = 0xf0000000;

// Symbol binding
constexpr unsigned char STB_LOCAL    = 0;
constexpr unsigned char STB_GLOBAL   = 1;
constexpr unsigned char STB_WEAK     = 2;
constexpr unsigned char STB_LOOS     = 10;
constexpr unsigned char STB_HIOS     = 12;
constexpr unsigned char STB_MULTIDEF = 13;
constexpr unsigned char STB_LOPROC   = 13;
constexpr unsigned char STB_HIPROC   = 15;

// Values of note segment descriptor types for core files
constexpr Elf_Word NT_PRSTATUS   = 1; // Contains copy of prstatus struct
constexpr Elf_Word NT_FPREGSET   = 2; // Contains copy of fpregset struct
constexpr Elf_Word NT_PRPSINFO   = 3; // Contains copy of prpsinfo struct
constexpr Elf_Word NT_TASKSTRUCT = 4; // Contains copy of task struct
constexpr Elf_Word NT_AUXV       = 6; // Contains copy of Elfxx_auxv_t
constexpr Elf_Word NT_SIGINFO    = 0x53494749; // Fields of siginfo_t.
constexpr Elf_Word NT_FILE       = 0x46494c45; // Description of mapped files.

// Note segments for core files on dir-style procfs systems.
constexpr Elf_Word NT_PSTATUS      = 10; // Has a struct pstatus
constexpr Elf_Word NT_FPREGS       = 12; // Has a struct fpregset
constexpr Elf_Word NT_PSINFO       = 13; // Has a struct psinfo
constexpr Elf_Word NT_LWPSTATUS    = 16; // Has a struct lwpstatus_t
constexpr Elf_Word NT_LWPSINFO     = 17; // Has a struct lwpsinfo_t
constexpr Elf_Word NT_WIN32PSTATUS = 18; // Has a struct win32_pstatus

// clang-format off

// Note name must be "LINUX"    
constexpr Elf_Word NT_PRXFPREG             = 0x46e62b7f; // Contains a user_xfpregs_struct
constexpr Elf_Word NT_PPC_VMX              = 0x100;      // PowerPC Altivec/VMX registers
constexpr Elf_Word NT_PPC_VSX              = 0x102;      // PowerPC VSX registers
constexpr Elf_Word NT_PPC_TAR              = 0x103;      // PowerPC Target Address Register
constexpr Elf_Word NT_PPC_PPR              = 0x104;      // PowerPC Program Priority Register
constexpr Elf_Word NT_PPC_DSCR             = 0x105;      // PowerPC Data Stream Control Register
constexpr Elf_Word NT_PPC_EBB              = 0x106;      // PowerPC Event Based Branch Registers
constexpr Elf_Word NT_PPC_PMU              = 0x107;      // PowerPC Performance Monitor Registers
constexpr Elf_Word NT_PPC_TM_CGPR          = 0x108;      // PowerPC TM checkpointed GPR Registers
constexpr Elf_Word NT_PPC_TM_CFPR          = 0x109;      // PowerPC TM checkpointed FPR Registers
constexpr Elf_Word NT_PPC_TM_CVMX          = 0x10a;      // PowerPC TM checkpointed VMX Registers
constexpr Elf_Word NT_PPC_TM_CVSX          = 0x10b;      // PowerPC TM checkpointed VSX Registers
constexpr Elf_Word NT_PPC_TM_SPR           = 0x10c;      // PowerPC TM Special Purpose Registers
constexpr Elf_Word NT_PPC_TM_CTAR          = 0x10d;      // PowerPC TM checkpointed TAR
constexpr Elf_Word NT_PPC_TM_CPPR          = 0x10e;      // PowerPC TM checkpointed PPR
constexpr Elf_Word NT_PPC_TM_CDSCR         = 0x10f;      // PowerPC TM checkpointed Data SCR
constexpr Elf_Word NT_386_TLS              = 0x200;      // x86 TLS information
constexpr Elf_Word NT_386_IOPERM           = 0x201;      // x86 io permissions
constexpr Elf_Word NT_X86_XSTATE           = 0x202;      // x86 XSAVE extended state
constexpr Elf_Word NT_X86_CET              = 0x203;      // x86 CET state.
constexpr Elf_Word NT_S390_HIGH_GPRS       = 0x300;      // S/390 upper halves of GPRs
constexpr Elf_Word NT_S390_TIMER           = 0x301;      // S390 timer
constexpr Elf_Word NT_S390_TODCMP          = 0x302;      // S390 TOD clock comparator
constexpr Elf_Word NT_S390_TODPREG         = 0x303;      // S390 TOD programmable register
constexpr Elf_Word NT_S390_CTRS            = 0x304;      // S390 control registers
constexpr Elf_Word NT_S390_PREFIX          = 0x305;      // S390 prefix register
constexpr Elf_Word NT_S390_LAST_BREAK      = 0x306;      // S390 breaking event address
constexpr Elf_Word NT_S390_SYSTEM_CALL     = 0x307;      // S390 system call restart data
constexpr Elf_Word NT_S390_TDB             = 0x308;      // S390 transaction diagnostic block
constexpr Elf_Word NT_S390_VXRS_LOW        = 0x309;      // S390 vector registers 0-15 upper half
constexpr Elf_Word NT_S390_VXRS_HIGH       = 0x30a;      // S390 vector registers 16-31
constexpr Elf_Word NT_S390_GS_CB           = 0x30b;      // s390 guarded storage registers
constexpr Elf_Word NT_S390_GS_BC           = 0x30c;      // s390 guarded storage broadcast control block
constexpr Elf_Word NT_ARM_VFP              = 0x400;      // ARM VFP registers
constexpr Elf_Word NT_ARM_TLS              = 0x401;      // AArch TLS registers
constexpr Elf_Word NT_ARM_HW_BREAK         = 0x402;      // AArch hardware breakpoint registers
constexpr Elf_Word NT_ARM_HW_WATCH         = 0x403;      // AArch hardware watchpoint registers
constexpr Elf_Word NT_ARM_SVE              = 0x405;      // AArch SVE registers.
constexpr Elf_Word NT_ARM_PAC_MASK         = 0x406;      // AArch pointer authentication code masks
constexpr Elf_Word NT_ARM_PACA_KEYS        = 0x407;      // ARM pointer authentication address keys
constexpr Elf_Word NT_ARM_PACG_KEYS        = 0x408;      // ARM pointer authentication generic keys
constexpr Elf_Word NT_ARM_TAGGED_ADDR_CTRL = 0x409;      // AArch64 tagged address control (prctl())
constexpr Elf_Word NT_ARM_PAC_ENABLED_KEYS = 0x40a;      // AArch64 pointer authentication enabled keys (prctl())
constexpr Elf_Word NT_ARC_V2               = 0x600;      // ARC HS accumulator/extra registers.
constexpr Elf_Word NT_LARCH_CPUCFG         = 0xa00;      // LoongArch CPU config registers
constexpr Elf_Word NT_LARCH_CSR            = 0xa01;      // LoongArch Control State Registers
constexpr Elf_Word NT_LARCH_LSX            = 0xa02;      // LoongArch SIMD eXtension registers
constexpr Elf_Word NT_LARCH_LASX           = 0xa03;      // LoongArch Advanced SIMD eXtension registers
constexpr Elf_Word NT_RISCV_CSR            = 0x900;      // RISC-V Control and Status Registers

// Note name must be "CORE"
constexpr Elf_Word NT_LARCH_LBT = 0xa04; // LoongArch Binary Translation registers

/* The range 0xff000000 to 0xffffffff is set aside for notes that don't
   originate from any particular operating system.  */
constexpr Elf_Word NT_GDB_TDESC = 0xff000000; // Contains copy of GDB's target description XML.
constexpr Elf_Word NT_MEMTAG    = 0xff000001; // Contains a copy of the memory tags.
/* ARM-specific NT_MEMTAG types.  */
constexpr Elf_Word NT_MEMTAG_TYPE_AARCH_MTE = 0x400; // MTE memory tags for AArch64.

constexpr Elf_Word NT_STAPSDT = 3; // Note segment for SystemTap probes.

// Note name is "FreeBSD"
constexpr Elf_Word NT_FREEBSD_THRMISC            = 7;  // Thread miscellaneous info.
constexpr Elf_Word NT_FREEBSD_PROCSTAT_PROC      = 8;  // Procstat proc data.
constexpr Elf_Word NT_FREEBSD_PROCSTAT_FILES     = 9;  // Procstat files data.
constexpr Elf_Word NT_FREEBSD_PROCSTAT_VMMAP     = 10; // Procstat vmmap data.
constexpr Elf_Word NT_FREEBSD_PROCSTAT_GROUPS    = 11; // Procstat groups data.
constexpr Elf_Word NT_FREEBSD_PROCSTAT_UMASK     = 12; // Procstat umask data.
constexpr Elf_Word NT_FREEBSD_PROCSTAT_RLIMIT    = 13; // Procstat rlimit data.
constexpr Elf_Word NT_FREEBSD_PROCSTAT_OSREL     = 14; // Procstat osreldate data.
constexpr Elf_Word NT_FREEBSD_PROCSTAT_PSSTRINGS = 15; // Procstat ps_strings data.
constexpr Elf_Word NT_FREEBSD_PROCSTAT_AUXV      = 16; // Procstat auxv data.
constexpr Elf_Word NT_FREEBSD_PTLWPINFO          = 17; // Thread ptrace miscellaneous info.

// Note name must start with  "NetBSD-CORE"
constexpr Elf_Word NT_NETBSDCORE_PROCINFO  = 1;  // Has a struct procinfo
constexpr Elf_Word NT_NETBSDCORE_AUXV      = 2;  // Has auxv data
constexpr Elf_Word NT_NETBSDCORE_LWPSTATUS = 24; // Has LWPSTATUS data
constexpr Elf_Word NT_NETBSDCORE_FIRSTMACH = 32; // start of machdep note types

// Note name is "OpenBSD"
constexpr Elf_Word NT_OPENBSD_PROCINFO = 10;
constexpr Elf_Word NT_OPENBSD_AUXV     = 11;
constexpr Elf_Word NT_OPENBSD_REGS     = 20;
constexpr Elf_Word NT_OPENBSD_FPREGS   = 21;
constexpr Elf_Word NT_OPENBSD_XFPREGS  = 22;
constexpr Elf_Word NT_OPENBSD_WCOOKIE  = 23;

// Note name must start with "SPU"
constexpr Elf_Word NT_SPU = 1;

// Values of note segment descriptor types for object files
constexpr Elf_Word NT_VERSION    = 1; // Contains a version string.
constexpr Elf_Word NT_ARCH       = 2; // Contains an architecture string.
constexpr Elf_Word NT_GO_BUILDID = 4; // Contains GO buildid data.

// Values for notes in non-core files using name "GNU"
constexpr Elf_Word NT_GNU_ABI_TAG         = 1;
constexpr Elf_Word NT_GNU_HWCAP           = 2; // Used by ld.so and kernel vDSO.
constexpr Elf_Word NT_GNU_BUILD_ID        = 3; // Generated by ld --build-id.
constexpr Elf_Word NT_GNU_GOLD_VERSION    = 4; // Generated by gold.
constexpr Elf_Word NT_GNU_PROPERTY_TYPE_0 = 5; // Generated by gcc.
// clang-format on

constexpr Elf_Word NT_GNU_BUILD_ATTRIBUTE_OPEN = 0x100;
constexpr Elf_Word NT_GNU_BUILD_ATTRIBUTE_FUNC = 0x101;

// Symbol types
constexpr Elf_Word STT_NOTYPE            = 0;
constexpr Elf_Word STT_OBJECT            = 1;
constexpr Elf_Word STT_FUNC              = 2;
constexpr Elf_Word STT_SECTION           = 3;
constexpr Elf_Word STT_FILE              = 4;
constexpr Elf_Word STT_COMMON            = 5;
constexpr Elf_Word STT_TLS               = 6;
constexpr Elf_Word STT_LOOS              = 10;
constexpr Elf_Word STT_AMDGPU_HSA_KERNEL = 10;
constexpr Elf_Word STT_HIOS              = 12;
constexpr Elf_Word STT_LOPROC            = 13;
constexpr Elf_Word STT_HIPROC            = 15;

// Symbol visibility
constexpr unsigned char STV_DEFAULT   = 0;
constexpr unsigned char STV_INTERNAL  = 1;
constexpr unsigned char STV_HIDDEN    = 2;
constexpr unsigned char STV_PROTECTED = 3;

// Undefined name
constexpr Elf_Word STN_UNDEF = 0;

// Relocation types
//   X86
constexpr unsigned R_386_NONE               = 0;
constexpr unsigned R_X86_64_NONE            = 0;
constexpr unsigned R_AMDGPU_NONE            = 0;
constexpr unsigned R_386_32                 = 1;
constexpr unsigned R_X86_64_64              = 1;
constexpr unsigned R_AMDGPU_ABS32_LO        = 1;
constexpr unsigned R_386_PC32               = 2;
constexpr unsigned R_X86_64_PC32            = 2;
constexpr unsigned R_AMDGPU_ABS32_HI        = 2;
constexpr unsigned R_386_GOT32              = 3;
constexpr unsigned R_X86_64_GOT32           = 3;
constexpr unsigned R_AMDGPU_ABS64           = 3;
constexpr unsigned R_386_PLT32              = 4;
constexpr unsigned R_X86_64_PLT32           = 4;
constexpr unsigned R_AMDGPU_REL32           = 4;
constexpr unsigned R_386_COPY               = 5;
constexpr unsigned R_X86_64_COPY            = 5;
constexpr unsigned R_AMDGPU_REL64           = 5;
constexpr unsigned R_386_GLOB_DAT           = 6;
constexpr unsigned R_X86_64_GLOB_DAT        = 6;
constexpr unsigned R_AMDGPU_ABS32           = 6;
constexpr unsigned R_386_JMP_SLOT           = 7;
constexpr unsigned R_X86_64_JUMP_SLOT       = 7;
constexpr unsigned R_AMDGPU_GOTPCREL        = 7;
constexpr unsigned R_386_RELATIVE           = 8;
constexpr unsigned R_X86_64_RELATIVE        = 8;
constexpr unsigned R_AMDGPU_GOTPCREL32_LO   = 8;
constexpr unsigned R_386_GOTOFF             = 9;
constexpr unsigned R_X86_64_GOTPCREL        = 9;
constexpr unsigned R_AMDGPU_GOTPCREL32_HI   = 9;
constexpr unsigned R_386_GOTPC              = 10;
constexpr unsigned R_X86_64_32              = 10;
constexpr unsigned R_AMDGPU_REL32_LO        = 10;
constexpr unsigned R_386_32PLT              = 11;
constexpr unsigned R_X86_64_32S             = 11;
constexpr unsigned R_AMDGPU_REL32_HI        = 11;
constexpr unsigned R_X86_64_16              = 12;
constexpr unsigned R_X86_64_PC16            = 13;
constexpr unsigned R_AMDGPU_RELATIVE64      = 13;
constexpr unsigned R_386_TLS_TPOFF          = 14;
constexpr unsigned R_X86_64_8               = 14;
constexpr unsigned R_386_TLS_IE             = 15;
constexpr unsigned R_X86_64_PC8             = 15;
constexpr unsigned R_386_TLS_GOTIE          = 16;
constexpr unsigned R_X86_64_DTPMOD64        = 16;
constexpr unsigned R_386_TLS_LE             = 17;
constexpr unsigned R_X86_64_DTPOFF64        = 17;
constexpr unsigned R_386_TLS_GD             = 18;
constexpr unsigned R_X86_64_TPOFF64         = 18;
constexpr unsigned R_386_TLS_LDM            = 19;
constexpr unsigned R_X86_64_TLSGD           = 19;
constexpr unsigned R_386_16                 = 20;
constexpr unsigned R_X86_64_TLSLD           = 20;
constexpr unsigned R_386_PC16               = 21;
constexpr unsigned R_X86_64_DTPOFF32        = 21;
constexpr unsigned R_386_8                  = 22;
constexpr unsigned R_X86_64_GOTTPOFF        = 22;
constexpr unsigned R_386_PC8                = 23;
constexpr unsigned R_X86_64_TPOFF32         = 23;
constexpr unsigned R_386_TLS_GD_32          = 24;
constexpr unsigned R_X86_64_PC64            = 24;
constexpr unsigned R_386_TLS_GD_PUSH        = 25;
constexpr unsigned R_X86_64_GOTOFF64        = 25;
constexpr unsigned R_386_TLS_GD_CALL        = 26;
constexpr unsigned R_X86_64_GOTPC32         = 26;
constexpr unsigned R_386_TLS_GD_POP         = 27;
constexpr unsigned R_X86_64_GOT64           = 27;
constexpr unsigned R_386_TLS_LDM_32         = 28;
constexpr unsigned R_X86_64_GOTPCREL64      = 28;
constexpr unsigned R_386_TLS_LDM_PUSH       = 29;
constexpr unsigned R_X86_64_GOTPC64         = 29;
constexpr unsigned R_386_TLS_LDM_CALL       = 30;
constexpr unsigned R_X86_64_GOTPLT64        = 30;
constexpr unsigned R_386_TLS_LDM_POP        = 31;
constexpr unsigned R_X86_64_PLTOFF64        = 31;
constexpr unsigned R_386_TLS_LDO_32         = 32;
constexpr unsigned R_386_TLS_IE_32          = 33;
constexpr unsigned R_386_TLS_LE_32          = 34;
constexpr unsigned R_X86_64_GOTPC32_TLSDESC = 34;
constexpr unsigned R_386_TLS_DTPMOD32       = 35;
constexpr unsigned R_X86_64_TLSDESC_CALL    = 35;
constexpr unsigned R_386_TLS_DTPOFF32       = 36;
constexpr unsigned R_X86_64_TLSDESC         = 36;
constexpr unsigned R_386_TLS_TPOFF32        = 37;
constexpr unsigned R_X86_64_IRELATIVE       = 37;
constexpr unsigned R_386_SIZE32             = 38;
constexpr unsigned R_386_TLS_GOTDESC        = 39;
constexpr unsigned R_386_TLS_DESC_CALL      = 40;
constexpr unsigned R_386_TLS_DESC           = 41;
constexpr unsigned R_386_IRELATIVE          = 42;
constexpr unsigned R_386_GOT32X             = 43;
constexpr unsigned R_X86_64_GNU_VTINHERIT   = 250;
constexpr unsigned R_X86_64_GNU_VTENTRY     = 251;
//   AArch64
constexpr unsigned R_AARCH64_NONE                         = 0;
constexpr unsigned R_AARCH64_P32_ABS32                    = 1;
constexpr unsigned R_AARCH64_P32_COPY                     = 180;
constexpr unsigned R_AARCH64_P32_GLOB_DAT                 = 181;
constexpr unsigned R_AARCH64_P32_JUMP_SLOT                = 182;
constexpr unsigned R_AARCH64_P32_RELATIVE                 = 183;
constexpr unsigned R_AARCH64_P32_TLS_DTPMOD               = 184;
constexpr unsigned R_AARCH64_P32_TLS_DTPREL               = 185;
constexpr unsigned R_AARCH64_P32_TLS_TPREL                = 186;
constexpr unsigned R_AARCH64_P32_TLSDESC                  = 187;
constexpr unsigned R_AARCH64_P32_IRELATIVE                = 188;
constexpr unsigned R_AARCH64_ABS64                        = 257;
constexpr unsigned R_AARCH64_ABS32                        = 258;
constexpr unsigned R_AARCH64_ABS16                        = 259;
constexpr unsigned R_AARCH64_PREL64                       = 260;
constexpr unsigned R_AARCH64_PREL32                       = 261;
constexpr unsigned R_AARCH64_PREL16                       = 262;
constexpr unsigned R_AARCH64_MOVW_UABS_G0                 = 263;
constexpr unsigned R_AARCH64_MOVW_UABS_G0_NC              = 264;
constexpr unsigned R_AARCH64_MOVW_UABS_G1                 = 265;
constexpr unsigned R_AARCH64_MOVW_UABS_G1_NC              = 266;
constexpr unsigned R_AARCH64_MOVW_UABS_G2                 = 267;
constexpr unsigned R_AARCH64_MOVW_UABS_G2_NC              = 268;
constexpr unsigned R_AARCH64_MOVW_UABS_G3                 = 269;
constexpr unsigned R_AARCH64_MOVW_SABS_G0                 = 270;
constexpr unsigned R_AARCH64_MOVW_SABS_G1                 = 271;
constexpr unsigned R_AARCH64_MOVW_SABS_G2                 = 272;
constexpr unsigned R_AARCH64_LD_PREL_LO19                 = 273;
constexpr unsigned R_AARCH64_ADR_PREL_LO21                = 274;
constexpr unsigned R_AARCH64_ADR_PREL_PG_HI21             = 275;
constexpr unsigned R_AARCH64_ADR_PREL_PG_HI21_NC          = 276;
constexpr unsigned R_AARCH64_ADD_ABS_LO12_NC              = 277;
constexpr unsigned R_AARCH64_LDST8_ABS_LO12_NC            = 278;
constexpr unsigned R_AARCH64_TSTBR14                      = 279;
constexpr unsigned R_AARCH64_CONDBR19                     = 280;
constexpr unsigned R_AARCH64_JUMP26                       = 282;
constexpr unsigned R_AARCH64_CALL26                       = 283;
constexpr unsigned R_AARCH64_LDST16_ABS_LO12_NC           = 284;
constexpr unsigned R_AARCH64_LDST32_ABS_LO12_NC           = 285;
constexpr unsigned R_AARCH64_LDST64_ABS_LO12_NC           = 286;
constexpr unsigned R_AARCH64_MOVW_PREL_G0                 = 287;
constexpr unsigned R_AARCH64_MOVW_PREL_G0_NC              = 288;
constexpr unsigned R_AARCH64_MOVW_PREL_G1                 = 289;
constexpr unsigned R_AARCH64_MOVW_PREL_G1_NC              = 290;
constexpr unsigned R_AARCH64_MOVW_PREL_G2                 = 291;
constexpr unsigned R_AARCH64_MOVW_PREL_G2_NC              = 292;
constexpr unsigned R_AARCH64_MOVW_PREL_G3                 = 293;
constexpr unsigned R_AARCH64_LDST128_ABS_LO12_NC          = 299;
constexpr unsigned R_AARCH64_MOVW_GOTOFF_G0               = 300;
constexpr unsigned R_AARCH64_MOVW_GOTOFF_G0_NC            = 301;
constexpr unsigned R_AARCH64_MOVW_GOTOFF_G1               = 302;
constexpr unsigned R_AARCH64_MOVW_GOTOFF_G1_NC            = 303;
constexpr unsigned R_AARCH64_MOVW_GOTOFF_G2               = 304;
constexpr unsigned R_AARCH64_MOVW_GOTOFF_G2_NC            = 305;
constexpr unsigned R_AARCH64_MOVW_GOTOFF_G3               = 306;
constexpr unsigned R_AARCH64_GOTREL64                     = 307;
constexpr unsigned R_AARCH64_GOTREL32                     = 308;
constexpr unsigned R_AARCH64_GOT_LD_PREL19                = 309;
constexpr unsigned R_AARCH64_LD64_GOTOFF_LO15             = 310;
constexpr unsigned R_AARCH64_ADR_GOT_PAGE                 = 311;
constexpr unsigned R_AARCH64_LD64_GOT_LO12_NC             = 312;
constexpr unsigned R_AARCH64_LD64_GOTPAGE_LO15            = 313;
constexpr unsigned R_AARCH64_TLSGD_ADR_PREL21             = 512;
constexpr unsigned R_AARCH64_TLSGD_ADR_PAGE21             = 513;
constexpr unsigned R_AARCH64_TLSGD_ADD_LO12_NC            = 514;
constexpr unsigned R_AARCH64_TLSGD_MOVW_G1                = 515;
constexpr unsigned R_AARCH64_TLSGD_MOVW_G0_NC             = 516;
constexpr unsigned R_AARCH64_TLSLD_ADR_PREL21             = 517;
constexpr unsigned R_AARCH64_TLSLD_ADR_PAGE21             = 518;
constexpr unsigned R_AARCH64_TLSLD_ADD_LO12_NC            = 519;
constexpr unsigned R_AARCH64_TLSLD_MOVW_G1                = 520;
constexpr unsigned R_AARCH64_TLSLD_MOVW_G0_NC             = 521;
constexpr unsigned R_AARCH64_TLSLD_LD_PREL19              = 522;
constexpr unsigned R_AARCH64_TLSLD_MOVW_DTPREL_G2         = 523;
constexpr unsigned R_AARCH64_TLSLD_MOVW_DTPREL_G1         = 524;
constexpr unsigned R_AARCH64_TLSLD_MOVW_DTPREL_G1_NC      = 525;
constexpr unsigned R_AARCH64_TLSLD_MOVW_DTPREL_G0         = 526;
constexpr unsigned R_AARCH64_TLSLD_MOVW_DTPREL_G0_NC      = 527;
constexpr unsigned R_AARCH64_TLSLD_ADD_DTPREL_HI12        = 528;
constexpr unsigned R_AARCH64_TLSLD_ADD_DTPREL_LO12        = 529;
constexpr unsigned R_AARCH64_TLSLD_ADD_DTPREL_LO12_NC     = 530;
constexpr unsigned R_AARCH64_TLSLD_LDST8_DTPREL_LO12      = 531;
constexpr unsigned R_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC   = 532;
constexpr unsigned R_AARCH64_TLSLD_LDST16_DTPREL_LO12     = 533;
constexpr unsigned R_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC  = 534;
constexpr unsigned R_AARCH64_TLSLD_LDST32_DTPREL_LO12     = 535;
constexpr unsigned R_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC  = 536;
constexpr unsigned R_AARCH64_TLSLD_LDST64_DTPREL_LO12     = 537;
constexpr unsigned R_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC  = 538;
constexpr unsigned R_AARCH64_TLSIE_MOVW_GOTTPREL_G1       = 539;
constexpr unsigned R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC    = 540;
constexpr unsigned R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21    = 541;
constexpr unsigned R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC  = 542;
constexpr unsigned R_AARCH64_TLSIE_LD_GOTTPREL_PREL19     = 543;
constexpr unsigned R_AARCH64_TLSLE_MOVW_TPREL_G2          = 544;
constexpr unsigned R_AARCH64_TLSLE_MOVW_TPREL_G1          = 545;
constexpr unsigned R_AARCH64_TLSLE_MOVW_TPREL_G1_NC       = 546;
constexpr unsigned R_AARCH64_TLSLE_MOVW_TPREL_G0          = 547;
constexpr unsigned R_AARCH64_TLSLE_MOVW_TPREL_G0_NC       = 548;
constexpr unsigned R_AARCH64_TLSLE_ADD_TPREL_HI12         = 549;
constexpr unsigned R_AARCH64_TLSLE_ADD_TPREL_LO12         = 550;
constexpr unsigned R_AARCH64_TLSLE_ADD_TPREL_LO12_NC      = 551;
constexpr unsigned R_AARCH64_TLSLE_LDST8_TPREL_LO12       = 552;
constexpr unsigned R_AARCH64_TLSLE_LDST8_TPREL_LO12_NC    = 553;
constexpr unsigned R_AARCH64_TLSLE_LDST16_TPREL_LO12      = 554;
constexpr unsigned R_AARCH64_TLSLE_LDST16_TPREL_LO12_NC   = 555;
constexpr unsigned R_AARCH64_TLSLE_LDST32_TPREL_LO12      = 556;
constexpr unsigned R_AARCH64_TLSLE_LDST32_TPREL_LO12_NC   = 557;
constexpr unsigned R_AARCH64_TLSLE_LDST64_TPREL_LO12      = 558;
constexpr unsigned R_AARCH64_TLSLE_LDST64_TPREL_LO12_NC   = 559;
constexpr unsigned R_AARCH64_TLSDESC_LD_PREL19            = 560;
constexpr unsigned R_AARCH64_TLSDESC_ADR_PREL21           = 561;
constexpr unsigned R_AARCH64_TLSDESC_ADR_PAGE21           = 562;
constexpr unsigned R_AARCH64_TLSDESC_LD64_LO12            = 563;
constexpr unsigned R_AARCH64_TLSDESC_ADD_LO12             = 564;
constexpr unsigned R_AARCH64_TLSDESC_OFF_G1               = 565;
constexpr unsigned R_AARCH64_TLSDESC_OFF_G0_NC            = 566;
constexpr unsigned R_AARCH64_TLSDESC_LDR                  = 567;
constexpr unsigned R_AARCH64_TLSDESC_ADD                  = 568;
constexpr unsigned R_AARCH64_TLSDESC_CALL                 = 569;
constexpr unsigned R_AARCH64_TLSLE_LDST128_TPREL_LO12     = 570;
constexpr unsigned R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC  = 571;
constexpr unsigned R_AARCH64_TLSLD_LDST128_DTPREL_LO12    = 572;
constexpr unsigned R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC = 573;
constexpr unsigned R_AARCH64_COPY                         = 1024;
constexpr unsigned R_AARCH64_GLOB_DAT                     = 1025;
constexpr unsigned R_AARCH64_JUMP_SLOT                    = 1026;
constexpr unsigned R_AARCH64_RELATIVE                     = 1027;
constexpr unsigned R_AARCH64_TLS_DTPMOD                   = 1028;
constexpr unsigned R_AARCH64_TLS_DTPMOD64                 = 1028;
constexpr unsigned R_AARCH64_TLS_DTPREL                   = 1029;
constexpr unsigned R_AARCH64_TLS_DTPREL64                 = 1029;
constexpr unsigned R_AARCH64_TLS_TPREL                    = 1030;
constexpr unsigned R_AARCH64_TLS_TPREL64                  = 1030;
constexpr unsigned R_AARCH64_TLSDESC                      = 1031;

// Segment types
constexpr Elf_Word PT_NULL         = 0;
constexpr Elf_Word PT_LOAD         = 1;
constexpr Elf_Word PT_DYNAMIC      = 2;
constexpr Elf_Word PT_INTERP       = 3;
constexpr Elf_Word PT_NOTE         = 4;
constexpr Elf_Word PT_SHLIB        = 5;
constexpr Elf_Word PT_PHDR         = 6;
constexpr Elf_Word PT_TLS          = 7;
constexpr Elf_Word PT_LOOS         = 0X60000000;
constexpr Elf_Word PT_GNU_EH_FRAME = 0X6474E550; // Frame unwind information
constexpr Elf_Word PT_GNU_STACK    = 0X6474E551; // Stack flags
constexpr Elf_Word PT_GNU_RELRO    = 0X6474E552; // Read only after relocs
constexpr Elf_Word PT_GNU_PROPERTY = 0X6474E553; // GNU property
constexpr Elf_Word PT_GNU_MBIND_LO = 0X6474E555; // Mbind segments start
constexpr Elf_Word PT_GNU_MBIND_HI = 0X6474F554; // Mbind segments finish
constexpr Elf_Word PT_PAX_FLAGS    = 0X65041580;
constexpr Elf_Word PT_OPENBSD_RANDOMIZE = 0X65A3DBE6;
constexpr Elf_Word PT_OPENBSD_WXNEEDED  = 0X65A3DBE7;
constexpr Elf_Word PT_OPENBSD_BOOTDATA  = 0X65A41BE6;
constexpr Elf_Word PT_SUNWBSS           = 0X6FFFFFFA;
constexpr Elf_Word PT_SUNWSTACK         = 0X6FFFFFFB;
constexpr Elf_Word PT_HIOS              = 0X6FFFFFFF;
constexpr Elf_Word PT_LOPROC            = 0X70000000;
constexpr Elf_Word PT_HIPROC            = 0X7FFFFFFF;

// Segment flags
constexpr Elf_Word PF_X        = 1;          // Execute
constexpr Elf_Word PF_W        = 2;          // Write
constexpr Elf_Word PF_R        = 4;          // Read
constexpr Elf_Word PF_MASKOS   = 0x0ff00000; // Unspecified
constexpr Elf_Word PF_MASKPROC = 0xf0000000; // Unspecified

// Dynamic Array Tags
constexpr Elf_Word DT_NULL            = 0;
constexpr Elf_Word DT_NEEDED          = 1;
constexpr Elf_Word DT_PLTRELSZ        = 2;
constexpr Elf_Word DT_PLTGOT          = 3;
constexpr Elf_Word DT_HASH            = 4;
constexpr Elf_Word DT_STRTAB          = 5;
constexpr Elf_Word DT_SYMTAB          = 6;
constexpr Elf_Word DT_RELA            = 7;
constexpr Elf_Word DT_RELASZ          = 8;
constexpr Elf_Word DT_RELAENT         = 9;
constexpr Elf_Word DT_STRSZ           = 10;
constexpr Elf_Word DT_SYMENT          = 11;
constexpr Elf_Word DT_INIT            = 12;
constexpr Elf_Word DT_FINI            = 13;
constexpr Elf_Word DT_SONAME          = 14;
constexpr Elf_Word DT_RPATH           = 15;
constexpr Elf_Word DT_SYMBOLIC        = 16;
constexpr Elf_Word DT_REL             = 17;
constexpr Elf_Word DT_RELSZ           = 18;
constexpr Elf_Word DT_RELENT          = 19;
constexpr Elf_Word DT_PLTREL          = 20;
constexpr Elf_Word DT_DEBUG           = 21;
constexpr Elf_Word DT_TEXTREL         = 22;
constexpr Elf_Word DT_JMPREL          = 23;
constexpr Elf_Word DT_BIND_NOW        = 24;
constexpr Elf_Word DT_INIT_ARRAY      = 25;
constexpr Elf_Word DT_FINI_ARRAY      = 26;
constexpr Elf_Word DT_INIT_ARRAYSZ    = 27;
constexpr Elf_Word DT_FINI_ARRAYSZ    = 28;
constexpr Elf_Word DT_RUNPATH         = 29;
constexpr Elf_Word DT_FLAGS           = 30;
constexpr Elf_Word DT_ENCODING        = 32;
constexpr Elf_Word DT_PREINIT_ARRAY   = 32;
constexpr Elf_Word DT_PREINIT_ARRAYSZ = 33;
constexpr Elf_Word DT_MAXPOSTAGS      = 34;
constexpr Elf_Word DT_LOOS            = 0x6000000D;
constexpr Elf_Word DT_HIOS            = 0x6ffff000;
constexpr Elf_Word DT_GNU_HASH        = 0x6ffffef5;
constexpr Elf_Word DT_TLSDESC_PLT     = 0x6ffffef6;
constexpr Elf_Word DT_TLSDESC_GOT     = 0x6ffffef7;
constexpr Elf_Word DT_GNU_CONFLICT    = 0x6ffffef8;
constexpr Elf_Word DT_GNU_LIBLIST     = 0x6ffffef9;
constexpr Elf_Word DT_CONFIG          = 0x6ffffefa;
constexpr Elf_Word DT_DEPAUDIT        = 0x6ffffefb;
constexpr Elf_Word DT_AUDIT           = 0x6ffffefc;
constexpr Elf_Word DT_PLTPAD          = 0x6ffffefd;
constexpr Elf_Word DT_MOVETAB         = 0x6ffffefe;
constexpr Elf_Word DT_SYMINFO         = 0x6ffffeff;
constexpr Elf_Word DT_ADDRRNGHI       = 0x6ffffeff;
constexpr Elf_Word DT_VERSYM          = 0x6ffffff0;
constexpr Elf_Word DT_RELACOUNT       = 0x6ffffff9;
constexpr Elf_Word DT_RELCOUNT        = 0x6ffffffa;
constexpr Elf_Word DT_FLAGS_1         = 0x6ffffffb;
constexpr Elf_Word DT_VERDEF          = 0x6ffffffc;
constexpr Elf_Word DT_VERDEFNUM       = 0x6ffffffd;
constexpr Elf_Word DT_VERNEED         = 0x6ffffffe;
constexpr Elf_Word DT_VERNEEDNUM      = 0x6fffffff;
constexpr Elf_Word DT_LOPROC          = 0x70000000;
constexpr Elf_Word DT_HIPROC          = 0x7FFFFFFF;

// DT_FLAGS values
constexpr Elf_Word DF_ORIGIN     = 0x1;
constexpr Elf_Word DF_SYMBOLIC   = 0x2;
constexpr Elf_Word DF_TEXTREL    = 0x4;
constexpr Elf_Word DF_BIND_NOW   = 0x8;
constexpr Elf_Word DF_STATIC_TLS = 0x10;

// Legal values for d_tag (dynamic entry type).
constexpr Elf_Word AT_NULL          = 0;  // End of vector
constexpr Elf_Word AT_IGNORE        = 1;  // Entry should be ignored
constexpr Elf_Word AT_EXECFD        = 2;  // File descriptor of program
constexpr Elf_Word AT_PHDR          = 3;  // Program headers for program
constexpr Elf_Word AT_PHENT         = 4;  // Size of program header entry
constexpr Elf_Word AT_PHNUM         = 5;  // Number of program headers
constexpr Elf_Word AT_PAGESZ        = 6;  // System page size
constexpr Elf_Word AT_BASE          = 7;  // Base address of interpreter
constexpr Elf_Word AT_FLAGS         = 8;  // Flags
constexpr Elf_Word AT_ENTRY         = 9;  // Entry point of program
constexpr Elf_Word AT_NOTELF        = 10; // Program is not ELF
constexpr Elf_Word AT_UID           = 11; // Real uid
constexpr Elf_Word AT_EUID          = 12; // Effective uid
constexpr Elf_Word AT_GID           = 13; // Real gid
constexpr Elf_Word AT_EGID          = 14; // Effective gid
constexpr Elf_Word AT_CLKTCK        = 17; // Frequency of times()
constexpr Elf_Word AT_PLATFORM      = 15; // String identifying platform.
constexpr Elf_Word AT_HWCAP         = 16; // Hints about processor capabilities.
constexpr Elf_Word AT_FPUCW         = 18; // Used FPU control word.
constexpr Elf_Word AT_DCACHEBSIZE   = 19; // Data cache block size.
constexpr Elf_Word AT_ICACHEBSIZE   = 20; // Instruction cache block size.
constexpr Elf_Word AT_UCACHEBSIZE   = 21; // Unified cache block size.
constexpr Elf_Word AT_IGNOREPPC     = 22; // Entry should be ignored.
constexpr Elf_Word AT_SECURE        = 23; // Boolean, was exec setuid-like?
constexpr Elf_Word AT_BASE_PLATFORM = 24; // String identifying real platforms.
constexpr Elf_Word AT_RANDOM        = 25; // Address of 16 random bytes.
constexpr Elf_Word AT_HWCAP2  = 26; // More hints about processor capabilities.
constexpr Elf_Word AT_EXECFN  = 31; // Filename of executable.
constexpr Elf_Word AT_SYSINFO = 32; // EP to the system call in the vDSO.
constexpr Elf_Word AT_SYSINFO_EHDR = 33; // Start of the ELF header of the vDSO.
constexpr Elf_Word AT_L1I_CACHESHAPE    = 34;
constexpr Elf_Word AT_L1D_CACHESHAPE    = 35;
constexpr Elf_Word AT_L2_CACHESHAPE     = 36;
constexpr Elf_Word AT_L3_CACHESHAPE     = 37;
constexpr Elf_Word AT_L1I_CACHESIZE     = 40;
constexpr Elf_Word AT_L1I_CACHEGEOMETRY = 41;
constexpr Elf_Word AT_L1D_CACHESIZE     = 42;
constexpr Elf_Word AT_L1D_CACHEGEOMETRY = 43;
constexpr Elf_Word AT_L2_CACHESIZE      = 44;
constexpr Elf_Word AT_L2_CACHEGEOMETRY  = 45;
constexpr Elf_Word AT_L3_CACHESIZE      = 46;

// ELF file header
struct Elf32_Ehdr
{
    unsigned char e_ident[EI_NIDENT];
    Elf_Half      e_type;
    Elf_Half      e_machine;
    Elf_Word      e_version;
    Elf32_Addr    e_entry;
    Elf32_Off     e_phoff;
    Elf32_Off     e_shoff;
    Elf_Word      e_flags;
    Elf_Half      e_ehsize;
    Elf_Half      e_phentsize;
    Elf_Half      e_phnum;
    Elf_Half      e_shentsize;
    Elf_Half      e_shnum;
    Elf_Half      e_shstrndx;
};

struct Elf64_Ehdr
{
    unsigned char e_ident[EI_NIDENT];
    Elf_Half      e_type;
    Elf_Half      e_machine;
    Elf_Word      e_version;
    Elf64_Addr    e_entry;
    Elf64_Off     e_phoff;
    Elf64_Off     e_shoff;
    Elf_Word      e_flags;
    Elf_Half      e_ehsize;
    Elf_Half      e_phentsize;
    Elf_Half      e_phnum;
    Elf_Half      e_shentsize;
    Elf_Half      e_shnum;
    Elf_Half      e_shstrndx;
};

// Section header
struct Elf32_Shdr
{
    Elf_Word   sh_name;
    Elf_Word   sh_type;
    Elf_Word   sh_flags;
    Elf32_Addr sh_addr;
    Elf32_Off  sh_offset;
    Elf_Word   sh_size;
    Elf_Word   sh_link;
    Elf_Word   sh_info;
    Elf_Word   sh_addralign;
    Elf_Word   sh_entsize;
};

struct Elf64_Shdr
{
    Elf_Word   sh_name;
    Elf_Word   sh_type;
    Elf_Xword  sh_flags;
    Elf64_Addr sh_addr;
    Elf64_Off  sh_offset;
    Elf_Xword  sh_size;
    Elf_Word   sh_link;
    Elf_Word   sh_info;
    Elf_Xword  sh_addralign;
    Elf_Xword  sh_entsize;
};

// Segment header
struct Elf32_Phdr
{
    Elf_Word   p_type;
    Elf32_Off  p_offset;
    Elf32_Addr p_vaddr;
    Elf32_Addr p_paddr;
    Elf_Word   p_filesz;
    Elf_Word   p_memsz;
    Elf_Word   p_flags;
    Elf_Word   p_align;
};

struct Elf64_Phdr
{
    Elf_Word   p_type;
    Elf_Word   p_flags;
    Elf64_Off  p_offset;
    Elf64_Addr p_vaddr;
    Elf64_Addr p_paddr;
    Elf_Xword  p_filesz;
    Elf_Xword  p_memsz;
    Elf_Xword  p_align;
};

// Symbol table entry
struct Elf32_Sym
{
    Elf_Word      st_name;
    Elf32_Addr    st_value;
    Elf_Word      st_size;
    unsigned char st_info;
    unsigned char st_other;
    Elf_Half      st_shndx;
};

struct Elf64_Sym
{
    Elf_Word      st_name;
    unsigned char st_info;
    unsigned char st_other;
    Elf_Half      st_shndx;
    Elf64_Addr    st_value;
    Elf_Xword     st_size;
};

#define ELF_ST_BIND( i )    ( ( i ) >> 4 )
#define ELF_ST_TYPE( i )    ( ( i ) & 0xf )
#define ELF_ST_INFO( b, t ) ( ( ( b ) << 4 ) + ( ( t ) & 0xf ) )

#define ELF_ST_VISIBILITY( o ) ( ( o ) & 0x3 )

// Relocation entries
struct Elf32_Rel
{
    Elf32_Addr r_offset;
    Elf_Word   r_info;
};

struct Elf32_Rela
{
    Elf32_Addr r_offset;
    Elf_Word   r_info;
    Elf_Sword  r_addend;
};

struct Elf64_Rel
{
    Elf64_Addr r_offset;
    Elf_Xword  r_info;
};

struct Elf64_Rela
{
    Elf64_Addr r_offset;
    Elf_Xword  r_info;
    Elf_Sxword r_addend;
};

#define ELF32_R_SYM( i )     ( ( i ) >> 8 )
#define ELF32_R_TYPE( i )    ( (unsigned char)( i ) )
#define ELF32_R_INFO( s, t ) ( ( ( s ) << 8 ) + (unsigned char)( t ) )

#define ELF64_R_SYM( i )  ( ( i ) >> 32 )
#define ELF64_R_TYPE( i ) ( ( i ) & 0xffffffffL )
#define ELF64_R_INFO( s, t ) \
    ( ( ( (int64_t)( s ) ) << 32 ) + ( ( t ) & 0xffffffffL ) )

// Dynamic structure
struct Elf32_Dyn
{
    Elf_Sword d_tag;
    union {
        Elf_Word   d_val;
        Elf32_Addr d_ptr;
    } d_un;
};

struct Elf64_Dyn
{
    Elf_Sxword d_tag;
    union {
        Elf_Xword  d_val;
        Elf64_Addr d_ptr;
    } d_un;
};

struct Elfxx_Verneed
{
    Elf_Half vn_version;
    Elf_Half vn_cnt;
    Elf_Word vn_file;
    Elf_Word vn_aux;
    Elf_Word vn_next;
};

struct Elfxx_Vernaux
{
    Elf_Word vna_hash;
    Elf_Half vna_flags;
    Elf_Half vna_other;
    Elf_Word vna_name;
    Elf_Word vna_next;
};

// ELF auxiliary vectors, they are usually run-time information
// being passed to program when the kernel is loading it.
// This is now required,
// because in order to initialize the stack cookie
// to protect against buffer overflows,
// most of libc ask us to have a valid pointer for the AT_RANDOM entry.
// glibc for example crashes if you don't.
// https://sourceware.org/git/?p=glibc.git;a=blob;f=csu/libc-start.c;h=543560f36c33b07a1fbe1b7e4578374fe8007b1f;hb=HEAD#l308
// This is also useful to be able to reconstruct at run-time
// the ELF headers, if ELF headers were erased after loading.
// Although this library is targeted to be parsing files only,
// I assume auxiliary vectors could be also used to get
// more information about the ELF binary at run-time in future.
// The main purpose is also for ELF injectors.
struct Elf32_auxv
{
    uint32_t a_type; // Entry type

    union {
        uint32_t a_val; // Integer value, usually a pointer
    } a_un;
};

struct Elf64_auxv
{
    uint64_t a_type; // Entry type

    union {
        uint64_t a_val; // Integer value, usually a pointer
    } a_un;
};

struct Elf32_Chdr
{
    Elf32_Word ch_type; // The compression algorithm used
    Elf32_Word ch_size; //The size, in	bytes, of the uncompressed section data
    Elf32_Word
        ch_addralign; // The address alignment of the	uncompressed section data
};

struct Elf64_Chdr
{
    Elf64_Word ch_type;     //The compression algorithm used
    Elf64_Word ch_reserved; // Reserved
    Elf_Xword  ch_size; //The size, in	bytes, of the uncompressed section data
    Elf_Xword
        ch_addralign; //The address alignment of the	uncompressed section data
};

#ifdef __cplusplus
} // namespace ELFIO
#endif

#endif // ELFTYPES_H
#include "../runtime/common.h"
#include "../runtime/crypto.h"
#include "../runtime/loader.h"
#include "objects.h"
#include "osutils.h"
#include "streams.h"
#include "files.h"
#include "processors.h"
#include "lang.h"
#include "core.h"
#include "dwarf.h"
#include "pefile.h"
#include "macfile.h"
#include "elffile.h"
#include "packer.h"
#include "intel.h"
#include "objc.h"
#include <intrin.h>

/**
 * IntelCommand
 */

IntelCommand::IntelCommand(IFunction *owner, OperandSize size, uint64_t address)
	: BaseCommand(owner), address_(address), size_(size), type_(cmUnknown), flags_(0), preffix_command_(cmUnknown), 
	base_segment_(segDefault), command_pos_(0), original_dump_size_(0), section_options_(0), vex_operand_(0), 
	ext_vm_entry_(NULL), begin_section_cryptor_(NULL), end_section_cryptor_(NULL), seh_handler_(NULL)
{
	vm_command_info_list_ = new IntelCommandInfoList(size);
	if (address_)
		include_option(roClearOriginalCode);
#ifdef CHECKED
	update_hash();
#endif
}

IntelCommand::IntelCommand(IFunction *owner, OperandSize size, IntelCommandType type, IntelOperand operand1, IntelOperand operand2, IntelOperand operand3)
	: BaseCommand(owner), address_(0), size_(size), type_(cmUnknown), flags_(0), preffix_command_(cmUnknown), base_segment_(segDefault), 
	command_pos_(0), original_dump_size_(0), section_options_(0), vex_operand_(0), ext_vm_entry_(NULL), begin_section_cryptor_(NULL),
	end_section_cryptor_(NULL), seh_handler_(NULL)
{
	vm_command_info_list_ = new IntelCommandInfoList(size);
	type_ = type;
	operand_[0] = operand1;
	operand_[1] = operand2;
	operand_[2] = operand3;
	for (size_t i = 0; i < _countof(operand_); i++) {
		IntelOperand *operand = &operand_[i];
		if (operand->size == osDefault)
			operand->size = size_;
		if (operand->address_size == osDefault)
			operand->address_size = size_;
	}
#ifdef CHECKED
	update_hash();
#endif
}

IntelCommand::IntelCommand(IFunction *owner, OperandSize size, const std::string &value)
	: BaseCommand(owner, value), address_(0), size_(size), type_(cmUnknown), flags_(0), 
	preffix_command_(cmUnknown), base_segment_(segDefault), command_pos_(0), original_dump_size_(0), section_options_(0),
	vex_operand_(0), ext_vm_entry_(NULL), begin_section_cryptor_(NULL), end_section_cryptor_(NULL), seh_handler_(NULL)
{
	vm_command_info_list_ = new IntelCommandInfoList(size);
	type_ = cmDB;
#ifdef CHECKED
	update_hash();
#endif
}

IntelCommand::IntelCommand(IFunction *owner, OperandSize size, const os::unicode_string &value)
	: BaseCommand(owner, value), address_(0), size_(size), type_(cmUnknown), flags_(0),
	preffix_command_(cmUnknown), base_segment_(segDefault), command_pos_(0), original_dump_size_(0), section_options_(0),
	ext_vm_entry_(NULL), begin_section_cryptor_(NULL), end_section_cryptor_(NULL), seh_handler_(NULL)
{
	vm_command_info_list_ = new IntelCommandInfoList(size);
	type_ = cmDB;
#ifdef CHECKED
	update_hash();
#endif
}

IntelCommand::IntelCommand(IFunction *owner, OperandSize size, const Data &value)
	: BaseCommand(owner, value), address_(0), size_(size), type_(cmUnknown), flags_(0),
	preffix_command_(cmUnknown), base_segment_(segDefault), command_pos_(0), original_dump_size_(0), section_options_(0),
	ext_vm_entry_(NULL), begin_section_cryptor_(NULL), end_section_cryptor_(NULL), seh_handler_(NULL)
{
	vm_command_info_list_ = new IntelCommandInfoList(size);
	type_ = cmDB;
#ifdef CHECKED
	update_hash();
#endif
}

void IntelCommand::Init(IntelCommandType type, IntelOperand operand1, IntelOperand operand2, IntelOperand operand3)
{
	type_ = type;
	operand_[0] = operand1;
	operand_[1] = operand2;
	operand_[2] = operand3;
	for (size_t i = 0; i < _countof(operand_); i++) {
		IntelOperand *operand = &operand_[i];
		if (operand->size == osDefault)
			operand->size = size_;
		if (operand->address_size == osDefault)
			operand->address_size = size_;
	}
}

void IntelCommand::Init(const Data &data)
{
	type_ = cmDB;
	set_dump(data.data(), data.size());
}

void IntelCommand::InitUnknown()
{
	clear();
	type_ = cmUnknown;
	PushByte(0);
}

IntelCommand::IntelCommand(IFunction *owner, const IntelCommand &src)
	: BaseCommand(owner, src), section_options_(0), ext_vm_entry_(NULL), begin_section_cryptor_(NULL), end_section_cryptor_(NULL)
{ 
	vm_command_info_list_ = new IntelCommandInfoList(src.size());
	address_ = src.address_;
	size_ = src.size_;
	type_ = src.type_;
	flags_ = src.flags_;
	preffix_command_ = src.preffix_command_;
	base_segment_ = src.base_segment_;
	command_pos_ = src.command_pos_;
	original_dump_size_ = src.original_dump_size_;
	vex_operand_ = src.vex_operand_;
	seh_handler_ = src.seh_handler_;

	for (size_t i = 0; i < _countof(operand_); i++) {
		operand_[i] = src.operand_[i];
	}
#ifdef CHECKED
	update_hash();
#endif
}

IntelCommand::~IntelCommand()
{
	delete vm_command_info_list_;
}

void IntelCommand::clear()
{
	type_ = cmUnknown;
	base_segment_ = segDefault;
	preffix_command_ = cmUnknown;
	flags_ = 0;
	command_pos_ = 0;
	for (size_t i = 0; i < _countof(operand_); i++) {
		operand_[i].Clear();
	}
	vm_command_info_list_->clear();
	BaseCommand::clear();
}

IntelCommand *IntelCommand::Clone(IFunction *owner) const
{
	IntelCommand *command = new IntelCommand(owner, *this);
	return command;
}

bool IntelCommand::is_data() const
{
	return (type_ == cmDB || type_ == cmDW || type_ == cmDD || type_ == cmDQ || type_ == cmSleb || type_ == cmUleb || type_ == cmDC);
}

bool IntelCommand::is_end() const
{
	return (type_ == cmRet || type_ == cmIret || type_ == cmJmp || ((type_ == cmCall || type_ == cmJmpWithFlag) && (options() & roUseAsJmp)) || is_data());
}

static const char *size_name[] = {
	"byte",
	"word",
	"dword",
	"qword",
	"tbyte",
	"oword",
	"xmmword",
	"ymmword",
	"fword"
};

static const char *segment_name[] = {
	"es",
	"cs",
	"ss",
	"ds",
	"fs",
	"gs"
};

static const char *registr_name[4][22] = {
	{"al","cl","dl","bl","spl","bpl","sil","dil","r8b","r9b","r10b","r11b","r12b","r13b","r14b","r15b","fl","tl","rl","il","kl","el"},
	{"ax","cx","dx","bx","sp","bp","si","di","r8w","r9w","r10w","r11w","r12w","r13w","r14w","r15w","fx","tx","rx","ix","kx","ex"},
	{"eax","ecx","edx","ebx","esp","ebp","esi","edi","r8d","r9d","r10d","r11d","r12d","r13d","r14d","r15d","efx","etx","erx","eix","ekx","eex"},
	{"rax","rcx","rdx","rbx","rsp","rbp","rsi","rdi","r8","r9","r10","r11","r12","r13","r14","r15","rfx","rtx","rrx","rix","rkx","rex"}
};

bool IntelCommand::GetOperandText(std::string &str, size_t index) const
{
	const IntelOperand *operand = &operand_[index];

	if (operand->type == otNone)
		return false;

	str.clear();
	if (operand->type & otMemory) {
		if (operand->show_size)
			str.append(size_name[operand->size]).append(" ptr ");

		if (base_segment_ != segDefault && type_ != cmLea)
			str.append(segment_name[base_segment_]).append(":");

		str.append("[");
		if (operand->type & otBaseRegistr)
			str.append(registr_name[operand->address_size][operand->base_registr]);
	}

	if (operand->type & otRegistr) {
		if (operand->type & otMemory) {
			if (operand->type & otBaseRegistr)
				str.append("+");
			str.append(registr_name[operand->address_size][operand->registr]);
			if (operand->scale_registr)
				str.append(string_format("*%d", 2 << (operand->scale_registr - 1)));
		} else {
			str.append(operand->size > osQWord ? "???" : registr_name[operand->size][operand->registr]);
		}
	} else if (operand->type & otHiPartRegistr) {
		str.append(std::string(registr_name[osWord][operand->registr & 3], 1));
		str.append("h");
	} else if (operand->type & otFPURegistr) {
		str.append(string_format("st%d", operand->registr));
	} else if (operand->type & otSegmentRegistr) {
		str.append(operand->registr > segGS ? "???" : segment_name[operand->registr]);
	} else if (operand->type & otControlRegistr) {
		str.append(string_format("cr%d", operand->registr));
	} else if (operand->type & otDebugRegistr) {
		str.append(string_format("dr%d", operand->registr));
	} else if (operand->type & otMMXRegistr) {
		str.append(string_format("mm%d", operand->registr));
	} else if (operand->type & otXMMRegistr) {
		str.append(string_format((operand->size == osYMMWord) ? "ymm%d" : "xmm%d", operand->registr));
	}

	if (operand->type & otValue) {
		int64_t value = operand->value;
		bool is_neg = (value < 0 && (operand->size > operand->value_size || (operand->type & (otMemory | otRegistr | otBaseRegistr)) > otMemory));
		if (is_neg) {
			str.append("-");
			value = -value;
		} else if (operand->type & (otRegistr | otBaseRegistr)) {
			str.append("+");
		}

		if (operand->type == otValue && operand->size == osFWord) {
			switch (operand->value_size) {
			case osWord:
				str.append(string_format("%.4X:%.4X", static_cast<uint16_t>(operand->value >> 16), static_cast<uint16_t>(operand->value)));
				break;
			case osDWord:
				str.append(string_format("%.4X:%.8X", static_cast<uint16_t>(operand->value >> 32), static_cast<uint32_t>(operand->value)));
				break;
			}
		} else {
			switch (operand->value_size) {
			case osByte:
				str.append(string_format("%.2X", static_cast<uint8_t>(value)));
				break;
			case osWord:
				str.append(string_format("%.4X", static_cast<uint16_t>(value)));
				break;
			case osDWord:
				str.append(string_format("%.8X", static_cast<uint32_t>(value)));
				break;
			case osQWord:
				str.append(string_format("%.16llX", value));
				break;
			}
		}
	}

	if (operand->type & otMemory)
		str.append("]");

	return true;
}

std::string IntelCommand::text() const
{
	std::string res, operand_text;
	size_t i;

	if (type_ == cmDB) {
		res.append(intel_command_name[type_]);
		for (i = 0; i < dump_size(); i++) {
			if (i > 0)
				res.append(",");
			res.append(string_format(" %.2X", dump(i)));
		}
	} else {
		if (options() & roLockPrefix)
			res.append("lock ");

		if (preffix_command_ != cmUnknown)
			res.append(intel_command_name[preffix_command_]).append(" ");

		if (options() & roVexPrefix)
			res.append("v");

		if (type_ == cmJCXZ && operand_[1].size > osWord) {
			res.append(operand_[1].size == osDWord ? "jecxz" : "jrcxz");
		} else {
			res.append(intel_command_name[type_]);
		}

		if (flags_) {
			if (options() & roInverseFlag)
				res.append("n");
			switch (flags_) {
			case fl_O:
				res.append("o");
				break;
			case fl_C:
				res.append("b");
				break;
			case fl_Z:
				res.append("z");
				break;
			case fl_C | fl_Z:
				res.append("be");
				break;
			case fl_P:
				res.append("p");
				break;
			case fl_S | fl_O:
				res.append("l");
				break;
			case fl_S:
				res.append("s");
				break;
			case fl_Z | fl_S | fl_O:
				res.append("le");
				break;
			default:
				res.append("?");
				break;
			}
		}

		switch (type_) {
		case cmLods:
		case cmScas:
		case cmCmps:
		case cmMovs:
		case cmStos:
		case cmIns:
		case cmOuts:
			res.append(std::string(size_name[operand_[0].size], 1));
			break;
		case cmPusha:
		case cmPopa:
		case cmPushf:
		case cmPopf:
		case cmIret:
			if (operand_[0].size > osWord)
				res.append(std::string(size_name[operand_[0].size], 1));
			break;
		case cmXlat:
			res.append(std::string(size_name[osByte], 1));
			break;
		case cmRet:
			if ((options() & roFar) != 0)
				res.append("f");
			break;
		}

		for (i = 0; i < _countof(operand_); i++) {
			if (vex_operand_ && (vex_operand_ & 0x3) == i) {
				res.append(", ");
				res.append(string_format((vex_operand_ & 4) ? "ymm%d" : "xmm%d", (vex_operand_ >> 4) & 0x0f));
			}

			if (!GetOperandText(operand_text, i))
				break;

			if (i > 0)
				res.append(",");
			res.append(" ").append(operand_text);
		}
	}

	return res;
}

CommentInfo IntelCommand::comment()
{
	CommentInfo res = BaseCommand::comment();
	if (res.type != ttUnknown)
		return res;

	res.type = ttNone;
	if ((options() & roFar) == 0) {
		IArchitecture *file = owner()->owner()->owner();
		if (file) {
			size_t operand_index = NOT_ID;
			for (size_t i = 2; i > 0; i--) {
				if (operand_[i - 1].type == otValue || operand_[i - 1].type == (otMemory | otValue)) {
					operand_index = i - 1;
					break;
				}
			}
			if (operand_index != NOT_ID) {
				uint64_t address = operand_[operand_index].value;
				if (IRelocation *relocation = operand_[operand_index].relocation) {
					if (IImportFunction *import_function = file->import_list()->GetFunctionByAddress(relocation->address())) {
						res.value = string_format("%c %s", 3, import_function->full_name().c_str());
						res.type = ttImport;
					} else if (ISymbol *symbol = relocation->symbol()) {
						address = symbol->address();
						res.value = string_format("%c %s", 3, symbol->display_name().c_str());
						if (file->export_list()->GetExportByAddress(address))
							res.type = ttExport;
						else if (file->segment_list()->GetMemoryTypeByAddress(address) & mtExecutable)
							res.type = ttFunction;
						else
							res.type = ttVariable;
					}
				} else if (IImportFunction *import_function = file->import_list()->GetFunctionByAddress(address)) {
					res.value = string_format("%c %s", 3, import_function->full_name().c_str());
					res.type = ttImport;
				} else if (IRelocation *relocation = file->relocation_list() ? file->relocation_list()->GetRelocationByAddress(address) : NULL) {
					if (ISymbol *symbol = relocation->symbol()) {
						address = symbol->address();
						res.value = string_format("%c %s", 3, symbol->display_name().c_str());
						if (file->export_list()->GetExportByAddress(address))
							res.type = ttExport;
						else if (file->segment_list()->GetMemoryTypeByAddress(address) & mtExecutable)
							res.type = ttFunction;
						else
							res.type = ttVariable;
					}
				} else if (MapFunction *map_function = file->map_function_list()->GetFunctionByAddress(address)) {
					if (map_function->type() == otData) {
						if (map_function->name().compare("`string'") == 0) {
							std::string str = file->ReadString(address);
							if (!str.empty()) {
								res.value = string_format("%c string \"%s\"", 3, DisplayString(str).c_str());
								res.type = ttString;
							}
						}
						else {
							res.value = string_format("%c %s", 3, map_function->name().c_str());
							res.type = ttVariable;
						}
					}
					else {
						res.value = string_format("%c %s", 3, map_function->name().c_str());
						switch (map_function->type()) {
						case otString:
							res.type = ttString;
							break;
						case otExport:
							res.type = ttExport;
							break;
						default:
							res.type = ttFunction;
							break;
						}
					}
				} else if (type_ == cmLea || operand_[operand_index].type == otValue) {
					if (type_ == cmCall || type_ == cmJmp || type_ == cmJmpWithFlag || type_ == cmLoope || type_ == cmLoopne || type_ == cmLoop || type_ == cmJCXZ) {
						res.value = (next_address() > address) ? char(2) : char(4);
						res.type = ttJmp;
					}
					else {
						std::string str = file->ReadString(address);
						if (!str.empty()) {
							res.value = string_format("%c string \"%s\"", 3, DisplayString(str).c_str());
							res.type = ttString;
						}
					}
				}
			}
		}
	}

	set_comment(res);

	return res;
}

std::string IntelCommand::dump_str() const
{
	std::string res;
	if (type_ == cmUnknown) {
		for (size_t i = 0; i < dump_size(); i++) {
			res += "??";
		}
		return res;
	}

	res = BaseCommand::dump_str();

	size_t i, c;
	c = 0;
	for (i = 0; i < command_pos_; i++) {
		res.insert((i + 1) * 2 + c, ":");
		c++;
	}
	for (i = 0; i < _countof(operand_); i++) {
		const IntelOperand *operand = &operand_[i];
		if (operand->type == otNone)
			break;

		if ((operand->type & otValue) && operand->value_pos) {
			res.insert(operand->value_pos * 2 + c, " ");
			c++;
		}
	}

	return res;
}

std::string IntelCommand::display_address() const
{
	return DisplayValue(size(), address());
}

bool IntelCommand::is_equal(const IntelCommand &command) const
{
	if (type_ != command.type_)
		return false;
	for (size_t i = 0; i < _countof(operand_); i++) {
		if (operand_[i] != command.operand_[i])
			return false;
	}
	return true;
}

IntelOperand *IntelCommand::GetFreeOperand()
{
	for (size_t i = 0; i < _countof(operand_); i++) {
		IntelOperand *operand = &operand_[i];
		if (operand->type == otNone) {
			operand->Clear();
			return operand;
		}
	}

	return NULL;
}

static OperandSize GetOperandSize(uint8_t code, const DisasmContext &ctx)
{
	if ((code & 1) == 0)
		return osByte;
	if (ctx.rex_prefix & rexW)
		return osQWord;
	if (ctx.lower_reg)
		return osWord;
	return osDWord;
}

static OperandSize GetDefaultOperandSize(const DisasmContext &ctx)
{
	if ((ctx.rex_prefix & rexW) == 0 && ctx.lower_reg)
		return osWord;
	return ctx.file->cpu_address_size();
}

static OperandSize GetAddressSize(const DisasmContext &ctx)
{
	OperandSize cpu_address_size = ctx.file->cpu_address_size();

	if (ctx.lower_address)
		return (cpu_address_size == osQWord) ? osDWord : osWord;
	return cpu_address_size;
}

void IntelCommand::ReadFlags(uint8_t code)
{
	switch ((code >> 1) & 7) {
	case 0x00:
		flags_ = fl_O;
		break;
	case 0x01:
		flags_ = fl_C;
		break;
	case 0x02:
		flags_ = fl_Z;
		break;
	case 0x03:
		flags_ = fl_C | fl_Z;
		break;
	case 0x04:
		flags_ = fl_S;
		break;
	case 0x05:
		flags_ = fl_P;
		break;
	case 0x06:
		flags_ = fl_S | fl_O;
		break;
	case 0x07:
		flags_ = fl_Z | fl_S | fl_O;
		break;
	}

	if (code & 1)
		include_option(roInverseFlag);
}

void IntelCommand::ReadReg(uint8_t code, OperandSize operand_size, OperandType operand_type, const DisasmContext &ctx)
{
	IntelOperand *operand = GetFreeOperand();
	if (operand == NULL)
		throw std::runtime_error("ReadReg no free operands");

	operand->type = operand_type;
	operand->size = operand_size;
	operand->registr = (code & 7);

	if (ctx.rex_prefix && operand_type == otRegistr) {
		if (ctx.rex_prefix & rexB)
			operand->registr |= 8;
	} else if (operand_type == otRegistr && operand_size == osByte && operand->registr >= 4) {
		operand->type = otHiPartRegistr;
		operand->registr &= 3;
	}
}

void IntelCommand::ReadRegFromRM(uint8_t code, OperandSize operand_size, OperandType operand_type, const DisasmContext &ctx)
{
	IntelOperand *operand = GetFreeOperand();
	if (operand == NULL)
		throw std::runtime_error("ReadRegFromRM no free operands");

	operand->type = operand_type;
	operand->size = operand_size;
	operand->registr = ((code >> 3) & 7);

	if (ctx.rex_prefix && (operand_type == otRegistr || operand_type == otDebugRegistr || operand_type == otControlRegistr || operand_type == otXMMRegistr)) {
		if (ctx.rex_prefix & rexR)
			operand->registr |= 8;
	} else if (operand_type == otRegistr && operand_size == osByte && operand->registr >= 4) {
		operand->type = otHiPartRegistr;
		operand->registr &= 3;
	}
}

void IntelCommand::ReadRM(uint8_t code, OperandSize operand_size, OperandType operand_type, bool show_size, const DisasmContext &ctx)
{
	IntelOperand *operand = GetFreeOperand();
	if (operand == NULL)
		throw std::runtime_error("ReadRM no free operands");

	OperandSize value_size = osByte;
	uint8_t sib;

	switch (code & 0xc0) {
	case 0x00:
		if ((!ctx.lower_address && (code & 7) == 5) || (ctx.lower_address && (code & 7) == 6)) {
			operand->type = otMemory | otValue;
			value_size = GetAddressSize(ctx);
		} else {
			operand->type = otMemory | otRegistr;
		}
		break;
	case 0x40:
		operand->type = otMemory | otRegistr | otValue;
		break;
	case 0x80:
		operand->type = otMemory | otRegistr | otValue;
		value_size = GetAddressSize(ctx);
		break;
	default:
		operand->type = operand_type;
		break;
	}
	operand->size = operand_size;

	if (operand->type & otMemory) {
		operand->show_size = show_size;
		operand->address_size = GetAddressSize(ctx);

		if (operand->address_size == osWord) {
			if ((code & 7) < 4) {
				operand->base_registr = (code & 2) == 0 ? regEBX : regEBP;
				operand->type |= otBaseRegistr;
			}

			if (operand->type & otRegistr) {
				switch (code & 7) {
				case 0x00:
					operand->registr = regESI;
					operand->base_registr = regEBX;
					break;
				case 0x01:
					operand->registr = regEDI;
					operand->base_registr = regEBX;
					break;
				case 0x02:
					operand->registr = regESI;
					operand->base_registr = regEBP;
					break;
				case 0x03:
					operand->registr = regEDI;
					operand->base_registr = regEBP;
					break;
				case 0x04:
					operand->registr = regESI;
					break;
				case 0x05:
					operand->registr = regEDI;
					break;
				case 0x06:
					operand->registr = regEBP;
					break;
				case 0x07:
					operand->registr = regEBX;
					break;
				}
			}
		} else {
			if ((code & 7) == 4) {
				sib = ReadByte(*ctx.file);
				operand->registr = ((sib >> 3) & 7);
				operand->base_registr = (sib & 7);
				operand->type |= otBaseRegistr;

				if (ctx.rex_prefix) {
					if (ctx.rex_prefix & rexB)
						operand->base_registr |= 8;
					if (ctx.rex_prefix & rexX)
						operand->registr |= 8;
				}

				if (operand->registr == regESP)
					operand->type &= ~otRegistr;
				else
					operand->scale_registr = (sib >> 6);

				if ((code & 0xc0) == 0 && (operand->base_registr & 7) == regEBP) {
					operand->type &= ~otBaseRegistr;
					operand->type |= otValue;
				}

				if (operand->type & otValue) {
					switch (code & 0xc0) {
					case 0x00:
						value_size = osDWord;
						break;
					case 0x40:
						value_size = osByte;
						break;
					case 0x80:
						value_size = osDWord;
						break;
					}
				}
			} else {
				operand->registr = (code & 7);
				if (ctx.rex_prefix) {
					if (ctx.rex_prefix & rexB)
						operand->registr |= 8;
				}
			}
		}

		if (operand->type & otValue) {
			operand->value_size = value_size;
			operand->value_pos = static_cast<uint8_t>(dump_size());
			switch (value_size) {
			case osByte:
				operand->value = ByteToInt64(ReadByte(*ctx.file));
				break;
			case osWord:
				operand->value = WordToInt64(ReadWord(*ctx.file));
				break;
			case osDWord:
				operand->value = DWordToInt64(ReadDWord(*ctx.file));
				break;
			case osQWord:
				operand->value = DWordToInt64(ReadDWord(*ctx.file));
				if (operand->type == (otValue | otMemory))
					operand->is_large_value = true;
				break;
			}
		}
	} else {
		operand->registr = (code & 7);
		if (ctx.rex_prefix && (operand_type == otRegistr || operand_type == otDebugRegistr || operand_type == otControlRegistr || operand_type == otXMMRegistr)) {
			if (ctx.rex_prefix & rexB)
				operand->registr |= 8;
		} else if (operand_type == otRegistr && operand_size == osByte && operand->registr >= 4) {
			operand->type = otHiPartRegistr;
			operand->registr &= 3;
		}
	}
}

IntelOperand *IntelCommand::ReadValue(OperandSize operand_size, OperandSize value_size, const DisasmContext &ctx)
{
	IntelOperand *operand = GetFreeOperand();
	if (operand == NULL)
		throw std::runtime_error("ReadValue no free operands");

	operand->type = otValue;
	operand->size = operand_size;
	operand->value_size = value_size;
	operand->value_pos = static_cast<uint8_t>(dump_size());

	switch (value_size) {
	case osByte:
		operand->value = ByteToInt64(ReadByte(*ctx.file));
		break;
	case osWord:
		operand->value = WordToInt64(ReadWord(*ctx.file));
		break;
	case osDWord:
		operand->value = DWordToInt64(ReadDWord(*ctx.file));
		break;
	case osQWord:
		operand->value = ReadQWord(*ctx.file);
		break;
	}

	if (operand_size == osFWord)
		operand->value |= static_cast<uint64_t>(ReadWord(*ctx.file)) << (value_size == osWord ? 16 : 32);

	return operand;
}

void IntelCommand::ReadValueAddAddress(OperandSize operand_size, OperandSize value_size, const DisasmContext &ctx)
{
	IntelOperand *operand = ReadValue(operand_size, value_size, ctx);
	operand->value += next_address();
	operand->value_size = operand_size;

	switch (operand_size) {
	case osWord:
		operand->value = static_cast<uint16_t>(operand->value);
		break;
	case osDWord:
		operand->value = static_cast<uint32_t>(operand->value);
		break;
	}
}

uint64_t IntelCommand::ReadValueFromFile(IArchitecture &file, OperandSize value_size)
{
	DisasmContext ctx;
	IntelOperand *operand;

	switch (value_size) {
	case osByte:
		type_ = cmDB;
		break;
	case osWord:
		type_ = cmDW;
		break;
	case osDWord:
		type_ = cmDD;
		break;
	case osQWord:
		type_ = cmDQ;
		break;
	default:
		throw std::runtime_error("Invalid value size");
	}

	ctx.file = &file;
	ctx.lower_address = false;
	ctx.lower_reg = false;
	ctx.rex_prefix = 0;

	operand = ReadValue(value_size, value_size, ctx);
	operand->fixup = file.fixup_list()->GetFixupByAddress(address() + operand->value_pos);

	if (file.relocation_list())
		operand->relocation = file.relocation_list()->GetRelocationByAddress(address() + operand->value_pos);

	return operand->value;
}

enum OperandFlags {
	of_None = 0,

	of_Registr = 0x01000000,
	of_DebugRegistr = 0x02000000,
	of_ControlRegistr = 0x03000000,
	of_FPURegistr = 0x04000000,
	of_MMXRegistr = 0x05000000,
	of_XMMRegistr = 0x06000000,
	of_Value = 0x07000000,
	of_SegmentRegistr = 0x08000000,

	of_RM = 0x10000000,
	of_RegRM = 0x20000000,
	of_Reg = 0x30000000,
	of_Const = 0x40000000,
	of_Relative = 0x50000000,
	of_Far = 0x60000000,
	of_Memory = 0x70000000,
	of_XReg = 0x80000000,

	of_size = 0x00000100,
	of_mem_word = 0x00000200,
	of_mem_only = 0x00000400,
	of_reg_only = 0x00000800,

	of_value_b = 0x00000001,
	of_value_w = 0x00000002,
	of_value_z = 0x00000003,
	of_value_v = 0x00000004,

	of_E = (of_RM | of_Registr),
	of_G = (of_RegRM | of_Registr),
	of_IB = (of_Value | of_value_b),
	of_IW = (of_Value | of_value_w),
	of_IZ = (of_Value | of_value_z),
	of_IV = (of_Value | of_value_v),
	of_M = (of_RM | of_Registr | of_mem_only),
	of_J = (of_Value | of_Relative),
	of_S = (of_RegRM | of_SegmentRegistr),
	of_A = (of_Value | of_Far),
	of_O = (of_Value | of_Memory),
	of_V = (of_RegRM | of_XMMRegistr),
	of_W = (of_RM | of_XMMRegistr),
	of_X = (of_XReg | of_XMMRegistr),
	of_ST = (of_Const | of_FPURegistr),
	of_U = (of_RM | of_XMMRegistr | of_reg_only),
	of_C = (of_RegRM | of_ControlRegistr),
	of_R = (of_RM | of_Registr | of_reg_only),
	of_D = (of_RegRM | of_DebugRegistr),
	of_Q = (of_RM | of_MMXRegistr),
	of_P = (of_RegRM | of_MMXRegistr),
	of_N = (of_RM | of_MMXRegistr | of_reg_only),
	of_FI = (of_Const | of_Value),
	of_FS = (of_Const | of_SegmentRegistr),
	of_FG = (of_Const | of_Registr),
	of_Z = (of_Reg | of_Registr),

	of_b = 0x00010000, 
	of_w = 0x00020000, 
	of_v = 0x00030000,
	of_d = 0x00040000,
	of_z = 0x00050000,
	of_p = 0x00060000,
	of_t = 0x00070000,
	of_q = 0x00080000,
	of_s = 0x00090000,
	of_dq = 0x000E0000,
	of_qq = 0x000F0000,
	of_o = 0x00130000,
	of_x = 0x00150000,
	of_vdef = 0x00FC0000,
	of_cpu = 0x00FD0000,
	of_adr = 0x00FE0000,
	of_def = 0x00FF0000,

	of_Eb = (of_E | of_b),
	of_Ew = (of_E | of_w),
	of_Ed = (of_E | of_d),
	of_Eq = (of_E | of_q),
	of_Ev = (of_E | of_v),
	of_Ex = (of_E | of_x | of_size),
	of_Edef = (of_E | of_def),
	of_Gb = (of_G | of_b),
	of_Gw = (of_G | of_w),
	of_Gd = (of_G | of_d),
	of_Gv = (of_G | of_v),
	of_Gz = (of_G | of_z),
	of_Gx = (of_G | of_x),
	of_FGb = (of_FG | of_b),
	of_FGw = (of_FG | of_w),
	of_FGv = (of_FG | of_v),
	of_IBb = (of_IB | of_b),
	of_IBv = (of_IB | of_v),
	of_IZv = (of_IZ | of_v),
	of_IVv = (of_IV | of_v),
	of_IWw = (of_IW | of_w),
	of_Ma = (of_M | of_v),
	of_FSdef = (of_FS | of_def),
	of_Jb = (of_J | of_b),
	of_Jz = (of_J | of_z),
	of_Sw = (of_S | of_w),
	of_Mb = (of_M | of_b),
	of_Mw = (of_M | of_w),
	of_Mv = (of_M | of_v),
	of_Md = (of_M | of_d),
	of_Mq = (of_M | of_q),
	of_Mt = (of_M | of_t),
	of_Ms = (of_M | of_s),
	of_Mp = (of_M | of_p),
	of_Mdq = (of_M | of_dq),
	of_Mdef = (of_M | of_vdef | of_size),
	of_Mx = (of_M | of_x),
	of_Ap = (of_A | of_p),
	of_Ob = (of_O | of_b),
	of_Ov = (of_O | of_v),
	of_FIb = (of_FI | of_b),
	of_Vdq = (of_V | of_dq),
	of_Vqq = (of_V | of_qq),
	of_Vdef = (of_V | of_vdef),
	of_Ww = (of_W | of_w | of_size),
	of_Wd = (of_W | of_d | of_size),
	of_Wq = (of_W | of_q | of_size),
	of_Wdq = (of_W | of_dq | of_size),
	of_Wdef = (of_W | of_vdef | of_size),
	of_Xdq = (of_X | of_dq),
	of_Xdef = (of_X | of_vdef),
	of_Udq = (of_U | of_dq),
	of_Udef = (of_U | of_vdef),
	of_Nq = (of_N | of_q),
	of_Zb = (of_Z | of_b),
	of_Zv = (of_Z | of_v),
	of_Zdef = (of_Z | of_def),
	of_Rcpu = (of_R | of_cpu),
	of_Ccpu = (of_C | of_cpu),
	of_Dcpu = (of_D | of_cpu),
	of_Qd = (of_Q | of_d),
	of_Qq = (of_Q | of_q),
	of_Pq = (of_P | of_q),
};

void IntelCommand::ReadCommand(IntelCommandType type, uint32_t of_1, uint32_t of_2, uint32_t of_3, DisasmContext &ctx)
{
	size_t i;
	uint32_t of;
	uint8_t code;
	OperandSize os;
	IntelOperand *operand;
	OperandType ot;
	bool need_read_code;
	uint32_t ofs[] = {of_1, of_2, of_3};

	type_ = type;

	if (ctx.use_last_byte) {
		code = dump(dump_size() - 1);
		need_read_code = false;
	} else {
		code = 0;
		need_read_code = true;
	}

	for (i = 0; i < _countof(ofs); i++) {
		of = ofs[i];

		if (of == of_None)
			break;

		switch (of & 0x00FF0000) {
		case of_b:
			os = osByte;
			break;
		case of_w:
			os = osWord;
			break;
		case of_d:
			os = osDWord;
			break;
		case of_q:
			os = osQWord;
			break;
		case of_v:
			os = GetOperandSize(1, ctx);
			break;
		case of_z:
			os = ((ctx.rex_prefix & rexW) == 0 && ctx.lower_reg) ? osWord : osDWord;
			break;
		case of_x:
			os = (ctx.rex_prefix & rexW) ? osQWord : osDWord;
			break;
		case of_adr:
			os = GetAddressSize(ctx);
			break;
		case of_def:
			os = GetDefaultOperandSize(ctx);
			break;
		case of_p:
			os = osFWord;
			break;
		case of_t:
			os = osTByte;
			break;
		case of_cpu:
			os = size_;
			break;
		case of_s:
			// FIXME
			os = osByte;
			break;
		case of_o:
			os = osOWord;
			break;
		case of_dq:
			os = osXMMWord;
			break;
		case of_qq:
			os = osYMMWord;
			break;
		case of_vdef:
			os = ((options() & roVexPrefix) && (ctx.rex_prefix & 0x80)) ? osYMMWord : osXMMWord;
			break;
		default:
			os = osByte;
			break;
		}

		switch (of & 0x0F000000) {
		case of_Registr:
			ot = otRegistr;
			break;
		case of_DebugRegistr:
			ot = otDebugRegistr;
			break;
		case of_ControlRegistr:
			ot = otControlRegistr;
			break;
		case of_FPURegistr:
			ot = otFPURegistr;
			break;
		case of_MMXRegistr:
			ot = otMMXRegistr;
			break;
		case of_XMMRegistr:
			ot = otXMMRegistr;
			break;
		case of_Value:
			ot = otValue;
			break;
		case of_SegmentRegistr:
			ot = otSegmentRegistr;
			break;
		default:
			operand_[i].size = os;
			continue;
		}

		if (ot == otValue) {
			switch (of & 0xF0000000) {
			case of_Relative:
				ReadValueAddAddress(GetDefaultOperandSize(ctx), os, ctx);
				break;
			case of_Const:
				operand = &operand_[i];
				operand->type = otValue;
				operand->size = os;
				operand->value_size = os;
				operand->value = (of & 0xFF);
				break;
			case of_Far:
				ReadValue(os, GetDefaultOperandSize(ctx), ctx);
				break;
			case of_Memory:
				ReadValue(os, GetAddressSize(ctx), ctx);
				operand_[i].type |= otMemory;
				break;
			default:
				switch (of & 0x0F) {
				case of_value_b:
					ReadValue(os, osByte, ctx);
					break;
				case of_value_w:
					ReadValue(os, osWord, ctx);
					break;
				case of_value_z:
					ReadValue(os, (ctx.lower_reg) ? osWord : osDWord, ctx);
					break;
				case of_value_v:
					ReadValue(os, GetOperandSize(1, ctx), ctx);
					break;
				}
				break;
			}
		} else {
			switch (of & 0xF0000000) {
			case of_RM:
				if (need_read_code) {
					code = ReadByte(*ctx.file);
					need_read_code = false;
				}
				ReadRM(code, os, ot, (of & of_size) != 0, ctx);
				operand = &operand_[i];
				if ((operand->type & otMemory) == 0) {
					if ((of & of_mem_only) != 0) {
						type_ = cmDB;
						return;
					}
				} else {
					if ((of & of_reg_only) != 0) {
						type_ = cmDB;
						return;
					}
					if ((of & of_mem_word) != 0)
						operand->size = osWord;
				}
				break;
			case of_RegRM:
				if (need_read_code) {
					code = ReadByte(*ctx.file);
					need_read_code = false;
				}
				ReadRegFromRM(code, os, ot, ctx);
				break;
			case of_Reg:
				ReadReg((of & 0xff), os, ot, ctx);
				break;
			case of_XReg:
				code = ReadByte(*ctx.file);
				ReadReg((code >> 4), os, ot, ctx);
				break;
			case of_Const:
				operand = &operand_[i];
				operand->type = ot;
				operand->size = os;
				operand->registr = (of & 7);
				break;
			}

			operand = &operand_[i];
			switch (operand->type) {
			case otSegmentRegistr:
				if (operand->registr > segGS) {
					type_ = cmDB;
					return;
				}
				break;
			case otControlRegistr:
				if (operand->registr == 1
					|| operand->registr == 5
					|| operand->registr == 6
					|| operand->registr >= 9) {
					type_ = cmDB;
					return;
				}
				break;
			case otDebugRegistr:
				if (operand->registr >= 8) {
					type_ = cmDB;
					return;
				}
				break;
			}
		}
	}
};

size_t IntelCommand::ReadFromFile(IArchitecture &file)
{
	uint8_t code, prefix;
	OperandSize os;
	DisasmContext ctx;
	IntelOperand *operand;
	uint8_t vex_bytes[2];
	size_t i, vex_operand_index;
	
	clear();
	size_ = file.cpu_address_size();

	ctx.file = &file;
	ctx.lower_address = false;
	ctx.lower_reg = false;
	ctx.rex_prefix = 0;
	ctx.use_last_byte = false;
	ctx.vex_registr = 0;

	vex_operand_index = 0;
	prefix = 0;
	vex_bytes[0] = 0;
	vex_bytes[1] = 0;
	while (type_ == cmUnknown) {
		command_pos_ = dump_size();
		code = vex_bytes[0] ? vex_bytes[0] : ReadByte(file);
		switch (code) {
			case 0x00: 
				ReadCommand(cmAdd, of_Eb, of_Gb, of_None, ctx); 
				break;
			case 0x01:
				ReadCommand(cmAdd, of_Ev, of_Gv, of_None, ctx); 
				break;
			case 0x02:
				ReadCommand(cmAdd, of_Gb, of_Eb, of_None, ctx);
				break;
			case 0x03:
				ReadCommand(cmAdd, of_Gv, of_Ev, of_None, ctx);
				break;
			case 0x04:
				ReadCommand(cmAdd, of_FGb | regEAX, of_IBb, of_None, ctx);
				break;
			case 0x05:
				ReadCommand(cmAdd, of_FGv | regEAX, of_IZv, of_None, ctx);
				break;
			case 0x06:
				if (size_ == osQWord)  {
					type_ = cmDB;
				} else {
					ReadCommand(cmPush, of_FSdef | segES, of_None, of_None, ctx);
				}
				break;
			case 0x07:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					ReadCommand(cmPop, of_FSdef | segES, of_None, of_None, ctx);
				}
				break;
			case 0x08:
				ReadCommand(cmOr, of_Eb, of_Gb, of_None, ctx);
				break;
			case 0x09:
				ReadCommand(cmOr, of_Ev, of_Gv, of_None, ctx);
				break;
			case 0x0a:
				ReadCommand(cmOr, of_Gb, of_Eb, of_None, ctx);
				break;
			case 0x0b:
				ReadCommand(cmOr, of_Gv, of_Ev, of_None, ctx);
				break;
			case 0x0c:
				ReadCommand(cmOr, of_FGb | regEAX, of_IBb, of_None, ctx);
				break;
			case 0x0d:
				ReadCommand(cmOr, of_FGv | regEAX, of_IZv, of_None, ctx);
				break;
			case 0x0e:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					ReadCommand(cmPush, of_FSdef | segCS, of_None, of_None, ctx);
				}
				break;

			// Secondary Opcode Map
			case 0x0f:
				code = vex_bytes[1] ? vex_bytes[1] : ReadByte(file);
				switch (code) {
					case 0x00:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						switch ((code >> 3) & 7) {
							case 0x00:
								ReadCommand(cmSldt, of_Ev | of_mem_word, of_None, of_None, ctx);
								break;
							case 0x01:
								ReadCommand(cmStr, of_Ev | of_mem_word, of_None, of_None, ctx);
								break;
							case 0x02:
								ReadCommand(cmLldt, of_Ew, of_None, of_None, ctx);
								break;
							case 0x03:
								ReadCommand(cmLtr, of_Ew, of_None, of_None, ctx);
								break;
							case 0x04:
								ReadCommand(cmVerr, of_Ew, of_None, of_None, ctx);
								break;
							case 0x05:
								ReadCommand(cmVerw, of_Ew, of_None, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x01:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						if (code >= 0xc0) {
							switch (code) {
								case 0xc1:
									type_ = cmVmcall;
									break;
								case 0xc2:
									type_ = cmVmlaunch;
									break;
								case 0xc3:
									type_ = cmVmresume;
									break;
								case 0xc4:
									type_ = cmVmxoff;
									break;
								case 0xc8:
									type_ = cmMonitor;
									break;
								case 0xc9:
									type_ = cmMwait;
									break;
								case 0xd0:
									type_ = cmXgetbv;
									break;
								case 0xd1:
									type_ = cmXsetbv;
									break;
								case 0xd8:
									type_ = cmVmrun;
									break;
								case 0xd9:
									type_ = cmVmmcall;
									break;		
								case 0xda:
									type_ = cmVmload;
									break;
								case 0xdb:
									type_ = cmVmsave;
									break;
								case 0xdc:
									type_ = cmStgi;
									break;
								case 0xdd:
									type_ = cmClgi;
									break;
								case 0xde:
									type_ = cmSkinit;
									break;
								case 0xdf:
									type_ = cmInvlpga;
									break;
								case 0xf8:
									type_ = cmSwapgs;
									break;
								case 0xf9:
									type_ = cmRdtscp;
									break;
								default:
									type_ = cmDB;
									break;
							}
						} else {
							switch ((code >> 3) & 7) {
								case 0x00:
									ReadCommand(cmSgdt, of_Ms, of_None, of_None, ctx);
									break;
								case 0x01:
									ReadCommand(cmSidt, of_Ms, of_None, of_None, ctx);
									break;
								case 0x02:
									ReadCommand(cmLgdt, of_Ms, of_None, of_None, ctx);
									break;
								case 0x03:
									ReadCommand(cmLidt, of_Ms, of_None, of_None, ctx);
									break;
								case 0x04:
									ReadCommand(cmSmsw, of_Ev | of_mem_word, of_None, of_None, ctx);
									break;
								case 0x06:
									ReadCommand(cmLmsw, of_Ew, of_None, of_None, ctx);
									break;
								case 0x07:
									ReadCommand(cmInvlpg, of_Mb, of_None, of_None, ctx);
									break;
								default:
									type_ = cmDB;
									break;
							}
						}
						break;
					case 0x02:
						ReadCommand(cmLar, of_Gv, of_Ew, of_None, ctx);
						break;
					case 0x03:
						ReadCommand(cmLsl, of_Gv, of_Ew, of_None, ctx);
						break;
					case 0x05:
						type_ = cmSyscall;
						break;
					case 0x06:
						type_ = cmClts;
						break;
					case 0x07:
						type_ = cmSysret;
						break;
					case 0x08:
						type_ = cmInvd;
						break;
					case 0x09:
						type_ = cmWbinvd;
						break;
					case 0x0b:
						type_ = cmUd2;
						break;
					case 0x0d:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						switch ((code >> 3) & 7) {
							case 0x00:
								ReadCommand(cmPrefetch, of_Mb, of_None, of_None, ctx);
								break;
							case 0x01:
								ReadCommand(cmPrefetchw, of_Mb, of_None, of_None, ctx);
								break;
							default:
								ReadCommand(cmPrefetch, of_Mb, of_None, of_None, ctx);
								break;
						}
						break;
					case 0x0e:
						type_ = cmFemms;
						break;
					case 0x10:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovups, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovupd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovsd, of_Vdq, of_Wq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovss, of_Vdq, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x11:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovups, of_Wdef, of_Vdef, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovupd, of_Wdef, of_Vdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovsd, of_Wq, of_Vdq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovss, of_Wd, of_Vdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x12:
						switch (prefix) {
							case 0x00:
								code = ReadByte(file);
								ctx.use_last_byte = true;
								if ((code & 0xc0) == 0xc0) {
									vex_operand_index = 1;
									ReadCommand(cmMovhlps, of_Vdq, of_Udq, of_None, ctx);
								} else {
									vex_operand_index = 1;
									ReadCommand(cmMovlps, of_Vdq, of_Mq, of_None, ctx);
								}
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmMovlpd, of_Vdq, of_Mq, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovddup, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovsldup, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x13:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovlps, of_Mq, of_Vdq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovlpd, of_Mq, of_Vdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x14:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmUnpcklps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmUnpcklpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x15:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmUnpckhps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmUnpckhpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x16:
						switch (prefix) {
							case 0x00:
								code = ReadByte(file);
								ctx.use_last_byte = true;
								if ((code & 0xc0) == 0xc0) {
									ReadCommand(cmMovlhps, of_Vdq, of_Udq, of_None, ctx);
								} else {
									ReadCommand(cmMovhps, of_Vdq, of_Mq, of_None, ctx);
								}
								break;
							case 0x66:
								ReadCommand(cmMovhpd, of_Vdq, of_Mq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovshdup, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x17:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovhps, of_Mq, of_Vdq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovhpd, of_Mq, of_Vdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x18:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						switch ((code >> 3) & 7) {
							case 0x00:
								ReadCommand(cmPrefetchnta, of_Mb, of_None, of_None, ctx);
								break;
							case 0x01:
								ReadCommand(cmPrefetcht0, of_Mb, of_None, of_None, ctx);
								break;
							case 0x02:
								ReadCommand(cmPrefetcht1, of_Mb, of_None, of_None, ctx);
								break;
							case 0x03:
								ReadCommand(cmPrefetcht2, of_Mb, of_None, of_None, ctx);
								break;
							default:
								type_ = cmNop;
								break;
						}
						break;
					case 0x19: case 0x1a: case 0x1b: case 0x1c: case 0x1d: case 0x1e: case 0x1f:
						ReadCommand(cmNop, of_Ev, of_None, of_None, ctx);
						break;
					case 0x20:
						ReadCommand(cmMov, of_Rcpu, of_Ccpu, of_None, ctx);
						break;
					case 0x21:
						ReadCommand(cmMov, of_Rcpu, of_Dcpu, of_None, ctx);
						break;
					case 0x22:
						ReadCommand(cmMov, of_Ccpu, of_Rcpu, of_None, ctx);
						break;
					case 0x23:
						ReadCommand(cmMov, of_Dcpu, of_Rcpu, of_None, ctx);
						break;
					case 0x28:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovaps, of_Vdq, of_Wdq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovapd, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x29:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovaps, of_Wdq, of_Vdq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovapd, of_Wdq, of_Vdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x2a:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmCvtpi2ps, of_Vdq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmCvtpi2pd, of_Vdq, of_Qq, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmCvtsi2sd, of_Vdq, of_Ex, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmCvtsi2ss, of_Vdq, of_Ex, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x2b:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovntps, of_Mdef, of_Vdef, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovntpd, of_Mdef, of_Vdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovntsd, of_Mq, of_Vdq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovntss, of_Md, of_Vdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x2c:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmCvttps2pi, of_Pq, of_Wdq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmCvttpd2pi, of_Pq, of_Wdq, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								ReadCommand(cmCvttsd2si, of_Gx, of_Wq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmCvttss2si, of_Gx, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x2d:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmCvtps2pi, of_Pq, of_Wq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmCvtpd2pi, of_Pq, of_Wdq, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								ReadCommand(cmCvtsd2si, of_Gx, of_Wq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmCvtss2si, of_Gx, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x2e:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmUcomiss, of_Vdq, of_Wd, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmUcomisd, of_Vdq, of_Wq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x2f:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmComiss, of_Vdq, of_Wdq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmComisd, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x30:
						type_ = cmWrmsr;
						break;

					case 0x31:
						type_ = cmRdtsc;
						break;

					case 0x32:
						type_ = cmRdmsr;
						break;

					case 0x33:
						type_ = cmRdpmc;
						break;

					case 0x34:
						if (size_ == osQWord)
							type_ = cmDB;
						else
							type_ = cmSysenter;
						break;

					case 0x35:
						if (size_ == osQWord)
							type_ = cmDB;
						else
							type_ = cmSysexit;
						break;

					case 0x37:
						type_ = cmGetsec;
						break;

					case 0x38:
						code = ReadByte(file);
						switch (code) {
							case 0x00:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPshufb, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPshufb, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x01:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPhaddw, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPhaddw, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x02:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPhaddd, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPhaddd, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x03:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPhaddsw, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPhaddsw, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x04:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPmaddubsw, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPmaddubsw, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x05:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPhsubw, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPhsubw, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x06:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPhsubd, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPhsubd, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x07:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPhsubsw, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPhsubsw, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x08:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPsignb, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPsignb, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x09:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPsignw, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPsignw, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x0a:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPsignd, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPsignd, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x0b:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPmulhrsw, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPmulhrsw, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x0c:
								switch (prefix) {
									case 0x66:
										if (options() & roVexPrefix) {
											vex_operand_index = 1;
											ReadCommand(cmVpermilps, of_Vdef, of_Wdef, of_None, ctx);
										} else
											type_ = cmDB;
										break;
									default:
										type_ = cmDB;
										break;
									}
								break;
							case 0x0d:
								switch (prefix) {
									case 0x66:
										if (options() & roVexPrefix) {
											vex_operand_index = 1;
											ReadCommand(cmVpermilpd, of_Vdef, of_Wdef, of_None, ctx);
										} else
											type_ = cmDB;
										break;
									default:
										type_ = cmDB;
										break;
									}
								break;
							case 0x0e:
								switch (prefix) {
									case 0x66:
										if (options() & roVexPrefix)
											ReadCommand(cmVtestps, of_Vdef, of_Wdef, of_None, ctx);
										else
											type_ = cmDB;
										break;
									default:
										type_ = cmDB;
										break;
									}
								break;
							case 0x0f:
								switch (prefix) {
									case 0x66:
										if (options() & roVexPrefix)
											ReadCommand(cmVtestpd, of_Vdef, of_Wdef, of_None, ctx);
										else
											type_ = cmDB;
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x10:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPblendvb, of_Vdef, of_Wdef, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x14:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPblendps, of_Vdef, of_Wdef, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x15:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPblendpd, of_Vdef, of_Wdef, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x17:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPtest, of_Vdef, of_Wdef, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x18:
								switch (prefix) {
								case 0x66:
									ReadCommand(cmVbroadcastss, of_Vdef, of_Wd, of_None, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x19:
								switch (prefix) {
								case 0x66:
									if (ctx.rex_prefix & 0x80)
										ReadCommand(cmVbroadcastsd, of_Vdef, of_Wq, of_None, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x1a:
								switch (prefix) {
								case 0x66:
									if (ctx.rex_prefix & 0x80)
										ReadCommand(cmVbroadcastf128, of_Vdef, of_Wdq, of_None, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x1c:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPabsb, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPabsb, of_Vdef, of_Wdef, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x1d:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPabsw, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPabsw, of_Vdef, of_Wdef, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x1e:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPabsd, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPabsd, of_Vdef, of_Wdef, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x20:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmovsxbw, of_Vdef, of_Wq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x21:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmovsxbd, of_Vdef, of_Wd, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x22:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmovsxbq, of_Vdef, of_Ww, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x23:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmovsxwd, of_Vdef, of_Wq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x24:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmovsxwq, of_Vdef, of_Wd, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x25:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmovsxdq, of_Vdef, of_Wq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x28:
								switch (prefix) {
									case 0x66:
										vex_operand_index = 1;
										ReadCommand(cmPmuldq, of_Vdef, of_Wdef, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x29:
								switch (prefix) {
									case 0x66:
										vex_operand_index = 1;
										ReadCommand(cmPcmpeqq, of_Vdef, of_Wdef, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x2a:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmMovntdqa, of_Vdef, of_Mdef, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x2b:
								switch (prefix) {
									case 0x66:
										vex_operand_index = 1;
										ReadCommand(cmPackusdw, of_Vdef, of_Wdef, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x2c:
								switch (prefix) {
								case 0x66:
									vex_operand_index = 1;
									ReadCommand(cmMaskmovps, of_Vdef, of_Mdef, of_None, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x2d:
								switch (prefix) {
								case 0x66:
									vex_operand_index = 1;
									ReadCommand(cmMaskmovpd, of_Vdef, of_Mdef, of_None, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x2e:
								switch (prefix) {
								case 0x66:
									vex_operand_index = 1;
									ReadCommand(cmMaskmovps, of_Mdef, of_Vdef, of_None, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x2f:
								switch (prefix) {
								case 0x66:
									vex_operand_index = 1;
									ReadCommand(cmMaskmovpd, of_Mdef, of_Vdef, of_None, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x30:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmovzxbw, of_Vdq, of_Wq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x31:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmovzxbd, of_Vdq, of_Wd, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x32:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmovzxbq, of_Vdq, of_Ww, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x33:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmovzxwd, of_Vdq, of_Wq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x34:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmovzxwq, of_Vdq, of_Wd, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x35:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmovzxdq, of_Vdq, of_Wq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x37:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPcmpgtq, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x38:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPminsb, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x39:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPminsd, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x3a:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPminuw, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x3b:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPminud, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x3c:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmaxsb, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x3d:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmaxsd, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x3e:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmaxuw, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x3f:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmaxud, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x40:
								switch (prefix) {
								case 0x66:
									ReadCommand(cmPmulld, of_Vdq, of_Wdq, of_None, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;

							case 0x9d:
								switch (prefix) {
									case 0x66:
										vex_operand_index = 1;
										if (ctx.rex_prefix & rexW)
											ReadCommand(cmFnmadd132sd, of_Vdq, of_Wq, of_None, ctx);
										else
											ReadCommand(cmFnmadd132ss, of_Vdq, of_Wd, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;

							case 0xad:
								switch (prefix) {
									case 0x66:
										vex_operand_index = 1;
										if (ctx.rex_prefix & rexW)
											ReadCommand(cmFnmadd213sd, of_Vdq, of_Wq, of_None, ctx);
										else
											ReadCommand(cmFnmadd213ss, of_Vdq, of_Wd, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;

							case 0xbd:
								switch (prefix) {
									case 0x66:
										vex_operand_index = 1;
										if (ctx.rex_prefix & rexW)
											ReadCommand(cmFnmadd231sd, of_Vdq, of_Wq, of_None, ctx);
										else
											ReadCommand(cmFnmadd231ss, of_Vdq, of_Wd, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;

							case 0xdb:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmAesimc, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0xdc:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmAesenc, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0xdd:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmAesenclast, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0xde:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmAesdec, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0xdf:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmAesdeclast, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0xf0:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmMovbe, of_Gv, of_Mv, of_None, ctx);
										break;
									case 0xf2:
										preffix_command_ = cmUnknown;
										ReadCommand(cmCrc32, of_Gx, of_Mb | of_size, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0xf1:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmMovbe, of_Mv, of_Gv, of_None, ctx);
										break;
									case 0xf2:
										preffix_command_ = cmUnknown;
										ReadCommand(cmCrc32, of_Gx, of_Mv | of_size, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;

							// FIXME
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x3a:
						code = ReadByte(file);
						switch (code) {
							case 0x04:
								switch (prefix) {
								case 0x66:
									if (options() & roVexPrefix)
										ReadCommand(cmVpermilps, of_Vdef, of_Wdef, of_IBb, ctx);
									else
										type_ = cmDB;
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x05:
								switch (prefix) {
								case 0x66:
									if (options() & roVexPrefix)
										ReadCommand(cmVpermilpd, of_Vdef, of_Wdef, of_IBb, ctx);
									else
										type_ = cmDB;
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x06:
								switch (prefix) {
								case 0x66:
									if (options() & roVexPrefix) {
										vex_operand_index = 1;
										ReadCommand(cmVperm2f128, of_Vdef, of_Wdef, of_IBb, ctx);
									} else
										type_ = cmDB;
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x08:
								switch (prefix) {
								case 0x66:
									ReadCommand(cmRoundps, of_Vdef, of_Wdef, of_IBb, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x09:
								switch (prefix) {
								case 0x66:
									ReadCommand(cmRoundpd, of_Vdef, of_Wdef, of_IBb, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x0c:
								switch (prefix) {
								case 0x66:
									vex_operand_index = 1;
									ReadCommand(cmBlendps, of_Vdef, of_Wdef, of_IBb, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x0d:
								switch (prefix) {
								case 0x66:
									vex_operand_index = 1;
									ReadCommand(cmBlendpd, of_Vdef, of_Wdef, of_IBb, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x0e:
								switch (prefix) {
								case 0x66:
									ReadCommand(cmPblendw, of_Vdq, of_Wdq, of_IBb, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x0f:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPalignr, of_Pq, of_Qq, of_IBb, ctx);
										break;
									case 0x66:
										ReadCommand(cmPalignr, of_Vdq, of_Wdq, of_IBb, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x14:
								switch (prefix) {
								case 0x66:
									ReadCommand(cmPextrb, of_Ed, of_Vdq, of_IBb, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x16:
								switch (prefix) {
								case 0x66:
									if (ctx.rex_prefix & rexW)
										ReadCommand(cmPextrq, of_Eq, of_Vdq, of_IBb, ctx);
									else
										ReadCommand(cmPextrd, of_Ed, of_Vdq, of_IBb, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x18:
								switch (prefix) {
								case 0x66:
									vex_operand_index = 1;
									ReadCommand(cmInsertf128, of_Vdef, of_Wdq, of_IBb, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x19:
								switch (prefix) {
								case 0x66:
									ReadCommand(cmExtractf128, of_Wdq, of_Vqq, of_IBb, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x20:
								switch (prefix) {
									case 0x66:
										vex_operand_index = 1;
										ReadCommand(cmPinsrb, of_Vdq, of_Eb, of_IBb, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x22:
								switch (prefix) {
									case 0x66:
										vex_operand_index = 1;
										if (ctx.rex_prefix & rexW)
											ReadCommand(cmPinsrq, of_Vdq, of_Eq, of_IBb, ctx);
										else
											ReadCommand(cmPinsrd, of_Vdq, of_Ed, of_IBb, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x40:
								switch (prefix) {
								case 0x66:
									vex_operand_index = 1;
									ReadCommand(cmDpps, of_Vdef, of_Wdef, of_IBb, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x4a:
								switch (prefix) {
								case 0x66:
									vex_operand_index = 1;
									ReadCommand(cmBlendvps, of_Vdef, of_Wdef, of_Xdef, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x4b:
								switch (prefix) {
								case 0x66:
									vex_operand_index = 1;
									ReadCommand(cmBlendvpd, of_Vdef, of_Wdef, of_Xdef, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x63:
								switch (prefix) {
								case 0x66:
									ReadCommand(cmPcmpistri, of_Vdq, of_Wdq, of_IBb, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0xdf:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmAeskeygenassist, of_Vdq, of_Wdq, of_IBb, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							default:
								type_ = cmDB;
						}
						break;

					case 0x40: case 0x41: case 0x42: case 0x43: case 0x44: case 0x45: case 0x46: case 0x47:
					case 0x48: case 0x49: case 0x4a: case 0x4b: case 0x4c: case 0x4d: case 0x4e: case 0x4f:
						ReadFlags(code);
						ReadCommand(cmCmov, of_Gv, of_Ev, of_None, ctx);
						break;
					case 0x50:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovmskps, of_Gd, of_Udef, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovmskpd, of_Gd, of_Udef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x51:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmSqrtps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmSqrtpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								ReadCommand(cmSqrtsd, of_Vdq, of_Wq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmSqrtss, of_Vdq, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x52:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmRsqrtps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmRsqrtss, of_Vdq, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x53:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmRcpps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmRcpss, of_Vdq, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x54:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmAndps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmAndpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x55:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmAndnps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmAndnpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x56:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmOrps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmOrpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x57:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmXorps, of_Vdef, of_Wdq, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmXorpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x58:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmAddps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmAddpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmAddsd, of_Vdq, of_Wq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmAddss, of_Vdq, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x59:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmMulps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmMulpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmMulsd, of_Vdq, of_Wq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmMulss, of_Vdq, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x5a:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmCvtps2pd, of_Vdef, of_Wdq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmCvtpd2ps, of_Vdq, of_Wdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmCvtsd2ss, of_Vdq, of_Wq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmCvtss2sd, of_Vdq, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x5b:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmCvtdq2ps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmCvtps2dq, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmCvttps2dq, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x5c:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmSubps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmSubpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmSubsd, of_Vdq, of_Wq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmSubss, of_Vdq, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x5d:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmMinps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmMinpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmMinsd, of_Vdq, of_Wq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmMinss, of_Vdq, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x5e:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmDivps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmDivpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmDivsd, of_Vdq, of_Wq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmDivss, of_Vdq, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x5f:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmMaxps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmMaxpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmMaxsd, of_Vdq, of_Wq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmMaxss, of_Vdq, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x60:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPunpcklbw, of_Pq, of_Qd, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPunpcklbw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x61:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPunpcklwd, of_Pq, of_Qd, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPunpcklwd, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x62:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPunpckldq, of_Pq, of_Qd, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPunpckldq, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x63:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPacksswb, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPacksswb, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x64:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPcmpgtb, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPcmpgtb, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x65:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPcmpgtw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPcmpgtw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x66:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPcmpgtd, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPcmpgtd, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x67:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPackuswb, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPackuswb, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x68:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPunpckhbw, of_Pq, of_Qd, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPunpckhbw, of_Vdq, of_Wq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x69:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPunpckhwd, of_Pq, of_Qd, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPunpckhwd, of_Vdq, of_Wq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x6a:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPunpckhdq, of_Pq, of_Qd, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPunpckhdq, of_Vdq, of_Wq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x6b:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPackssdw, of_Pq, of_Qd, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPackssdw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x6c:
						switch (prefix) {
							case 0x66:
								ReadCommand(cmPunpcklqdq, of_Vdq, of_Wq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x6d:
						switch (prefix) {
							case 0x66:
								ReadCommand(cmPunpckhqdq, of_Vdq, of_Wq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x6e:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovd, of_Pq, of_Ex, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovd, of_Vdq, of_Ex, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x6f:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovq, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovdqa, of_Vdq, of_Wdq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovdqu, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x70:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPshufw, of_Pq, of_Qq, of_IBb, ctx);
								break;
							case 0x66:
								ReadCommand(cmPshufd, of_Vdq, of_Wdq, of_IBb, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								ReadCommand(cmPshuflw, of_Vdq, of_Wdq, of_IBb, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmPshufhw, of_Vdq, of_Wdq, of_IBb, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x71:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						switch ((code >> 3) & 7) {
							case 0x02:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPsrlw, of_Nq, of_IBb, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPsrlw, of_Udq, of_IBb, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x04:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPsraw, of_Nq, of_IBb, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPsraw, of_Udq, of_IBb, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x06:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPsllw, of_Nq, of_IBb, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPsllw, of_Udq, of_IBb, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x72:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						switch ((code >> 3) & 7) {
							case 0x02:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPsrld, of_Nq, of_IBb, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPsrld, of_Udq, of_IBb, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x04:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPsrad, of_Nq, of_IBb, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPsrad, of_Udq, of_IBb, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x06:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPslld, of_Nq, of_IBb, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPslld, of_Udq, of_IBb, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x73:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						switch ((code >> 3) & 7) {
							case 0x02:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPsrlq, of_Nq, of_IBb, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPsrlq, of_Udq, of_IBb, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x03:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPsrldq, of_Udq, of_IBb, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x06:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPsllq, of_Nq, of_IBb, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPsllq, of_Udq, of_IBb, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x07:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPslldq, of_Udq, of_IBb, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x74:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPcmpeqb, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmPcmpeqb, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x75:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPcmpeqw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmPcmpeqw, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x76:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPcmpeqd, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmPcmpeqd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x77:
						if (prefix == 0)
							if (options() & roVexPrefix) {
								type_ = ctx.rex_prefix & 0x80 ? cmVzeroall : cmVzeroupper;
							}
							else {
								type_ = cmEmms;
							}
						else
							type_ = cmDB;
						break;

					case 0x78:
						/* Stick on Intel decoding here; ignore AMD. */
						if (prefix == 0) {
							type_ = cmVmread;
							os = size_;
							code = ReadByte(file);
							ReadRM(code, os, otRegistr, false, ctx);
							ReadRegFromRM(code, os, otRegistr, ctx);
						} else {
							type_ = cmDB;
						}
						break;

					case 0x79:
						/* Stick on Intel decoding here; ignore AMD. */
						if (prefix == 0) {
							type_ = cmVmwrite;
							os = size_;
							code = ReadByte(file);
							ReadRegFromRM(code, os, otRegistr, ctx);
							ReadRM(code, os, otRegistr, false, ctx);
						} else {
							type_ = cmDB;
						}
						break;

					case 0x7c:
						switch (prefix) {
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmHaddpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmHaddps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x7d:
						switch (prefix) {
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmHsubpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmHsubps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x7e:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovd, of_Ex, of_Pq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovd, of_Ex, of_Vdq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovq, of_Vdq, of_Wq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x7f:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovq, of_Qq, of_Pq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovdqa, of_Wdq, of_Vdq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovdqu, of_Wdef, of_Vdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x80: case 0x81: case 0x82: case 0x83: case 0x84: case 0x85: case 0x86: case 0x87:
					case 0x88: case 0x89: case 0x8a: case 0x8b: case 0x8c: case 0x8d: case 0x8e: case 0x8f:
						ReadFlags(code);
						ReadCommand(cmJmpWithFlag, of_Jz, of_None, of_None, ctx);
						break;

					case 0x90: case 0x91: case 0x92: case 0x93: case 0x94: case 0x95: case 0x96: case 0x97:
					case 0x98: case 0x99: case 0x9a: case 0x9b: case 0x9c: case 0x9d: case 0x9e: case 0x9f:
						ReadFlags(code);
						ReadCommand(cmSetXX, of_Eb, of_None, of_None, ctx);
						break;
					case 0xa0:
						ReadCommand(cmPush, of_FSdef | segFS, of_None, of_None, ctx);
						break;
					case 0xa1:
						ReadCommand(cmPop, of_FSdef | segFS, of_None, of_None, ctx);
						break;
					case 0xa2:
						type_ = cmCpuid;
						break;
					case 0xa3:
						ReadCommand(cmBt, of_Ev, of_Gv, of_None, ctx);
						break;
					case 0xa4:
						ReadCommand(cmShld, of_Ev, of_Gv, of_IBb, ctx);
						break;
					case 0xa5:
						ReadCommand(cmShld, of_Ev, of_Gv, of_FGb | regECX, ctx);
						break;
					case 0xa8:
						ReadCommand(cmPush, of_FSdef | segGS, of_None, of_None, ctx);
						break;
					case 0xa9:
						ReadCommand(cmPop, of_FSdef | segGS, of_None, of_None, ctx);
						break;
					case 0xaa:
						type_ = cmRsm;
						break;
					case 0xab:
						ReadCommand(cmBts, of_Ev, of_Gv, of_None, ctx);
						break;
					case 0xac:
						ReadCommand(cmShrd, of_Ev, of_Gv, of_IBb, ctx);
						break;
					case 0xad:
						ReadCommand(cmShrd, of_Ev, of_Gv, of_FGb | regECX, ctx);
						break;
					case 0xae:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						switch ((code >> 3) & 7) {
							case 0x00:
								ReadCommand(cmFxsave, of_M, of_None, of_None, ctx);
								break;
							case 0x01:
								ReadCommand(cmFxrstor, of_M, of_None, of_None, ctx);
								break;
							case 0x02:
								ReadCommand(cmLdmxcsr, of_Md, of_None, of_None, ctx);
								break;
							case 0x03:
								ReadCommand(cmStmxcsr, of_Md, of_None, of_None, ctx);
								break;
							case 0x04:
								ReadCommand(cmXsave, of_M, of_None, of_None, ctx);
								break;
							case 0x05:
								if ((code & 0xc0) == 0xc0) {
									type_ = cmLfence;
								} else {
									ReadCommand(cmXrstor, of_M, of_None, of_None, ctx);
								}
								break;
							case 0x06:
								if ((code & 0xc0) == 0xc0) {
									type_ = cmMfence;
								} else {
									ReadCommand(cmXsaveopt, of_M, of_None, of_None, ctx);
								}
								break;
							case 0x07:
								if ((code & 0xc0) == 0xc0) {
									type_ = cmSfence;
								} else {
									ReadCommand(cmClflush, of_M, of_None, of_None, ctx);
								}
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xaf:
						ReadCommand(cmImul, of_Gv, of_Ev, of_None, ctx);
						break;
					case 0xb0:
						ReadCommand(cmCmpxchg, of_Eb, of_Gb, of_None, ctx);
						break;
					case 0xb1:
						ReadCommand(cmCmpxchg, of_Ev, of_Gv, of_None, ctx);
						break;
					case 0xb2:
						ReadCommand(cmLss, of_Gz, of_Mp, of_None, ctx);
						break;
					case 0xb3:
						ReadCommand(cmBtr, of_Ev, of_Gv, of_None, ctx);
						break;
					case 0xb4:
						ReadCommand(cmLfs, of_Gz, of_Mp, of_None, ctx);
						break;
					case 0xb5:
						ReadCommand(cmLgs, of_Gz, of_Mp, of_None, ctx);
						break;
					case 0xb6:
						ReadCommand(cmMovzx, of_Gv, of_Eb | of_size, of_None, ctx);
						break;
					case 0xb7:
						ReadCommand(cmMovzx, of_Gv, of_Ew | of_size, of_None, ctx);
						break;
					case 0xb8:
						switch (prefix) {
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmPopcnt, of_Gv, of_Ev, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xb9:
						switch (prefix) {
							case 0x00:
							case 0x66:
								type_ = cmUd1;
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xba:
						if (prefix == 0 || prefix == 0x66) {
							code = ReadByte(file);
							ctx.use_last_byte = true;
							switch ((code >> 3) & 7) { 
								case 0x04:
									ReadCommand(cmBt, of_Ev | of_size, of_IBb, of_None, ctx);
									break;
								case 0x05:
									ReadCommand(cmBts, of_Ev | of_size, of_IBb, of_None, ctx);
									break;
								case 0x06:
									ReadCommand(cmBtr, of_Ev | of_size, of_IBb, of_None, ctx);
									break;
								case 0x07:
									ReadCommand(cmBtc, of_Ev | of_size, of_IBb, of_None, ctx);
									break;
								default:
									type_ = cmDB;
									break;
							}
						} else {
							type_ = cmDB;
						}
						break;

					case 0xbb:
						switch (prefix) {
							case 0x00:
							case 0x66:
								ReadCommand(cmBtc, of_Ev, of_Gv, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0xbc:
						switch (prefix) {
							case 0x00:
							case 0x66:
								ReadCommand(cmBsf, of_Gv, of_Ev, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmTzcnt, of_Gv, of_Ev, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xbd:
						switch (prefix) {
							case 0x00:
							case 0x66:
								ReadCommand(cmBsr, of_Gv, of_Ev, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmLzcnt, of_Gv, of_Ev, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xbe:
						switch (prefix) {
							case 0x00:
							case 0x66:
								ReadCommand(cmMovsx, of_Gv, of_Eb | of_size, of_None, ctx);
								break;
							default:
								type_ = cmDB;
						}
						break;
					case 0xbf:
						switch (prefix) {
							case 0x00:
							case 0x66:
								ReadCommand(cmMovsx, of_Gv, of_Ew | of_size, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xc0:
						ReadCommand(cmXadd, of_Eb, of_Gb, of_None, ctx);
						break;
					case 0xc1:
						ReadCommand(cmXadd, of_Ev, of_Gv, of_None, ctx);
						break;
					case 0xc2:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmCmpps, of_Vdef, of_Wdef, of_IBb, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmCmppd, of_Vdef, of_Wdef, of_IBb, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmCmpsd, of_Vdq, of_Wq, of_IBb, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmCmpss, of_Vdq, of_Wd, of_IBb, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0xc3:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovnti, of_Mx, of_Gx, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0xc4:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPinsrw, of_Pq, of_Ew | of_size, of_IBb, ctx);
								break;
							case 0x66:
								ReadCommand(cmPinsrw, of_Vdq, of_Ew | of_size, of_IBb, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0xc5:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPextrw, of_Gd, of_Nq, of_IBb, ctx);
								break;
							case 0x66:
								ReadCommand(cmPextrw, of_Gd, of_Udq, of_IBb, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0xc6:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmShufps, of_Vdef, of_Wdef, of_IBb, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmShufpd, of_Vdef, of_Wdef, of_IBb, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0xc7:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						switch ((code >> 3) & 7) { 
							case 0x01:
								ReadCommand(cmCmpxchg8b, of_Mq, of_None, of_None, ctx);
								break;
							case 0x06:
								if (code && 0xc0 == 0xc0)
									ReadCommand(cmRdrand, of_Zv | code, of_None, of_None, ctx);
								else
									ReadCommand(cmVmptrld, of_Mq, of_None, of_None, ctx);
								break;
							case 0x07:
								if (code && 0xc0 == 0xc0)
									ReadCommand(cmRdseed, of_Zv | code, of_None, of_None, ctx);
								else
									ReadCommand(cmVmptrst, of_Mq, of_None, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0xc8: case 0xc9: case 0xca: case 0xcb: case 0xcc: case 0xcd: case 0xce: case 0xcf:
						ReadCommand(cmBswap, of_Zv | code, of_None, of_None, ctx);
						break;
					case 0xd0:
						switch (prefix) {
							case 0x66:
								ReadCommand(cmAddsubpd, of_Vdq, of_Wdq, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								ReadCommand(cmAddsubps, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xd1:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsrlw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsrlw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xd2:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsrld, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsrld, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xd3:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsrlq, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsrlq, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xd4:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPaddq, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPaddq, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xd5:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPmullw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPmullw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xd6:
						switch (prefix) {
							case 0x66:
								ReadCommand(cmMovq, of_Wq, of_Vdq, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovdq2q, of_Pq, of_Udq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovq2dq, of_Vdq, of_Nq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xd7:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPmovmskb, of_Gd, of_Nq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPmovmskb, of_Gd, of_Udq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xd8:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsubusb, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsubusb, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xd9:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsubusw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsubusw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xda:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPminub, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPminub, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xdb:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPand, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPand, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xdc:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPaddusb, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPaddusb, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xdd:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPaddusw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPaddusw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xde:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPmaxub, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPmaxub, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xdf:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPandn, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPandn, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xe0:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPavgb, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPavgb, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xe1:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsraw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsraw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xe2:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsrad, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsrad, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xe3:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPavgw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPavgw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xe4:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPmulhuw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPmulhuw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xe5:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPmulhw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPmulhw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xe6:
						switch (prefix) {
							case 0x66:
								ReadCommand(cmCvttpd2dq, of_Vdq, of_Wdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								ReadCommand(cmCvtpd2dq, of_Vdq, of_Wdef, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmCvtdq2pd, of_Vdef, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xe7:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovntq, of_Mq, of_Pq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovntdq, of_Mdq, of_Vdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xe8:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsubsb, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsubsb, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xe9:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsubsw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsubsw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xea:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPminsw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPminsw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xeb:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPor, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPor, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xec:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPaddsb, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPaddsb, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xed:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPaddsw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPaddsw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xee:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPmaxsw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPmaxsw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xef:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPxor, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmPxor, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0xf0:
						switch (prefix) {
							case 0xF2:
								preffix_command_ = cmUnknown;
								ReadCommand(cmLddqu, of_Vdef, of_Mdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0xf1:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsllw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsllw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xf2:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPslld, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPslld, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xf3:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsllq, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsllq, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xf4:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPmuludq, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPmuludq, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xf5:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPmaddwd, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPmaddwd, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xf6:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsadbw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsadbw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xf7:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMaskmovq, of_Pq, of_Nq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMaskmovdqu, of_Vdq, of_Udq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xf8:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsubb, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsubb, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xf9:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsubw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsubw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xfa:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsubd, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsubd, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xfb:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsubq, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsubq, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xfc:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPaddb, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPaddb, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xfd:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPaddw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPaddw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xfe:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPaddd, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPaddd, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xff:
						type_ = cmUd0;
						break;

					default:
						type_ = cmDB;
						break;
			}
			break;

			// End

			case 0x10:
				ReadCommand(cmAdc, of_Eb, of_Gb, of_None, ctx);
				break;
			case 0x11:
				ReadCommand(cmAdc, of_Ev, of_Gv, of_None, ctx);
				break;
			case 0x12:
				ReadCommand(cmAdc, of_Gb, of_Eb, of_None, ctx);
				break;
			case 0x13:
				ReadCommand(cmAdc, of_Gv, of_Ev, of_None, ctx);
				break;
			case 0x14:
				ReadCommand(cmAdc, of_FGb | regEAX, of_IBb, of_None, ctx);
				break;
			case 0x15:
				ReadCommand(cmAdc, of_FGv | regEAX, of_IZv, of_None, ctx);
				break;
			case 0x16:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					ReadCommand(cmPush, of_FSdef | segSS, of_None, of_None, ctx);
				}
				break;
			case 0x17:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					ReadCommand(cmPop, of_FSdef | segSS, of_None, of_None, ctx);
				}
				break;
			case 0x18:
				ReadCommand(cmSbb, of_Eb, of_Gb, of_None, ctx);
				break;
			case 0x19:
				ReadCommand(cmSbb, of_Ev, of_Gv, of_None, ctx);
				break;
			case 0x1a:
				ReadCommand(cmSbb, of_Gb, of_Eb, of_None, ctx);
				break;
			case 0x1b:
				ReadCommand(cmSbb, of_Gv, of_Ev, of_None, ctx);
				break;
			case 0x1c:
				ReadCommand(cmSbb, of_FGb | regEAX, of_IBb, of_None, ctx);
				break;
			case 0x1d: 
				ReadCommand(cmSbb, of_FGv | regEAX, of_IZv, of_None, ctx);
				break;
			case 0x1e:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					ReadCommand(cmPush, of_FSdef | segDS, of_None, of_None, ctx);
				}
				break;
			case 0x1f:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					ReadCommand(cmPop, of_FSdef | segDS, of_None, of_None, ctx);
				}
				break;
			case 0x20:
				ReadCommand(cmAnd, of_Eb, of_Gb, of_None, ctx);
				break;
			case 0x21:
				ReadCommand(cmAnd, of_Ev, of_Gv, of_None, ctx);
				break;
			case 0x22:
				ReadCommand(cmAnd, of_Gb, of_Eb, of_None, ctx);
				break;
			case 0x23:
				ReadCommand(cmAnd, of_Gv, of_Ev, of_None, ctx);
				break;
			case 0x24:
				ReadCommand(cmAnd, of_FGb | regEAX, of_IBb, of_None, ctx);
				break;
			case 0x25:
				ReadCommand(cmAnd, of_FGv | regEAX, of_IZv, of_None, ctx);
				break;
			case 0x26:
				base_segment_ = segES;
				ctx.rex_prefix = 0;
				break;
			case 0x27:
				type_ = (size_ == osQWord) ? cmDB : cmDaa;
				break;
			case 0x28:
				ReadCommand(cmSub, of_Eb, of_Gb, of_None, ctx);
				break;
			case 0x29:
				ReadCommand(cmSub, of_Ev, of_Gv, of_None, ctx);
				break;
			case 0x2a:
				ReadCommand(cmSub, of_Gb, of_Eb, of_None, ctx);
				break;
			case 0x2b:
				ReadCommand(cmSub, of_Gv, of_Ev, of_None, ctx);
				break;
			case 0x2c:
				ReadCommand(cmSub, of_FGb | regEAX, of_IBb, of_None, ctx);
				break;
			case 0x2d:
				ReadCommand(cmSub, of_FGv | regEAX, of_IZv, of_None, ctx);
				break;
			case 0x2e:
				base_segment_ = segCS; ctx.rex_prefix = 0;
				break;
			case 0x2f:
				type_ = (size_ == osQWord) ? cmDB : cmDas;
				break;
			case 0x30:
				ReadCommand(cmXor, of_Eb, of_Gb, of_None, ctx);
				break;
			case 0x31:
				ReadCommand(cmXor, of_Ev, of_Gv, of_None, ctx);
				break;
			case 0x32:
				ReadCommand(cmXor, of_Gb, of_Eb, of_None, ctx);
				break;
			case 0x33:
				ReadCommand(cmXor, of_Gv, of_Ev, of_None, ctx);
				break;
			case 0x34:
				ReadCommand(cmXor, of_FGb | regEAX, of_IBb, of_None, ctx);
				break;
			case 0x35:
				ReadCommand(cmXor, of_FGv | regEAX, of_IZv, of_None, ctx);
				break;
			case 0x36:
				base_segment_ = segSS;
				ctx.rex_prefix = 0;
				break;
			case 0x37:
				type_ = (size_ == osQWord) ? cmDB : cmAaa;
				break;
			case 0x38:
				ReadCommand(cmCmp, of_Eb, of_Gb, of_None, ctx);
				break;
			case 0x39:
				ReadCommand(cmCmp, of_Ev, of_Gv, of_None, ctx);
				break;
			case 0x3a:
				ReadCommand(cmCmp, of_Gb, of_Eb, of_None, ctx);
				break;
			case 0x3b:
				ReadCommand(cmCmp, of_Gv, of_Ev, of_None, ctx);
				break;
			case 0x3c:
				ReadCommand(cmCmp, of_FGb | regEAX, of_IBb, of_None, ctx);
				break;
			case 0x3d:
				ReadCommand(cmCmp, of_FGv | regEAX, of_IZv, of_None, ctx);
				break;
			case 0x3e:
				base_segment_ = segDS;
				ctx.rex_prefix = 0;
				break;
			case 0x3f:
				type_ = (size_ == osQWord) ? cmDB : cmAas;
				break;
			case 0x40: case 0x41: case 0x42: case 0x43: case 0x44: case 0x45: case 0x46: case 0x47:
				if (size_ == osQWord) {
					ctx.rex_prefix = code;
				} else {
					ReadCommand(cmInc, of_Zdef | code, of_None, of_None, ctx);
				}
				break;
			case 0x48: case 0x49: case 0x4a: case 0x4b: case 0x4c: case 0x4d: case 0x4e: case 0x4f:
				if (size_ == osQWord) {
					ctx.rex_prefix = code;
				} else {
					ReadCommand(cmDec, of_Zdef | code, of_None, of_None, ctx);
				}
				break;
			case 0x50: case 0x51: case 0x52: case 0x53: case 0x54: case 0x55: case 0x56: case 0x57:
				ReadCommand(cmPush, of_Zdef | code, of_None, of_None, ctx);
				break;
			case 0x58: case 0x59: case 0x5a: case 0x5b: case 0x5c: case 0x5d: case 0x5e: case 0x5f:
				ReadCommand(cmPop, of_Zdef | code, of_None, of_None, ctx);
				break;
			case 0x60:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					ReadCommand(cmPusha, of_def, of_None, of_None, ctx);
				}
				break;
			case 0x61:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					ReadCommand(cmPopa, of_def, of_None, of_None, ctx);
				}
				break;
			case 0x62:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					ReadCommand(cmBound, of_Gv, of_Ma, of_None, ctx);
				}
				break;
			case 0x63:
				if (size_ == osQWord) {
					ReadCommand(cmMovsxd, of_Gv, of_Ed | of_size, of_None, ctx);
				} else {
					ReadCommand(cmArpl, of_Ew, of_Gw, of_None, ctx);
				}
				break;
			case 0x64:
				base_segment_ = segFS;
				ctx.rex_prefix = 0;
				break;
			case 0x65:
				base_segment_ = segGS;
				ctx.rex_prefix = 0;
				break;
			case 0x66:
				ctx.lower_reg = true;
				if (prefix == 0)
					prefix = code;
				break;
			case 0x67:
				ctx.lower_address = true;
				break;
			case 0x68:
				ReadCommand(cmPush, of_IZ | of_def, of_None, of_None, ctx);
				break;
			case 0x69:
				ReadCommand(cmImul, of_Gv, of_Ev, of_IZv, ctx);
				break;
			case 0x6a:
				ReadCommand(cmPush, of_IB | of_def, of_None, of_None, ctx);
				break;
			case 0x6b:
				ReadCommand(cmImul, of_Gv, of_Ev, of_IBv, ctx);
				break;
			case 0x6c:
				ReadCommand(cmIns, of_b, of_adr, of_None, ctx);
				break;
			case 0x6d:
				ReadCommand(cmIns, of_z, of_adr, of_None, ctx);
				break;
			case 0x6e:
				ReadCommand(cmOuts, of_b, of_adr, of_None, ctx);
				break;
			case 0x6f:
				ReadCommand(cmOuts, of_z, of_adr, of_None, ctx);
				break;
			case 0x70: case 0x71: case 0x72: case 0x73: case 0x74: case 0x75: case 0x76: case 0x77:
			case 0x78: case 0x79: case 0x7a: case 0x7b: case 0x7c: case 0x7d: case 0x7e: case 0x7f:
				ReadFlags(code);
				ReadCommand(cmJmpWithFlag, of_Jb, of_adr, of_None, ctx);
				break;
			case 0x80:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmAdd, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x01:
						ReadCommand(cmOr, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x02:
						ReadCommand(cmAdc, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x03:
						ReadCommand(cmSbb, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x04:
						ReadCommand(cmAnd, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x05:
						ReadCommand(cmSub, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x06:
						ReadCommand(cmXor, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x07:
						ReadCommand(cmCmp, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0x81:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmAdd, of_Ev | of_size, of_IZv, of_None, ctx);
						break;
					case 0x01:
						ReadCommand(cmOr, of_Ev | of_size, of_IZv, of_None, ctx);
						break;
					case 0x02:
						ReadCommand(cmAdc, of_Ev | of_size, of_IZv, of_None, ctx);
						break;
					case 0x03:
						ReadCommand(cmSbb, of_Ev | of_size, of_IZv, of_None, ctx);
						break;
					case 0x04:
						ReadCommand(cmAnd, of_Ev | of_size, of_IZv, of_None, ctx);
						break;
					case 0x05:
						ReadCommand(cmSub, of_Ev | of_size, of_IZv, of_None, ctx);
						break;
					case 0x06:
						ReadCommand(cmXor, of_Ev | of_size, of_IZv, of_None, ctx);
						break;
					case 0x07:
						ReadCommand(cmCmp, of_Ev | of_size, of_IZv, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0x82:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					code = ReadByte(file);
					ctx.use_last_byte = true;
					switch ((code >> 3) & 7) {
						case 0x00:
							ReadCommand(cmAdd, of_Eb | of_size, of_IBb, of_None, ctx);
							break;
						case 0x01:
							ReadCommand(cmOr, of_Eb | of_size, of_IBb, of_None, ctx);
							break;
						case 0x02:
							ReadCommand(cmAdc, of_Eb | of_size, of_IBb, of_None, ctx);
							break;
						case 0x03:
							ReadCommand(cmSbb, of_Eb | of_size, of_IBb, of_None, ctx);
							break;
						case 0x04:
							ReadCommand(cmAnd, of_Eb | of_size, of_IBb, of_None, ctx);
							break;
						case 0x05:
							ReadCommand(cmSub, of_Eb | of_size, of_IBb, of_None, ctx);
							break;
						case 0x06:
							ReadCommand(cmXor, of_Eb | of_size, of_IBb, of_None, ctx);
							break;
						case 0x07:
							ReadCommand(cmCmp, of_Eb | of_size, of_IBb, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				}
				break;
			case 0x83:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmAdd, of_Ev | of_size, of_IBv, of_None, ctx);
						break;
					case 0x01:
						ReadCommand(cmOr, of_Ev | of_size, of_IBv, of_None, ctx);
						break;
					case 0x02:
						ReadCommand(cmAdc, of_Ev | of_size, of_IBv, of_None, ctx);
						break;
					case 0x03:
						ReadCommand(cmSbb, of_Ev | of_size, of_IBv, of_None, ctx);
						break;
					case 0x04:
						ReadCommand(cmAnd, of_Ev | of_size, of_IBv, of_None, ctx);
						break;
					case 0x05:
						ReadCommand(cmSub, of_Ev | of_size, of_IBv, of_None, ctx);
						break;
					case 0x06:
						ReadCommand(cmXor, of_Ev | of_size, of_IBv, of_None, ctx);
						break;
					case 0x07:
						ReadCommand(cmCmp, of_Ev | of_size, of_IBv, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0x84:
				ReadCommand(cmTest, of_Eb, of_Gb, of_None, ctx);
				break;
			case 0x85:
				ReadCommand(cmTest, of_Ev, of_Gv, of_None, ctx);
				break;
			case 0x86:
				ReadCommand(cmXchg, of_Eb, of_Gb, of_None, ctx);
				break;
			case 0x87:
				ReadCommand(cmXchg, of_Ev, of_Gv, of_None, ctx);
				break;
			case 0x88:
				ReadCommand(cmMov, of_Eb, of_Gb, of_None, ctx);
				break;
			case 0x89:
				ReadCommand(cmMov, of_Ev, of_Gv, of_None, ctx);
				break;
			case 0x8a:
				ReadCommand(cmMov, of_Gb, of_Eb, of_None, ctx);
				break;
			case 0x8b:
				ReadCommand(cmMov, of_Gv, of_Ev, of_None, ctx);
				break;
			case 0x8c:
				ReadCommand(cmMov, of_Ev | of_mem_word, of_Sw, of_None, ctx);
				break;
			case 0x8d:
				ReadCommand(cmLea, of_Gv, of_Mv, of_None, ctx);
				break;
			case 0x8e:
				ReadCommand(cmMov, of_Sw, of_Ew, of_None, ctx);
				break;
			case 0x8f:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmPop, of_Edef | of_size, of_None, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0x90:
				if (prefix == 0xF3) {
					preffix_command_ = cmUnknown;
					type_ = cmPause;
				} else {
					if (size_ == osQWord && (ctx.rex_prefix & rexB) != 0) {
						ReadCommand(cmXchg, of_Zv | regEAX, of_FGv | regEAX, of_None, ctx);
					} else {
						type_ = cmNop;
					}
				}
				break;
			case 0x91: case 0x92: case 0x93: case 0x94: case 0x95: case 0x96: case 0x97:
				ReadCommand(cmXchg, of_Zv | code, of_FGv | regEAX, of_None, ctx);
				break;
			case 0x98:
				os = GetOperandSize(1, ctx);
				switch (os) {
					case osWord:
						type_ = cmCbw;
						break;
					case osDWord:
						type_ = cmCwde;
						break;
					default:
						type_ = cmCdqe;
						break;
				}
				break;
			case 0x99:
				os = GetOperandSize(1, ctx);
				switch (os) {
					case osWord:
						type_ = cmCwd;
						break;
					case osDWord:
						type_ = cmCdq;
						break;
					default:
						type_ = cmCqo;
						break;
				}
				break;
			case 0x9a:
				if (size_ == osQWord) 
					type_ = cmDB;
				else {
					include_option(roFar);
					ReadCommand(cmCall, of_Ap, of_None, of_None, ctx);
				}
				break;
			case 0x9b:
				type_ = cmWait;
				{
					Data old_dump;
					for (i = 0; i < dump_size(); i++) {
						old_dump.PushByte(dump(i));
					}
					uint64_t pos = file.Tell();
					code = ReadByte(file);
					switch (code) {
					case 0xd9:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						if ((code & 0xc0) != 0xc0) {
							switch ((code >> 3) & 7) {
							case 0x06:
								ReadCommand(cmFstenv, of_Mb, of_None, of_None, ctx);
								break;
							case 0x07:
								ReadCommand(cmFstcw, of_Mw | of_size, of_None, of_None, ctx);
								break;
							}
						}
						break;
					case 0xdb:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						switch (code) {
						case 0xe2:
							type_ = cmFclex;
							break;
						case 0xe3:
							type_ = cmFinit;
							break;
						}
						break;
					case 0xdd:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						if ((code & 0xc0) != 0xc0) {
							switch ((code >> 3) & 7) {
							case 0x06:
								ReadCommand(cmFsave, of_Mb, of_None, of_None, ctx);
								break;
							case 0x07:
								ReadCommand(cmFstsw, of_Mw | of_size, of_None, of_None, ctx);
								break;
							}
						}
						break;
					case 0xdf:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						if (code == 0xe0)
							ReadCommand(cmFstsw, of_FGw | regEAX, of_None, of_None, ctx);
						break;
					}
					if (type_ == cmWait) {
						set_dump(old_dump.data(), old_dump.size());
						file.Seek(pos);
					}
				}
				break;
			case 0x9c:
				ReadCommand(cmPushf, of_def, of_None, of_None, ctx);
				break;
			case 0x9d:
				ReadCommand(cmPopf, of_def, of_None, of_None, ctx);
				break;
			case 0x9e:
				ReadCommand(cmSahf, of_b, of_None, of_None, ctx);
				break;
			case 0x9f:
				ReadCommand(cmLahf, of_b, of_None, of_None, ctx);
				break;
			case 0xa0:
				ReadCommand(cmMov, of_FGb | regEAX, of_Ob, of_None, ctx);
				break;
			case 0xa1:
				ReadCommand(cmMov, of_FGv | regEAX, of_Ov, of_None, ctx);
				break;
			case 0xa2:
				ReadCommand(cmMov, of_Ob, of_FGb | regEAX, of_None, ctx);
				break;
			case 0xa3:
				ReadCommand(cmMov, of_Ov, of_FGv | regEAX, of_None, ctx);
				break;
			case 0xa4:
				ReadCommand(cmMovs, of_b, of_adr, of_None, ctx);
				break;
			case 0xa5:
				ReadCommand(cmMovs, of_v, of_adr, of_None, ctx);
				break;
			case 0xa6:
				ReadCommand(cmCmps, of_b, of_adr, of_None, ctx);
				break;
			case 0xa7:
				ReadCommand(cmCmps, of_v, of_adr, of_None, ctx);
				break;
			case 0xa8:
				ReadCommand(cmTest, of_FGb | regEAX, of_IBb, of_None, ctx);
				break;
			case 0xa9:
				ReadCommand(cmTest, of_FGv | regEAX, of_IZv, of_None, ctx);
				break;
			case 0xaa:
				ReadCommand(cmStos, of_b, of_adr, of_None, ctx);
				break;
			case 0xab:
				ReadCommand(cmStos, of_v, of_adr, of_None, ctx);
				break;
			case 0xac:
				ReadCommand(cmLods, of_b, of_adr, of_None, ctx);
				break;
			case 0xad:
				ReadCommand(cmLods, of_v, of_adr, of_None, ctx);
				break;
			case 0xae:
				ReadCommand(cmScas, of_b, of_adr, of_None, ctx);
				break;
			case 0xaf:
				ReadCommand(cmScas, of_v, of_adr, of_None, ctx);
				break;
			case 0xb0: case 0xb1: case 0xb2: case 0xb3: case 0xb4: case 0xb5: case 0xb6: case 0xb7:
				ReadCommand(cmMov, of_Zb | code, of_IBb, of_None, ctx);
				break;
			case 0xb8: case 0xb9: case 0xba: case 0xbb: case 0xbc: case 0xbd: case 0xbe: case 0xbf:
				ReadCommand(cmMov, of_Zv | code, of_IVv, of_None, ctx);
				break;
			case 0xc0:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmRol, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x01:
						ReadCommand(cmRor, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x02:
						ReadCommand(cmRcl, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x03:
						ReadCommand(cmRcr, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x04:
						ReadCommand(cmShl, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x05:
						ReadCommand(cmShr, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x06:
						ReadCommand(cmSal, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x07:
						ReadCommand(cmSar, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0xc1:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmRol, of_Ev | of_size, of_IBb, of_None, ctx);
						break;
					case 0x01:
						ReadCommand(cmRor, of_Ev | of_size, of_IBb, of_None, ctx);
						break;
					case 0x02:
						ReadCommand(cmRcl, of_Ev | of_size, of_IBb, of_None, ctx);
						break;
					case 0x03:
						ReadCommand(cmRcr, of_Ev | of_size, of_IBb, of_None, ctx);
						break;
					case 0x04:
						ReadCommand(cmShl, of_Ev | of_size, of_IBb, of_None, ctx);
						break;
					case 0x05:
						ReadCommand(cmShr, of_Ev | of_size, of_IBb, of_None, ctx);
						break;
					case 0x06:
						ReadCommand(cmSal, of_Ev | of_size, of_IBb, of_None, ctx);
						break;
					case 0x07:
						ReadCommand(cmSar, of_Ev | of_size, of_IBb, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0xc2:
				ReadCommand(cmRet, of_IWw, of_None, of_None, ctx);
				break;
			case 0xc3:
				type_ = cmRet;
				break;
			case 0xc4:
				code = ReadByte(file);
				if (size_ == osDWord && (code & 0xc0) == 0) {
					ctx.use_last_byte = true;
					ReadCommand(cmLes, of_Gz, of_Mp, of_None, ctx);
				} else {
					if (prefix || ctx.rex_prefix || (options() & roLockPrefix))
						type_ = cmDB;
					else {
						include_option(roVexPrefix);
						uint8_t vex_1 = code;
						uint8_t vex_2 = ReadByte(file);
						switch (vex_1 & 0x1f) {
						case 1:
							vex_bytes[0] = 0x0f;
							break;
						case 2:
							vex_bytes[0] = 0x0f;
							vex_bytes[1] = 0x38;
							break;
						case 3:
							vex_bytes[0] = 0x0f;
							vex_bytes[1] = 0x3a;
							break;
						default:
							type_ = cmDB;
						}
						switch (vex_2 & 3) {
						case 1:
							prefix = 0x66;
							break;
						case 2:
							prefix = 0xf3;
							break;
						case 3:
							prefix = 0xf2;
							break;
						}
						ctx.rex_prefix = static_cast<uint8_t>(~vex_1) >> 5; // REX.RXB
						ctx.rex_prefix |= (vex_2 & 0x80) >> 4; // REX.W
						ctx.rex_prefix |= (vex_2 & 4) << 5; // VEX.L
						ctx.vex_registr = ((~vex_2) >> 3) & 0xf;
					}
				}
				break;
			case 0xc5:
				code = ReadByte(file);
				if (size_ == osDWord && (code & 0xc0) == 0) {
					ctx.use_last_byte = true;
					ReadCommand(cmLds, of_Gz, of_Mp, of_None, ctx);
				} else {
					if (prefix || ctx.rex_prefix || (options() & roLockPrefix))
						type_ = cmDB;
					else {
						include_option(roVexPrefix);
						uint8_t vex_1 = code;
						vex_bytes[0] = 0x0f;
						switch (vex_1 & 3) {
						case 1:
							prefix = 0x66;
							break;
						case 2:
							prefix = 0xf3;
							break;
						case 3:
							prefix = 0xf2;
							break;
						}
						ctx.rex_prefix = (static_cast<uint8_t>(~vex_1) & 0x80) >> 5;  // REX.R
						ctx.rex_prefix |= (vex_1 & 4) << 5; // VEX.L
						ctx.vex_registr = ((~vex_1) >> 3) & 0xf;
					}
				}
				break;
			case 0xc6:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmMov, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0xc7:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmMov, of_Ev | of_size, of_IZv, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0xc8:
				ReadCommand(cmEnter, of_IWw, of_IBb, of_None, ctx);
				break;
			case 0xc9:
				type_ = cmLeave;
				break;
			case 0xca:
				include_option(roFar);
				ReadCommand(cmRet, of_IWw, of_None, of_None, ctx);
				break;
			case 0xcb:
				include_option(roFar);
				type_ = cmRet;
				break;
			case 0xcc:
				ReadCommand(cmInt, of_FIb | 3, of_None, of_None, ctx);
				break;
			case 0xcd:
				ReadCommand(cmInt, of_IBb, of_None, of_None, ctx);
				break;
			case 0xce:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					type_ = cmInto;
				}
				break;
			case 0xcf:
				ReadCommand(cmIret, of_v, of_None, of_None, ctx);
				break;
			case 0xd0:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmRol, of_Eb | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x01:
						ReadCommand(cmRor, of_Eb | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x02:
						ReadCommand(cmRcl, of_Eb | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x03:
						ReadCommand(cmRcr, of_Eb | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x04:
						ReadCommand(cmShl, of_Eb | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x05:
						ReadCommand(cmShr, of_Eb | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x06:
						ReadCommand(cmSal, of_Eb | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x07:
						ReadCommand(cmSar, of_Eb | of_size, of_FIb | 1, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0xd1:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmRol, of_Ev | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x01:
						ReadCommand(cmRor, of_Ev | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x02:
						ReadCommand(cmRcl, of_Ev | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x03:
						ReadCommand(cmRcr, of_Ev | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x04:
						ReadCommand(cmShl, of_Ev | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x05:
						ReadCommand(cmShr, of_Ev | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x06:
						ReadCommand(cmSal, of_Ev | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x07:
						ReadCommand(cmSar, of_Ev | of_size, of_FIb | 1, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0xd2:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmRol, of_Eb | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x01:
						ReadCommand(cmRor, of_Eb | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x02:
						ReadCommand(cmRcl, of_Eb | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x03:
						ReadCommand(cmRcr, of_Eb | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x04:
						ReadCommand(cmShl, of_Eb | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x05:
						ReadCommand(cmShr, of_Eb | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x06:
						ReadCommand(cmSal, of_Eb | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x07:
						ReadCommand(cmSar, of_Eb | of_size, of_FGb | regECX, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0xd3:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmRol, of_Ev | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x01:
						ReadCommand(cmRor, of_Ev | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x02:
						ReadCommand(cmRcl, of_Ev | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x03:
						ReadCommand(cmRcr, of_Ev | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x04:
						ReadCommand(cmShl, of_Ev | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x05:
						ReadCommand(cmShr, of_Ev | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x06:
						ReadCommand(cmSal, of_Ev | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x07:
						ReadCommand(cmSar, of_Ev | of_size, of_FGb | regECX, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0xd4:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					ReadCommand(cmAam, of_IBb, of_None, of_None, ctx);
				}
				break;
			case 0xd5:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					ReadCommand(cmAad, of_IBb, of_None, of_None, ctx);
				}
				break;
			case 0xd7:
				ReadCommand(cmXlat, of_adr, of_None, of_None, ctx);
				break;
			case 0xd8:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				if ((code & 0xc0) != 0xc0) {
					switch ((code >> 3) & 7) {
						case 0x00:
							ReadCommand(cmFadd, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x01:
							ReadCommand(cmFmul, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x02:
							ReadCommand(cmFcom, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x03:
							ReadCommand(cmFcomp, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x04:
							ReadCommand(cmFsub, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x05:
							ReadCommand(cmFsubr, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x06:
							ReadCommand(cmFdiv, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x07:
							ReadCommand(cmFdivr, of_Md | of_size, of_None, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				} else {
					switch ((code >> 3) & 7) {
						case 0x00:
							ReadCommand(cmFadd, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0x01:
							ReadCommand(cmFmul, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0x02:
							ReadCommand(cmFcom, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0x03:
							ReadCommand(cmFcomp, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0x04:
							ReadCommand(cmFsub, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0x05:
							ReadCommand(cmFsubr, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0x06:
							ReadCommand(cmFdiv, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0x07:
							ReadCommand(cmFdivr, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				}
				break;
			case 0xd9:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				if ((code & 0xc0) != 0xc0) {
					switch ((code >> 3) & 7) {
						case 0x00:
							ReadCommand(cmFld, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x02:
							ReadCommand(cmFst, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x03:
							ReadCommand(cmFstp, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x04:
							ReadCommand(cmFldenv, of_Mb, of_None, of_None, ctx);
							break;
						case 0x05:
							ReadCommand(cmFldcw, of_Mw | of_size, of_None, of_None, ctx);
							break;
						case 0x06:
							ReadCommand(cmFnstenv, of_Mb, of_None, of_None, ctx);
							break;
						case 0x07:
							ReadCommand(cmFnstcw, of_Mw | of_size, of_None, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				} else {
					switch (code) {
						case 0xc0: case 0xc1: case 0xc2: case 0xc3: 
						case 0xc4: case 0xc5: case 0xc6: case 0xc7:
							ReadCommand(cmFld, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0xc8: case 0xc9: case 0xca: case 0xcb:
						case 0xcc: case 0xcd: case 0xce: case 0xcf:
							ReadCommand(cmFxch, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0xd0:
							type_ = cmFnop;
							break;
						case 0xd8: case 0xd9: case 0xda: case 0xdb:
						case 0xdc: case 0xdd: case 0xde: case 0xdf:
							ReadCommand(cmFstp1, of_ST | code, of_None, of_None, ctx);
							break;
						case 0xe0:
							type_ = cmFchs;
							break;
						case 0xe1:
							type_ = cmFabs;
							break;
						case 0xe4:
							type_ = cmFtst;
							break;
						case 0xe5:
							type_ = cmFxam;
							break;
						case 0xe8:
							type_ = cmFld1;
							break;
						case 0xe9:
							type_ = cmFldl2t;
							break;
						case 0xea:
							type_ = cmFldl2e;
							break;
						case 0xeb:
							type_ = cmFldpi;
							break;
						case 0xec:
							type_ = cmFldlg2;
							break;
						case 0xed:
							type_ = cmFldln2;
							break;
						case 0xee:
							type_ = cmFldz;
							break;
						case 0xf0:
							type_ = cmF2xm1;
							break;
						case 0xf1:
							type_ = cmFyl2x;
							break;
						case 0xf2:
							type_ = cmFptan;
							break;
						case 0xf3:
							type_ = cmFpatan;
							break;
						case 0xf4:
							type_ = cmFxtract;
							break;
						case 0xf5:
							type_ = cmFprem1;
							break;
						case 0xf6:
							type_ = cmFdecstp;
							break;
						case 0xf7:
							type_ = cmFincstp;
							break;
						case 0xf8:
							type_ = cmFprem;
							break;
						case 0xf9:
							type_ = cmFyl2xp1;
							break;
						case 0xfa:
							type_ = cmFsqrt;
							break;
						case 0xfb:
							type_ = cmFsincos;
							break;
						case 0xfc:
							type_ = cmFrndint;
							break;
						case 0xfd:
							type_ = cmFscale;
							break;
						case 0xfe:
							type_ = cmFsin;
							break;
						case 0xff:
							type_ = cmFcos;
							break;
						default:
							type_ = cmDB;
							break;
					}
				}
				break;
			case 0xda:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				if ((code & 0xc0) != 0xc0) {
					switch ((code >> 3) & 7) {
						case 0x00:
							ReadCommand(cmFiadd, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x01:
							ReadCommand(cmFimul, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x02:
							ReadCommand(cmFicom, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x03:
							ReadCommand(cmFicomp, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x04:
							ReadCommand(cmFisub, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x05:
							ReadCommand(cmFisubr, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x06:
							ReadCommand(cmFidiv, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x07:
							ReadCommand(cmFidivr, of_Md | of_size, of_None, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				} else {
					switch (code) {
						case 0xc0: case 0xc1: case 0xc2: case 0xc3: 
						case 0xc4: case 0xc5: case 0xc6: case 0xc7:
							ReadCommand(cmFcmovb, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0xc8: case 0xc9: case 0xca: case 0xcb: 
						case 0xcc: case 0xcd: case 0xce: case 0xcf:
							ReadCommand(cmFcmove, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0xd0: case 0xd1: case 0xd2: case 0xd3: 
						case 0xd4: case 0xd5: case 0xd6: case 0xd7:
							ReadCommand(cmFcmovbe, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0xd8: case 0xd9: case 0xda: case 0xdb: 
						case 0xdc: case 0xdd: case 0xde: case 0xdf:
							ReadCommand(cmFcmovu, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0xe9:
							type_ = cmFucompp;
							break;
						default:
							type_ = cmDB;
							break;
					}
				}
				break;
			case 0xdb:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				if ((code & 0xc0) != 0xc0) {
					switch ((code >> 3) & 7) {
						case 0x00:
							ReadCommand(cmFild, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x01:
							ReadCommand(cmFisttp, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x02:
							ReadCommand(cmFist, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x03:
							ReadCommand(cmFistp, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x05:
							ReadCommand(cmFld, of_Mt | of_size, of_None, of_None, ctx);
							break;
						case 0x07:
							ReadCommand(cmFstp, of_Mt | of_size, of_None, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				} else {
					switch (code) {
						case 0xc0: case 0xc1: case 0xc2: case 0xc3: 
						case 0xc4: case 0xc5: case 0xc6: case 0xc7:
							ReadCommand(cmFcmovnb, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0xc8: case 0xc9: case 0xca: case 0xcb: 
						case 0xcc: case 0xcd: case 0xce: case 0xcf:
							ReadCommand(cmFcmovne, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0xd0: case 0xd1: case 0xd2: case 0xd3: 
						case 0xd4: case 0xd5: case 0xd6: case 0xd7:
							ReadCommand(cmFcmovnbe, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0xd8: case 0xd9: case 0xda: case 0xdb: 
						case 0xdc: case 0xdd: case 0xde: case 0xdf:
							ReadCommand(cmFcmovnu, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0xe2:
							type_ = cmFnclex;
							break;
						case 0xe3:
							type_ = cmFninit;
							break;
						case 0xe8: case 0xe9: case 0xea: case 0xeb: 
						case 0xec: case 0xed: case 0xee: case 0xef:
							ReadCommand(cmFucomi, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0xf0: case 0xf1: case 0xf2: case 0xf3: 
						case 0xf4: case 0xf5: case 0xf6: case 0xf7:
							ReadCommand(cmFcomi, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				}
				break;
			case 0xdc:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				if ((code & 0xc0) != 0xc0) {
					switch ((code >> 3) & 7) {
						case 0x00:
							ReadCommand(cmFadd, of_Mq | of_size, of_None, of_None, ctx);
							break;
						case 0x01:
							ReadCommand(cmFmul, of_Mq | of_size, of_None, of_None, ctx);
							break;
						case 0x02:
							ReadCommand(cmFcom, of_Mq | of_size, of_None, of_None, ctx);
							break;
						case 0x03:
							ReadCommand(cmFcomp, of_Mq | of_size, of_None, of_None, ctx);
							break;
						case 0x04:
							ReadCommand(cmFsub, of_Mq | of_size, of_None, of_None, ctx);
							break;
						case 0x05:
							ReadCommand(cmFsubr, of_Mq | of_size, of_None, of_None, ctx);
							break;
						case 0x06:
							ReadCommand(cmFdiv, of_Mq | of_size, of_None, of_None, ctx);
							break;
						case 0x07:
							ReadCommand(cmFdivr, of_Mq | of_size, of_None, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				} else {
					switch ((code >> 3) & 7) {
						case 0x00:
							ReadCommand(cmFadd, of_ST | code, of_ST | 0, of_None, ctx);
							break;
						case 0x01:
							ReadCommand(cmFmul, of_ST | code, of_ST | 0, of_None, ctx);
							break;
						case 0x02:
							ReadCommand(cmFcom2, of_ST | code, of_None, of_None, ctx);
							break;
						case 0x03:
							ReadCommand(cmFcomp3, of_ST | code, of_None, of_None, ctx);
							break;
						case 0x04:
							ReadCommand(cmFsubr, of_ST | code, of_ST | 0, of_None, ctx);
							break;
						case 0x05:
							ReadCommand(cmFsub, of_ST | code, of_ST | 0, of_None, ctx);
							break;
						case 0x06:
							ReadCommand(cmFdivr, of_ST | code, of_ST | 0, of_None, ctx);
							break;
						case 0x07:
							ReadCommand(cmFdiv, of_ST | code, of_ST | 0, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				}
				break;
			case 0xdd:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				if ((code & 0xc0) != 0xc0) {
					switch ((code >> 3) & 7) {
						case 0x00:
							ReadCommand(cmFld, of_Mq | of_size, of_None, of_None, ctx);
							break;
						case 0x01:
							ReadCommand(cmFisttp, of_Mq | of_size, of_None, of_None, ctx);
							break;
						case 0x02:
							ReadCommand(cmFst, of_Mq | of_size, of_None, of_None, ctx);
							break;
						case 0x03:
							ReadCommand(cmFstp, of_Mq | of_size, of_None, of_None, ctx);
							break;
						case 0x04:
							ReadCommand(cmFrstor, of_Mb, of_None, of_None, ctx);
							break;
						case 0x06:
							ReadCommand(cmFnsave, of_Mb, of_None, of_None, ctx);
							break;
						case 0x07:
							ReadCommand(cmFnstsw, of_Mw | of_size, of_None, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				} else {
					switch ((code >> 3) & 7) {
						case 0x00:
							ReadCommand(cmFfree, of_ST | code, of_None, of_None, ctx);
							break;
						case 0x01:
							ReadCommand(cmFxch4, of_ST | code, of_None, of_None, ctx);
							break;
						case 0x02:
							ReadCommand(cmFst, of_ST | code, of_None, of_None, ctx);
							break;
						case 0x03:
							ReadCommand(cmFstp, of_ST | code, of_None, of_None, ctx);
							break;
						case 0x04:
							ReadCommand(cmFucom, of_ST | code, of_None, of_None, ctx);
							break;
						case 0x05:
							ReadCommand(cmFucomp, of_ST | code, of_None, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				}
				break;
			case 0xde:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				if ((code & 0xc0) != 0xc0) {
					switch ((code >> 3) & 7) {
						case 0x00:
							ReadCommand(cmFiadd, of_Mw | of_size, of_None, of_None, ctx);
							break;
						case 0x01:
							ReadCommand(cmFimul, of_Mw | of_size, of_None, of_None, ctx);
							break;
						case 0x02:
							ReadCommand(cmFicom, of_Mw | of_size, of_None, of_None, ctx);
							break;
						case 0x03:
							ReadCommand(cmFicomp, of_Mw | of_size, of_None, of_None, ctx);
							break;
						case 0x04:
							ReadCommand(cmFisub, of_Mw | of_size, of_None, of_None, ctx);
							break;
						case 0x05:
							ReadCommand(cmFisubr, of_Mw | of_size, of_None, of_None, ctx);
							break;
						case 0x06:
							ReadCommand(cmFidiv, of_Mw | of_size, of_None, of_None, ctx);
							break;
						case 0x07:
							ReadCommand(cmFidivr, of_Mw | of_size, of_None, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				} else {
					switch (code) {
						case 0xc0: case 0xc1: case 0xc2: case 0xc3: 
						case 0xc4: case 0xc5: case 0xc6: case 0xc7:
							ReadCommand(cmFaddp, of_ST | code, of_ST | 0, of_None, ctx);
							break;
						case 0xc8: case 0xc9: case 0xca: case 0xcb: 
						case 0xcc: case 0xcd: case 0xce: case 0xcf:
							ReadCommand(cmFmulp, of_ST | code, of_ST | 0, of_None, ctx);
							break;
						case 0xd0: case 0xd1: case 0xd2: case 0xd3: 
						case 0xd4: case 0xd5: case 0xd6: case 0xd7:
							ReadCommand(cmFcomp5, of_ST | code, of_None, of_None, ctx);
							break;
						case 0xd9: 
							type_ = cmFcompp;
							break;
						case 0xe0: case 0xe1: case 0xe2: case 0xe3: 
						case 0xe4: case 0xe5: case 0xe6: case 0xe7:
							ReadCommand(cmFsubrp, of_ST | code, of_ST | 0, of_None, ctx);
							break;
						case 0xe8: case 0xe9: case 0xea: case 0xeb: 
						case 0xec: case 0xed: case 0xee: case 0xef:
							ReadCommand(cmFsubp, of_ST | code, of_ST | 0, of_None, ctx);
							break;
						case 0xf0: case 0xf1: case 0xf2: case 0xf3: 
						case 0xf4: case 0xf5: case 0xf6: case 0xf7:
							ReadCommand(cmFdivrp, of_ST | code, of_ST | 0, of_None, ctx);
							break;
						case 0xf8: case 0xf9: case 0xfa: case 0xfb: 
						case 0xfc: case 0xfd: case 0xfe: case 0xff:
							ReadCommand(cmFdivp, of_ST | code, of_ST | 0, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				}
				break;
			case 0xdf:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				if ((code & 0xc0) != 0xc0) {
					switch ((code >> 3) & 7) {
						case 0x00:
							ReadCommand(cmFild, of_Mw | of_size, of_None, of_None, ctx);
							break;
						case 0x01:
							ReadCommand(cmFisttp, of_Mw | of_size, of_None, of_None, ctx);
							break;
						case 0x02:
							ReadCommand(cmFist, of_Mw | of_size, of_None, of_None, ctx);
							break;
						case 0x03:
							ReadCommand(cmFistp, of_Mw | of_size, of_None, of_None, ctx);
							break;
						case 0x04:
							ReadCommand(cmFbld, of_Mt, of_None, of_None, ctx);
							break;
						case 0x05:
							ReadCommand(cmFild, of_Mq | of_size, of_None, of_None, ctx);
							break;
						case 0x06:
							ReadCommand(cmFbstp, of_Mt, of_None, of_None, ctx);
							break;
						case 0x07:
							ReadCommand(cmFistp, of_Mq | of_size, of_None, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				} else {
					switch (code) {
						case 0xc0: case 0xc1: case 0xc2: case 0xc3: 
						case 0xc4: case 0xc5: case 0xc6: case 0xc7:
							ReadCommand(cmFfreep, of_ST | code, of_None, of_None, ctx);
							break;
						case 0xc8: case 0xc9: case 0xca: case 0xcb: 
						case 0xcc: case 0xcd: case 0xce: case 0xcf:
							ReadCommand(cmFxch7, of_ST | code, of_None, of_None, ctx);
							break;
						case 0xd0: case 0xd1: case 0xd2: case 0xd3: 
						case 0xd4: case 0xd5: case 0xd6: case 0xd7:
							ReadCommand(cmFstp8, of_ST | code, of_None, of_None, ctx);
							break;
						case 0xd8: case 0xd9: case 0xda: case 0xdb: 
						case 0xdc: case 0xdd: case 0xde: case 0xdf:
							ReadCommand(cmFstp9, of_ST | code, of_None, of_None, ctx);
							break;
						case 0xe0:
							ReadCommand(cmFnstsw, of_FGw | regEAX, of_None, of_None, ctx);
							break;
						case 0xe8: case 0xe9: case 0xea: case 0xeb: 
						case 0xec: case 0xed: case 0xee: case 0xef:
							ReadCommand(cmFucomip, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0xf0: case 0xf1: case 0xf2: case 0xf3: 
						case 0xf4: case 0xf5: case 0xf6: case 0xf7:
							ReadCommand(cmFcomip, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				}
				break;
			case 0xe0: 
				ReadCommand(cmLoopne, of_Jb, of_adr, of_None, ctx);
				break;
			case 0xe1: 
				ReadCommand(cmLoope, of_Jb, of_adr, of_None, ctx);
				break;
			case 0xe2: 
				ReadCommand(cmLoop, of_Jb, of_adr, of_None, ctx);
				break;
			case 0xe3: 
				ReadCommand(cmJCXZ, of_Jb, of_adr, of_None, ctx);
				break;
			case 0xe4: 
				ReadCommand(cmIn, of_FGb | regEAX, of_IBb, of_None, ctx);
				break;
			case 0xe5: 
				ReadCommand(cmIn, of_FGv | regEAX, of_IBb, of_None, ctx);
				break;
			case 0xe6: 
				ReadCommand(cmOut, of_IBb, of_FGb | regEAX, of_None, ctx);
				break;
			case 0xe7: 
				ReadCommand(cmOut, of_IBb, of_FGv | regEAX, of_None, ctx);
				break;
			case 0xe8:
				ReadCommand(cmCall, of_Jz, of_None, of_None, ctx);
				break;
			case 0xe9:
				ReadCommand(cmJmp, of_Jz, of_None, of_None, ctx);
				break;
			case 0xea:
				if (size_ == osQWord)
					type_ = cmDB;
				else {
					include_option(roFar);
					ReadCommand(cmJmp, of_Ap, of_None, of_None, ctx);
				}
				break;
			case 0xeb:
				ReadCommand(cmJmp, of_Jb, of_None, of_None, ctx);
				break;
			case 0xec: 
				ReadCommand(cmIn, of_FGb | regEAX, of_FGw | regEDX, of_None, ctx);
				break;
			case 0xed: 
				ReadCommand(cmIn, of_FGv | regEAX, of_FGw | regEDX, of_None, ctx);
				break;
			case 0xee:
				ReadCommand(cmOut, of_FGw | regEDX, of_FGb | regEAX, of_None, ctx);
				break;
			case 0xef:
				ReadCommand(cmOut, of_FGw | regEDX, of_FGv | regEAX, of_None, ctx);
				break;
			case 0xf0:
				include_option(roLockPrefix);
				break;
			case 0xf1:
				ReadCommand(cmInt, of_FIb | 1, of_None, of_None, ctx);
				break;
			case 0xf2:
				preffix_command_ = cmRepne;
				prefix = code;
				break;
			case 0xf3:
				preffix_command_ = cmRep;
				prefix = code;
				break;
			case 0xf4:
				type_ = cmHlt;
				break;
			case 0xf5:
				type_ = cmCmc;
				break;
			case 0xf6:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
					case 0x01:
						ReadCommand(cmTest, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x02:
						ReadCommand(cmNot, of_Eb | of_size, of_None, of_None, ctx);
						break;
					case 0x03:
						ReadCommand(cmNeg, of_Eb | of_size, of_None, of_None, ctx);
						break;
					case 0x04:
						ReadCommand(cmMul, of_Eb | of_size, of_None, of_None, ctx);
						break;
					case 0x05:
						ReadCommand(cmImul, of_Eb | of_size, of_None, of_None, ctx);
						break;
					case 0x06:
						ReadCommand(cmDiv, of_Eb | of_size, of_None, of_None, ctx);
						break;
					case 0x07:
						ReadCommand(cmIdiv, of_Eb | of_size, of_None, of_None, ctx);
						break;
				}
				break;
			case 0xf7:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
					case 0x01:
						ReadCommand(cmTest, of_Ev | of_size, of_IZv, of_None, ctx);
						break;
					case 0x02:
						ReadCommand(cmNot, of_Ev | of_size, of_None, of_None, ctx);
						break;
					case 0x03:
						ReadCommand(cmNeg, of_Ev | of_size, of_None, of_None, ctx);
						break;
					case 0x04:
						ReadCommand(cmMul, of_Ev | of_size, of_None, of_None, ctx);
						break;
					case 0x05:
						ReadCommand(cmImul, of_Ev | of_size, of_None, of_None, ctx);
						break;
					case 0x06:
						ReadCommand(cmDiv, of_Ev | of_size, of_None, of_None, ctx);
						break;
					case 0x07:
						ReadCommand(cmIdiv, of_Ev | of_size, of_None, of_None, ctx);
						break;
				}
				break;
			case 0xf8:
				type_ = cmClc;
				break;
			case 0xf9:
				type_ = cmStc;
				break;
			case 0xfa:
				type_ = cmCli;
				break;
			case 0xfb:
				type_ = cmSti;
				break;
			case 0xfc:
				type_ = cmCld;
				break;
			case 0xfd:
				type_ = cmStd;
				break;
			case 0xfe:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmInc, of_Eb | of_size, of_None, of_None, ctx);
						break;
					case 0x01:
						ReadCommand(cmDec, of_Eb | of_size, of_None, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0xff:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmInc, of_Ev | of_size, of_None, of_None, ctx);
						break;
					case 0x01:
						ReadCommand(cmDec, of_Ev | of_size, of_None, of_None, ctx);
						break;
					case 0x02:
						ReadCommand(cmCall, of_Edef | of_size, of_None, of_None, ctx);
						break;
					case 0x03:
						include_option(roFar);
						ReadCommand(cmCall, of_Mp | of_size, of_None, of_None, ctx);
						break;
					case 0x04:
						ReadCommand(cmJmp, of_Edef | of_size, of_None, of_None, ctx);
						break;
					case 0x05:
						include_option(roFar);
						ReadCommand(cmJmp, of_Mp | of_size, of_None, of_None, ctx);
						break;
					case 0x06:
						ReadCommand(cmPush, of_Edef | of_size, of_None, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;

			default:
				type_ = cmDB;
				break;
		}
	}

	if ((options() & roVexPrefix) && vex_operand_index) {
		vex_operand_ = (vex_operand_index & 3) | (operand_[0].size == osYMMWord ? 4 : 0) | (ctx.vex_registr << 4);
	}

	if (file.seh_handler_list())
		set_seh_handler(file.seh_handler_list()->GetHandlerByAddress(address_));

	for (i = 0; i < _countof(operand_); i++) {
		operand = &operand_[i];
		if (operand->type & otValue) {
			if (operand->is_large_value)
				operand->value += next_address();
			operand->fixup = file.fixup_list()->GetFixupByAddress(address() + operand->value_pos);

			if (file.relocation_list())
				operand->relocation = file.relocation_list()->GetRelocationByAddress(address() + operand->value_pos);
		}
	}

	original_dump_size_ = dump_size();

	return original_dump_size_; 
}

void IntelCommand::ReadArray(IArchitecture &file, size_t len)
{
	type_ = cmDB;
	Read(file, len);
	original_dump_size_ = dump_size();
}

uint8_t IntelCommand::ReadDataByte(EncodedData &data, size_t *pos)
{
	uint8_t res = data.ReadByte(pos);

	Init(cmDB);
	set_dump(&res, sizeof(res));
	return res;
}

uint16_t IntelCommand::ReadDataWord(EncodedData &data, size_t *pos)
{
	uint16_t res = data.ReadWord(pos);

	Init(cmDW, IntelOperand(otValue, osWord, 0, res));
	set_dump(&res, sizeof(res));
	return res;
}

uint32_t IntelCommand::ReadDataDWord(EncodedData &data, size_t *pos)
{
	uint32_t res = data.ReadDWord(pos);

	Init(cmDD, IntelOperand(otValue, osDWord, 0, res));
	set_dump(&res, sizeof(res));
	return res;
}

uint64_t IntelCommand::ReadDataQWord(EncodedData &data, size_t *pos)
{
	uint64_t res = data.ReadQWord(pos);

	Init(cmDQ, IntelOperand(otValue, osQWord, 0, res));
	set_dump(&res, sizeof(res));
	return res;
}

uint64_t IntelCommand::ReadUleb128(EncodedData &data, size_t *pos)
{
	size_t old_pos = *pos;
	uint64_t res = data.ReadUleb128(pos);

	Init(cmUleb, IntelOperand(otValue, osQWord, 0, res));
	set_dump(data.data() + old_pos, *pos - old_pos);

	original_dump_size_ = dump_size();
	return res;
}

int64_t IntelCommand::ReadSleb128(EncodedData &data, size_t *pos)
{
	size_t old_pos = *pos;
	int64_t res = data.ReadSleb128(pos);

	Init(cmSleb, IntelOperand(otValue, osQWord, 0, res));
	set_dump(data.data() + old_pos, *pos - old_pos);
	return res;
}

uint64_t IntelCommand::ReadEncoding(EncodedData &data, uint8_t encoding, size_t *pos)
{
	uint64_t base;
	switch (encoding & 0x70) {
	case DW_EH_PE_pcrel:
		base = data.address() + *pos;
		break;
	case DW_EH_PE_datarel:
		base = data.address();
		break;
	default:
		base = 0;
		break;
	}

	switch (encoding & 0x0f) {
	case DW_EH_PE_absptr:
		if (data.pointer_size() == osDWord)
			return base + static_cast<int32_t>(ReadDataDWord(data, pos));
		if (data.pointer_size() == osQWord)
			return base + static_cast<int64_t>(ReadDataQWord(data, pos));
		break;
	case DW_EH_PE_uleb128:
		return base + ReadUleb128(data, pos);
	case DW_EH_PE_sleb128:
		return base + ReadSleb128(data, pos);
	case DW_EH_PE_udata2:
		return base + ReadDataWord(data, pos);
	case DW_EH_PE_sdata2:
		return base + static_cast<int16_t>(ReadDataWord(data, pos));
	case DW_EH_PE_udata4:
		return base + ReadDataDWord(data, pos);
	case DW_EH_PE_sdata4:
		return base + static_cast<int32_t>(ReadDataDWord(data, pos));
	case DW_EH_PE_udata8:
		return base + ReadDataQWord(data, pos);
	case DW_EH_PE_sdata8:
		return base + static_cast<int64_t>(ReadDataQWord(data, pos));
	}
	throw std::runtime_error("Invalid encoding");
}

std::string IntelCommand::ReadString(EncodedData &data, size_t *pos)
{
	std::string res = data.ReadString(pos);

	Init(cmDB);
	set_dump(res.c_str(), res.size() + 1);
	return res;
}

void IntelCommand::ReadData(EncodedData &data, size_t size, size_t *pos)
{
	std::vector<uint8_t> res;
	for (size_t i = 0; i < size; i++) {
		res.push_back(data.ReadByte(pos));
	}

	Init(cmDB);
	set_dump(res.data(), res.size());
}

int32_t IntelCommand::ReadCompressedValue(IArchitecture &file)
{
	uint32_t res;
	uint8_t b = ReadByte(file);
	if ((b & 1) == 0)
		res = b >> 1;
	else if ((b & 2) == 0) {
		res = b >> 2;
		res |= ReadByte(file) << 6;
	}
	else if ((b & 4) == 0) {
		res = b >> 3;
		res |= ReadByte(file) << 5;
		res |= ReadByte(file) << 13;
	}
	else if ((b & 8) == 0) {
		res = b >> 4;
		res |= ReadByte(file) << 4;
		res |= ReadByte(file) << 12;
		res |= ReadByte(file) << 20;
	}
	else
		res = ReadDWord(file);

	Init(cmDC, IntelOperand(otValue, osDWord, 0, res));

	return res;
}

void IntelCommand::set_address(uint64_t address)
{
	address_ = address;

	if (type_ == cmJmp || type_ == cmCall || type_ == cmJmpWithFlag || type_ == cmLoop || type_ == cmLoope || type_ == cmLoopne || type_ == cmJCXZ) {
		if (operand_[0].type == otValue) {
			CompileToNative();
			return;
		}
	}

	if (size_ == osQWord) {
		for (size_t i = 0; i < _countof(operand_); i++) {
			IntelOperand *operand = &operand_[i];
			if (operand->type == otNone)
				break;

			if (operand->type == (otMemory | otValue) && operand->is_large_value)
				WriteDWord(operand->value_pos, static_cast<uint32_t>(operand->value - next_address()));
		}
	}
}

void IntelCommand::PushReg(size_t operand_index, uint8_t add_code, AsmContext &ctx)
{
	IntelOperand *operand = &operand_[operand_index];
	uint8_t registr = operand->registr;

	switch (operand->type) {
		case otRegistr:
			if (registr > 7) {
				registr &= 7;
				ctx.rex_prefix |= rexB;
			} else if (operand->size == osByte && registr > 3) {
				ctx.rex_prefix |= 0x40;
			}
			break;
		case otHiPartRegistr:
			registr |= 4;
			break;
		case otControlRegistr:
		case otDebugRegistr:
			if (registr > 7) {
				registr &= 7;
				ctx.rex_prefix |= rexB;
			}
			break;
	}
	PushByte(add_code | registr);
}

void IntelCommand::PushRegAndRM(size_t reg_operand_index, size_t rm_operand_index, AsmContext &ctx)
{
	IntelOperand *operand = &operand_[reg_operand_index];
	uint8_t registr = operand->registr;

	switch (operand->type) {
	case otRegistr:
		if (registr > 7) {
			registr &= 7;
			ctx.rex_prefix |= rexR;
		} else if (operand->size == osByte && registr > 3) {
			ctx.rex_prefix |= 0x40;
		}
		break;
	case otHiPartRegistr:
		registr |= 4;
		break;
	case otControlRegistr:
	case otDebugRegistr:
	case otXMMRegistr:
		if (registr > 7) {
			registr &= 7;
			ctx.rex_prefix |= rexR;
		}
		break;
	case otSegmentRegistr:
	case otMMXRegistr:
		break;
	default:
		throw std::runtime_error("Runtime error at PushRegAndRM: " + text());
	}

	PushRM(rm_operand_index, registr << 3, ctx);
}

void IntelCommand::PushRM(size_t operand_index, uint8_t add_code, AsmContext &ctx)
{
	IntelOperand *operand = &operand_[operand_index];
	uint8_t registr;

	switch (operand->type) {
	case otRegistr:
		registr = operand->registr;
		if (registr > 7) {
			registr &= 7;
			ctx.rex_prefix |= rexB;
		} else if (operand->size == osByte && registr > 3) {
			ctx.rex_prefix |= 0x40;
		}
		PushByte(add_code | 0xc0 | registr);
		break;
	case otDebugRegistr:
	case otControlRegistr:
	case otXMMRegistr:
		registr = operand->registr;
		if (registr > 7) {
			registr &= 7;
			ctx.rex_prefix |= rexB;
		}
		PushByte(add_code | 0xc0 | registr);
		break;
	case otHiPartRegistr:
		registr = operand->registr | 4;
		PushByte(add_code | 0xc0 | registr);
		break;
	default:
		if (operand->type & otMemory) {
			IntelOperand new_operand, *mem_operand = operand;
			if (((mem_operand->type & (otBaseRegistr | otRegistr | otValue)) == otRegistr && (mem_operand->registr & 7) == 5) ||
				((mem_operand->type & (otBaseRegistr | otRegistr | otValue)) == (otBaseRegistr | otRegistr) && (mem_operand->base_registr & 7) == 5)) {
				new_operand = *mem_operand;
				mem_operand = &new_operand;
				mem_operand->type |= otValue;
				mem_operand->value_size = osByte;
				mem_operand->value = 0;
			}

			if (mem_operand->type & otValue) {
				if ((mem_operand->type & (otRegistr | otBaseRegistr)) == 0) {
					add_code |= 0x5;
				} else {
					add_code |= (mem_operand->value_size == osByte) ? 0x40 : 0x80;
				}
			}

			if (mem_operand->type & otBaseRegistr) {
				PushByte(add_code | 0x4);

				if (mem_operand->type & otRegistr) {
					registr = mem_operand->registr;
					if (registr > 7) {
						registr &= 7;
						ctx.rex_prefix |= rexX;
					}
					add_code = (mem_operand->scale_registr << 6) | (registr << 3);
				} else {
					add_code = 0x20;
				}

				registr = mem_operand->base_registr;
				if (registr > 7) {
					registr &= 7;
					ctx.rex_prefix |= rexB;
				}

				PushByte(add_code | registr);
			} else if (mem_operand->type & otRegistr) {
				registr = mem_operand->registr;
				if (mem_operand->scale_registr) {
					if (registr > 7) {
						registr &= 7;
						ctx.rex_prefix |= rexX;
					}
					PushByte((add_code & ~0xc0) | 0x4);
					PushByte((mem_operand->scale_registr << 6) | (registr << 3) | 0x5);
				} else {
					if (registr > 7) {
						registr &= 7;
						ctx.rex_prefix |= rexB;
					}
					PushByte(add_code | registr);
					if (registr == 4)
						PushByte((registr << 3) | 0x4);
				}
			} else {
				PushByte(add_code);
			}

			if (mem_operand->type & otValue) {
				mem_operand->value_pos = static_cast<uint8_t>(dump_size());
				if (mem_operand->value_size == osByte && !mem_operand->is_large_value) {
					PushByte(static_cast<uint8_t>(mem_operand->value));
				} else {
					PushDWord(static_cast<uint32_t>(mem_operand->value));
				}
			}
		} else {
			throw std::runtime_error("Runtime error at PushRM: " + text());
		}
	}
}

void IntelCommand::PushBytePrefix(uint8_t prefix)
{
	PushByte(prefix);
	command_pos_ = dump_size();
}

void IntelCommand::PushWordPrefix()
{
	PushBytePrefix(0x66);
}

void IntelCommand::PushPrefix(AsmContext &ctx)
{
	switch (operand_[0].size) {
	case osWord:
		PushWordPrefix();
		break;
	case osQWord:
		ctx.rex_prefix = rexW;
		break;
	}
}

void IntelCommand::PushFlags(uint8_t add_code)
{
	uint8_t b;

	switch (flags_) {
	case fl_O:
		b = 0;
		break;
	case fl_C:
		b = 2;
		break;
	case fl_Z:
		b = 4;
		break;
	case fl_C | fl_Z:
		b = 6;
		break;
	case fl_S:
		b = 8;
		break;
	case fl_P:
		b = 0xa;
		break;
	case fl_S | fl_O:
		b = 0xc;
		break;
	case fl_Z | fl_S | fl_O:
		b = 0xe;
		break;
	default:
		b = 0;
	}

	if ((options() & roInverseFlag) != 0)
		b |= 1;

	PushByte(add_code | b);
}

void IntelCommand::CompileToNative()
{
	if (type() == cmDB)
		return;

	BaseCommand::clear();

	IntelOperand *operand, *operand1, *mem_operand;
	AsmContext ctx;
	uint8_t i;
	uint8_t b;
	IntelSegment segment;

	if (options() & roLockPrefix)
		PushByte(0xf0);

	switch (preffix_command_) {
	case cmRepne:
		PushByte(0xf2);
		break;
	case cmRep:
	case cmRepe:
		PushByte(0xf3);
		break;
	}

	if (base_segment_ != segDefault) {
		for (i = 0; i < _countof(operand_); i++) {
			operand = &operand_[i];
			if (operand->type & otMemory) {
				if (operand->type & otBaseRegistr) {
					b = operand->base_registr;
				} else if (operand->type & otRegistr) {
					b = operand->registr;
				} else {
					b = regEAX;
				}
				segment = (b == regEBP || b == regESP) ? segSS : segDS;
				if (segment != base_segment_) {
					switch (base_segment_) { //-V719
					case segES: 
						PushByte(0x26);
						break;
					case segSS: 
						PushByte(0x36);
						break;
					case segCS: 
						PushByte(0x2e);
						break;
					case segDS: 
						PushByte(0x3e);
						break;
					case segFS: 
						PushByte(0x64);
						break;
					case segGS: 
						PushByte(0x65);
						break;
					}
				}
			}
		}
	}

	command_pos_ = dump_size();
	ctx.rex_prefix = 0;
	switch (type()) {
		case cmDW:
			operand = &operand_[0];
			operand->value_pos = static_cast<uint8_t>(dump_size());
			PushWord(static_cast<uint16_t>(operand->value));
			break;

		case cmDD:
			operand = &operand_[0];
			operand->value_pos = static_cast<uint8_t>(dump_size());
			PushDWord(static_cast<uint32_t>(operand->value));
			break;

		case cmDQ:
			operand = &operand_[0];
			operand->value_pos = static_cast<uint8_t>(dump_size());
			PushQWord(operand->value);
			break;

		case cmUleb:
			operand = &operand_[0];
			operand->value_pos = static_cast<uint8_t>(dump_size());
			{
				EncodedData data;
				data.WriteUleb128(operand->value);
				if (options() & roFillNop) {
					for (size_t j = data.size(); j < original_dump_size_ + 1; j++) {
						data[j - 1] = data[j - 1] | 0x80;
						data.push_back(0);
					}
				}
				for (i = 0; i < data.size(); i++) {
					PushByte(data[i]);
				}
			}
			break;

		case cmSleb:
			operand = &operand_[0];
			operand->value_pos = static_cast<uint8_t>(dump_size());
			{
				EncodedData data;
				data.WriteSleb128(operand->value);
				for (i = 0; i < data.size(); i++) {
					PushByte(data[i]);
				}
			}
			break;

		case cmDC:
			operand = &operand_[0];
			operand->value_pos = static_cast<uint8_t>(dump_size());
			if (options() & roFillNop) {
				PushByte(0x0f);
				PushDWord(static_cast<uint32_t>(operand->value));
			}
			else {
				uint32_t value = static_cast<uint32_t>(operand->value);
				if (value < 0x80) {
					PushByte(static_cast<uint8_t>((value << 1) + 0));
				}
				else if (value < 0x80 * 0x80) {
					PushByte(static_cast<uint8_t>((value << 2) + 1));
					PushByte(static_cast<uint8_t>(value >> 6));
				}
				else if (value < 0x80 * 0x80 * 0x80) {
					PushByte(static_cast<uint8_t>((value << 3) + 3));
					PushByte(static_cast<uint8_t>(value >> 5));
					PushByte(static_cast<uint8_t>(value >> 13));
				}
				else if (value < 0x80 * 0x80 * 0x80 * 0x80) {
					PushByte(static_cast<uint8_t>((value << 4) + 7));
					PushByte(static_cast<uint8_t>(value >> 4));
					PushByte(static_cast<uint8_t>(value >> 12));
					PushByte(static_cast<uint8_t>(value >> 20));
				}
				else {
					PushByte(0x0f);
					PushDWord(value);
				}
			}
			break;

		case cmPush:
			operand = &operand_[0];
			if (operand->size == osWord)
				PushWordPrefix();

			switch (operand->type) {
			case otRegistr:
				PushReg(0, 0x50, ctx);
				break;
			case otValue:
				if (operand->value_size == osByte) {
					PushByte(0x6a);
				} else {
					PushByte(0x68);
				}
				operand->value_pos = static_cast<uint8_t>(dump_size());
				switch (operand->value_size) {
				case osByte:
					PushByte(static_cast<uint8_t>(operand->value));
					break;
				case osWord:
					PushWord(static_cast<uint16_t>(operand->value));
					break;
				default:
					PushDWord(static_cast<uint32_t>(operand->value));
					break;
				}
				break;
			case otSegmentRegistr:
				switch (operand->registr) {
				case segES:
					if (size_ == osDWord)
						PushByte(0x06);
					break;
				case segCS:
					if (size_ == osDWord)
						PushByte(0x0e);
					break;
				case segSS:
					if (size_ == osDWord)
						PushByte(0x16);
					break;
				case segDS:
					if (size_ == osDWord)
						PushByte(0x1e);
					break;
				case segFS:
					PushByte(0x0f);
					PushByte(0xa0);
					break;
				case segGS:
					PushByte(0x0f);
					PushByte(0xa8);
					break;
				}
				break;
			default:
				if (operand->type & otMemory) {
					PushByte(0xff);
					PushRM(0, 0x30, ctx);
				}
			}
			break;

		case cmPop:
			operand = &operand_[0];
			if (operand->size == osWord)
				PushWordPrefix();

			switch (operand->type) {
			case otRegistr:
				PushReg(0, 0x58, ctx);
				break;
			case otSegmentRegistr:
				switch (operand->registr) {
				case segES:
					if (size_ == osDWord)
						PushByte(0x07);
					break;
				case segCS:
					if (size_ == osDWord)
						PushByte(0x0f);
					break;
				case segSS:
					if (size_ == osDWord)
						PushByte(0x17);
					break;
				case segDS:
					if (size_ == osDWord)
						PushByte(0x1f);
					break;
				case segFS:
					PushByte(0x0f);
					PushByte(0xa1);
					break;
				case segGS:
					PushByte(0x0f);
					PushByte(0xa9);
					break;
				}
				break;
			default:
				if (operand->type & otMemory) {
					PushByte(0x8f);
					PushRM(0, 0x00, ctx);
				}
			}
			break;

		case cmPusha:
			if (size_ == osDWord) {
				if (operand_[0].size == osWord)
					PushWordPrefix();
				PushByte(0x60);
			}
			break;

		case cmPopa:
			if (size_ == osDWord) {
				if (operand_[0].size == osWord)
					PushWordPrefix();
				PushByte(0x61);
			}
			break;

		case cmPushf:
			if (operand_[0].size == osWord)
				PushWordPrefix();
			PushByte(0x9c);
			break;

		case cmPopf:
			if (operand_[0].size == osWord)
				PushWordPrefix();
			PushByte(0x9d);
			break;

		case cmNop:
			PushByte(0x90);
			break;

		case cmPause:
			PushByte(0xf3);
			PushByte(0x90);
			break;

		case cmRdtsc:
			PushByte(0x0f);
			PushByte(0x31);
			break;

		case cmCpuid:
			PushByte(0x0f);
			PushByte(0xa2);
			break;

		case cmCmc:
			PushByte(0xf5);
			break;

		case cmClc:
			PushByte(0xf8);
			break;

		case cmStc:
			PushByte(0xf9);
			break;

		case cmCld:
			PushByte(0xfc);
			break;

		case cmStd:
			PushByte(0xfd);
			break;

		case cmSahf:
			PushByte(0x9e);
			break;

		case cmLahf:
			PushByte(0x9f);
			break;

		case cmCbw:
			PushByte(0x66);
			PushByte(0x98);
			break;

		case cmCwde:
			PushByte(0x98);
			break;

		case cmCdqe:
			if (size_ == osQWord) {
				PushByte(0x48);
				PushByte(0x98);
			}
			break;

		case cmCwd:
			PushByte(0x66);
			PushByte(0x99);
			break;

		case cmCdq:
			PushByte(0x99);
			break;

		case cmCqo:
			if (size_ == osQWord) {
				PushByte(0x48);
				PushByte(0x99);
			}
			break;

		case cmRet:
			operand = &operand_[0];
			b = (options() & roFar) ? 8 : 0;
			switch (operand->type) {
			case otNone:
				PushByte(0xc3 | b);
				break;
			case otValue:
				PushByte(0xc2 | b);
				PushWord(static_cast<uint16_t>(operand->value));
				break;
			}
			break;

		case cmIret:
			if (operand_[0].size == osWord)
				PushWordPrefix();
			PushByte(0xcf);
			break;

		case cmJmp:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if (operand1->type == otValue) {
				PushByte(0xea);
				operand->value_pos = static_cast<uint8_t>(dump_size());
				PushDWord(static_cast<uint32_t>(operand->value));
				operand1->value_pos = static_cast<uint8_t>(dump_size());
				PushWord(static_cast<uint16_t>(operand1->value));
			} else if (options() & roFar) {
				PushByte(0xff);
				PushRM(0, 0x28, ctx);
			} else if (operand->type == otValue) {
				PushByte(0xe9);
				operand->value_pos = static_cast<uint8_t>(dump_size());
				PushDWord(static_cast<uint32_t>(operand->value - next_address() - 4));
			} else {
				PushByte(0xff);
				PushRM(0, 0x20, ctx);
			}
			break;

		case cmCall:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if (operand1->type == otValue) {
				PushByte(0x9a);
				operand->value_pos = static_cast<uint8_t>(dump_size());
				PushDWord(static_cast<uint32_t>(operand->value));
				operand1->value_pos = static_cast<uint8_t>(dump_size());
				PushWord(static_cast<uint16_t>(operand1->value));
			} else if (options() & roFar) {
				PushByte(0xff);
				PushRM(0, 0x18, ctx);
			} else if (operand->type == otValue) {
				PushByte(0xe8);
				operand->value_pos = static_cast<uint8_t>(dump_size());
				PushDWord(static_cast<uint32_t>(operand->value - next_address() - 4));
			} else {
				PushByte(0xff);
				PushRM(0, 0x10, ctx);
			}
			break;

		case cmSyscall:
			PushByte(0x0f);
			PushByte(0x05);
			break;

		case cmSysenter:
			if (size_ == osDWord) {
				PushByte(0x0f);
				PushByte(0x34);
			}
			break;

		case cmSetXX:
			PushByte(0x0f);
			PushFlags(0x90);
			PushRM(0, 0, ctx);
			break;

		case cmJmpWithFlag:
			operand = &operand_[0];
			PushByte(0x0f);
			PushFlags(0x80);
			operand->value_pos = static_cast<uint8_t>(dump_size());
			PushDWord(static_cast<uint32_t>(operand->value - next_address() - 4));
			break;

		case cmLoopne:
			operand = &operand_[0];
			PushByte(0xe0);
			operand->value_pos = static_cast<uint8_t>(dump_size());
			PushByte(static_cast<uint8_t>(operand->value - next_address() - 1));
			break;

		case cmLoope:
			operand = &operand_[0];
			PushByte(0xe1);
			operand->value_pos = static_cast<uint8_t>(dump_size());
			PushByte(static_cast<uint8_t>(operand->value - next_address() - 1));
			break;

		case cmLoop:
			operand = &operand_[0];
			PushByte(0xe2);
			operand->value_pos = static_cast<uint8_t>(dump_size());
			PushByte(static_cast<uint8_t>(operand->value - next_address() - 1));
			break;

		case cmJCXZ:
			if (operand_[1].size == osWord)
				PushBytePrefix(0x67);
			operand = &operand_[0];
			PushByte(0xe3);
			operand->value_pos = static_cast<uint8_t>(dump_size());
			PushByte(static_cast<uint8_t>(operand->value - next_address() - 1));
			break;

		case cmMovs:
			operand = &operand_[0];
			PushPrefix(ctx);
			PushByte((operand->size == osByte) ? 0xa4 : 0xa5);
			break;

		case cmCmps:
			operand = &operand_[0];
			PushPrefix(ctx);
			PushByte((operand->size == osByte) ? 0xa6 : 0xa7);
			break;

		case cmStos:
			operand = &operand_[0];
			PushPrefix(ctx);
			PushByte((operand->size == osByte) ? 0xaa : 0xab);
			break;

		case cmLods:
			operand = &operand_[0];
			PushPrefix(ctx);
			PushByte((operand->size == osByte) ? 0xac : 0xad);
			break;

		case cmScas:
			operand = &operand_[0];
			PushPrefix(ctx);
			PushByte((operand->size == osByte) ? 0xae : 0xaf);
			break;

		case cmCmov:
			PushPrefix(ctx);
			PushByte(0x0f);
			PushFlags(0x40);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmIn:
			operand = &operand_[0];
			PushByte(0xec | ((operand->size == osByte) ? 0 : 1));
			break;

		case cmInt:
			operand = &operand_[0];
			switch (operand->value) {
				case 0:
					PushByte(0xce);
					break;
				case 3:
					PushByte(0xcc);
					break;
				default:
					PushByte(0xcd);
					PushByte(static_cast<uint8_t>(operand->value));
					break;
			}
			break;

		case cmAdd: case cmOr: case cmAdc: case cmSbb: case cmAnd: case cmSub: case cmXor: case cmCmp:
			operand = &operand_[0];
			operand1 = &operand_[1];
			switch (type_) {
			case cmAdd: b = 0 << 3; break;
			case cmOr: b = 1 << 3; break;
			case cmAdc: b = 2 << 3; break;
			case cmSbb: b = 3 << 3; break;
			case cmAnd: b = 4 << 3; break;
			case cmSub: b = 5 << 3; break;
			case cmXor: b = 6 << 3; break;
			case cmCmp: b = 7 << 3; break;
			}
			PushPrefix(ctx);
			if (operand1->type == otValue) {
				i = (operand->size == osByte) ? 0 : 1;
				if (operand->type == otRegistr && operand->registr == regEAX && operand->size == operand1->value_size) {
					PushByte(b | 0x4 | i);
				} else {
					if (operand->size != osByte && operand1->value_size == osByte)
						i |= 2;
					PushByte(0x80 | i);
					PushRM(0, b, ctx);
				}

				operand1->value_pos = static_cast<uint8_t>(dump_size());
				switch (operand1->value_size) {
				case osByte:
					PushByte(static_cast<uint8_t>(operand1->value));
					break;
				case osWord:
					PushWord(static_cast<uint16_t>(operand1->value));
					break;
				default:
					PushDWord(static_cast<uint32_t>(operand1->value));
					break;
				}
			} else {
				i = (operand->type & otMemory) ? 0 : 1;
				PushByte(b | (i << 1) | ((operand->size == osByte) ? 0 : 1));
				PushRegAndRM(1 - i, i, ctx);
			}
			break;

		case cmTest:
			operand = &operand_[0];
			operand1 = &operand_[1];
			i = (operand->size == osByte) ? 0 : 1;
			PushPrefix(ctx);
			if (operand1->type == otValue) {
				if (operand->type == otRegistr && operand->registr == regEAX) {
					PushByte(0xa8 | i);
				} else {
					PushByte(0xf6 | i);
					PushRM(0, 0, ctx);
				}

				operand1->value_pos = static_cast<uint8_t>(dump_size());
				switch (operand1->value_size) {
				case osByte:
					PushByte(static_cast<uint8_t>(operand1->value));
					break;
				case osWord:
					PushWord(static_cast<uint16_t>(operand1->value));
					break;
				default:
					PushDWord(static_cast<uint32_t>(operand1->value));
					break;
				}
			} else {
				PushByte(0x84 | i);
				i = (operand->type & otMemory) ? 0 : 1;
				PushRegAndRM(1 - i, i, ctx);
			}
			break;

		case cmXchg:
			operand = &operand_[0];
			operand1 = &operand_[1];
			PushPrefix(ctx);
			if (operand->size != osByte && operand->type == otRegistr && operand1->type == otRegistr && 
				(operand->registr == regEAX || operand1->registr == regEAX)) {
				i = (operand1->registr == regEAX) ? 0 : 1;
				PushReg(i, 0x90, ctx);
			} else {
				i = (operand->type & otMemory) ? 0 : 1;
				PushByte(0x86 | ((operand->size == osByte) ? 0 : 1));
				PushRegAndRM(1 - i, i, ctx);
			}
			break;

		case cmXadd:
			operand = &operand_[0];
			PushPrefix(ctx);
			PushByte(0x0f);
			PushByte(0xc0 | ((operand->size == osByte) ? 0 : 1));
			PushRegAndRM(1, 0, ctx);
			break;

		case cmLea:
			PushPrefix(ctx);
			PushByte(0x8d);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmNot: case cmNeg: case cmMul: case cmDiv: case cmIdiv: 
			operand = &operand_[0];
			switch (type_) {
			case cmNot: b = 2 << 3; break;
			case cmNeg: b = 3 << 3; break;
			case cmMul: b = 4 << 3; break;
			//unreachable case cmImul: b = 5 << 3; break;
			case cmDiv: b = 6 << 3; break;
			case cmIdiv: b = 7 << 3; break;
			}
			i = (operand->size == osByte) ? 0 : 1;
			PushPrefix(ctx);
			PushByte(0xf6 | i);
			PushRM(0, b, ctx);
			break;

		case cmImul:
			PushPrefix(ctx);
			if (operand_[2].type != otNone) {
				operand = &operand_[2];
				i = (operand->value_size == osByte) ? 1 : 0;
				PushByte(0x69 | (i << 1));
				PushRegAndRM(0, 1, ctx);
				switch (operand->value_size) {
				case osByte:
					PushByte(static_cast<uint8_t>(operand->value));
					break;
				case osWord:
					PushWord(static_cast<uint16_t>(operand->value));
					break;
				default:
					PushDWord(static_cast<uint32_t>(operand->value));
					break;
				}
			} else if (operand_[1].type != otNone) {
				PushByte(0x0f);
				PushByte(0xaf);
				PushRegAndRM(0, 1, ctx);
			} else {
				operand = &operand_[0];
				i = (operand->size == osByte) ? 0 : 1;
				PushByte(0xf6 | i);
				PushRM(0, 0x28, ctx);
			}
			break;

		case cmInc: case cmDec:
			operand = &operand_[0];
			b = (type_ == cmInc) ? 0 : 8;
			PushPrefix(ctx);
			if (operand->type == otRegistr && size_ != osQWord && size_ == operand->size) {
				PushReg(0, 0x40 | b, ctx);
			} else {
				i = (operand->size == osByte) ? 0 : 1;
				PushByte(0xfe | i);
				PushRM(0, b, ctx);
			}
			break;

		case cmShl: case cmShr: case cmRol: case cmRor: case cmRcl: case cmRcr: case cmSal: case cmSar:
			operand = &operand_[0];
			operand1 = &operand_[1];
			i = (operand->size == osByte) ? 0 : 1;
			switch (type_) {
			case cmRol: b = 0 << 3; break;
			case cmRor: b = 1 << 3; break;
			case cmRcl: b = 2 << 3; break;
			case cmRcr: b = 3 << 3; break;
			case cmShl: b = 4 << 3; break;
			case cmShr: b = 5 << 3; break;
			case cmSal: b = 6 << 3; break;
			case cmSar: b = 7 << 3; break;
			}
			PushPrefix(ctx);
			if (operand1->type == otRegistr && operand1->registr == regECX && operand1->size == osByte) {
				PushByte(0xd2 | i);
				PushRM(0, b, ctx);
			} else if (operand1->type == otValue) {
				if (operand1->value == 1) {
					PushByte(0xd0 | i);
					PushRM(0, b, ctx);
				} else {
					PushByte(0xc0 | i);
					PushRM(0, b, ctx);
					PushByte(static_cast<uint8_t>(operand1->value));
				}
			}
			break;

		case cmShld: case cmShrd:
			operand = &operand_[2];
			PushPrefix(ctx);
			PushByte(0x0f);
			PushByte((type_ == cmShld ? 0xa4 : 0xac) | ((operand->type == otValue) ? 0 : 1));
			PushRegAndRM(1, 0, ctx);
			if (operand->type == otValue)
				PushByte(static_cast<uint8_t>(operand->value));
			break;

		case cmBsr:
			PushPrefix(ctx);
			PushByte(0x0f);
			PushByte(0xbd);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmBsf: 
			PushPrefix(ctx);
			PushByte(0x0f);
			PushByte(0xbc);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmBt: case cmBts: case cmBtr: case cmBtc: 
			//operand = &operand_[0];
			operand1 = &operand_[1];
			PushPrefix(ctx);
			PushByte(0x0f);
			if (operand1->type == otValue) {
				PushByte(0xba);
				switch (type_) {
				case cmBt: b = 4 << 3; break;
				case cmBts: b = 5 << 3; break;
				case cmBtr: b = 6 << 3; break;
				case cmBtc: b = 7 << 3; break;
				}
				PushRM(0, b, ctx);
				PushByte(static_cast<uint8_t>(operand1->value));
			} else {
				switch (type_) {
				case cmBt: b = 0 << 3; break;
				case cmBts: b = 1 << 3; break;
				case cmBtr: b = 2 << 3; break;
				case cmBtc: b = 3 << 3; break;
				}
				PushByte(0xa3 | b);
				PushRegAndRM(1, 0, ctx);
			}
			break;

		case cmMovups: case cmMovupd: case cmMovsd: case cmMovss:
			operand = &operand_[0];
			i = (operand->type & otMemory) ? 0 : 1;
			switch (type_) {
			case cmMovupd: PushBytePrefix(0x66); break;
			case cmMovsd: PushBytePrefix(0xf2); break;
			case cmMovss: PushBytePrefix(0xf3); break;
			}
			PushByte(0x0f);
			PushByte(0x10 | (1 - i));
			PushRegAndRM(1 - i, i, ctx);
			break;

		case cmMovaps: case cmMovapd:
			operand = &operand_[0];
			i = (operand->type & otMemory) ? 0 : 1;
			switch (type_) {
			case cmMovapd: PushBytePrefix(0x66); break;
			}
			PushByte(0x0f);
			PushByte(0x28 | (1 - i));
			PushRegAndRM(1 - i, i, ctx);
			break;

		case cmMovsx:
			operand1 = &operand_[1];
			if (operand1->size < osDWord) {
				PushPrefix(ctx);
				PushByte(0x0f);
				PushByte(0xbe | ((operand1->size == osWord) ? 1 : 0));
				PushRegAndRM(0, 1, ctx);
			}
			break;

		case cmMovsxd:
			if (size_ == osQWord) {
				PushPrefix(ctx);
				PushByte(0x63);
				PushRegAndRM(0, 1, ctx);
			}
			break;

		case cmMovzx:
			operand1 = &operand_[1];
			if (operand1->size < osDWord) {
				PushPrefix(ctx);
				PushByte(0x0f);
				PushByte(0xb6 | ((operand1->size == osWord) ? 1 : 0));
				PushRegAndRM(0, 1, ctx);
			}
			break;

		case cmMov:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if (operand1->type == otValue) {
				PushPrefix(ctx);
				i = (operand->size == osByte) ? 0 : 1;
				if (operand->type == otRegistr && operand1->value_size == operand->size) {
					PushReg(0, static_cast<uint8_t>(0xb0 | (i << 3)), ctx);
				} else {
					PushByte(0xc6 | i);
					PushRM(0, 0, ctx);
				}
				operand1->value_pos = static_cast<uint8_t>(dump_size());
				switch (operand1->value_size) {
				case osByte:
					PushByte(static_cast<uint8_t>(operand1->value));
					break;
				case osWord:
					PushWord(static_cast<uint16_t>(operand1->value));
					break;
				case osDWord:
					PushDWord(static_cast<uint32_t>(operand1->value));
					break;
				case osQWord:
					PushQWord(operand1->value);
					break;
				}
			} else if ((operand->type | operand1->type) & otControlRegistr) {
				i = (operand->type == otControlRegistr) ? 1 : 0;
				PushByte(0x0f);
				PushByte(0x20 | (i << 1));
				PushRegAndRM(1 - i, i, ctx);
			} else if ((operand->type | operand1->type) & otDebugRegistr) {
				i = (operand->type == otDebugRegistr) ? 1 : 0;
				PushByte(0x0f);
				PushByte(0x21 | (i << 1));
				PushRegAndRM(1 - i, i, ctx);
			} else if ((operand->type | operand1->type) & otSegmentRegistr) {
				i = (operand->type == otSegmentRegistr) ? 1 : 0;
				if (operand->size == osWord)
					PushWordPrefix();
				PushByte(0x8c | (i << 1));
				PushRegAndRM(1 - i, i, ctx);
			} else {
				i = (operand->type & otMemory) ? 0 : 1;
				PushPrefix(ctx);
				operand = &operand_[1 - i];
				mem_operand = &operand_[i];
				if (operand->type == otRegistr && operand->registr == regEAX && mem_operand->type == (otValue | otMemory) && !mem_operand->is_large_value) {
					PushByte(0xa1 | ((1 - i) << 1));
					mem_operand->value_pos = static_cast<uint8_t>(dump_size());
					if (size_ == osDWord) {
						PushDWord(static_cast<uint32_t>(mem_operand->value));
					} else {
						PushQWord(mem_operand->value);
					}
				} else {
					PushByte(0x88 | (i << 1) | ((operand->size == osByte) ? 0 : 1));
					PushRegAndRM(1 - i, i, ctx);
				}
			}
			break;

		case cmMovd:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr) {
				i = (operand->type == otXMMRegistr) ? 1 : 0;
				PushBytePrefix(0x66);
				PushByte(0x0f);
				PushByte(i ? 0x6e : 0x7e);
				PushRegAndRM(1 - i, i, ctx);
			} else if ((operand->type | operand1->type) & otMMXRegistr) {
				i = (operand->type == otMMXRegistr) ? 1 : 0;
				PushByte(0x0f);
				PushByte(i ? 0x6e : 0x7e);
				PushRegAndRM(1 - i, i, ctx);
			}
			break;

		case cmMovdqa:
			operand = &operand_[0];
			i = (operand->type == otXMMRegistr) ? 1 : 0;
			PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(i ? 0x6f : 0x7f);
			PushRegAndRM(1 - i, i, ctx);
			break;

		case cmMovq:
			operand = &operand_[0];
			operand1 = &operand_[1];
			i = (operand->type & otMemory) ? 0 : 1;
			if ((operand->type | operand1->type) & otXMMRegistr) {
				PushBytePrefix(i ? 0xf3 : 0x66);
				PushByte(0x0f);
				PushByte(i ? 0x7e : 0xd6);
				PushRegAndRM(1 - i, i, ctx);
			} else if ((operand->type | operand1->type) & otMMXRegistr) {
				PushByte(0x0f);
				PushByte(i ? 0x6f : 0x7f);
				PushRegAndRM(1 - i, i, ctx);
			}
			break;

		case cmMovdqu:
			operand = &operand_[0];
			i = (operand->type & otMemory) ? 0 : 1;
			PushBytePrefix(0xf3);
			PushByte(0x0f);
			PushByte(i ? 0x6f : 0x7f);
			PushRegAndRM(1 - i, i, ctx);
			break;

		case cmPslldq:
			PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0x73);
			PushReg(0, 0xc0 | (7 << 3), ctx);
			PushByte(static_cast<uint8_t>(operand_[1].value));
			break;

		case cmPunpcklqdq:
			PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0x6c);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmPunpckhqdq:
			PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0x6d);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmPsrld:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr)
				PushBytePrefix(0x66);
			if (operand1->type == otValue) {
				PushByte(0x0f);
				PushByte(0x72);
				PushReg(0, 0xc0 | (2 << 3), ctx);
				PushByte(static_cast<uint8_t>(operand_[1].value));
			}
			else {
				PushByte(0x0f);
				PushByte(0xd2);
				PushRegAndRM(0, 1, ctx);
			}
			break;

		case cmPsrlq:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr)
				PushBytePrefix(0x66);
			if (operand1->type == otValue) {
				PushByte(0x0f);
				PushByte(0x73);
				PushReg(0, 0xc0 | (2 << 3), ctx);
				PushByte(static_cast<uint8_t>(operand_[1].value));
			} else {
				PushByte(0x0f);
				PushByte(0xd3);
				PushRegAndRM(0, 1, ctx);
			}
			break;

		case cmPaddq:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr)
				PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0xd4);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmPsubq:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr)
				PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0xfb);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmPand:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr)
				PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0xdb);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmPinsrw:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr)
				PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0xc4);
			PushRegAndRM(0, 1, ctx);
			PushByte(static_cast<uint8_t>(operand_[2].value));
			break;

		case cmPextrw:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr)
				PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0xc5);
			PushRegAndRM(0, 1, ctx);
			PushByte(static_cast<uint8_t>(operand_[2].value));
			break;

		case cmShufpd:
			operand = &operand_[0];
			operand1 = &operand_[1];
			PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0xc6);
			PushRegAndRM(0, 1, ctx);
			PushByte(static_cast<uint8_t>(operand_[2].value));
			break;

		case cmPshufd:
			PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0x70);
			PushRegAndRM(0, 1, ctx);
			PushByte(static_cast<uint8_t>(operand_[2].value));
			break;

		case cmPshuflw:
			PushBytePrefix(0xf2);
			PushByte(0x0f);
			PushByte(0x70);
			PushRegAndRM(0, 1, ctx);
			PushByte(static_cast<uint8_t>(operand_[2].value));
			break;

		case cmPaddd:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr)
				PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0xfe);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmPsubd:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr)
				PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0xfa);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmPunpcklbw:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr)
				PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0x60);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmPunpcklwd:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr)
				PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0x61);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmPunpckldq:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr)
				PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0x62);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmMovlpd:
			operand = &operand_[1];
			if (operand->type == otXMMRegistr) {
				PushBytePrefix(0x66);
				PushByte(0x0f);
				PushByte(0x13);
				PushRegAndRM(1, 0, ctx);
			}
			break;

		case cmMovlhps:
			PushByte(0x0f);
			PushByte(0x16);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmMovhlps:
			PushByte(0x0f);
			PushByte(0x12);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmFld:
			operand = &operand_[0];
			if (operand->type == otFPURegistr) {
				PushByte(0xd9);
				PushReg(0, 0xc0, ctx);
			} else {
				switch (operand->size) {
				case osDWord:
					PushByte(0xd9);
					PushRM(0, 0, ctx);
					break;
				case osQWord:
					PushByte(0xdd);
					PushRM(0, 0, ctx);
					break;
				case osTByte:
					PushByte(0xdb);
					PushRM(0, 5 << 3, ctx);
				}
			}
			break;

		case cmFild:
			operand = &operand_[0];
			switch (operand->size) {
			case osWord:
				PushByte(0xdf);
				PushRM(0, 0, ctx);
				break;
			case osDWord:
				PushByte(0xdb);
				PushRM(0, 0, ctx);
				break;
			case osQWord:
				PushByte(0xdf);
				PushRM(0, 5 << 3, ctx);
				break;
			}
			break;

		case cmFadd:
			operand = &operand_[0];
			if (operand->type == otFPURegistr) {
				if (operand->registr == 0) {
					PushByte(0xd8);
					PushRM(1, 0xc0, ctx);
				} else {
					PushByte(0xdc);
					PushRM(0, 0xc0, ctx);
				}
			} else {
				switch (operand->size) {
				case osDWord:
					PushByte(0xd8);
					PushRM(0, 0, ctx);
					break;
				case osQWord:
					PushByte(0xdc);
					PushRM(0, 0, ctx);
					break;
				}
			}
			break;

		case cmFsub:
			operand = &operand_[0];
			if (operand->type == otFPURegistr) {
				if (operand->registr == 0) {
					PushByte(0xd8);
					PushRM(1, 0xc0 | (4 << 3), ctx);
				} else {
					PushByte(0xdc);
					PushRM(0, 0xc0 | (5 << 3), ctx);
				}
			} else {
				switch (operand->size) {
				case osDWord:
					PushByte(0xd8);
					PushRM(0, 4 << 3, ctx);
					break;
				case osQWord:
					PushByte(0xdc);
					PushRM(0, 4 << 3, ctx);
					break;
				}
			}
			break;

		case cmFsubr:
			operand = &operand_[0];
			if (operand->type == otFPURegistr) {
				if (operand->registr == 0) {
					PushByte(0xd8);
					PushRM(1, 0xc0 | (5 << 3), ctx);
				} else {
					PushByte(0xdc);
					PushRM(0, 0xc0 | (4 << 3), ctx);
				}
			} else {
				switch (operand->size) {
				case osDWord:
					PushByte(0xd8);
					PushRM(0, 5 << 3, ctx);
					break;
				case osQWord:
					PushByte(0xdc);
					PushRM(0, 5 << 3, ctx);
					break;
				}
			}
			break;

		case cmFst:
			operand = &operand_[0];
			if (operand->type == otFPURegistr) {
				PushByte(0xdd);
				PushRM(0, 0xc0 | (2 << 3), ctx);
			} else {
				switch (operand->size) {
				case osDWord:
					PushByte(0xd9);
					PushRM(0, 2 << 3, ctx);
					break;
				case osQWord:
					PushByte(0xdd);
					PushRM(0, 2 << 3, ctx);
					break;
				}
			}
			break;

		case cmFstp:
			operand = &operand_[0];
			if (operand->type == otFPURegistr) {
				PushByte(0xdd);
				PushRM(0, 0xc0 | (3 << 3), ctx);
			} else {
				switch (operand->size) {
				case osDWord:
					PushByte(0xd9);
					PushRM(0, 3 << 3, ctx);
					break;
				case osQWord:
					PushByte(0xdd);
					PushRM(0, 3 << 3, ctx);
					break;
				case osTByte:
					PushByte(0xdb);
					PushRM(0, 7 << 3, ctx);
					break;
				}
			}
			break;

		case cmFist:
			operand = &operand_[0];
			switch (operand->size) {
			case osWord:
				PushByte(0xdf);
				PushRM(0, 2 << 3, ctx);
				break;
			case osDWord:
				PushByte(0xdb);
				PushRM(0, 2 << 3, ctx);
				break;
			}
			break;

		case cmFistp:
			operand = &operand_[0];
			switch (operand->size) {
			case osWord:
				PushByte(0xdf);
				PushRM(0, 3 << 3, ctx);
				break;
			case osDWord:
				PushByte(0xdb);
				PushRM(0, 3 << 3, ctx);
				break;
			case osQWord:
				PushByte(0xdf);
				PushRM(0, 7 << 3, ctx);
				break;
			}
			break;

		case cmFisub:
			operand = &operand_[0];
			switch (operand->size) {
			case osWord:
				PushByte(0xde);
				PushRM(0, 4 << 3, ctx);
				break;
			case osDWord:
				PushByte(0xda);
				PushRM(0, 4 << 3, ctx);
				break;
			}
			break;

		case cmFdiv:
			operand = &operand_[0];
			if (operand->type == otFPURegistr) {
				if (operand->registr == 0) {
					PushByte(0xd8);
					PushRM(1, 0xc0 | (6 << 3), ctx);
				} else {
					PushByte(0xdc);
					PushRM(0, 0xc0 | (7 << 3), ctx);
				}
			} else {
				switch (operand->size) {
				case osDWord:
					PushByte(0xd8);
					PushRM(0, 6 << 3, ctx);
					break;
				case osQWord:
					PushByte(0xdc);
					PushRM(0, 6 << 3, ctx);
					break;
				}
			}
			break;

		case cmFmul:
			operand = &operand_[0];
			if (operand->type == otFPURegistr) {
				if (operand->registr == 0) {
					PushByte(0xd8);
					PushRM(1, 0xc0 | (1 << 3), ctx);
				} else {
					PushByte(0xdc);
					PushRM(0, 0xc0 | (1 << 3), ctx);
				}
			} else {
				switch (operand->size) {
				case osDWord:
					PushByte(0xd8);
					PushRM(0, 1 << 3, ctx);
					break;
				case osQWord:
					PushByte(0xdc);
					PushRM(0, 1 << 3, ctx);
					break;
				}
			}
			break;

		case cmFcomp:
			operand = &operand_[0];
			if (operand->type == otFPURegistr) {
				PushByte(0xd8);
				PushRM(0, 0xc0 | (3 << 3), ctx);
			} else {
				switch (operand->size) {
				case osDWord:
					PushByte(0xd8);
					PushRM(0, 3 << 3, ctx);
					break;
				case osQWord:
					PushByte(0xdc);
					PushRM(0, 3 << 3, ctx);
					break;
				}
			}
			break;

		case cmFnstcw:
			PushByte(0xd9);
			PushRM(0, 7 << 3, ctx);
			break;

		case cmFstcw:
			PushByte(0x9b);
			PushByte(0xd9);
			PushRM(0, 7 << 3, ctx);
			break;

		case cmFnstsw:
			PushByte(0xdd);
			PushRM(0, 7 << 3, ctx);
			break;

		case cmFstsw:
			PushByte(0x9b);
			PushByte(0xdd);
			PushRM(0, 7 << 3, ctx);
			break;

		case cmFldcw:
			PushByte(0xd9);
			PushRM(0, 5 << 3, ctx);
			break;

		case cmWait:
			PushByte(0x9b);
			break;

		case cmFchs:
			PushByte(0xd9);
			PushByte(0xe0);
			break;

		case cmFsqrt:
			PushByte(0xd9);
			PushByte(0xfa);
			break;

		case cmF2xm1:
			PushByte(0xd9);
			PushByte(0xf0);
			break;

		case cmFabs:
			PushByte(0xd9);
			PushByte(0xe1);
			break;

		case cmFclex:
			PushByte(0x9b);
			PushByte(0xdb);
			PushByte(0xe2);
			break;

		case cmFcos:
			PushByte(0xd9);
			PushByte(0xff);
			break;

		case cmFdecstp:
			PushByte(0xd9);
			PushByte(0xf6);
			break;

		case cmFincstp:
			PushByte(0xd9);
			PushByte(0xf7);
			break;

		case cmFinit:
			PushByte(0x9b);
			PushByte(0xdb);
			PushByte(0xe3);
			break;

		case cmFldln2:
			PushByte(0xd9);
			PushByte(0xed);
			break;

		case cmFldz:
			PushByte(0xd9);
			PushByte(0xee);
			break;

		case cmFld1:
			PushByte(0xd9);
			PushByte(0xe8);
			break;

		case cmFldpi:
			PushByte(0xd9);
			PushByte(0xeb);
			break;

		case cmFpatan:
			PushByte(0xd9);
			PushByte(0xf3);
			break;

		case cmFprem:
			PushByte(0xd9);
			PushByte(0xf8);
			break;

		case cmFprem1:
			PushByte(0xd9);
			PushByte(0xf5);
			break;

		case cmFptan:
			PushByte(0xd9);
			PushByte(0xf2);
			break;

		case cmFrndint:
			PushByte(0xd9);
			PushByte(0xfc);
			break;

		case cmFsin:
			PushByte(0xd9);
			PushByte(0xfe);
			break;

		case cmFtst:
			PushByte(0xd9);
			PushByte(0xe4);
			break;

		case cmFyl2x:
			PushByte(0xd9);
			PushByte(0xf1);
			break;

		case cmFldlg2:
			PushByte(0xd9);
			PushByte(0xec);
			break;

		case cmBswap:
			operand = &operand_[0];
			if (operand->type == otRegistr) {
				PushPrefix(ctx);
				PushByte(0x0f);
				PushReg(0, 0xc8, ctx);
			}
			break;

		case cmUd2:
			PushByte(0x0f);
			PushByte(0x0b);
			break;

		case cmPxor:
			operand = &operand_[0];
			if (operand->type == otMMXRegistr) {
				PushByte(0x0f);
				PushByte(0xef);
				PushRegAndRM(0, 1, ctx);
			} else if (operand->type == otXMMRegistr) {
				PushByte(0x66);
				PushByte(0x0f);
				PushByte(0xef);
				PushRegAndRM(0, 1, ctx);
			}
			break;

		case cmXorps:
			operand = &operand_[0];
			if (operand->type == otXMMRegistr) {
				PushByte(0x0f);
				PushByte(0x57);
				PushRegAndRM(0, 1, ctx);
			}
			break;

		case cmCrc:
			PushByte(0xcc);
			break;
	}

	if (ctx.rex_prefix) {
		if (size_ == osQWord) {
			InsertByte(command_pos_, 0x40 | ctx.rex_prefix);
			command_pos_++;
			for (i = 0; i < _countof(operand_); i++) {
				operand = &operand_[i];
				if (operand->type == otNone)
					break;
				if (operand->type & otValue)
					operand->value_pos++;
			}
		} else {
			// 32-bit commands can not have REX preffix
			command_pos_ = dump_size();
		}
	}

	if (command_pos_ == dump_size())
		throw std::runtime_error("Runtime error at CompileToNative: " + text());

	for (i = 0; i < _countof(operand_); i++) {
		operand = &operand_[i];
		if (operand->is_large_value)
			WriteDWord(operand->value_pos, static_cast<uint32_t>(operand->value - next_address()));
	}

	if (options() & roFillNop) {
		for (size_t j = dump_size(); j < original_dump_size_; j++) {
			PushByte(0x90);
		}
	}
}

void IntelCommand::set_operand_value(size_t operand_index, uint64_t value)
{
	operand_[operand_index].value = value;
}

void IntelCommand::set_operand_fixup(size_t operand_index, IFixup *fixup)
{
	operand_[operand_index].fixup = fixup;
}

void IntelCommand::set_operand_relocation(size_t operand_index, IRelocation *relocation)
{
	operand_[operand_index].relocation = relocation;
}

void IntelCommand::set_operand_scale(size_t operand_index, uint8_t value)
{
	operand_[operand_index].scale_registr = value;
}

void IntelCommand::set_link_value(size_t link_index, uint64_t value)
{
	IntelVMCommand *vm_command = vm_links_[link_index];
	vm_command->set_value(value);
	vm_command->Compile();
}

void IntelCommand::set_jmp_value(size_t link_index, uint64_t value)
{
	IntelVMCommand *vm_command = jmp_links_[link_index];
	vm_command->set_value(value);
	vm_command->Compile();
}

void IntelCommand::ReadFromBuffer(Buffer &buffer, IArchitecture &file)
{
	uint8_t b;
	uint16_t opt;
	size_t i, j, r;
	uint32_t dw;
	uint64_t add_address = file.image_base();

	r = buffer.ReadByte();
	address_ = buffer.ReadDWord() + add_address;
	type_ = static_cast<IntelCommandType>(buffer.ReadWord());
	BaseCommand::ReadFromBuffer(buffer, file);

	if (r & 0x8)
		preffix_command_ = static_cast<IntelCommandType>(buffer.ReadWord());

	original_dump_size_ = (r & 0x10) ? buffer.ReadWord() : buffer.ReadByte();

	if (r & 0x40)
		base_segment_ = static_cast<IntelSegment>(buffer.ReadByte());

	if (r & 0x80)
		flags_ = buffer.ReadWord();

	if (type_ == cmDB) {
		for (i = 0; i < original_dump_size_; i++) {
			PushByte(buffer.ReadByte());
		}
	} else {
		for (i = 0; i < original_dump_size_; i++) {
			PushByte(0);
		}
		for (j = 0; j < (r & 3); j++) {
			IntelOperand *operand = &operand_[j];
			operand->size = static_cast<OperandSize>(buffer.ReadByte());
			opt = buffer.ReadWord();
			operand->type = opt & 0xfff;

			if (operand->type & (otRegistr | otSegmentRegistr | otControlRegistr | otDebugRegistr | otFPURegistr | otHiPartRegistr | otMMXRegistr | otXMMRegistr))
				operand->registr = buffer.ReadByte();

			if (operand->type & otBaseRegistr)
				operand->base_registr = buffer.ReadByte();

			if (operand->type & otValue) {
				operand->value_size = static_cast<OperandSize>(buffer.ReadByte());
				if (opt & 0x9000) {
					dw = buffer.ReadDWord();
					operand->value = dw + add_address;
				} else {
					switch (operand->value_size) {
					case osByte: 
						operand->value = ByteToInt64(buffer.ReadByte());
						break;
					case osWord: 
						operand->value = WordToInt64(buffer.ReadWord());
						break;
					case osDWord: 
						operand->value = DWordToInt64(buffer.ReadDWord());
						break;
					case osQWord: 
						operand->value = buffer.ReadQWord();
						break;
					}
				}

				if (opt & 0x8000) {
					b = buffer.ReadByte();
					if (b == 1) {
						operand->fixup = NEED_FIXUP;
					} else if (b == 2) {
						operand->is_large_value = true;
					}
				}
			}

			if (operand->type & otMemory) {
				if (opt & 0x4000)
					operand->scale_registr = buffer.ReadByte();
				operand->address_size = (opt & 0x2000) ? static_cast<OperandSize>(buffer.ReadByte()) : size_;
			}
		}
	}
}

void IntelCommand::WriteToFile(IArchitecture &file)
{
	for (size_t i = 0; i < _countof(operand_); i++) {
		IntelOperand *operand = &operand_[i];
		if (operand->type == otNone)
			break;

		if (operand->type & otValue) {
			if (operand->fixup) {
				if (operand->fixup == NEED_FIXUP) {
					ISection *segment = file.segment_list()->GetSectionByAddress(address_);
					operand->fixup = file.fixup_list()->AddDefault(file.cpu_address_size(), segment && (segment->memory_type() & mtExecutable) != 0);
				}
				operand->fixup->set_address(address_ + operand->value_pos);
			}
			if (operand->relocation)
				operand->relocation->set_address(address_ + operand->value_pos);
		}
	}

	if (seh_handler_) {
		if (seh_handler_ == NEED_SEH_HANDLER) {
			seh_handler_ = file.seh_handler_list()->Add(address());
		}
		else {
			seh_handler_->set_address(address());
		}
	}

	BaseCommand::WriteToFile(file);
}

void IntelCommand::Rebase(uint64_t delta_base)
{
	if (!address_)
		return;

	if ((type_ == cmJmp || type_ == cmCall || type_ == cmJmpWithFlag) && operand_[0].type == otValue) {
		operand_[0].value += delta_base;
	} else {
		for (size_t i = 0; i < _countof(operand_); i++) {
			IntelOperand *operand = &operand_[i];
			if (operand->type == otNone)
				break;

			if ((operand->type & otValue) && (operand->fixup || operand->is_large_value))
				operand->value += delta_base;
		}
	}

	address_ += delta_base;

#ifdef CHECKED
	update_hash();
#endif
}

IntelVMCommand *IntelCommand::AddVMCommand(const CompileContext &ctx, IntelCommandType command_type, OperandType operand_type, OperandSize operand_size, uint64_t value, uint32_t options, IFixup *fixup)
{
	bool need_popf = false;
	if ((command_type == cmAdd || command_type == cmNor || command_type == cmNand || command_type == cmShr || command_type == cmShl) && !value) {
		need_popf = true;
		value = true;
	}

	IntelVMCommand *vm_command = NULL;
#ifdef ULTIMATE
	if ((owner()->compilation_options() & coLockToKey) && command_type == cmPush && operand_type == otValue && (options & voLinkCommand)) {
		vm_command = new IntelVMCommand(this, command_type, operand_type, osDWord, value, options);
		vm_command->set_crypt_command(cmXadd, operand_size, ctx.options.licensing_manager->product_code());
	}
#endif
	if (!vm_command)
		vm_command = new IntelVMCommand(this, command_type, operand_type, operand_size, value, options);

	AddObject(vm_command);
	if (options & voLinkCommand)
		vm_links_.push_back(vm_command);
	if (command_type == cmJmp)
		jmp_links_.push_back(vm_command);

	uint32_t new_options = options & (voSectionCommand | voNoCRC);
	if (need_popf)
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty, new_options);

	if ((ctx.options.flags & cpMemoryProtection) && (new_options & voNoCRC) == 0 && vm_command->command_type() == cmPush && vm_command->operand_type() == otValue && vm_command->size() > osByte) {
		new_options |= voNoCRC;
		IntelVMCommand *address_command = AddVMCommand(ctx, cmPush, otValue, size_, 0, new_options | voFixup);
		AddVMCommand(ctx, cmPush, otMemory, vm_command->size(), segDS, new_options);
		AddVMCommand(ctx, cmAdd, otNone, vm_command->size(), false, new_options);

		internal_links_.Add(vlCRCValue, address_command, vm_command);
	}

	if (vm_command->crypt_command() == cmXadd) {
		size_t i;
		IntelVMCommand *cur_command = vm_command;
		// read session key
		uint64_t address = ctx.runtime->export_list()->GetAddressByType(atLoaderData);
		IntelVMCommand *from_command = AddVMCommand(ctx, cmPush, otValue, size_, address, new_options | voFixup);
		ICommand *to_command = ctx.file->function_list()->GetCommandByAddress(address, true);
		if (to_command)
			internal_links_.Add(vlNone, from_command, to_command);
		AddVMCommand(ctx, cmPush, otMemory, size_, segDS, new_options);
		AddVMCommand(ctx, cmPush, otValue, size_, ctx.runtime_var_index[VAR_SESSION_KEY] * OperandSizeToValue(size_), new_options);
		AddVMCommand(ctx, cmAdd, otNone, size_, false);
		AddVMCommand(ctx, cmPush, otMemory, size_, segDS, new_options);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regETX, new_options);
		// add session key
		AddVMCommand(ctx, cmPush, otRegistr, osDWord, regETX, new_options);
		AddVMCommand(ctx, cmAdd, otNone, osDWord, false, new_options);
		for (i = 1; i < 4; i++) {
			cur_command->set_link_command(AddVMCommand(ctx, cmPush, otValue, osDWord, 0, new_options));
			// add session key
			AddVMCommand(ctx, cmPush, otRegistr, osDWord, regETX, new_options);
			AddVMCommand(ctx, cmAdd, otNone, osDWord, false, new_options);
			cur_command = cur_command->link_command();
		}
		AddVMCommand(ctx, cmPush, otRegistr, size_, regESP, new_options);

		address = ctx.runtime->export_list()->GetAddressByType(atDecryptBuffer);
		from_command = AddVMCommand(ctx, cmPush, otValue, size_, address, new_options | voFixup);
		to_command = ctx.file->function_list()->GetCommandByAddress(address, true);
		if (to_command)
			internal_links_.Add(vlNone, from_command, to_command);
		AddVMCommand(ctx, cmCall, otNone, size_, 1, new_options);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty, new_options);

		// correct stack
		if (ctx.file->calling_convention() == ccCdecl)
			AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty, new_options);
		if (size_ == osQWord) {
			AddVMCommand(ctx, cmPop, otRegistr, osQWord, regEmpty, new_options);
		} else {
			AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty, new_options);
			AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty, new_options);
			AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty, new_options);
		}

		// add session key
		if (size_ == osQWord) {
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP, new_options);
			AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToStack(osDWord), new_options);
			AddVMCommand(ctx, cmAdd, otNone, size_, false, new_options);
			AddVMCommand(ctx, cmPush, otMemory, osDWord, segSS, new_options);

			AddVMCommand(ctx, cmPush, otRegistr, osDWord, regETX, new_options);
			AddVMCommand(ctx, cmAdd, otNone, osDWord, false);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP, new_options);
			AddVMCommand(ctx, cmPush, otValue, size_, 2 * OperandSizeToStack(osDWord), new_options);
			AddVMCommand(ctx, cmAdd, otNone, size_, false, new_options);
			AddVMCommand(ctx, cmPop, otMemory, osDWord, segSS, new_options);
		}
		AddVMCommand(ctx, cmPush, otRegistr, osDWord, regETX, new_options);
		AddVMCommand(ctx, cmAdd, otNone, osDWord, false, new_options);
	}

	if ((options & voFixup) && (ctx.options.flags & cpStripFixups) == 0) {
		if (vm_command->is_data()) {
			vm_command->set_fixup(fixup);
		} else {
			FixupType fixup_type = (fixup && fixup != NEED_FIXUP) ? fixup->type() : ftHighLow;
			switch (fixup_type) {
			case ftHigh:
				AddVMCommand(ctx, cmPush, otRegistr, operand_size, regERX, new_options);
				AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty, new_options);
				AddVMCommand(ctx, cmPush, otValue, osWord, 0, new_options);
				if (options & voInverseValue) {
					AddVMCommand(ctx, cmPush, otRegistr, size_, regESP, new_options);
					AddVMCommand(ctx, cmPush, otMemory, operand_size, segSS, new_options);
					AddVMCommand(ctx, cmNor, otNone, operand_size, false, new_options);
					AddVMCommand(ctx, cmPush, otValue, operand_size, 1, new_options);
					AddVMCommand(ctx, cmAdd, otNone, operand_size, false, new_options);
				}
				AddVMCommand(ctx, cmAdd, otNone, operand_size, false, new_options);
				break;

			case ftLow:
				AddVMCommand(ctx, cmPush, otValue, osWord, 0, options);
				AddVMCommand(ctx, cmPush, otRegistr, osWord, regERX, new_options);
				if (options & voInverseValue) {
					AddVMCommand(ctx, cmPush, otRegistr, size_, regESP, new_options);
					AddVMCommand(ctx, cmPush, otMemory, operand_size, segSS, new_options);
					AddVMCommand(ctx, cmNor, otNone, operand_size, false, new_options);
					AddVMCommand(ctx, cmPush, otValue, operand_size, 1, new_options);
					AddVMCommand(ctx, cmAdd, otNone, operand_size, false, new_options);
				}
				AddVMCommand(ctx, cmAdd, otNone, operand_size, false, new_options);
				break;

			case ftHighLow:
				AddVMCommand(ctx, cmPush, otRegistr, operand_size, regERX, new_options);
				if (options & voInverseValue) {
					AddVMCommand(ctx, cmPush, otRegistr, operand_size, regERX, new_options);
					AddVMCommand(ctx, cmNor, otNone, operand_size, false, new_options);
					AddVMCommand(ctx, cmPush, otValue, operand_size, 1, new_options);
					AddVMCommand(ctx, cmAdd, otNone, operand_size, false, new_options);
				}
				AddVMCommand(ctx, cmAdd, otNone, operand_size, false, new_options);
				break;
			}
		}
	}

	if (command_type == cmRet || command_type == cmIret || command_type == cmJmp)
		section_options_ |= rtCloseSection;

	return vm_command;
}

void IntelCommand::AddCorrectOperandSizeSection(const CompileContext &ctx, OperandSize src, OperandSize dst)
{
	int i = (int)(OperandSizeToStack(dst) - OperandSizeToStack(src));
	switch (i) {
	case -2:
		AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);
		break;
	case -4:
		AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
		break;
	case -6:
		AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);
		AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
		break;
	case 2:
		AddVMCommand(ctx, cmPush, otValue, osWord, 0);
		break;
	case 4:
		AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
		break;
	case 6:
		AddVMCommand(ctx, cmPush, otValue, osWord, 0);
		AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
		break;
	}
}

void IntelCommand::AddRegistrAndValueSection(const CompileContext &ctx, uint8_t registr, OperandSize registr_size, uint64_t value, bool need_pushf)
{
	if (rand() & 1) {
		AddVMCommand(ctx, cmPush, otRegistr, registr_size, registr);
		AddVMCommand(ctx, cmPush, otRegistr, registr_size, registr);

		AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, registr_size, false);
		AddVMCommand(ctx, cmPush, otValue, registr_size, ~value);
		AddVMCommand(ctx, cmNor, otNone, registr_size, need_pushf);
	} else {
		AddVMCommand(ctx, cmPush, otRegistr, registr_size, registr);
		AddVMCommand(ctx, cmPush, otValue, registr_size, value);
		AddVMCommand(ctx, cmNand, otNone, registr_size, false);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
		AddVMCommand(ctx, cmPush, otMemory, registr_size, segSS);
		AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, registr_size, need_pushf);
	}
}

void IntelCommand::AddRegistrOrValueSection(const CompileContext &ctx, uint8_t registr, OperandSize registr_size, uint64_t value, bool need_pushf)
{
	AddVMCommand(ctx, cmPush, otRegistr, registr_size, registr);
	AddVMCommand(ctx, cmPush, otValue, registr_size, value);
	AddVMCommand(ctx, cmNor, otNone, registr_size, false);

	AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
	AddVMCommand(ctx, cmPush, otMemory, registr_size, segSS);
	AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, registr_size, need_pushf);
}

void IntelCommand::AddCombineFlagsSection(const CompileContext &ctx, uint16_t mask)
{
	AddRegistrAndValueSection(ctx, regEFX, size_, mask);
	AddRegistrAndValueSection(ctx, regEIX, size_, ~mask);
	AddVMCommand(ctx, cmAdd, otNone, size_, false);
	AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);
}

void IntelCommand::AddCorrectFlagSection(const CompileContext &ctx, uint16_t flags)
{
	AddRegistrAndValueSection(ctx, regEFX, size_, flags);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);
	AddVMCommand(ctx, cmPush, otValue, size_, flags);
	AddVMCommand(ctx, cmNor, otNone, size_, false);
	AddVMCommand(ctx, cmNor, otNone, size_, false);
	AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);
}

void IntelCommand::AddExtractFlagSection(const CompileContext &ctx, uint16_t flags, bool is_inverse, uint8_t extract_to)
{
	bool one_bit = (flags & (flags - 1)) == 0;
	uint16_t check_flag = one_bit ? flags : (uint16_t)fl_Z;
	int c = 0;

	if (check_flag > extract_to) {
		while (check_flag > extract_to) {
			c++;
			check_flag >>= 1;
		}
	} else if (check_flag < extract_to) {
		while (check_flag < extract_to) {
			c--;
			check_flag <<= 1;
		}
	}
	if (c != 0)
		AddVMCommand(ctx, cmPush, otValue, osWord, abs(c));

	if (one_bit) {
		AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);
		if (!is_inverse) {
			AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);
			AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);
		}
		AddVMCommand(ctx, cmPush, otValue, size_ , ~flags);
		AddVMCommand(ctx, cmNor, otNone, size_, false);
	} else {
		bool is_os = (flags & fl_OS) == fl_OS;
		if (is_os) {
			AddRegistrAndValueSection(ctx, regEFX, size_, fl_S, true);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty);

			AddRegistrAndValueSection(ctx, regEFX, size_, fl_O, true);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regEIX);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
			AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX);
			AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);

			AddVMCommand(ctx, cmNor, otNone, size_, false);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX);
			AddVMCommand(ctx, cmNor, otNone, size_, false);

			AddVMCommand(ctx, cmNor, otNone, size_, false);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);

			if (is_inverse) {
				AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
				AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
				AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);
				AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);
			}
			check_flag = flags & ~fl_OS;
		} else {
			check_flag = flags;
		}

		if (check_flag) {
			AddRegistrAndValueSection(ctx, regEFX, size_, check_flag, true);
			AddVMCommand(ctx, cmPop, otRegistr, size_, is_os ? regEIX : regETX);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty);

			if (is_os) {
				AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX);
				AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX);
				AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);

				AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);

				if (is_inverse) {
					AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
					AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);
				}

				AddVMCommand(ctx, cmNor, otNone, size_, false);
				AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);
			}

			if (!is_inverse) {
				AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
				AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
				AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);
				AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);
			}
		}

		AddRegistrAndValueSection(ctx, regETX, size_, fl_Z);
	}

	if (c != 0)
		AddVMCommand(ctx, c > 0 ? cmShr : cmShl, otNone, size_, false);
}

void IntelCommand::AddJmpWithFlagSection(const CompileContext &ctx, IntelCommandType jmp_command_type)
{
	OperandSize os = operand_[1].size;
	uint8_t extract_to;
#ifdef DEMO
	extract_to = static_cast<uint8_t>(OperandSizeToStack(size_));

	AddVMCommand(ctx, cmPush, otValue, size_, 0, voLinkCommand);
	AddVMCommand(ctx, cmPush, otValue, size_, 0, voLinkCommand);

	AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
#else
	extract_to = 1;
#endif

	switch (jmp_command_type) {
	case cmCmpxchg:
		AddExtractFlagSection(ctx, fl_Z, false, extract_to);
		break;

	case cmJmpWithFlag:
		AddExtractFlagSection(ctx, flags_, (options() & roInverseFlag) != 0, extract_to);
		break;

	case cmJCXZ:
		AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);

		AddVMCommand(ctx, cmPush, otValue, os, 0);
		AddVMCommand(ctx, cmPush, otRegistr, os, regECX);
		AddVMCommand(ctx, cmAdd, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);
		AddVMCommand(ctx, cmPop, otRegistr, os, regEmpty);

		AddExtractFlagSection(ctx, fl_Z, false, extract_to);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);

		AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
		break;

	case cmLoop: case cmRep:
		AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);

		AddVMCommand(ctx, cmPush, otValue, os, -1);
		AddVMCommand(ctx, cmPush, otRegistr, os, regECX);
		AddVMCommand(ctx, cmAdd, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);
		AddVMCommand(ctx, cmPop, otRegistr, os, regECX);

		AddExtractFlagSection(ctx, fl_Z, true, extract_to);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);

		AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
		break;

	case cmLoopne: case cmRepne: case cmLoope: case cmRepe:
		AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);

		AddVMCommand(ctx, cmPush, otValue, os, -1);
		AddVMCommand(ctx, cmPush, otRegistr, os, regECX);
		AddVMCommand(ctx, cmAdd, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);
		AddVMCommand(ctx, cmPop, otRegistr, os, regECX);

		if (jmp_command_type == cmLoope || jmp_command_type == cmRepe) {
			AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);
			AddVMCommand(ctx, cmNor, otNone, size_, false);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);
		}

		AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);
		AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
		AddVMCommand(ctx, cmNor, otNone, size_, false);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
		AddVMCommand(ctx, cmPush, otMemory, size_, segSS);

		AddVMCommand(ctx, cmNor, otNone, size_, false);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);

		AddExtractFlagSection(ctx, fl_Z, true, extract_to);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);

		AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
		break;
	}

#ifdef DEMO
	AddVMCommand(ctx, cmAdd, otNone, size_, false);

	AddVMCommand(ctx, cmPush, otMemory, size_, segSS);

	AddVMCommand(ctx, cmPop, otRegistr, size_, regEIX);
	AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty);
	AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty);

	AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX);
#else
	AddVMCommand(ctx, cmPush, otValue, size_, (uint64_t)-1);
	AddVMCommand(ctx, cmAdd, otNone, size_, false);
	AddVMCommand(ctx, cmPop, otRegistr, size_, regEIX);

	// first address AND !condition
	AddVMCommand(ctx, cmPush, otValue, size_, 0, voLinkCommand);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX);
	AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);
	AddVMCommand(ctx, cmNand, otNone, size_, false);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
	AddVMCommand(ctx, cmPush, otMemory, size_, segSS);
	AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);

	// second address AND condition
	AddVMCommand(ctx, cmPush, otValue, size_, 0, voLinkCommand);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX);
	AddVMCommand(ctx, cmNand, otNone, size_, false);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
	AddVMCommand(ctx, cmPush, otMemory, size_, segSS);
	AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);

	// OR addresses 
	AddVMCommand(ctx, cmAdd, otNone, size_, false);
#endif

	AddVMCommand(ctx, cmPush, otRegistr, size_, regERX);
	AddVMCommand(ctx, cmAdd, otNone, size_, false);
	AddEndSection(ctx, cmJmp, 0, voUseEndSectionCryptor);
}

void IntelCommand::AddBeginSection(const CompileContext &ctx, uint32_t options)
{
	options |= voSectionCommand;

	if (count() == 0)
		section_options_ |= rtBeginSection;

	SectionCryptor *section_cryptor;
	if (options & voUseBeginSectionCryptor) {
		section_cryptor = begin_section_cryptor_;
	} else if (options & voUseEndSectionCryptor) {
		section_cryptor = end_section_cryptor_;
	} else {
		section_cryptor = NULL;
	}

	ByteList *registr_order = (section_cryptor) ? section_cryptor->end_cryptor()->registr_order() : reinterpret_cast<IntelVirtualMachine *>(block()->virtual_machine())->registr_order();

	AddVMCommand(ctx, cmPop, otRegistr, size_, regERX, options);
	options &= ~voLinkCommand;

	for (size_t i = registr_order->size(); i > 0; i--) {
		uint8_t reg = registr_order->at(i - 1);
		AddVMCommand(ctx, cmPop, otRegistr, size_, reg, options);
	}

	AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty, options);
	AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty, options);
}

static IntelCommandType CryptorCommandToIntel(CryptCommandType crypt_command)
{
	IntelCommandType res;
	switch (crypt_command) {
	case ccAdd:
		res = cmAdd;
		break;
	case ccSub:
		res = cmSub;
		break;
	case ccXor:
		res = cmXor;
		break;
	case ccInc:
		res = cmInc;
		break;
	case ccDec:
		res = cmDec;
		break;
	case ccBswap:
		res = cmBswap;
		break;
	case ccRol:
		res = cmRol;
		break;
	case ccRor:
		res = cmRor;
		break;
	case ccNot:
		res = cmNot;
		break;
	case ccNeg:
		res = cmNeg;
		break;
	default:
		res = cmUnknown;
		break;
	}

	return res;
}

void IntelCommand::AddCryptorSection(const CompileContext &ctx, ValueCryptor *cryptor, bool is_decrypt)
{
	if (!cryptor)
		return;

	CompileContext new_ctx = ctx;
	new_ctx.options.flags &= ~cpMemoryProtection;

	size_t i;
	IntelCommand tmp_command(owner(), size_);
	tmp_command.set_block(block());
	tmp_command.include_option(roNoSaveFlags);
	IntelOperand first_operand = IntelOperand(otMemory | otRegistr, cryptor->size(), regESP);
	size_t c = cryptor->count();
	for (i = 0; i < c; i++) {
		ValueCommand *value_command = cryptor->item(is_decrypt ? c - i - 1 : i);
		IntelCommandType command_type = CryptorCommandToIntel(value_command->type(is_decrypt));
		if (command_type == cmUnknown)
			throw std::runtime_error("Unknown cryptor command");

		IntelOperand second_operand;
		if (command_type == cmAdd || command_type == cmSub || command_type == cmXor || command_type == cmRol || command_type == cmRor)
			second_operand = IntelOperand(otValue, (command_type == cmRol || command_type == cmRor) ? osByte : cryptor->size(), 0, value_command->value());
		tmp_command.Init(command_type, first_operand, second_operand);
		tmp_command.CompileToVM(new_ctx);
	}
	for (i = 0; i < tmp_command.count(); i++) {
		AddObject(tmp_command.item(i)->Clone(this));
	}
}

void IntelCommand::AddCheckBreakpointSection(const CompileContext &ctx, OperandSize address_size)
{
	if (address_size < size_) {
		AddVMCommand(ctx, cmPop, otRegistr, address_size, regEIX);
		AddVMCommand(ctx, cmPush, otRegistr, address_size, regEIX);
		AddVMCommand(ctx, cmPush, otValue, osDWord, 0, 0);
		AddVMCommand(ctx, cmPush, otRegistr, address_size, regEIX);
	}
	else {
		AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
		AddVMCommand(ctx, cmPush, otMemory, address_size, segSS);
	}

	AddVMCommand(ctx, cmPush, otMemory, osWord, segDS);
	AddVMCommand(ctx, cmPop, otRegistr, osWord, regEIX);

	AddVMCommand(ctx, cmPush, otRegistr, osByte, regEIX);
	AddVMCommand(ctx, cmPush, otValue, osByte, 0 - 0xcc); // short "int 03"
	AddVMCommand(ctx, cmAdd, otNone, osByte, true);
	AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);
	AddVMCommand(ctx, cmPop, otRegistr, osByte, regEmpty);

	AddVMCommand(ctx, cmPush, otRegistr, osWord, regEIX);
	AddVMCommand(ctx, cmPush, otValue, osWord, 0 - 0x03cd); // long "int 03"
	AddVMCommand(ctx, cmAdd, otNone, osWord, true);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
	AddVMCommand(ctx, cmNor, otNone, size_, false);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
	AddVMCommand(ctx, cmPush, otMemory, size_, segSS);
	AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);
	AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);
	AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);

	AddVMCommand(ctx, cmPush, otRegistr, osWord, regEIX);
	AddVMCommand(ctx, cmPush, otValue, osWord, 0 - 0x0b0f); // "ud2"
	AddVMCommand(ctx, cmAdd, otNone, osWord, true);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
	AddVMCommand(ctx, cmNor, otNone, size_, false);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
	AddVMCommand(ctx, cmPush, otMemory, size_, segSS);
	AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);
	AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);
	AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);

	// extract Z flag to random value
	AddVMCommand(ctx, cmPush, otValue, osWord, 6);
	AddVMCommand(ctx, cmPush, otRegistr, address_size, regETX);
	AddVMCommand(ctx, cmShr, otNone, address_size, false);
	AddVMCommand(ctx, cmPush, otValue, address_size, ~1);
	AddVMCommand(ctx, cmNor, otNone, address_size, false);
	AddVMCommand(ctx, cmPush, otValue, address_size, (uint64_t)-1);
	AddVMCommand(ctx, cmAdd, otNone, address_size, false);
	AddVMCommand(ctx, cmPush, otValue, address_size, rand32());
	AddVMCommand(ctx, cmNand, otNone, address_size, false);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
	AddVMCommand(ctx, cmPush, otMemory, address_size, segSS);
	AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, address_size, false);

	AddVMCommand(ctx, cmAdd, otNone, address_size, false);
}

void IntelCommand::AddCheckCRCSection(const CompileContext &ctx, OperandSize address_size)
{
	AddVMCommand(ctx, cmRdtsc, otNone, size_, 0);
	AddVMCommand(ctx, cmAdd, otNone, osDWord, false);
	AddVMCommand(ctx, cmPush, otValue, osDWord, rand32());
	AddVMCommand(ctx, cmAdd, otNone, osDWord, false);
	AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEIX);

	IntelVMCommand *vm_command = AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
	internal_links_.Add(vlCRCTableCount, vm_command, NULL);
	AddVMCommand(ctx, cmPush, otRegistr, osDWord, regEIX);
	AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
	AddVMCommand(ctx, cmDiv, otNone, osDWord, true);
	AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty);

	AddVMCommand(ctx, cmPush, otValue, osDWord, sizeof(CRCInfo::POD));
	AddVMCommand(ctx, cmMul, otNone, osDWord, true);
	AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty);

	AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
	AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEIX);

	AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);

	if (size_ == osQWord)
		AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
	AddVMCommand(ctx, cmPush, otRegistr, osDWord, regEIX);
	vm_command = AddVMCommand(ctx, cmPush, otValue, size_, 0, voFixup);
	internal_links_.Add(vlCRCTableAddress, vm_command, NULL);
	AddVMCommand(ctx, cmAdd, otNone, size_, false);
	AddVMCommand(ctx, cmPop, otRegistr, size_, regEIX);

	if (address_size == osQWord)
		AddVMCommand(ctx, cmPush, otValue, osDWord, 0);

	if (size_ == osQWord)
		AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX);
	assert(sizeof(CRCInfo::POD) == 12);
	AddVMCommand(ctx, cmPush, otValue, size_, offsetof(CRCInfo::POD, size));
	AddVMCommand(ctx, cmAdd, otNone, size_, false);
	AddVMCommand(ctx, cmPush, otMemory, osDWord, segDS);
	AddCryptorSection(ctx, ctx.file->function_list()->crc_cryptor(), true);

	if (size_ == osQWord)
		AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX);
	AddVMCommand(ctx, cmPush, otMemory, osDWord, segDS);
	AddCryptorSection(ctx, ctx.file->function_list()->crc_cryptor(), true);
	AddVMCommand(ctx, cmPush, otValue, size_, ctx.file->image_base(), voFixup);
	AddVMCommand(ctx, cmAdd, otNone, size_, false);

	AddVMCommand(ctx, cmCrc, otNone, size_, 0);

	AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX);
	AddVMCommand(ctx, cmPush, otValue, size_, offsetof(CRCInfo::POD, hash));
	AddVMCommand(ctx, cmAdd, otNone, size_, false);
	AddVMCommand(ctx, cmPush, otMemory, osDWord, segDS);

	AddVMCommand(ctx, cmAdd, otNone, osDWord, false);

	AddVMCommand(ctx, cmAdd, otNone, address_size, false);
}

void IntelCommand::AddEndSection(const CompileContext &ctx, IntelCommandType end_command, uint8_t end_value, uint32_t options)
{
	options |= voSectionCommand;

	SectionCryptor *section_cryptor;
	if (options & voUseBeginSectionCryptor) {
		section_cryptor = begin_section_cryptor_;
	} else if (options & voUseEndSectionCryptor) {
		section_cryptor = end_section_cryptor_;
	} else {
		section_cryptor = NULL;
	}

	ByteList *registr_order;
	if (section_cryptor)
		registr_order = section_cryptor->end_cryptor()->registr_order();
	else if (end_command == cmJmp && end_value == 0xff)
		registr_order = link()->to_command()->block()->virtual_machine()->registr_order();
	else 
		registr_order = block()->virtual_machine()->registr_order();

	switch (end_command) {
	case cmRet:
		{
			OperandSize address_size = (end_value == 1) ? osDWord : size_;
			if (ctx.options.flags & cpCheckDebugger)
				AddCheckBreakpointSection(ctx, address_size);
			if (ctx.options.flags & cpMemoryProtection)
				AddCheckCRCSection(ctx, address_size);
		}
		break;

	case cmJmp:
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEIX, options);
		AddVMCommand(ctx, cmPush, otRegistr, size_, regEmpty, options);
		AddVMCommand(ctx, cmPush, otRegistr, size_, regEmpty, options);
		break;
	}

	for (size_t i = 0; i < registr_order->size(); i++) {
		uint8_t reg = registr_order->at(i);
		AddVMCommand(ctx, cmPush, otRegistr, size_, reg, options);
	}

	if (end_command != cmRet)
		AddVMCommand(ctx, cmPush, otRegistr, size_, regERX, options);

	section_options_ |= rtEndSection;

	if (end_command != cmNop) {
		if (end_command == cmJmp)
			AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX, options);
		AddVMCommand(ctx, end_command, otNone, size_, end_value, options);
	}
}

uint64_t IntelCommand::AddStoreEIPSection(const CompileContext &ctx, uint64_t prev_eip)
{
	if (ctx.file->runtime_function_list() && ctx.file->runtime_function_list()->count()) {
		uint64_t value;
		AddressRange *range = address_range();
		if (range) {
			FunctionInfo *info = range->owner();
			uint64_t end_prolog = info->begin() + info->prolog_size();
			if (range->original_begin() > end_prolog || !address_) {
				value = range->original_begin();
			} else if (address_ <= end_prolog) {
				value = address_;
			} else {
				value = end_prolog;
			}
		} else {
			value = 0;
		}
		if (prev_eip != value) {
			AddVMCommand(ctx, cmPush, otValue, size_, value, voFixup);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regExtended + 0);
		}
		return value;
	}
	return -1;
}

void IntelCommand::AddStoreExtRegistrSection(const CompileContext &ctx, uint8_t registr)
{
	if (ctx.file->runtime_function_list() && ctx.file->runtime_function_list()->count()) {
		uint8_t ext_registr;
		if (registr == regESP) {
			ext_registr = regExtended + 1;
		} else {
			if (!address_range() || address_range()->owner()->frame_registr() != registr)
				return;

			switch (registr) {
			case regEBP:
				ext_registr = regExtended + 2;
				break;
			case regESI:
				ext_registr = regExtended + 3;
				break;
			case regEDI:
				ext_registr = regExtended + 4;
				break;
			case regEBX:
				ext_registr = regExtended + 5;
				break;
			default:
				return;
			}
		}

		AddVMCommand(ctx, cmPush, otRegistr, size_, registr);
		AddVMCommand(ctx, cmPop, otRegistr, size_, ext_registr);
	}
}

void IntelCommand::AddStoreExtRegistersSection(const CompileContext &ctx)
{
	if (ctx.file->runtime_function_list() && ctx.file->runtime_function_list()->count()) {
		AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regExtended + 1);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regEBP);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regExtended + 2);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regESI);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regExtended + 3);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regEDI);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regExtended + 4);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regEBX);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regExtended + 5);
	}
}

void IntelCommand::AddExtSection(const CompileContext &ctx, IntelCommand *next_command)
{
	if (next_command) {
		if (ctx.options.flags & cpEncryptBytecode) {
			block()->AddCorrectCommand(AddVMCommand(ctx, cmPush, otValue, size_, rand64(), voSectionCommand));
		} else {
			AddVMCommand(ctx, cmPush, otRegistr, size(), regEmpty, voSectionCommand);
		}
		AddVMCommand(ctx, cmPush, otRegistr, size(), regEmpty, voSectionCommand);
		end_section_cryptor_ = next_command->begin_section_cryptor_;
		AddEndSection(ctx, cmNop, 0, voUseEndSectionCryptor);
		item(count() - 1)->include_option(voInitOffset);
	} else {
		AddBeginSection(ctx, voUseBeginSectionCryptor);
		if ((section_options() & rtLinkedToExt) && begin_section_cryptor_) {
			if (ctx.options.flags & cpEncryptBytecode) {
				block()->AddCorrectCommand(AddVMCommand(ctx, cmPush, otValue, size_, rand64(), voSectionCommand));
			} else {
				AddVMCommand(ctx, cmPush, otRegistr, size_, regEmpty, voSectionCommand);
			}
			AddVMCommand(ctx, cmPush, otRegistr, size_, regEmpty, voSectionCommand);
			AddEndSection(ctx, cmNop);
			item(count() - 1)->include_option(voInitOffset);
			section_options_ &= ~rtEndSection;
			size_t c = count();
			AddBeginSection(ctx);
			ext_vm_entry_ = item(c);
		}
	}
}

void IntelCommand::AddCorrectESPSection(const CompileContext &ctx, OperandSize operand_size, size_t value)
{
	size_t i, j;
	IntelVMCommand *vm_command;

	j = 0;
	for (i = count(); i > 0; i--) {
		vm_command = item(i - 1);
		if (vm_command->options() & voSectionCommand) {
			j = i;
			break;
		}
	}

	for (i = j; i < count() - 1; i++) {
		vm_command = item(i);
		value += vm_command->GetStackLevel();
	}

	if (value) {
		AddVMCommand(ctx, cmPush, otValue, operand_size, value);
		AddVMCommand(ctx, cmAdd, otNone, operand_size, false);
	}
}

void IntelCommand::CompileOperand(const CompileContext &ctx, size_t operand_index, uint32_t options)
{
	IntelOperand *operand = &operand_[operand_index];
	OperandSize operand_size = operand->size;
	uint32_t vm_options = 0;
	if (operand->type & otValue) {
		if (operand->fixup || (options & coFixup) || operand->is_large_value)
			vm_options |= voFixup;
		if (link() && link()->operand_index() == (int)operand_index)
			vm_options |= voLinkCommand;
	}
	if (options & coAsWord) {
		operand_size = osWord;
	} else if (options & coAsPointer) {
		operand_size = size_;
	}
	
	switch (operand->type) {
	case otSegmentRegistr:
		if (options & coSaveResult) {
			AddVMCommand(ctx, cmPop, otSegmentRegistr, osWord, operand->registr);
			AddCorrectOperandSizeSection(ctx, operand_size, osWord);
		} else {
			AddCorrectOperandSizeSection(ctx, osWord, operand_size);
			AddVMCommand(ctx, cmPush, otSegmentRegistr, osWord, operand->registr);
		}
		break;

	case otDebugRegistr:
		if (options & coSaveResult) {
			AddVMCommand(ctx, cmPop, otDebugRegistr, operand_size, operand->registr);
		} else {
			AddVMCommand(ctx, cmPush, otDebugRegistr, operand_size, operand->registr);
		}
		break;

	case otControlRegistr:
		if (options & coSaveResult) {
			AddVMCommand(ctx, cmPop, otControlRegistr, operand_size, operand->registr);
		} else {
			AddVMCommand(ctx, cmPush, otControlRegistr, operand_size, operand->registr);
		}
		break;

	case otHiPartRegistr:
		if (options & coSaveResult) {
			AddVMCommand(ctx, cmPop, otHiPartRegistr, operand_size, operand->registr);
		} else {
			AddVMCommand(ctx, cmPush, otHiPartRegistr, operand_size, operand->registr);
		}
		break;

	case otRegistr:
		if (options & coSaveResult) {
			AddVMCommand(ctx, cmPop, otRegistr, operand_size, operand->registr);
			if (size_ == osQWord && operand_size == osDWord) {
              AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
              AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, operand->registr);
			}
			AddStoreExtRegistrSection(ctx, operand->registr);
		} else {
			AddVMCommand(ctx, cmPush, otRegistr, operand_size, operand->registr);
			if (operand->registr == regESP)
				AddCorrectESPSection(ctx, operand_size, 0);
		}
		break;

	case otValue:
		if ((options & coInverse) && (vm_options & voFixup) == 0) {
			AddVMCommand(ctx, cmPush, otValue, operand_size, ~operand->value, vm_options, operand->fixup);
			options &= ~coInverse;
		} else 
			AddVMCommand(ctx, cmPush, otValue, operand_size, operand->value, vm_options, operand->fixup);
		break;

	default:
		if (operand->type & otMemory) {
			if (operand->type & otBaseRegistr) {
				AddCorrectOperandSizeSection(ctx, operand->address_size, size_);
				AddVMCommand(ctx, cmPush, otRegistr, operand->address_size, operand->base_registr);
				if (operand->base_registr == regESP)
					AddCorrectESPSection(ctx, size_, type_ == cmPop ? OperandSizeToStack(operand_size) : 0);
			}
			if (operand->type & otRegistr) {
				if (operand->scale_registr > 0)
					AddVMCommand(ctx, cmPush, otValue, osWord, operand->scale_registr);
				AddCorrectOperandSizeSection(ctx, operand->address_size, size_);
				AddVMCommand(ctx, cmPush, otRegistr, operand->address_size, operand->registr);
				if (operand->registr == regESP)
					AddCorrectESPSection(ctx, size_, type_ == cmPop ? OperandSizeToStack(operand_size) : 0);
				if (operand->scale_registr > 0)
					AddVMCommand(ctx, cmShl, otNone, size_, false);
				if (operand->type & otBaseRegistr)
					AddVMCommand(ctx, cmAdd, otNone, size_, false);
			}
			if (operand->type & otValue) {
				AddVMCommand(ctx, cmPush, otValue, size_, operand->value, vm_options, operand->fixup);
				if (operand->type & (otBaseRegistr | otRegistr))
					AddVMCommand(ctx, cmAdd, otNone, size_, false);
			}

			if ((options & coAsPointer) == 0) {
				if (options & coSaveResult) {
					AddVMCommand(ctx, cmPop, otMemory, operand_size, operand->effective_base_segment(base_segment_));
				} else {
					AddVMCommand(ctx, cmPush, otMemory, operand_size, operand->effective_base_segment(base_segment_));
				}
			}
		}
	}

	if (options & coInverse) {
		if (operand->type & otMemory) {
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, operand_size, segSS);
		} else {
			CompileOperand(ctx, operand_index);
		}
		AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, operand_size, false);
	}
}

void IntelCommand::CompileToVM(const CompileContext &ctx)
{
	if (link() && link()->type() == ltNative) {
		AddVMCommand(ctx, cmPush, otValue, size_, 0, voLinkCommand | voFixup);
		AddEndSection(ctx, cmRet);
		return;
	}

	size_t i;
	OperandSize os, adr_os;
	IntelOperand *operand;
	uint16_t flags;
	size_t value;
	bool save_flags = (options() & roNoSaveFlags) == 0;

	if ((options() & roLockPrefix) && type_ != cmXchg) {
		switch (type_) {
		case cmAdd: case cmAnd: case cmSub: case cmXor: case cmOr: case cmXadd:
			i = (operand_[0].type & otMemory) ? 0 : 1;
			CompileOperand(ctx, 1 - i);
			CompileOperand(ctx, i, coAsPointer);
			AddVMCommand(ctx, type_, otMemory, operand_[0].size, operand_[i].effective_base_segment(base_segment_));
			AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEFX : regEmpty);
			if (type_ == cmXadd)
				CompileOperand(ctx, 1 - i, coSaveResult);
			break;
		default:
			throw std::runtime_error("Runtime error at CompileToVM: " + text());
		}
	} else
	switch (type_) {
	case cmBt: case cmBtr: case cmBts: case cmBtc:
		uint8_t mask;
		switch (operand_[0].size) {
		case osWord: mask = 15; break;
		case osDWord: mask = 31; break;
		default: mask = 63; break;
		}

		if (operand_[0].type & otMemory) {
			os = osByte;
			uint8_t old_mask = mask;
			mask = 7;

			if (operand_[1].type == otValue) {
				AddVMCommand(ctx, cmPush, otValue, osWord, operand_[1].value & mask);
				AddVMCommand(ctx, cmPush, otValue, size_, (operand_[1].value & old_mask) >> 3);
			} else {
				CompileOperand(ctx, 1, coAsWord);
				AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
				AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
				AddVMCommand(ctx, cmNor, otNone, osWord, false);
				AddVMCommand(ctx, cmPush, otValue, osWord, ~mask);
				AddVMCommand(ctx, cmNor, otNone, osWord, false);

				AddVMCommand(ctx, cmPush, otValue, osWord, 3);
				AddCorrectOperandSizeSection(ctx, operand_[1].size, size_);
				CompileOperand(ctx, 1);
				AddVMCommand(ctx, cmShr, otNone, size_, false);
			}

			CompileOperand(ctx, 0, coAsPointer);
			AddVMCommand(ctx, cmAdd, otNone, size_, false);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
			AddVMCommand(ctx, cmPush, otMemory, osByte, operand_[0].effective_base_segment(base_segment_));
			AddVMCommand(ctx, cmShr, otNone, os, false);
		} else {
			os = operand_[0].size;

			if (operand_[1].type == otValue) {
				AddVMCommand(ctx, cmPush, otValue, osWord, operand_[1].value & mask);
			} else {
				CompileOperand(ctx, 1, coAsWord);
				AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
				AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
				AddVMCommand(ctx, cmNor, otNone, osWord, false);
				AddVMCommand(ctx, cmPush, otValue, osWord, ~mask);
				AddVMCommand(ctx, cmNor, otNone, osWord, false);
			}

			CompileOperand(ctx, 0);
			AddVMCommand(ctx, cmShr, otNone, os, false);
		}

		AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
		AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
		AddVMCommand(ctx, cmNor, otNone, osWord, false);

		AddVMCommand(ctx, cmPush, otValue, osWord, ~fl_C);
		AddVMCommand(ctx, cmNor, otNone, osWord, false);

		AddVMCommand(ctx, cmPush, otRegistr, osWord, regEFX);
		AddVMCommand(ctx, cmPush, otRegistr, osWord, regEFX);
		AddVMCommand(ctx, cmNor, otNone, osWord, false);
		AddVMCommand(ctx, cmPush, otValue, osWord, fl_C);
		AddVMCommand(ctx, cmNor, otNone, osWord, false);

		AddVMCommand(ctx, cmAdd, otNone, osWord, false);

		AddVMCommand(ctx, cmPop, otRegistr, osWord, regEFX);

		AddCorrectOperandSizeSection(ctx, os, osWord);

		if (type_ != cmBt) {
			if (operand_[1].type == otValue) {
				if (operand_[0].type & otMemory) {
					AddVMCommand(ctx, cmPush, otValue, os, 1ull << (operand_[1].value & 7));
				} else {
					AddVMCommand(ctx, cmPush, otValue, os, 1ull << operand_[1].value);
				}
			} else {
				CompileOperand(ctx, 1, coAsWord);
				AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
				AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
				AddVMCommand(ctx, cmNor, otNone, osWord, false);
				AddVMCommand(ctx, cmPush, otValue, osWord, ~mask);
				AddVMCommand(ctx, cmNor, otNone, osWord, false);

				AddVMCommand(ctx, cmPush, otValue, os, 1);
				AddVMCommand(ctx, cmShl, otNone, os, false);
			}

			switch (type_) {
			case cmBts:
				if (operand_[0].type & otMemory) {
					AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
					AddVMCommand(ctx, cmPush, otMemory, osByte, operand_[0].effective_base_segment(base_segment_));
				} else {
					CompileOperand(ctx, 0);
				}
				AddVMCommand(ctx, cmNor, otNone, os, false);

				AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
				AddVMCommand(ctx, cmPush, otMemory, os, segSS);
				break;
			case cmBtr:
				if (operand_[0].type & otMemory) {
					AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
					AddVMCommand(ctx, cmPush, otMemory, osByte, operand_[0].effective_base_segment(base_segment_));

					AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
					AddVMCommand(ctx, cmPush, otMemory, osByte, segSS);
					AddVMCommand(ctx, cmNor, otNone, osByte, false);
				} else {
					CompileOperand(ctx, 0, coInverse);
				}
				break;
			case cmBtc:
				if (operand_[0].type & otMemory) {
					AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
					AddVMCommand(ctx, cmPush, otMemory, osByte, operand_[0].effective_base_segment(base_segment_));
					AddVMCommand(ctx, cmNor, otNone, os, false);

					AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
					AddVMCommand(ctx, cmPush, otMemory, osByte, operand_[0].effective_base_segment(base_segment_));
					AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
					AddVMCommand(ctx, cmPush, otMemory, osByte, segSS);
					AddVMCommand(ctx, cmNor, otNone, osByte, false);
				} else {
					CompileOperand(ctx, 0);
					AddVMCommand(ctx, cmNor, otNone, os, false);

					CompileOperand(ctx, 0, coInverse);
				}

				if (operand_[1].type == otValue) {
					if (operand_[0].type & otMemory) {
						AddVMCommand(ctx, cmPush, otValue, os, ~(1 << (operand_[1].value & 7)));
					} else {
						AddVMCommand(ctx, cmPush, otValue, os, ~(1 << operand_[1].value));
					}
				} else {
					CompileOperand(ctx, 1, coAsWord);
					AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
					AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
					AddVMCommand(ctx, cmNor, otNone, osWord, false);
					AddVMCommand(ctx, cmPush, otValue, osWord, ~mask);
					AddVMCommand(ctx, cmNor, otNone, osWord, false);

					AddVMCommand(ctx, cmPush, otValue, os, 1);
					AddVMCommand(ctx, cmShl, otNone, os, false);

					AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
					AddVMCommand(ctx, cmPush, otMemory, os, segSS);

					AddVMCommand(ctx, cmNor, otNone, os, false);
				}
				AddVMCommand(ctx, cmNor, otNone, os, false);
				break;
			}

			AddVMCommand(ctx, cmNor, otNone, os, false);

			if (operand_[0].type & otMemory) {
				AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
				AddVMCommand(ctx, cmPop, otMemory, osByte, operand_[0].effective_base_segment(base_segment_));
			} else {
				CompileOperand(ctx, 0, coSaveResult);
			}
		}
		break;

	case cmPush:
		CompileOperand(ctx, 0);
		AddStoreExtRegistrSection(ctx, regESP);
		break;

	case cmPop:
		CompileOperand(ctx, 0, coSaveResult);
		AddStoreExtRegistrSection(ctx, regESP);
		break;

	case cmMov:
		CompileOperand(ctx, 1);
		CompileOperand(ctx, 0, coSaveResult);
		break;

	case cmLea:
		CompileOperand(ctx, 1, coAsPointer);
		CompileOperand(ctx, 0, coSaveResult);
		AddCorrectOperandSizeSection(ctx, size_, operand_[0].size);
		break;

	case cmNot:
		CompileOperand(ctx, 0, coInverse);
		CompileOperand(ctx, 0, coSaveResult);
		break;

	case cmNeg:
		CompileOperand(ctx, 0);

		os = operand_[0].size;
		AddVMCommand(ctx, cmPush, otValue, os, -1);
		AddVMCommand(ctx, cmAdd, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEFX : regEmpty);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
		AddVMCommand(ctx, cmPush, otMemory, os, segSS);
		AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEIX : regEmpty);

		CompileOperand(ctx, 0, coSaveResult);

		if (save_flags)
			AddCombineFlagsSection(ctx, fl_P | fl_O | fl_A | fl_C);
		break;

	case cmAdd: case cmAdc: case cmXadd:
		if (type_ == cmXadd)
			CompileOperand(ctx, 0);
		CompileOperand(ctx, 1);

		os = operand_[0].size;
		if (type_ == cmAdc) {
			AddCorrectOperandSizeSection(ctx, osWord, os);
			AddRegistrAndValueSection(ctx, regEFX, osWord, fl_C);
			AddVMCommand(ctx, cmAdd, otNone, os, true);
			AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEIX : regEmpty);
		}

		CompileOperand(ctx, 0);
		AddVMCommand(ctx, cmAdd, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEFX : regEmpty);

		CompileOperand(ctx, 0, coSaveResult);

		if (type_ == cmXadd)
			CompileOperand(ctx, 1, coSaveResult);

		if (type_ == cmAdc && save_flags) {
			AddRegistrAndValueSection(ctx, regEIX, size_, fl_C | fl_A | fl_O);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);
			AddVMCommand(ctx, cmNor, otNone, size_, false);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, size_, segSS);
			AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);
		}
		break;

	case cmSbb:
		CompileOperand(ctx, 1);

		os = operand_[0].size;
		AddCorrectOperandSizeSection(ctx, osWord, os);
		AddRegistrAndValueSection(ctx, regEFX, osWord, fl_C);
		AddVMCommand(ctx, cmAdd, otNone, os, false);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
		AddVMCommand(ctx, cmPush, otMemory, os, segSS);
		AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, os, false);

		AddVMCommand(ctx, cmPush, otValue, os, 1);
		AddVMCommand(ctx, cmAdd, otNone, os, false);

		CompileOperand(ctx, 0);

		AddVMCommand(ctx, cmAdd, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEFX : regEmpty);

		CompileOperand(ctx, 0, coSaveResult);

		if (save_flags)
			AddCorrectFlagSection(ctx, fl_A | fl_C);
		break;

	case cmSub: case cmCmp:
		CompileOperand(ctx, 1);
		CompileOperand(ctx, 0, coInverse);

		os = operand_[0].size;
		AddVMCommand(ctx, cmAdd, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEFX : regEmpty);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
		AddVMCommand(ctx, cmPush, otMemory, os, segSS);

		AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEIX : regEmpty);

		if (type_ == cmCmp) {
			AddVMCommand(ctx, cmPop, otRegistr, os, regEmpty);
		} else {
			CompileOperand(ctx, 0, coSaveResult);
		}

		if (save_flags)
			AddCombineFlagsSection(ctx, fl_P | fl_O | fl_A | fl_C);
		break;

	case cmInc:
		os = operand_[0].size;
		AddVMCommand(ctx, cmPush, otValue, os, 1);
		CompileOperand(ctx, 0);

		AddVMCommand(ctx, cmAdd, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEIX : regEmpty);

		CompileOperand(ctx, 0, coSaveResult);

		if (save_flags)
			AddCombineFlagsSection(ctx, fl_C);
		break;

	case cmDec:
		os = operand_[0].size;
		AddVMCommand(ctx, cmPush, otValue, os, -1);
		CompileOperand(ctx, 0);

		AddVMCommand(ctx, cmAdd, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEIX : regEmpty);

		CompileOperand(ctx, 0, coSaveResult);

		if (save_flags) {
			AddCombineFlagsSection(ctx, fl_C);
			AddCorrectFlagSection(ctx, fl_A);
		}
		break;

	case cmXlat:
		os = operand_[0].size;
		AddCorrectOperandSizeSection(ctx, os, size_);

		AddCorrectOperandSizeSection(ctx, osWord, os);
		AddVMCommand(ctx, cmPush, otRegistr, osByte, regEAX);

		AddVMCommand(ctx, cmPush, otRegistr, os, regEBX);
		AddVMCommand(ctx, cmAdd, otNone, os, false);
		AddVMCommand(ctx, cmPush, otMemory, osByte, (base_segment_ == segDefault) ? segDS : base_segment_);
		AddVMCommand(ctx, cmPop, otRegistr, osByte, regEAX);
		break;

	case cmSetXX:
		AddExtractFlagSection(ctx, flags_,(options() & roInverseFlag) != 0, 1);
		CompileOperand(ctx, 0, coSaveResult);
		AddCorrectOperandSizeSection(ctx, size_, osWord);
		break;

	case cmAnd: case cmTest:
		os = operand_[0].size;
		if (rand() & 1) {
			CompileOperand(ctx, 1, coInverse);
			CompileOperand(ctx, 0, coInverse);
			AddVMCommand(ctx, cmNor, otNone, os, true);
		} else {
			CompileOperand(ctx, 1);
			CompileOperand(ctx, 0);
			AddVMCommand(ctx, cmNand, otNone, os, false);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, os, segSS);
			AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, os, true);
		}
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEFX : regEmpty);

		if (type_ == cmTest) {
			AddVMCommand(ctx, cmPop, otRegistr, os, regEmpty);
		} else {
			CompileOperand(ctx, 0, coSaveResult);
		}
		break;

	case cmXor:
		os = operand_[0].size;
		if (rand() & 1) {
			CompileOperand(ctx, 1, coInverse);
			CompileOperand(ctx, 0, coInverse);
			AddVMCommand(ctx, cmNor, otNone, os, false);

			CompileOperand(ctx, 1);
			CompileOperand(ctx, 0);
			AddVMCommand(ctx, cmNor, otNone, os, false);

			AddVMCommand(ctx, cmNor, otNone, os, true);
		} else {
			CompileOperand(ctx, 1, coInverse);
			CompileOperand(ctx, 0);
			AddVMCommand(ctx, cmNand, otNone, os, false);

			CompileOperand(ctx, 1);
			CompileOperand(ctx, 0, coInverse);
			AddVMCommand(ctx, cmNand, otNone, os, false);

			AddVMCommand(ctx, cmNand, otNone, os, true);
		}
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEFX : regEmpty);

		CompileOperand(ctx, 0, coSaveResult);
		break;

	case cmOr:
		os = operand_[0].size;
		if (rand() & 1) {
			CompileOperand(ctx, 1);
			CompileOperand(ctx, 0);
			AddVMCommand(ctx, cmNor, otNone, os, false);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, os, segSS);
			AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, os, true);
		} else {
			CompileOperand(ctx, 1, coInverse);
			CompileOperand(ctx, 0, coInverse);
			AddVMCommand(ctx, cmNand, otNone, os, true);
		}
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEFX : regEmpty);

		CompileOperand(ctx, 0, coSaveResult);
		break;

	case cmShld: case cmShrd:
		CompileOperand(ctx, 2);
		CompileOperand(ctx, 1);
		CompileOperand(ctx, 0);

		os = operand_[0].size;
		if (os == osWord) {
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, osDWord, segSS);
		}

		AddVMCommand(ctx, type_, otNone, os == osQWord ? osQWord : osDWord, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEFX : regEmpty);

		CompileOperand(ctx, 0, coSaveResult);

		if (os == osWord)
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);
		break;

	case cmRol: case cmRor:
		CompileOperand(ctx, 1);
		CompileOperand(ctx, 0);

		os = operand_[0].size;
		switch (os) {
		case osByte:
			AddVMCommand(ctx, cmPush, otValue, osWord, 8);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otValue, size_, 2);
			AddVMCommand(ctx, cmAdd, otNone, size_, false);
			AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
			AddVMCommand(ctx, cmShl, otNone, osWord, false);
			AddVMCommand(ctx, cmAdd, otNone, osWord, false);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
			break;
		case osWord:
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
			break;
		}

		adr_os = (os == osQWord) ? osQWord : osDWord;
		AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
		AddVMCommand(ctx, cmPush, otMemory, adr_os, segSS);

		AddVMCommand(ctx, type_ == cmRol ? cmShld : cmShrd, otNone, adr_os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEIX : regEmpty);

		CompileOperand(ctx, 0, coSaveResult);

		if (os == osByte || os == osWord)
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);

		if (save_flags)
			AddCombineFlagsSection(ctx, fl_P | fl_A | fl_Z | fl_S);
		break;

	case cmShl: case cmSal: case cmShr:
		CompileOperand(ctx, 1);
		CompileOperand(ctx, 0);

		os = operand_[0].size;
		AddVMCommand(ctx, type_ == cmShr ? cmShr : cmShl, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEFX : regEmpty);

		CompileOperand(ctx, 0, coSaveResult);
		break;

	case cmSar:
		CompileOperand(ctx, 1);

		os = operand_[0].size;
		adr_os = (os == osQWord) ? osQWord : osDWord;
		AddVMCommand(ctx, cmPush, otValue, adr_os, 1);
		AddVMCommand(ctx, cmPush, otValue, osWord, OperandSizeToValue(os) * 8 - 1);
		if (os == osByte || os == osWord)
			AddVMCommand(ctx, cmPush, otValue, osWord, 0);

		CompileOperand(ctx, 0);
		AddVMCommand(ctx, cmShr, otNone, adr_os, false);
		AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
		AddVMCommand(ctx, cmPush, otMemory, adr_os, segSS);
		AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, adr_os, false);
		AddVMCommand(ctx, cmAdd, otNone, adr_os, false);

		switch (os) {
		case osByte:
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);

			AddVMCommand(ctx, cmPush, otValue, osWord, 8);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otValue, size_, 2);
			AddVMCommand(ctx, cmAdd, otNone, size_, false);
			AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
			AddVMCommand(ctx, cmShl, otNone, osWord, false);

			CompileOperand(ctx, 0);

			AddVMCommand(ctx, cmAdd, otNone, osWord, false);
			break;
		case osWord:
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
			CompileOperand(ctx, 0);
			break;
		default:
			CompileOperand(ctx, 0);
			break;
		}

		AddVMCommand(ctx, cmShrd, otNone, adr_os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEFX : regEmpty);

		CompileOperand(ctx, 0, coSaveResult);

		if (os == osByte || os == osWord)
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);
		break;

	case cmRcl: case cmRcr:
		AddVMCommand(ctx, cmPush, otValue, osByte, 8);
		AddRegistrAndValueSection(ctx, regEFX, osWord, fl_C);
		AddVMCommand(ctx, cmShl, otNone, osWord, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty);

		os = operand_[0].size;
		CompileOperand(ctx, 1);
		AddVMCommand(ctx, cmAdd, otNone, osWord, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty);

		CompileOperand(ctx, 0);

		AddVMCommand(ctx, type_, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEIX : regEmpty);
		CompileOperand(ctx, 0, coSaveResult);

		if (save_flags)
			AddCombineFlagsSection(ctx, fl_S | fl_Z | fl_A | fl_P);
		break;

	case cmCbw: case cmCwde: case cmCwd: case cmCdq: case cmCdqe: case cmCqo:
		switch (type_) {
		case cmCbw:
			os = osByte;
			break;
		case cmCwde: case cmCwd:
			os = osWord;
			break;
		case cmCdq: case cmCdqe:
			os = osDWord;
			break;
		default:
			os = osQWord;
			break;
		}
		AddVMCommand(ctx, cmPush, otValue, os, 1);

		AddVMCommand(ctx, cmPush, otValue, osWord, OperandSizeToValue(os) * 8 - 1);
		AddVMCommand(ctx, cmPush, otRegistr, os, regEAX);
		AddVMCommand(ctx, cmShr, otNone, os, false);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
		AddVMCommand(ctx, cmPush, otMemory, os, segSS);
		AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, os, false);

		AddVMCommand(ctx, cmAdd, otNone, os, false);

		switch (type_) {
		case cmCbw:
			AddVMCommand(ctx, cmPop, otHiPartRegistr, osByte, regEAX);
			break;
		case cmCwde:
			AddVMCommand(ctx, cmPush, otRegistr, osWord, regEAX);
			AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEAX);
			if (size_ == osQWord) {
				AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
				AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regEAX);
			}
			break;
		case cmCwd:
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regEDX);
			break;
		case cmCdq:
			AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEDX);
			if (size_ == osQWord) {
				AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
				AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regEDX);
			}
			break;
		case cmCdqe:
			AddVMCommand(ctx, cmPush, otRegistr, osDWord, regEAX);
			AddVMCommand(ctx, cmPop, otRegistr, osQWord, regEAX);
			break;
		default:
			AddVMCommand(ctx, cmPop, otRegistr, osQWord, regEDX);
			break;
		}
		break;

	case cmMovsx:
	case cmMovsxd:
		if (operand_[1].size == operand_[0].size) {
			CompileOperand(ctx, 1);
		} else {
			AddCorrectOperandSizeSection(ctx, operand_[1].size, operand_[0].size);
			CompileOperand(ctx, 1);

			AddVMCommand(ctx, cmPush, otValue, osWord, OperandSizeToValue(operand_[1].size) * 8);
			AddVMCommand(ctx, cmPush, otValue, osWord, OperandSizeToValue(operand_[1].size) * 8 - 1);

			os = operand_[0].size;
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToValue(osWord) * 2);
			AddVMCommand(ctx, cmAdd, otNone, size_, false);
			AddVMCommand(ctx, cmPush, otMemory, os, segSS);

			AddVMCommand(ctx, cmShr, otNone, os, false);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, os, segSS);
			AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, os, false);

			AddVMCommand(ctx, cmPush, otValue, os, 1);
			AddVMCommand(ctx, cmAdd, otNone, os, false);

			AddVMCommand(ctx, cmShl, otNone, os, false);

			AddVMCommand(ctx, cmAdd, otNone, os, false);
		}

		CompileOperand(ctx, 0, coSaveResult);
		break;

	case cmMovzx:
		AddCorrectOperandSizeSection(ctx, operand_[1].size, operand_[0].size);
		CompileOperand(ctx, 1);
		CompileOperand(ctx, 0, coSaveResult);
		break;

	case cmPushf:
		AddVMCommand(ctx, cmPush, otRegistr, operand_[0].size, regEFX);
		AddStoreExtRegistrSection(ctx, regESP);
		break;

	case cmPopf:
		AddVMCommand(ctx, cmPop, otRegistr, operand_[0].size, regEFX);
		AddRegistrAndValueSection(ctx, regEFX, size_, ~0x8ff);
		AddVMCommand(ctx, cmPopf, otNone, size_, 0);
		AddStoreExtRegistrSection(ctx, regESP);
		break;

	case cmPusha:
		os = operand_[0].size;

		AddVMCommand(ctx, cmPush, otRegistr, os, regEAX);
		AddVMCommand(ctx, cmPush, otRegistr, os, regECX);
		AddVMCommand(ctx, cmPush, otRegistr, os, regEDX);
		AddVMCommand(ctx, cmPush, otRegistr, os, regEBX);

		AddVMCommand(ctx, cmPush, otRegistr, os, regESP);
		AddVMCommand(ctx, cmPush, otValue, os, OperandSizeToValue(os) * 4);
		AddVMCommand(ctx, cmAdd, otNone, os, false);

		AddVMCommand(ctx, cmPush, otRegistr, os, regEBP);
		AddVMCommand(ctx, cmPush, otRegistr, os, regESI);
		AddVMCommand(ctx, cmPush, otRegistr, os, regEDI);
		AddStoreExtRegistrSection(ctx, regESP);
		break;

	case cmPopa:
		os = operand_[0].size;

		AddVMCommand(ctx, cmPop, otRegistr, os, regEDI);
		AddVMCommand(ctx, cmPop, otRegistr, os, regESI);
		AddVMCommand(ctx, cmPop, otRegistr, os, regEBP);
		AddVMCommand(ctx, cmPop, otRegistr, os, regEmpty);
		AddVMCommand(ctx, cmPop, otRegistr, os, regEBX);
		AddVMCommand(ctx, cmPop, otRegistr, os, regEDX);
		AddVMCommand(ctx, cmPop, otRegistr, os, regECX);
		AddVMCommand(ctx, cmPop, otRegistr, os, regEAX);
		AddStoreExtRegistrSection(ctx, regESP);
		break;

	case cmLahf:
		AddVMCommand(ctx, cmPush, otRegistr, osWord, regEFX);
		AddVMCommand(ctx, cmPop, otHiPartRegistr, osByte, regEAX);
		break;

	case cmSahf:
		flags = fl_C | fl_P | fl_A | fl_Z | fl_S;

		AddVMCommand(ctx, cmPush, otHiPartRegistr, osByte, regEAX);
		AddVMCommand(ctx, cmPush, otHiPartRegistr, osByte, regEAX);
		AddVMCommand(ctx, cmNor, otNone, osByte, false);
		AddVMCommand(ctx, cmPush, otValue, osByte, ~flags);
		AddVMCommand(ctx, cmNor, otNone, osByte, false);

		AddRegistrAndValueSection(ctx, regEFX, osWord, ~flags);
		AddVMCommand(ctx, cmAdd, otNone, osWord, false);
		AddVMCommand(ctx, cmPop, otRegistr, osWord, regEFX);
		break;

	case cmXchg:
		if ((operand_[0].type | operand_[1].type) & otMemory) {
			i = (operand_[0].type & otMemory) ? 0 : 1;
			CompileOperand(ctx, 1 - i);
			CompileOperand(ctx, i, coAsPointer);
			AddVMCommand(ctx, cmXchg, otMemory, operand_[0].size, operand_[i].effective_base_segment(base_segment_));
			CompileOperand(ctx, 1 - i, coSaveResult);
		}
		else {
			operand = &operand_[1];
			if (operand->type == otRegistr && operand->size > osByte && operand->registr == regESP) {
				CompileOperand(ctx, 0);
				CompileOperand(ctx, 1);
				CompileOperand(ctx, 0, coSaveResult);
				CompileOperand(ctx, 1, coSaveResult);
			}
			else {
				CompileOperand(ctx, 1);
				CompileOperand(ctx, 0);
				CompileOperand(ctx, 1, coSaveResult);
				CompileOperand(ctx, 0, coSaveResult);
			}
		}
		break;

	case cmFnop: case cmNop:
		// do nothing
		break;

	case cmClc:
		AddRegistrAndValueSection(ctx, regEFX, size_, ~fl_C);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);
		break;

	case cmStc:
		AddRegistrOrValueSection(ctx, regEFX, size_, fl_C);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);
		break;

	case cmCmc:
		AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);
		AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);
		AddVMCommand(ctx, cmNor, otNone, size_, false);

		AddVMCommand(ctx, cmPush, otValue, size_, ~fl_C);
		AddVMCommand(ctx, cmNor, otNone, size_, false);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);
		AddVMCommand(ctx, cmPush, otValue, size_, fl_C);
		AddVMCommand(ctx, cmNor, otNone, size_, false);

		AddVMCommand(ctx, cmNor, otNone, size_, false);

		AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);
		break;

	case cmCld:
		AddRegistrAndValueSection(ctx, regEFX, size_, ~fl_D);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);
		AddRegistrAndValueSection(ctx, regEFX, size_, ~0x8ff);
		AddVMCommand(ctx, cmPopf, otNone, size_, false);
		break;

	case cmStd:
		AddRegistrOrValueSection(ctx, regEFX, size_, fl_D);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);
		AddRegistrAndValueSection(ctx, regEFX, size_, ~0x8ff);
		AddVMCommand(ctx, cmPopf, otNone, size_, false);
		break;

	case cmBswap:
		switch (operand_[0].size) {
		case osWord:
			AddVMCommand(ctx, cmPush, otValue, osWord, 0);
			CompileOperand(ctx, 0, coSaveResult);
			break;
		case osDWord:
			AddVMCommand(ctx, cmPush, otValue, osWord, 8);
			CompileOperand(ctx, 0);
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regETX);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
			AddVMCommand(ctx, cmShl, otNone, osDWord, false);

			AddVMCommand(ctx, cmPush, otValue, osWord, 8);
			AddVMCommand(ctx, cmPush, otRegistr, osWord, regETX);
			AddVMCommand(ctx, cmPush, otRegistr, osWord, regETX);
			AddVMCommand(ctx, cmShl, otNone, osDWord, false);
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otValue, size_, 4);
			AddVMCommand(ctx, cmAdd, otNone, size_, false);
			AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);

			CompileOperand(ctx, 0, coSaveResult);

			AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
			break;
		case osQWord:
			AddVMCommand(ctx, cmPush, otValue, osWord, 8);
			CompileOperand(ctx, 0);
			AddVMCommand(ctx, cmPop, otRegistr, osDWord, regETX);
			AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
			AddVMCommand(ctx, cmPush, otRegistr, osDWord, regETX);
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
			AddVMCommand(ctx, cmShl, otNone, osDWord, false);

			AddVMCommand(ctx, cmPush, otValue, osWord, 8);
			AddVMCommand(ctx, cmPush, otRegistr, osWord, regETX);
			AddVMCommand(ctx, cmPush, otRegistr, osWord, regETX);
			AddVMCommand(ctx, cmShl, otNone, osDWord, false);
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otValue, size_, 4);
			AddVMCommand(ctx, cmAdd, otNone, size_, false);
			AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);

			AddVMCommand(ctx, cmPush, otValue, osWord, 8);
			CompileOperand(ctx, 0);
			AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regETX);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
			AddVMCommand(ctx, cmShl, otNone, osDWord, false);

			AddVMCommand(ctx, cmPush, otValue, osWord, 8);
			AddVMCommand(ctx, cmPush, otRegistr, osWord, regETX);
			AddVMCommand(ctx, cmPush, otRegistr, osWord, regETX);
			AddVMCommand(ctx, cmShl, otNone, osDWord, false);
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otValue, size_, 4);
			AddVMCommand(ctx, cmAdd, otNone, size_, false);
			AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);

			AddVMCommand(ctx, cmPop, otRegistr, osDWord, regETX);
			AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
			AddVMCommand(ctx, cmPush, otRegistr, osDWord, regETX);
			CompileOperand(ctx, 0, coSaveResult);
			AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
			break;
		}
		break;

	case cmFstsw:
		operand = &operand_[0];
		if (operand->type == (otMemory | otBaseRegistr) && operand->base_registr == regESP) {
			AddVMCommand(ctx, cmFstsw, otNone, osWord, 0);
		} else {
			AddVMCommand(ctx, cmPush, otRegistr, osWord, regEmpty);
			AddVMCommand(ctx, cmFstsw, otNone, osWord, 0);
			CompileOperand(ctx, 0, coSaveResult);
		}
		break;

	case cmFldcw:
		operand = &operand_[0];
		if (operand->type == (otMemory | otBaseRegistr) && operand->base_registr == regESP) {
			AddVMCommand(ctx, cmFldcw, otNone, osWord, 0);
		} else {
			CompileOperand(ctx, 0);
			AddVMCommand(ctx, cmFldcw, otNone, osWord, 0);
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);
		}
		break;

	case cmFstcw:
		operand = &operand_[0];
		if (operand->type == (otMemory | otBaseRegistr) && operand->base_registr == regESP) {
			AddVMCommand(ctx, cmFstcw, otNone, osWord, 0);
		} else {
			AddVMCommand(ctx, cmPush, otRegistr, osWord, regEmpty);
			AddVMCommand(ctx, cmFstcw, otNone, osWord, 0);
			CompileOperand(ctx, 0, coSaveResult);
		}
		break;

	case cmImul: case cmMul:
		os = operand_[0].size;

		if (operand_[2].type != otNone) {
			CompileOperand(ctx, 2);
			CompileOperand(ctx, 1);
		} else if (operand_[1].type != otNone) {
			CompileOperand(ctx, 1);
			CompileOperand(ctx, 0);
		} else {
			CompileOperand(ctx, 0);
			AddVMCommand(ctx, cmPush, otRegistr, os, regEAX);
		}

		AddVMCommand(ctx, type_, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEIX : regEmpty);

		if (operand_[1].type != otNone) {
			if (os > osByte)
				AddVMCommand(ctx, cmPop, otRegistr, os, regEmpty);
			CompileOperand(ctx, 0, coSaveResult);
		} else if (os == osByte) {
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regEAX);
		} else {
			AddVMCommand(ctx, cmPop, otRegistr, os, regEDX);
			AddVMCommand(ctx, cmPop, otRegistr, os, regEAX);
			if (size_ == osQWord && os == osDWord) {
				AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
				AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regEAX);
				AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
				AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regEDX);
			}
		}

		if (save_flags)
			AddCombineFlagsSection(ctx, fl_S | fl_Z | fl_A | fl_P);
		break;

	case cmDiv: case cmIdiv:
		os = operand_[0].size;

		CompileOperand(ctx, 0);
		if (os == osByte) {
			AddVMCommand(ctx, cmPush, otRegistr, osWord, regEAX);
		} else {
			AddVMCommand(ctx, cmPush, otRegistr, os, regEAX);
			AddVMCommand(ctx, cmPush, otRegistr, os, regEDX);
		}

		AddVMCommand(ctx, type_, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEFX : regEmpty);

		if (os == osByte) {
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regEAX);
		} else {
			AddVMCommand(ctx, cmPop, otRegistr, os, regEDX);
			AddVMCommand(ctx, cmPop, otRegistr, os, regEAX);
		}

		if (size_ == osQWord && os == osDWord) {
			AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
			AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regEAX);
			AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
			AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regEDX);
		}
		break;

	case cmJmpWithFlag: case cmJCXZ: case cmLoop: case cmLoope: case cmLoopne:
		AddJmpWithFlagSection(ctx, type_);
		if (section_options_ & rtLinkedNext) {
			AddBeginSection(ctx, voLinkCommand | voUseEndSectionCryptor);
			AddVMCommand(ctx, cmPush, otValue, size_, 0, voLinkCommand | voFixup);
			AddEndSection(ctx, cmJmp, 0, voUseEndSectionCryptor);
		} else {
			AddBeginSection(ctx, voLinkCommand | voUseEndSectionCryptor);
			AddVMCommand(ctx, cmPush, otValue, size_, address() + original_dump_size(), voFixup);
			AddEndSection(ctx, cmRet);
		}
		if (section_options_ & rtLinkedFrom) {
			AddBeginSection(ctx, voLinkCommand | voUseEndSectionCryptor);
			AddVMCommand(ctx, cmPush, otValue, size_, 0, voLinkCommand | voFixup);
			AddEndSection(ctx, cmJmp, 0, voUseEndSectionCryptor);
		} else {
			AddBeginSection(ctx, voLinkCommand | voUseEndSectionCryptor);
			AddCorrectOperandSizeSection(ctx, operand_[0].size, size_);
			CompileOperand(ctx, 0, coFixup);
			AddEndSection(ctx, cmRet);
		}
		break;

	case cmJmp:
		CompileOperand(ctx, 1, coAsPointer);

		operand = &operand_[0];
		if ((options() & roFar) && (operand->type & otMemory)) {
			CompileOperand(ctx, 0, coAsPointer);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);

			AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToValue(size_));
			AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
			AddVMCommand(ctx, cmAdd, otNone, size_, false);
			AddVMCommand(ctx, cmPush, otMemory, size_, operand->effective_base_segment(base_segment_));

			AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
			AddVMCommand(ctx, cmPush, otMemory, size_, operand->effective_base_segment(base_segment_));
		} else {
			AddCorrectOperandSizeSection(ctx, operand->size, size_);
			CompileOperand(ctx, 0, ((options() & roFar) || operand->type != otValue) ? 0 : coFixup);
		}

		if (section_options_ & rtLinkedFrom) {
			AddEndSection(ctx, cmJmp, (options() & roExternal) ? 0xff : 0, voUseEndSectionCryptor);
		} else {
			AddEndSection(ctx, cmRet, (options() & roFar) != 0);
		}
		break;

	case cmCall:
		if ((options() & roInternal) && (section_options_ & rtLinkedFrom) == 0) {
			uint8_t arg_count = static_cast<uint32_t>(operand_[2].value);
			switch (ctx.file->calling_convention()) {
			case ccMSx64:
				if (arg_count > 3)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regR9);
				if (arg_count > 2)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regR8);
				if (arg_count > 1)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regEDX);
				if (arg_count > 0)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regECX);
				break;
			case ccABIx64:
				if (arg_count > 5)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regR9);
				if (arg_count > 4)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regR8);
				if (arg_count > 3)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regECX);
				if (arg_count > 2)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regEDX);
				if (arg_count > 1)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regESI);
				if (arg_count > 0)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regEDI);
				break;
			}
		} else {
			if (options() & roFar) {
				AddCorrectOperandSizeSection(ctx, osWord, size_);
				AddVMCommand(ctx, cmPush, otSegmentRegistr, osWord, segCS);
			}
			AddVMCommand(ctx, cmPush, otValue, size_, 0, voLinkCommand | voFixup);
			CompileOperand(ctx, 1, coAsPointer);
		}

		operand = &operand_[0];
		if ((options() & roFar) && (operand->type & otMemory)) {
			CompileOperand(ctx, 0, coAsPointer);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);

			AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToValue(size_));
			AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
			AddVMCommand(ctx, cmAdd, otNone, size_, false);
			AddVMCommand(ctx, cmPush, otMemory, size_, operand->effective_base_segment(base_segment_));

			AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
			AddVMCommand(ctx, cmPush, otMemory, size_, operand->effective_base_segment(base_segment_));
		} else {
			AddCorrectOperandSizeSection(ctx, operand->size, size_);
			CompileOperand(ctx, 0, ((options() & roFar) || operand->type != otValue) ? 0 : coFixup);
		}

		if (section_options_ & rtLinkedFrom) {
			AddStoreExtRegistersSection(ctx);
			AddEndSection(ctx, cmJmp, (options() & roExternal) ? 0xff : 0, voUseEndSectionCryptor);
		} else if (options() & roInternal) {
			if (ctx.options.flags & cpCheckDebugger)
				AddCheckBreakpointSection(ctx, size_);
			if (ctx.options.flags & cpMemoryProtection)
				AddCheckCRCSection(ctx, size_);
			AddVMCommand(ctx, cmCall, otNone, size_, operand_[2].value);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regEAX);
		} else {
			AddEndSection(ctx, cmRet, (options() & roFar) != 0);
		}
		break;

	case cmSyscall:
		{
			uint8_t arg_count = static_cast<uint32_t>(operand_[2].value);
			switch (ctx.file->calling_convention()) {
			case ccMSx64:
				if (arg_count > 3)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regR9);
				if (arg_count > 2)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regR8);
				if (arg_count > 1)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regEDX);
				if (arg_count > 0)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regECX);
				break;
			}
		}
		CompileOperand(ctx, 0);
		AddVMCommand(ctx, cmSyscall, otNone, size_, operand_[2].value);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEAX);
		break;

	case cmCmov:
		AddJmpWithFlagSection(ctx, cmJmpWithFlag);
		AddBeginSection(ctx, voLinkCommand | voUseEndSectionCryptor);
		CompileOperand(ctx, 1);
		CompileOperand(ctx, 0, coSaveResult);

		if (section_options_ & rtLinkedNext) {
			AddVMCommand(ctx, cmPush, otValue, size_, 0, voLinkCommand | voFixup);
			AddEndSection(ctx, cmJmp, 0, voUseEndSectionCryptor);

			AddBeginSection(ctx, voLinkCommand | voUseEndSectionCryptor);
			AddVMCommand(ctx, cmPush, otValue, size_, 0, voLinkCommand | voFixup);
			AddEndSection(ctx, cmJmp, 0, voUseEndSectionCryptor);
		} else {
			AddVMCommand(ctx, cmPush, otValue, size_, address() + original_dump_size(), voFixup);
			AddEndSection(ctx, cmRet);

			AddBeginSection(ctx, voLinkCommand | voUseEndSectionCryptor);
			AddVMCommand(ctx, cmPush, otValue, size_, address() + original_dump_size(), voFixup);
			AddEndSection(ctx, cmRet);
		}
		break;

	case cmLods: case cmStos: case cmScas: case cmMovs: case cmCmps: case cmIns: case cmOuts:
		os = operand_[0].size;
		adr_os = operand_[1].size;
		value = OperandSizeToValue(os);

		if (preffix_command_ == cmRep || preffix_command_ == cmRepe || preffix_command_ == cmRepne) {
			if ((section_options_ & rtBeginSection) == 0)
				AddBeginSection(ctx, voUseBeginSectionCryptor);
			AddJmpWithFlagSection(ctx, cmJCXZ);
			AddBeginSection(ctx, voLinkCommand | voUseEndSectionCryptor);
		}

		switch (type_) {
		case cmLods:
			AddCorrectOperandSizeSection(ctx, adr_os, size_);
			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regESI);
			AddVMCommand(ctx, cmPush, otMemory, os, base_segment_ == segDefault ? segDS : base_segment_);

			AddVMCommand(ctx, cmPop, otRegistr, os, regEAX);
			if (size_ == osQWord && os == osDWord) {
				AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
				AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regEAX);
			}
			break;

		case cmStos:
			AddCorrectOperandSizeSection(ctx, adr_os, size_);
			AddVMCommand(ctx, cmPush, otRegistr, os, regEAX);
			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regEDI);
			AddVMCommand(ctx, cmPop, otMemory, os, segES);
			break;
		
		case cmMovs:
			AddCorrectOperandSizeSection(ctx, adr_os, size_);
			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regESI);
			AddVMCommand(ctx, cmPush, otMemory, os, base_segment_ == segDefault ? segDS : base_segment_);

			AddCorrectOperandSizeSection(ctx, adr_os, size_);
			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regEDI);
			AddVMCommand(ctx, cmPop, otMemory, os, segES);
			break;

		case cmScas:
			AddCorrectOperandSizeSection(ctx, adr_os, size_);
			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regEDI);
			AddVMCommand(ctx, cmPush, otMemory, os, segES);

			AddVMCommand(ctx, cmPush, otRegistr, os, regEAX);
			AddVMCommand(ctx, cmPush, otRegistr, os, regEAX);
			AddVMCommand(ctx, cmNor, otNone, os, false);

			AddVMCommand(ctx, cmAdd, otNone, os, true);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, os, segSS);
			AddVMCommand(ctx, cmNor, otNone, os, true);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regEIX);

			AddVMCommand(ctx, cmPop, otRegistr, os, regEmpty);

			AddCombineFlagsSection(ctx, fl_P | fl_O | fl_A | fl_C);
			break;

		case cmCmps:
			AddCorrectOperandSizeSection(ctx, adr_os, size_);
			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regESI);
			AddVMCommand(ctx, cmPush, otMemory, os, base_segment_ == segDefault ? segDS : base_segment_);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, os, segSS);
			AddVMCommand(ctx, cmNor, otNone, os, false);

			AddCorrectOperandSizeSection(ctx, adr_os, size_);
			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regEDI);
			AddVMCommand(ctx, cmPush, otMemory, os, segES);

			AddVMCommand(ctx, cmAdd, otNone, os, true);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, os, segSS);
			AddVMCommand(ctx, cmNor, otNone, os, true);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regEIX);

			AddVMCommand(ctx, cmPop, otRegistr, os, regEmpty);

			AddCombineFlagsSection(ctx, fl_P | fl_O | fl_A | fl_C);
			break;

		case cmIns:
			AddCorrectOperandSizeSection(ctx, adr_os, size_);

			AddVMCommand(ctx, cmPush, otRegistr, osWord, regEDX);
			AddVMCommand(ctx, cmIn, otNone, os, 0);

			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regEDI);
			AddVMCommand(ctx, cmPop, otMemory, os, segES);
			break;

		case cmOuts:
			AddCorrectOperandSizeSection(ctx, adr_os, size_);

			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regESI);
			AddVMCommand(ctx, cmPush, otMemory, os, base_segment_ == segDefault ? segDS : base_segment_);

			AddVMCommand(ctx, cmPush, otRegistr, osWord, regEDX);
			AddVMCommand(ctx, cmOut, otNone, os, 0);
			break;
		}
		
		AddExtractFlagSection(ctx, fl_D, true, (uint8_t)(value << 1));

		if (adr_os != size_) {
			AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);
			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regETX);
		}
		AddVMCommand(ctx, cmPush, otValue, adr_os, 0 - value);
		AddVMCommand(ctx, cmAdd, otNone, adr_os, false);

		switch (type_) {
		case cmLods: case cmOuts:
			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regESI);
			AddVMCommand(ctx, cmAdd, otNone, adr_os, false);
			AddVMCommand(ctx, cmPop, otRegistr, adr_os, regESI);
			break;

		case cmStos: case cmScas: case cmIns:
			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regEDI);
			AddVMCommand(ctx, cmAdd, otNone, adr_os, false);
			AddVMCommand(ctx, cmPop, otRegistr, adr_os, regEDI);
			break;

		case cmMovs: case cmCmps:
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, adr_os, segSS);

			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regESI);
			AddVMCommand(ctx, cmAdd, otNone, adr_os, false);
			AddVMCommand(ctx, cmPop, otRegistr, adr_os, regESI);

			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regEDI);
			AddVMCommand(ctx, cmAdd, otNone, adr_os, false);
			AddVMCommand(ctx, cmPop, otRegistr, adr_os, regEDI);
			break;
		}

		if (preffix_command_ == cmRep || preffix_command_ == cmRepe || preffix_command_ == cmRepne) {
			AddJmpWithFlagSection(ctx, (type_ == cmScas || type_ == cmCmps) ? preffix_command_ : cmRep);
			if ((section_options_ & rtLinkedNext) == 0) {
				AddBeginSection(ctx, voLinkCommand | voUseEndSectionCryptor);
				AddVMCommand(ctx, cmPush, otValue, size_, address() + original_dump_size(), voFixup);
				AddEndSection(ctx, cmRet);
			}
		}
		break;

	case cmRet:
		operand = &operand_[0];
		if (operand->type == otValue) {
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, size_, segSS);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otValue, size_, operand->value + OperandSizeToStack(size_));
			AddVMCommand(ctx, cmAdd, otNone, size_, false);
			AddVMCommand(ctx, cmPop, otMemory, size_, segSS);

			if (options() & roFar) {
				AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
				AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToStack(size_));
				AddVMCommand(ctx, cmAdd, otNone, size_, false);
				AddVMCommand(ctx, cmPush, otMemory, size_, segSS);

				AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
				AddVMCommand(ctx, cmPush, otValue, size_, operand->value + OperandSizeToStack(size_) * 2);
				AddVMCommand(ctx, cmAdd, otNone, size_, false);
				AddVMCommand(ctx, cmPop, otMemory, size_, segSS);
			}

			switch (operand->value) {
			case 2:
				AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);
				break;
			case 4:
				AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
				break;
			case 8:
				AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
				AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
				break;
			case 10:
				AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);
				AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
				AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
				break;
			case 12:
				AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
				AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
				AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
				break;
			default:
				AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
				AddVMCommand(ctx, cmPush, otValue, size_, operand->value);
				AddVMCommand(ctx, cmAdd, otNone, size_, false);
				AddVMCommand(ctx, cmPop, otRegistr, size_, regESP);
				break;
			}
		}
		if (options() & roInternal) {
			AddEndSection(ctx, cmJmp, 0);
		} else {
			AddEndSection(ctx, cmRet, (options() & roFar) ? 1 : 0);
		}
		break;

	case cmIret:
		AddEndSection(ctx, cmIret);
		break;

	case cmLeave:
		AddVMCommand(ctx, cmPush, otRegistr, size_, regEBP);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regESP);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEBP);
		break;

	case cmLes: case cmLds: case cmLfs: case cmLgs:
		os = operand_[0].size;
		CompileOperand(ctx, 1, coAsPointer);

		AddVMCommand(ctx, cmPush, otRegistr, osDWord, regESP);
		AddVMCommand(ctx, cmPush, otMemory, osDWord, segSS);
		AddVMCommand(ctx, cmPush, otValue, osDWord, OperandSizeToStack(os));
		AddVMCommand(ctx, cmAdd, otNone, osDWord, false);

		AddVMCommand(ctx, cmPush, otMemory, osWord, operand_[1].effective_base_segment(base_segment_));

		switch (type_) {
		case cmLes:
			AddVMCommand(ctx, cmPop, otSegmentRegistr, osWord, segES);
			break;
		case cmLds:
			AddVMCommand(ctx, cmPop, otSegmentRegistr, osWord, segDS);
			break;
		case cmLfs:
			AddVMCommand(ctx, cmPop, otSegmentRegistr, osWord, segFS);
			break;
		case cmLgs:
			AddVMCommand(ctx, cmPop, otSegmentRegistr, osWord, segGS);
			break;
		}

		AddVMCommand(ctx, cmPush, otMemory, os, operand_[1].effective_base_segment(base_segment_));
		CompileOperand(ctx, 0, coSaveResult);
		break;

	case cmRdtsc:
		AddVMCommand(ctx, cmRdtsc, otNone, size_, 0);
		AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEDX);
		AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEAX);

		if (size_ == osQWord) {
			AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
			AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regEAX);
			AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
			AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regEDX);
		}
		break;

	case cmCpuid:
		AddVMCommand(ctx, cmPush, otRegistr, osDWord, regEAX);
		AddVMCommand(ctx, cmCpuid, otNone, size_, 0);            
		AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEDX);
		AddVMCommand(ctx, cmPop, otRegistr, osDWord, regECX);
		AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEBX);
		AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEAX);

		if (size_ == osQWord) {
			AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
			AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regEAX);
			AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
			AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regEBX);
			AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
			AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regECX);
			AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
			AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regEDX);
		}
		break;

	case cmF2xm1: case cmFabs: case cmFclex: case cmFcos: case cmFdecstp: case cmFincstp:
	case cmFinit: case cmFldln2: case cmFldlg2: case cmFprem: case cmFprem1: case cmFptan:
	case cmFrndint: case cmFsin: case cmFtst: case cmFyl2x: case cmFpatan: case cmFldz: case cmFld1:
	case cmFldpi: case cmWait: case cmFchs: case cmFsqrt:
		AddVMCommand(ctx, type_, otNone, size_, 0);
		break;

	case cmFistp: case cmFist: case cmFstp: case cmFst:
		os = operand_[0].size;
		operand = &operand_[0];

		if (operand->type == (otMemory | otBaseRegistr) && operand->base_registr == regESP) {
			AddVMCommand(ctx, type_, otNone, os, 0);
		} else {
			switch (os) {
			case osWord:
				AddVMCommand(ctx, cmPush, otRegistr, osWord, regEmpty);
				break;
			case osDWord:
				AddVMCommand(ctx, cmPush, otRegistr, osDWord, regEmpty);
				break;
			case osQWord:
				if (size_ == osQWord) {
					AddVMCommand(ctx, cmPush, otRegistr, osQWord, regEmpty);
				} else {
					AddVMCommand(ctx, cmPush, otRegistr, osDWord, regEmpty);
					AddVMCommand(ctx, cmPush, otRegistr, osDWord, regEmpty);
				}
				break;
			case osTByte:
				if (size_ == osQWord) {
					AddVMCommand(ctx, cmPush, otRegistr, osQWord, regEmpty);
				} else {
					AddVMCommand(ctx, cmPush, otRegistr, osDWord, regEmpty);
					AddVMCommand(ctx, cmPush, otRegistr, osDWord, regEmpty);
				}
				AddVMCommand(ctx, cmPush, otRegistr, osWord, regEmpty);
				break;
			}

			AddVMCommand(ctx, type_, otNone, os, 0);
			CompileOperand(ctx, 0, coAsPointer);

			IntelSegment base_segment = operand->effective_base_segment(base_segment_);
			switch (os) {
			case osWord:
				AddVMCommand(ctx, cmPop, otMemory, osWord, base_segment);
				break;
			case osDWord:
				AddVMCommand(ctx, cmPop, otMemory, osDWord, base_segment);
				break;
			case osQWord:
				if (size_ == osQWord) {
					AddVMCommand(ctx, cmPop, otMemory, osQWord, base_segment);
				} else {
					AddVMCommand(ctx, cmPop, otMemory, osDWord, base_segment);
					CompileOperand(ctx, 0, coAsPointer);
					AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToValue(osDWord));
					AddVMCommand(ctx, cmAdd, otNone, size_, false);
					AddVMCommand(ctx, cmPop, otMemory, osDWord, base_segment);
				}
				break;
			case osTByte:
				if (size_ == osQWord) {
					AddVMCommand(ctx, cmPop, otMemory, osQWord, base_segment);
				} else {
					AddVMCommand(ctx, cmPop, otMemory, osDWord, base_segment);
					CompileOperand(ctx, 0, coAsPointer);
					AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToValue(osDWord));
					AddVMCommand(ctx, cmAdd, otNone, size_, false);
					AddVMCommand(ctx, cmPop, otMemory, osDWord, base_segment);
				}
				CompileOperand(ctx, 0, coAsPointer);
				AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToValue(osQWord));
				AddVMCommand(ctx, cmAdd, otNone, size_, false);
				AddVMCommand(ctx, cmPop, otMemory, osWord, base_segment);
				break;
			}
		}
		break;

	case cmFadd: case cmFsub: case cmFisub: case cmFsubr: case cmFdiv: case cmFmul: case cmFcomp:
	case cmFild: case cmFld:
		os = operand_[0].size;
		operand = &operand_[0];

		if (operand->type == (otMemory | otBaseRegistr) && operand->base_registr == regESP) {
			AddVMCommand(ctx, type_, otNone, os, 0);
		} else {
			CompileOperand(ctx, 0, coAsPointer);

			IntelSegment base_segment = operand->effective_base_segment(base_segment_);
			switch (os) {
			case osWord:
				AddVMCommand(ctx, cmPush, otMemory, osWord, base_segment);
				break;
			case osDWord:
				AddVMCommand(ctx, cmPush, otMemory, osDWord, base_segment);
				break;
			case osQWord:
				if (size_ == osQWord) {
					AddVMCommand(ctx, cmPush, otMemory, osQWord, base_segment);
				} else {
					AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToValue(osDWord));
					AddVMCommand(ctx, cmAdd, otNone, size_, false);
					AddVMCommand(ctx, cmPush, otMemory, osDWord, base_segment);
					CompileOperand(ctx, 0, coAsPointer);
					AddVMCommand(ctx, cmPush, otMemory, osDWord, base_segment);
				}
				break;
			case osTByte:
				AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToValue(osQWord));
				AddVMCommand(ctx, cmAdd, otNone, size_, false);
				AddVMCommand(ctx, cmPush, otMemory, osWord, base_segment);
				CompileOperand(ctx, 0, coAsPointer);
				if (size_ == osQWord) {
					AddVMCommand(ctx, cmPush, otMemory, osQWord, base_segment);
				} else {
					AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToValue(osDWord));
					AddVMCommand(ctx, cmAdd, otNone, size_, false);
					AddVMCommand(ctx, cmPush, otMemory, osDWord, base_segment);
					CompileOperand(ctx, 0, coAsPointer);
					AddVMCommand(ctx, cmPush, otMemory, osDWord, base_segment);
				}
				break;
			}

			AddVMCommand(ctx, type_, otNone, os, 0);

			switch (os) {
			case osWord:
				AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);
				break;
			case osDWord:
				AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
				break;
			case osQWord:
				if (size_ == osQWord) {
					AddVMCommand(ctx, cmPop, otRegistr, osQWord, regEmpty);
				} else {
					AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
					AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
				}
				break;
			case osTByte:
				if (size_ == osQWord) {
					AddVMCommand(ctx, cmPop, otRegistr, osQWord, regEmpty);
				} else {
					AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
					AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
				}
				AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);
				break;
			}
		}
		break;

	case cmCrc:
		switch (ctx.file->calling_convention()) { //-V719
		case ccStdcall:
			// do nothing
			break;
		case ccCdecl:
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP); //-V760
			AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToStack(size_));
			AddVMCommand(ctx, cmAdd, otNone, size_, false);
			AddVMCommand(ctx, cmPush, otMemory, size_, segSS);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToStack(size_));
			AddVMCommand(ctx, cmAdd, otNone, size_, false);
			AddVMCommand(ctx, cmPush, otMemory, size_, segSS);
			break;
		case ccMSx64:
			AddVMCommand(ctx, cmPush, otRegistr, size_, regEDX);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regECX);
			break;
		case ccABIx64:
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESI);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regEDI);
			break;
		}
		AddVMCommand(ctx, cmCrc, otNone, size_, 0);
		AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEAX);
		break;

	case cmDD: case cmDQ:
		operand = &operand_[0];
		AddVMCommand(ctx, type_, otValue, (type_ == cmDD) ? osDWord : osQWord, operand->value, voLinkCommand | (operand->fixup ? voFixup : voNone), operand->fixup);
		break;

	default:
		throw std::runtime_error("Runtime error at CompileToVM: " + text());
		break;
	}

	GetCommandInfo(*vm_command_info_list_);
	for (i = vm_command_info_list_->count(); i > 0 ; i--) {
		CommandInfo *command_info = vm_command_info_list_->item(i - 1);
		if ((command_info->operand_type() == otRegistr || command_info->operand_type() == otHiPartRegistr) && command_info->value() == regEFX)
			delete command_info;
	}
	for (i = 0; i < count(); i++) {
		IntelVMCommand *command = item(i);
		if (command->options() & voSectionCommand) {
			if (section_options() & rtBeginSection)
				continue;
			if (section_options() & rtEndSection)
				break;
		}

		switch (command->command_type()) {
		case cmPush: case cmPop:
			if ((command->operand_type() == otRegistr || command->operand_type() == otHiPartRegistr) && 
				(command->registr() == regEFX || command->registr() == regETX || command->registr() == regEIX || (command->registr() & regExtended)))
				vm_command_info_list_->Add(command->command_type() == cmPush ? atRead : atWrite, command->registr(), command->operand_type(), command->size());
			break;
		case cmCall:
			vm_command_info_list_->Add(atWrite, regEAX, otRegistr, size());
			break;
		case cmCrc:
			vm_command_info_list_->Add(atRead, regESP, otRegistr, size());
			vm_command_info_list_->Add(atWrite, regESP, otRegistr, size());
			vm_command_info_list_->Add(atWrite, regEAX, otRegistr, size());
			break;
		}
	}
}

void IntelCommand::PrepareLink(const CompileContext &ctx)
{
	bool from_native = block() && (block()->type() & mtExecutable) ? true : owner()->compilation_type() == ctMutation;

	IntelCommand *to_command = reinterpret_cast<IntelCommand *>(link()->to_command());
	if (to_command) {
		if (link()->operand_index() > -1) {
			IntelOperand *operand = &operand_[link()->operand_index()];
			if (size_ == osQWord && link()->sub_value() > ctx.file->image_base()) {
				if (link()->operand_index() == 1 && (operand->type & otMemory) && operand_[0].size == osDWord && type_ != cmMovsxd) {
					if (type_ == cmMov) {
						type_ = cmMovsxd;
						operand_[0].size = osQWord;
						CompileToNative();
					} else {
						throw std::runtime_error("Runtime error at PrepareLink: " + text());
					}
				}
			}
			if (operand->type & otMemory) {
				if ((operand->type & otValue) == 0) {
					operand->type |= otValue;
					operand->value = 0;
					operand->value_size = osDWord;
					CompileToNative();
				} else if (operand->value_size < osDWord) {
					operand->value_size = osDWord;
					CompileToNative();
				}
			}

			if ((operand->type & otValue) == 0)
				throw std::runtime_error("Runtime error at PrepareLink: " + text());
		}

		bool to_native = to_command->block() && (to_command->block()->type() & mtExecutable) ? true : to_command->owner()->compilation_type() == ctMutation;
		if (from_native == to_native) {
			section_options_ |= rtLinkedFrom;
		} else {
			section_options_ |= rtLinkedFromOtherType;
		}

		if ((section_options_ & rtLinkedFromOtherType)
			|| link()->type() == ltSEHBlock
			|| link()->type() == ltFinallyBlock
			|| link()->type() == ltFilterSEHBlock
			|| link()->type() == ltDualSEHBlock
			|| link()->type() == ltGateOffset
			|| link()->type() == ltMemSEHBlock
			|| link()->type() == ltExtSEHHandler
			|| link()->type() == ltVBMemSEHBlock) {
			to_command->include_section_option(rtLinkedToExt);
		} else {
			to_command->include_section_option(rtLinkedToInt);
		}
	}

	if (from_native)
		return;

	size_t j;
	bool need_next_command = false;
	bool need_init_cryptor = false;
	ICommand *next_command;

	switch (link()->type()) {
	case ltCall:
		if ((options() & roUseAsJmp) == 0)
			need_next_command = true;
		need_init_cryptor = true;
		break;
	case ltJmp:
		if (section_options_ & rtLinkedFrom)
			need_init_cryptor = true;
		break;
	case ltSwitch:
		if (section_options_ & rtLinkedFrom) {
			if (!end_section_cryptor_)
				need_init_cryptor = true;
		}
		break;
	case ltCase:
		if (to_command)
			need_init_cryptor = true;
		break;
	case ltNative:
		if ((options() & roBreaked) == 0 && type_ != cmJmp)
			need_next_command = true;
		break;
	case ltJmpWithFlagNSNS:
		need_next_command = true;
		need_init_cryptor = true;
		break;
	case ltJmpWithFlagNSNA:
		need_next_command = true;
		need_init_cryptor = true;
		break;
	case ltJmpWithFlagNSFS:
		include_section_option(rtLinkedToInt);
		to_command = this;
		link()->set_to_command(to_command);
		need_next_command = true;
		need_init_cryptor = true;
		break;
	case ltJmpWithFlag:
		need_next_command = true;
		need_init_cryptor = true;
		break;
	case ltDualSEHBlock:
		if (to_command) {
			j = owner()->IndexOf(to_command) + 1;
			next_command = owner()->item(j);
			link()->set_next_command(next_command);
			next_command->include_section_option(rtLinkedToExt);
		}
		break;
	}

	if (need_next_command) {
		j = owner()->IndexOf(this) + 1;
		if (j < owner()->count()) {
			next_command = owner()->item(j);
			if (owner()->is_breaked_address(next_command->address()))
				next_command = NULL;
			else {
				if (link()->type() == ltCall) {
					if (to_command != next_command) {
						include_section_option(rtLinkedNext);
						link()->set_next_command(next_command);
						next_command->include_section_option(rtLinkedToExt);
					}
				} else {
					include_section_option(rtLinkedNext);
					link()->set_next_command(next_command);
					next_command->include_section_option(link()->type() == ltNative ? rtLinkedToExt : rtLinkedToInt);
				}
			}
		}
	}

	if (need_init_cryptor) {
		SectionCryptorList *section_cryptor_list = reinterpret_cast<IntelFunction*>(owner())->section_cryptor_list();
		SectionCryptor *cur_section_cryptor = NULL;
		IntelCommand *save_cryptor_command = NULL;
		IntelCommand *parent_command = reinterpret_cast<IntelCommand*>(link()->parent_command());

		if (link()->type() == ltCase) {
			cur_section_cryptor = parent_command->end_section_cryptor_;
			if (!cur_section_cryptor) {
				cur_section_cryptor = section_cryptor_list->Add();
				parent_command->end_section_cryptor_ = cur_section_cryptor;
			}
			begin_section_cryptor_ = cur_section_cryptor;
			save_cryptor_command = to_command;
		} else {
			if (to_command) {
				if (section_options_ & rtLinkedFromOtherType) {
					if (link()->type() == ltCall) {
						cur_section_cryptor = section_cryptor_list->Add();
					} else {
						return;
					}
				} else {
					cur_section_cryptor = to_command->begin_section_cryptor_;
					if (!cur_section_cryptor && (options() & roExternal) == 0) {
						cur_section_cryptor = section_cryptor_list->Add();
						to_command->begin_section_cryptor_ = cur_section_cryptor;
					}
				}
			} else {
				cur_section_cryptor = section_cryptor_list->Add();
			}
			end_section_cryptor_ = cur_section_cryptor;

			if (link()->type() == ltSwitch && parent_command)
				parent_command->end_section_cryptor_ = cur_section_cryptor;

			if (link()->type() == ltSwitch && to_command && to_command->link() && to_command->link()->parent_command() != this) {
				save_cryptor_command = reinterpret_cast<IntelCommand*>(to_command->link()->parent_command());
			} else if (link()->type() == ltJmpWithFlag || link()->type() == ltJmpWithFlagNSNA || link()->type() == ltJmpWithFlagNSFS || link()->type() == ltJmpWithFlagNSNS) {
				save_cryptor_command = reinterpret_cast<IntelCommand*>(link()->next_command());
			}
		}

		if (save_cryptor_command) {
			if (link()->type() == ltSwitch) {
				if (save_cryptor_command->end_section_cryptor_ != cur_section_cryptor) {
					if (save_cryptor_command->end_section_cryptor_) {
						cur_section_cryptor->set_end_cryptor(save_cryptor_command->end_section_cryptor_);
					} else {
						save_cryptor_command->end_section_cryptor_ = cur_section_cryptor;
					}
				}
			} else {
				if (save_cryptor_command->begin_section_cryptor_ != cur_section_cryptor) {
					if (save_cryptor_command->begin_section_cryptor_) {
						cur_section_cryptor->set_end_cryptor(save_cryptor_command->begin_section_cryptor_);
					} else {
						save_cryptor_command->begin_section_cryptor_ = cur_section_cryptor;
					}
				}
			}
		}
	}
}

void IntelCommand::CompileLink(const CompileContext &ctx)
{
	size_t k;
	uint64_t value, value1;
	
	if (block()->type() & mtExecutable) {
		// native block
		if (!link() || link()->operand_index() == -1)
			return;

		ICommand *to_command = link()->to_command();
		if (to_command) {
			value = (to_command->block()->type() & mtExecutable) ? to_command->address() : to_command->ext_vm_address();
		} else if (link()->type() == ltDelta) {
			value = link()->to_address();
		} else {
			return;
		}

		if (link()->type() == ltDelta)
			value -= link()->parent_command() ? link()->parent_command()->address() : address();
		set_operand_value(link()->operand_index(), link()->Encrypt(value));
		CompileToNative();
	} else {
		// VM block
		for (size_t i = 0; i < internal_links_.count(); i++) {
			InternalLink *internal_link = internal_links_.item(i);
			IntelVMCommand *vm_command = reinterpret_cast<IntelVMCommand *>(internal_link->from_command());

			switch (internal_link->type()) {
			case vlCRCTableAddress:
				value = reinterpret_cast<IntelFunctionList *>(ctx.file->function_list())->runtime_crc_table()->entry()->address();
				break;
			case vlCRCTableCount:
				value = reinterpret_cast<IntelFunctionList *>(ctx.file->function_list())->runtime_crc_table()->region_count();
				break;
			case vlCRCValue:
				{
					IntelVMCommand *value_command = reinterpret_cast<IntelVMCommand*>(internal_link->to_command());
					uint64_t crc_value = reinterpret_cast<IntelVirtualMachineList *>(ctx.file->virtual_machine_list())->GetCRCValue(value, OperandSizeToValue(value_command->size()));
					value_command->set_sub_value(crc_value);
					value_command->Compile();
				}
				break;
			default:
				{
					IntelCommand *command = reinterpret_cast<IntelCommand*>(internal_link->to_command());
					if (!command)
						continue;

					value = command->is_data() ? command->address() : command->owner()->entry()->address();
				}
				break;
			}
			vm_command->set_value(value);
			vm_command->Compile();
		}

		if (vm_links_.empty())
			return;

		ICommand *to_command = link()->to_command();
		ICommand *next_command = link()->next_command();
		ICommand *ext_command;

		switch (link()->type()) {
		case ltSEHBlock: case ltFinallyBlock: case ltExtSEHBlock:
			if (to_command)
				set_link_value(0, link()->gate_command(0)->address());
			break;

		case ltMemSEHBlock: case ltExtSEHHandler: case ltVBMemSEHBlock:
			// do nothing
			break;

		case ltDualSEHBlock: case ltFilterSEHBlock:
			if (to_command)
				set_link_value(0, link()->gate_command(0)->address());
			break;

		case ltJmpWithFlag:
			k = next_command ? 1 : 0;

			value = vm_links_[2]->address();
			value1 = vm_links_[3 + k]->address();
			set_link_value(0, value1);
			set_link_value(1, value);

			if (next_command) {
				if (next_command->block()->virtual_machine()->id() == block()->virtual_machine()->id())
					set_link_value(1, next_command->vm_address());
				else {
					set_link_value(3, next_command->vm_address());
					set_jmp_value(1, next_command->block()->virtual_machine()->id());
				}
			}
			if (to_command) {
				if (section_options_ & rtLinkedFrom) {
					if (to_command->block()->virtual_machine()->id() == block()->virtual_machine()->id())
						set_link_value(0, to_command->vm_address());
					else {
						set_link_value(4 + k, to_command->vm_address());
						set_jmp_value(1 + k, to_command->block()->virtual_machine()->id());
					}
				}
			}
			break;

		case ltJmpWithFlagNSNS:
			value = vm_links_[2]->address();
			value1 = vm_links_[4]->address();

			set_link_value(0, value);
			set_link_value(1, value1);

			if (next_command) {
				value = next_command->vm_address();
				set_link_value(3, value);
				set_link_value(5, value);
			}
			break;

		case ltJmpWithFlagNSNA:
			value = vm_links_[2]->address();
			if (next_command) {
				value1 = vm_links_[4]->address();
			} else {
				value1 = vm_links_[3]->address();
			}

			set_link_value(0, value);
			set_link_value(1, value1);

			if (next_command) {
				set_link_value(3, next_command->vm_address());
				set_jmp_value(1, next_command->block()->virtual_machine()->id());
				if (next_command->block()->virtual_machine()->id() == block()->virtual_machine()->id()) {
					set_link_value(1, next_command->vm_address());
				} else {
					set_link_value(5, next_command->vm_address());
					set_jmp_value(2, next_command->block()->virtual_machine()->id());
				}
			}
			break;

		case ltJmpWithFlagNSFS:
			value = vm_links_[2]->address();
			if (next_command) {
				value1 = next_command->vm_address();
			} else {
				value1 = vm_links_[5]->address();
			}

			set_link_value(0, value1);
			set_link_value(1, value);
			set_link_value(3, value);
			set_link_value(4, value1);
			break;

		case ltJmp:
			if (to_command) {
				if (section_options_ & rtLinkedFromOtherType) {
					value = to_command->address();
				} else {
					value = to_command->vm_address();
					set_jmp_value(0, to_command->block()->virtual_machine()->id());
				}
				set_link_value(0, link()->Encrypt(value));
			}
			break;

		case ltCall:
			if ((options() & roInternal) && (section_options_ & rtLinkedFrom) == 0) {
				k = 0;
			} else {
				k = 1;
				ext_command = link()->gate_command(0);
				if (ext_command) {
					value = ext_command->address();
				} else if (options() & roInternal) {
					value = next_command->ext_vm_address();
				} else {
					value = address() + original_dump_size();
				}
				set_link_value(0, value);
			}

			if (section_options_ & rtLinkedFrom) {
				set_link_value(k, to_command->vm_address());
				set_jmp_value(0, to_command->block()->virtual_machine()->id());
			} else if (section_options_ & rtLinkedFromOtherType) {
				set_link_value(k, to_command->address());
			}
			break;

		case ltNative:
			set_link_value(0, link()->gate_command(0)->address());
			break;

		case ltOffset:
			if (to_command) {
				if ((section_options_ & rtLinkedFromOtherType) || to_command->is_data()) {
					value = to_command->address();
				} else {
					value = to_command->vm_address();
				}
				set_link_value(0, link()->Encrypt(value));
			}
			break;

		case ltGateOffset:
			if (to_command) {
				value = to_command->address();
				set_link_value(0, link()->Encrypt(value));
			}
			break;

		case ltSwitch:
			if (to_command) {
				if (section_options_ & rtLinkedFromOtherType) {
					value = to_command->address();
				} else {
					value = to_command->vm_address();
				}
				set_link_value(0, link()->Encrypt(value));
			}
			break;

		case ltCase:
			if (to_command) {
				ext_command = link()->gate_command(0);
				if (section_options_ & rtLinkedFromOtherType) {
					ext_command->set_link_value(0, to_command->address());
					value = ext_command->vm_address();
				} else if (ext_command->block()->virtual_machine()->id() != to_command->block()->virtual_machine()->id()) {
					ext_command->set_link_value(0, to_command->vm_address());
					ext_command->set_jmp_value(0, to_command->block()->virtual_machine()->id());
					value = ext_command->vm_address();
				} else {
					value = to_command->vm_address();
				}
				set_link_value(0, link()->Encrypt(value));
			}
			break;
		}
	}
}

bool IntelCommand::GetCommandInfo(IntelCommandInfoList &command_info_list) const
{
	OperandSize os, adr_os;

	command_info_list.clear();
	command_info_list.set_base_segment(base_segment_);

	switch (type_) {
	case cmAaa: case cmAas:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_A);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.Add(atRead, regEAX, otRegistr, osByte);
		command_info_list.Add(atWrite, regEAX, otRegistr, osWord);
		break;

	case cmAad:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.Add(atRead, regEAX, otRegistr, osWord);
		command_info_list.Add(atWrite, regEAX, otRegistr, osWord);
		break;

	case cmAam:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.Add(atRead, regEAX, otRegistr, osByte);
		command_info_list.Add(atWrite, regEAX, otRegistr, osWord);
		break;

	case cmAdc:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_C);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmAdd: case cmAnd:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmBsf: case cmBsr:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmBswap:
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmBt:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		break;

	case cmBtc: case cmBtr: case cmBts:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmCall:
		command_info_list.Add(atRead, regESP, otRegistr, size_);
		command_info_list.Add(atWrite, regESP, otRegistr, size_);
		command_info_list.Add(atWrite, regEIP, otBaseRegistr, size_);

		command_info_list.AddOperand(operand_[0], atRead);
		break;

	case cmSyscall:
		command_info_list.Add(atRead, regESP, otRegistr, size_);
		command_info_list.Add(atWrite, regESP, otRegistr, size_);
		command_info_list.Add(atWrite, regEIP, otBaseRegistr, size_);
		break;

	case cmCbw:
		command_info_list.Add(atRead, regEAX, otRegistr, osByte);
		command_info_list.Add(atWrite, regEAX, otHiPartRegistr, osByte);
		break;

	case cmCwde:
		command_info_list.Add(atRead, regEAX, otRegistr, osWord);
		command_info_list.Add(atWrite, regEAX, otRegistr, osDWord);
		break;

	case cmCdqe:
		command_info_list.Add(atRead, regEAX, otRegistr, osDWord);
		command_info_list.Add(atWrite, regEAX, otRegistr, osQWord);
		break;

	case cmCwd:
		command_info_list.Add(atRead, regEAX, otRegistr, osWord);
		command_info_list.Add(atWrite, regEDX, otRegistr, osWord);
		break;

	case cmCdq:
		command_info_list.Add(atRead, regEAX, otRegistr, osDWord);
		command_info_list.Add(atWrite, regEDX, otRegistr, osDWord);
		break;

	case cmCqo:
		command_info_list.Add(atRead, regEAX, otRegistr, osQWord);
		command_info_list.Add(atWrite, regEDX, otRegistr, osQWord);
		break;

	case cmClc: case cmStc:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_C);
		break;

	case cmCmc:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_C);
		command_info_list.set_change_flags(fl_C);
		break;

	case cmCld: case cmStd:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_D);
		break;

	case cmCli: case cmSti:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_I);
		break;

	case cmCmov:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(flags_);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmCmp:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		break;

	case cmCmps:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_D);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		os = operand_[0].size;
		adr_os = operand_[1].size;
     
		command_info_list.Add(atRead, regESI, otRegistr, adr_os);
		command_info_list.Add(atRead, regEDI, otRegistr, adr_os);
		command_info_list.Add(atWrite, regESI, otRegistr, adr_os);
		command_info_list.Add(atWrite, regEDI, otRegistr, adr_os);

		command_info_list.Add(atRead, segES, otMemory, os);

		if (preffix_command_ == cmRep || preffix_command_ == cmRepe || preffix_command_ == cmRepne) {
			command_info_list.Add(atRead, regECX, otRegistr, adr_os);
			command_info_list.Add(atWrite, regECX, otRegistr, adr_os);
		}
		break;

	case cmCmpxchg:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		os = operand_[0].size;
		command_info_list.Add(atRead, regEAX, otRegistr, os);
		command_info_list.Add(atWrite, regEAX, otRegistr, os);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmCmpxchg8b:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_Z);

		command_info_list.Add(atRead, regEAX, otRegistr, osDWord);
		command_info_list.Add(atRead, regEDX, otRegistr, osDWord);
		command_info_list.Add(atWrite, regEAX, otRegistr, osDWord);
		command_info_list.Add(atWrite, regEDX, otRegistr, osDWord);

		command_info_list.Add(atRead, regEBX, otRegistr, osDWord);
		command_info_list.Add(atRead, regECX, otRegistr, osDWord);

		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmCpuid:
		command_info_list.Add(atRead, regEAX, otRegistr, osDWord);

		command_info_list.Add(atWrite, regEAX, otRegistr, osDWord);
		command_info_list.Add(atWrite, regECX, otRegistr, osDWord);
		command_info_list.Add(atWrite, regEDX, otRegistr, osDWord);
		command_info_list.Add(atWrite, regEBX, otRegistr, osDWord);     
		break;

	case cmDaa:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_A);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.Add(atRead, regEAX, otRegistr, osByte);
		command_info_list.Add(atWrite, regEAX, otRegistr, osByte);
		break;

	case cmDas:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_A | fl_C);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.Add(atRead, regEAX, otRegistr, osByte);
		command_info_list.Add(atWrite, regEAX, otRegistr, osByte);
		break;

	case cmDec: case cmInc:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P);

		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmDiv: case cmIdiv:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[0], atRead);

		os = operand_[0].size;
		if (os == osByte) {
			command_info_list.Add(atRead, regEAX, otRegistr, osWord);
			command_info_list.Add(atWrite, regEAX, otRegistr, osWord);
		} else {
			command_info_list.Add(atRead, regEAX, otRegistr, os);
			command_info_list.Add(atWrite, regEAX, otRegistr, os);
			command_info_list.Add(atRead, regEDX, otRegistr, os);
			command_info_list.Add(atWrite, regEDX, otRegistr, os);
		}
		break;

	case cmMul: case cmImul:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		os = operand_[0].size;
		if (operand_[2].type != otNone) {
			command_info_list.AddOperand(operand_[2], atRead);
			command_info_list.AddOperand(operand_[1], atRead);
			command_info_list.AddOperand(operand_[0], atWrite);
		} else if (operand_[1].type != otNone) {
			command_info_list.AddOperand(operand_[1], atRead);
			command_info_list.AddOperand(operand_[0], atRead);
			command_info_list.AddOperand(operand_[0], atWrite);
		} else {
			command_info_list.AddOperand(operand_[0], atRead);
			command_info_list.Add(atRead, regEAX, otRegistr, os);
		}

		if (operand_[1].type == otNone) {
			if (os == osByte) {
				command_info_list.Add(atWrite, regEAX, otRegistr, osWord);
			} else {
				command_info_list.Add(atWrite, regEAX, otRegistr, os);
				command_info_list.Add(atWrite, regEDX, otRegistr, os);
			}
		}
		break;

	case cmJCXZ:
		os = operand_[1].size;
		command_info_list.Add(atRead, regECX, otRegistr, os);

		command_info_list.Add(atWrite, regEIP, otBaseRegistr, size_);
		break;

	case cmJmpWithFlag:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(flags_);

		command_info_list.Add(atWrite, regEIP, otBaseRegistr, size_);
		break;

	case cmJmp:
		command_info_list.Add(atWrite, regEIP, otBaseRegistr, size_);

		command_info_list.AddOperand(operand_[0], atRead);
		break;

	case cmLahf:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.Add(atWrite, regEAX, otHiPartRegistr, osByte);
		break;

	case cmLds:
		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);

		command_info_list.Add(atWrite, segDS, otSegmentRegistr, osWord);
		break;

	case cmLes:
		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);

		command_info_list.Add(atWrite, segES, otSegmentRegistr, osWord);
		break;

	case cmLfs:
		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);

		command_info_list.Add(atWrite, segFS, otSegmentRegistr, osWord);
		break;

	case cmLgs:
		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);

		command_info_list.Add(atWrite, segGS, otSegmentRegistr, osWord);
		break;

	case cmLss:
		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);

		command_info_list.Add(atWrite, segSS, otSegmentRegistr, osWord);
		break;

	case cmLea:
		{
			IntelOperand operand = operand_[1];
			operand.type &= ~otMemory;
			command_info_list.AddOperand(operand, atRead);
		}
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmLeave:
		command_info_list.Add(atRead, regESP, otRegistr, size_);
		command_info_list.Add(atWrite, regESP, otRegistr, size_);

		command_info_list.Add(atRead, regEBP, otRegistr, size_);
		command_info_list.Add(atWrite, regEBP, otRegistr, size_);
		break;

	case cmLods:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_D);

		os = operand_[0].size;
		adr_os = operand_[1].size;

		command_info_list.Add(atRead, regESI, otRegistr, adr_os);
		command_info_list.Add(atWrite, regESI, otRegistr, adr_os);

		command_info_list.Add(atWrite, regEAX, otRegistr, os);
		command_info_list.Add(atRead, (base_segment_ == segDefault) ? segDS : base_segment_, otMemory, os);

		if (preffix_command_ == cmRep || preffix_command_ == cmRepe || preffix_command_ == cmRepne) {
			command_info_list.Add(atRead, regECX, otRegistr, adr_os);
			command_info_list.Add(atWrite, regECX, otRegistr, adr_os);
		}
		break;

	case cmLoop:
		os = operand_[1].size;
		command_info_list.Add(atRead, regECX, otRegistr, os);
		command_info_list.Add(atWrite, regECX, otRegistr, os);

		command_info_list.Add(atWrite, regEIP, otBaseRegistr, size_);
		break;

	case cmLoope: case cmLoopne:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_Z);

		os = operand_[1].size;
		command_info_list.Add(atRead, regECX, otRegistr, os);
		command_info_list.Add(atWrite, regECX, otRegistr, os);

		command_info_list.Add(atWrite, regEIP, otBaseRegistr, size_);
		break;

	case cmMov: case cmMovsx: case cmMovsxd: case cmMovzx:
		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmMovs:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_D);

		os = operand_[0].size;
		adr_os = operand_[1].size;

		command_info_list.Add(atRead, regESI, otRegistr, adr_os);
		command_info_list.Add(atWrite, regESI, otRegistr, adr_os);
		command_info_list.Add(atRead, regEDI, otRegistr, adr_os);
		command_info_list.Add(atWrite, regEDI, otRegistr, adr_os);

		command_info_list.Add(atRead, (base_segment_ == segDefault) ? segDS : base_segment_, otMemory, os);
		command_info_list.Add(atWrite, segES, otMemory, os);

		if (preffix_command_ == cmRep || preffix_command_ == cmRepe || preffix_command_ == cmRepne) {
			command_info_list.Add(atRead, regECX, otRegistr, adr_os);
			command_info_list.Add(atWrite, regECX, otRegistr, adr_os);
		}
		break;

	case cmNeg:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmNop:
		break;

	case cmNot:
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmOr:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmPop:
		command_info_list.Add(atRead, regESP, otRegistr, size_);
		command_info_list.Add(atWrite, regESP, otRegistr, size_);

		os = operand_[0].size;
		command_info_list.Add(atRead, segSS, otMemory, os);

		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmPopa:
		command_info_list.Add(atRead, regESP, otRegistr, size_);
		command_info_list.Add(atWrite, regESP, otRegistr, size_);

		os = operand_[0].size;
		command_info_list.Add(atRead, segSS, otMemory, os);

		command_info_list.Add(atWrite, regEAX, otRegistr, os);
		command_info_list.Add(atWrite, regECX, otRegistr, os);
		command_info_list.Add(atWrite, regEDX, otRegistr, os);
		command_info_list.Add(atWrite, regEBX, otRegistr, os);
		command_info_list.Add(atWrite, regEBP, otRegistr, os);
		command_info_list.Add(atWrite, regESI, otRegistr, os);
		command_info_list.Add(atWrite, regEDI, otRegistr, os);
		break;

	case cmPopf:
		command_info_list.Add(atRead, regESP, otRegistr, size_);
		command_info_list.Add(atWrite, regESP, otRegistr, size_);

		os = operand_[0].size;
		command_info_list.Add(atRead, segSS, otMemory, os);

		command_info_list.Add(atWrite, regEFX, otRegistr, os);
		command_info_list.set_change_flags(0xFFFF);
		break;

	case cmPush:
		command_info_list.Add(atRead, regESP, otRegistr, size_);
		command_info_list.Add(atWrite, regESP, otRegistr, size_);

		os = operand_[0].size;
		command_info_list.Add(atWrite, segSS, otMemory, os);

		command_info_list.AddOperand(operand_[0], atRead);
		break;

	case cmPusha:
		command_info_list.Add(atRead, regESP, otRegistr, size_);
		command_info_list.Add(atWrite, regESP, otRegistr, size_);

		os = operand_[0].size;
		command_info_list.Add(atWrite, segSS, otMemory, os);

		command_info_list.Add(atRead, regEAX, otRegistr, os);
		command_info_list.Add(atRead, regECX, otRegistr, os);
		command_info_list.Add(atRead, regEDX, otRegistr, os);
		command_info_list.Add(atRead, regEBX, otRegistr, os);
		command_info_list.Add(atRead, regEBP, otRegistr, os);
		command_info_list.Add(atRead, regESI, otRegistr, os);
		command_info_list.Add(atRead, regEDI, otRegistr, os);
		break;

	case cmPushf:
		command_info_list.Add(atRead, regESP, otRegistr, size_);
		command_info_list.Add(atWrite, regESP, otRegistr, size_);

		os = operand_[0].size;
		command_info_list.Add(atWrite, segSS, otMemory, os);

		command_info_list.Add(atRead, regEFX, otRegistr, os);
		command_info_list.set_need_flags(0xFFFF);
		break;

	case cmRet: case cmIret:
		command_info_list.Add(atRead, regESP, otRegistr, size_);
		command_info_list.Add(atWrite, regESP, otRegistr, size_);

		command_info_list.Add(atRead, segSS, otMemory, size_);
		command_info_list.Add(atWrite, regEIP, otBaseRegistr, size_);
		break;

	case cmRcl: case cmRcr:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_C);
		command_info_list.set_change_flags(fl_O | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmRdtsc:
		command_info_list.Add(atWrite, regEAX, otRegistr, osDWord);
		command_info_list.Add(atWrite, regEDX, otRegistr, osDWord);
		break;

	case cmRol: case cmRor:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmSahf:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.Add(atRead, regEAX, otHiPartRegistr, osByte);
		break;

	case cmSal: case cmSar:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmSbb:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_C);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmScas:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_D);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		os = operand_[0].size;
		adr_os = operand_[1].size;

		command_info_list.Add(atRead, regEDI, otRegistr, adr_os);
		command_info_list.Add(atWrite, regEDI, otRegistr, adr_os);

		command_info_list.Add(atRead, regEAX, otRegistr, os);
		command_info_list.Add(atRead, segES, otMemory, os);

		if (preffix_command_ == cmRep || preffix_command_ == cmRepe || preffix_command_ == cmRepne) {
			command_info_list.Add(atRead, regECX, otRegistr, adr_os);
			command_info_list.Add(atWrite, regECX, otRegistr, adr_os);
		}
		break;

	case cmSetXX:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(flags_);

		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmShl: case cmShr:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmShld: case cmShrd:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[2], atRead);
		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmStos:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_D);

		os = operand_[0].size;
		adr_os = operand_[1].size;

		command_info_list.Add(atRead, regEDI, otRegistr, adr_os);
		command_info_list.Add(atWrite, regEDI, otRegistr, adr_os);

		command_info_list.Add(atRead, regEAX, otRegistr, os);
		command_info_list.Add(atWrite, segES, otMemory, os);

		if (preffix_command_ == cmRep || preffix_command_ == cmRepe || preffix_command_ == cmRepne) {
			command_info_list.Add(atRead, regECX, otRegistr, adr_os);
			command_info_list.Add(atWrite, regECX, otRegistr, adr_os);
		}
		break;

	case cmSub:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmTest:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		break;

	case cmXadd:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[1], atWrite);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmXchg:
		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[1], atWrite);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmXlat:
		adr_os = operand_[0].size;
		command_info_list.Add(atRead, regEBX, otRegistr, adr_os);
		command_info_list.Add(atRead, regEAX, otRegistr, osByte);
		command_info_list.Add(atWrite, regEAX, otRegistr, osByte);

		command_info_list.Add(atRead, (base_segment_ == segDefault) ? segDS : base_segment_, otMemory, osByte);
		break;

	case cmXor:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	// FPU commands

	case cmWait: case cmFabs: case cmFchs: case cmFclex: case cmFcos: case cmFdecstp:
	case cmFfree: case cmFincstp: case cmFinit: case cmFld1: case cmFldl2t: case cmFldl2e: 
	case cmFldlg2: case cmFldln2: case cmFldpi: case cmFldz:
	case cmFpatan: case cmFprem: case cmFprem1: case cmFptan:
	case cmFrndint: case cmFscale: case cmFsin: case cmFsincos: case cmFsqrt:
	case cmFtst: case cmFxam: case cmFxtract: case cmFyl2x: case cmFyl2xp1:
		command_info_list.Add(atRead, 0, otFPURegistr, size_);
		command_info_list.Add(atWrite, 0, otFPURegistr, size_);
		break;

	case cmFadd: case cmFaddp: case cmFiadd: case cmFcom: case cmFcomp: case cmFcompp: case cmFdiv: case cmFidiv: case cmFdivp:
	case cmFdivr: case cmFidivr: case cmFdivrp: case cmFicom: case cmFicomp: case cmFild: case cmFld: case cmFmul: case cmFimul:
	case cmFmulp: case cmFsub: case cmFisub: case cmFsubp: case cmFsubr: case cmFisubr: case cmFsubrp: case cmFucom: case cmFucomp:
	case cmFucompp: case cmFxch:
		os = operand_[0].size;
		command_info_list.Add(atRead, 0, otFPURegistr, os);
		command_info_list.Add(atWrite, 0, otFPURegistr, os);

		command_info_list.AddOperand(operand_[0], atRead);
		break;

	case cmFcomi: case cmFcomip: case cmFucomi: case cmFucomip:
		os = operand_[0].size;
		command_info_list.Add(atRead, 0, otFPURegistr, os);
		command_info_list.Add(atWrite, 0, otFPURegistr, os);

		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_Z | fl_P | fl_C);

		command_info_list.AddOperand(operand_[0], atRead);
		break;    

		/*
	case cmFcmov:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(flags_);

		OS:=FOperand[0].OperandSize;
		command_info_list.Add(atRead, 0, otFPURegistr, OS);
		command_info_list.Add(atWrite, 0, otFPURegistr, OS);
		break;
		*/

	case cmFist: case cmFistp: case cmFst: case cmFstp: case cmFstsw: case cmFstcw:
		os = operand_[0].size;
		command_info_list.Add(atRead, 0, otFPURegistr, os);
		command_info_list.Add(atWrite, 0, otFPURegistr, os);

		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmFldcw:
		os = operand_[0].size;
		command_info_list.Add(atRead, 0, otFPURegistr, os);
		command_info_list.Add(atWrite, 0, otFPURegistr, os);

		command_info_list.AddOperand(operand_[0], atRead);
		break;

	case cmFnop:
		break;

	case cmRdrand:
	case cmRdseed:
		command_info_list.AddOperand(operand_[0], atWrite);

		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);
		break;

	case cmMovsd:
	case cmMovss:
	case cmMovupd:
	case cmMovups:
	case cmMovdqu:
	case cmMovq:
	case cmMovlpd:
	case cmMovaps:
		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	default:
		return false;
	}

	return true;
}

bool IntelCommand::Merge(ICommand *command)
{
	if (count() == 0 || command->count() == 0 || command->owner() != owner() || address_range() != command->address_range())
		return false;

	IntelCommand *dest = reinterpret_cast<IntelCommand *>(command);
	size_t i;
	for (i = 0; i < vm_command_info_list_->count(); i++) {
		CommandInfo *command_info = vm_command_info_list_->item(i);
		switch (command_info->operand_type()) {
		case otRegistr:
			if (command_info->value() == regESP || (command_info->value() & regExtended))
				return false;
			break;
		case otControlRegistr:
			if (command_info->type() == atWrite)
				return false;
			break;
		case otMemory:
			if (dest->vm_command_info_list_->GetInfo(atWrite, otRegistr, regESP))
				return false;
			break;
		}
	}

	size_t dest_count = dest->count();
	for (i = 0; i < dest->count(); i++) {
		IntelVMCommand *vm_command = dest->item(i);
		if (vm_command->command_type() == cmJmp || vm_command->command_type() == cmRet || vm_command->command_type() == cmIret) {
			dest_count = i;
			break;
		}
	}

	size_t dest_pos = NOT_ID;
	if (owner()->IndexOf(dest) > owner()->IndexOf(this)) {
		for (i = 0; i < dest_count; i++) {
			if (!dest->item(i)->can_merge(*vm_command_info_list_))
				break;
			dest_pos = i;
		}
		if (dest_pos != NOT_ID)
			dest_pos = rand() % (dest_pos + 1);
	} else {
		for (i = dest_count; i > 0; i--) {
			if (!dest->item(i - 1)->can_merge(*vm_command_info_list_))
				break;
			dest_pos = i - 1;
		}
		if (dest_pos != NOT_ID)
			dest_pos = dest_pos + rand() % (dest_count - dest_pos);
	}

	if (dest_pos == NOT_ID)
		return false;

	for (size_t p = 0; p < count(); ) {
		IntelVMCommand *vm_command = item(p);
		if (vm_command->options() & voSectionCommand) {
			if (section_options() & rtBeginSection) {
				p++;
				continue;
			}
			if (section_options() & rtEndSection)
				break;
		}
		RemoveObject(vm_command);
		vm_command->set_owner(dest);
		dest->InsertObject(dest_pos++, vm_command);
	}

	for (i = 0; i < vm_command_info_list_->count(); i++) {
		CommandInfo *command_info = vm_command_info_list_->item(i);
		dest->vm_command_info_list_->Add(command_info->type(), command_info->value(), command_info->operand_type(), command_info->size());
	}

	return true;
}

/**
 * IntelCommandInfoList
 */

IntelCommandInfoList::IntelCommandInfoList(OperandSize cpu_address_size)
	: CommandInfoList(), cpu_address_size_(cpu_address_size), base_segment_(segDefault)
{

}

void IntelCommandInfoList::Add(AccessType access_type, uint8_t value, OperandType operand_type, OperandSize size)
{
	CommandInfoList::Add(access_type, value, operand_type, (cpu_address_size_ == osQWord && access_type == atWrite && operand_type == otRegistr && size == osDWord) ? osQWord : size);
}

void IntelCommandInfoList::AddOperand(const IntelOperand &operand, AccessType access_type)
{
	static const OperandType operand_types[] = {
		otValue,
		otRegistr,
		otMemory,
		otSegmentRegistr,
		otControlRegistr,
		otDebugRegistr,
		otFPURegistr,
		otHiPartRegistr,
		otBaseRegistr,
		otMMXRegistr,
		otXMMRegistr
	};
	
	for (size_t i = 0; i < _countof(operand_types); i++) {
		OperandType ot = operand_types[i];
		if ((operand.type & ot) == 0)
			continue;

		switch (ot) { //-V719
		case otRegistr:
		case otSegmentRegistr:
		case otControlRegistr:
		case otDebugRegistr:
		case otMMXRegistr:
		case otXMMRegistr:
			if (operand.type & otMemory) {
				Add(atRead, operand.registr, ot, operand.address_size);
			} else {
				Add(access_type, operand.registr, ot, operand.size);
			}
			break;

		case otHiPartRegistr:
			Add(access_type, operand.registr, ot, operand.size);
			break;

		case otBaseRegistr:
			if (operand.type & otMemory) {
				Add(atRead, operand.base_registr, otRegistr, operand.address_size);
			} else {
				Add(access_type, operand.base_registr, otRegistr, operand.size);
			}
			break;

		case otFPURegistr:
			Add(access_type, 0, ot, operand.size);
			break;

		case otMemory:
			Add(access_type, operand.effective_base_segment(base_segment_), ot, operand.size);
			break;
		}
	}
}

#ifdef CHECKED
bool IntelCommand::check_hash() const
{
	return (hash_ == calc_hash());
}

void IntelCommand::update_hash()
{
	hash_ = calc_hash();
}

uint32_t IntelCommand::calc_hash() const
{
	Data data;
	data.PushDWord(type_);
	data.PushDWord(preffix_command_);
	data.PushDWord(size_);
	data.PushDWord(base_segment_);
	for (size_t i = 0; i < 3; i++) {
		const IntelOperand *operand = &operand_[i];
		data.PushWord(operand->type);
		data.PushByte(operand->size);
		data.PushByte(operand->registr);
		data.PushByte(operand->base_registr);
		data.PushByte(operand->scale_registr);
		data.PushByte(operand->address_size);
		data.PushByte(operand->value_size);
		data.PushQWord(operand->value);
	}
	SHA1 sha;
	sha.Input(data.data(), data.size());
	return *reinterpret_cast<const uint32_t *>(sha.Result());
}
#endif

/**
 * IntelFunction
 */

IntelFunction::IntelFunction(IFunctionList *owner, const std::string &name, CompilationType compilation_type, uint32_t compilation_options, bool need_compile, Folder *folder)
	: BaseFunction(owner, name, compilation_type, compilation_options, need_compile, folder)
{
	section_cryptor_list_ = new SectionCryptorList(this);
}

IntelFunction::IntelFunction(IFunctionList *owner)
	: BaseFunction(owner, FunctionName(""), ctVirtualization, 0, true, NULL)
{
	section_cryptor_list_ = new SectionCryptorList(this);
}

IntelFunction::IntelFunction(IFunctionList *owner, OperandSize cpu_address_size, IFunction *parent)
	: BaseFunction(owner, cpu_address_size, parent)
{
	section_cryptor_list_ = new SectionCryptorList(this);
}

IntelFunction::IntelFunction(IFunctionList *owner, const IntelFunction &src)
	: BaseFunction(owner, src)
{
	section_cryptor_list_ = new SectionCryptorList(this);
}

IntelFunction *IntelFunction::Clone(IFunctionList *owner) const
{
	IntelFunction *func = new IntelFunction(owner, *this);
	return func;
}

IntelFunction::~IntelFunction()
{
	delete section_cryptor_list_;
}

void IntelFunction::clear()
{
	break_case_list_.clear();
	BaseFunction::clear();
}

IntelCommand *IntelFunction::GetCommandByAddress(uint64_t address) const
{
	return reinterpret_cast<IntelCommand *>(BaseFunction::GetCommandByAddress(address));
}

IntelCommand *IntelFunction::GetCommandByNearAddress(uint64_t address) const
{
	return reinterpret_cast<IntelCommand *>(BaseFunction::GetCommandByNearAddress(address));
}

IntelCommand *IntelFunction::Add(uint64_t address)
{
	IntelCommand *command = new IntelCommand(this, cpu_address_size(), address);
	AddObject(command);
	return command;
}

IntelCommand *IntelFunction::AddCommand(IntelCommandType type, IntelOperand operand1, IntelOperand operand2, IntelOperand operand3)
{
	IntelCommand *command = new IntelCommand(this, cpu_address_size(), type, operand1, operand2, operand3);
	AddObject(command);
	return command;
}

IntelCommand *IntelFunction::AddCommand(const std::string &value)
{
	IntelCommand *command = new IntelCommand(this, cpu_address_size(), value);
	AddObject(command);
	return command;
}

IntelCommand *IntelFunction::AddCommand(const os::unicode_string &value)
{
	IntelCommand *command = new IntelCommand(this, cpu_address_size(), value);
	AddObject(command);
	return command;
}

IntelCommand *IntelFunction::AddCommand(const Data &value)
{
	IntelCommand *command = new IntelCommand(this, cpu_address_size(), value);
	AddObject(command);
	return command;
}

IntelCommand *IntelFunction::AddCommand(OperandSize value_size, uint64_t value)
{
	IntelCommandType command_type;
	switch (value_size) {
	case osWord:
		command_type = cmDW;
		break;
	case osDWord:
		command_type = cmDD;
		break;
	case osQWord:
		command_type = cmDQ;
		break;
	default:
		return NULL;
	}

	return AddCommand(command_type, IntelOperand(otValue, value_size, 0, value));
}

bool IntelFunction::ParseFilterSEH(IArchitecture &file, uint64_t address)
{
	uint32_t table_count;
	size_t i, j, c;
	uint64_t pos, value;
	IntelCommand *command;

	if (file.cpu_address_size() != osDWord || !file.AddressSeek(address))
		return false;

	pos = file.Tell();
	table_count = file.ReadDWord();
	for (i = 0; i < table_count; i++) {
		for (j = 0; j < 2; j++) {
			value = file.ReadDWord();
			if (value == 0) {
				if (j > 0) 
					return false;
			} else {
				if (file.segment_list()->GetMemoryTypeByAddress(value) == mtNone || 
					(file.fixup_list()->count() != 0 && file.fixup_list()->GetFixupByAddress(address + (1 + i * 2 + j) * sizeof(uint32_t)) == NULL))
					return false;
			}
		}
	}

	file.Seek(pos);

	c = count();

	command = Add(address);
	command->ReadValueFromFile(file, osDWord);
	command->set_comment(CommentInfo(ttComment, "Count"));
	address = command->next_address();

	for (i = 0; i < table_count; i++) {
		command = Add(address);
		command->ReadValueFromFile(file, osDWord);
		command->set_comment(CommentInfo(ttComment, "Class"));
		address = command->next_address();

		command = Add(address);
		value = command->ReadValueFromFile(file, osDWord);
		command->set_comment(CommentInfo(ttComment, "Handler"));
		address = command->next_address();
		command->AddLink(0, ltMemSEHBlock, value);
	}

	for (i = c; i < count(); i++) {
		command = item(i);
		command->exclude_option(roClearOriginalCode);
	}

	return true;
}

bool IntelFunction::ParseSwitch(IArchitecture &file, uint64_t address, OperandSize value_size, uint64_t add_value, IntelCommand *parent_command, size_t mode, size_t max_table_count)
{
	if (value_size < osDWord || value_size > osQWord)
		return false;

	size_t i, table_count, c;
	IntelCommand *command;
	uint64_t pos, value;

	command = GetCommandByAddress(address);
	if (command) {
		// CASEs already parsed by previous switch
		for (table_count = 0; command && (command->type() == cmDD || command->type() == cmDQ) && command->link() && command->link()->type() == ltCase; table_count++) {
			if (command->link()->sub_value() != add_value) {
				if (break_case_list_.find(command->address()) != break_case_list_.end())
					break;
				break_case_list_.insert(command->address());
				ClearItems();
				return false;
			}
			command->link()->set_parent_command(parent_command);
			command = GetCommandByAddress(command->next_address());
		}
		return table_count != 0;
	}

	if (!file.AddressSeek(address))
		return false;

	pos = file.Tell();
	std::vector<uint64_t> value_list;
	for (table_count = 0; table_count <= max_table_count; table_count++) {
		uint64_t case_address = address + table_count * OperandSizeToValue(value_size);
		bool is_ok = true;
		for (i = 0; i < OperandSizeToValue(value_size); i++) {
			uint64_t tmp = case_address + i;
			if (GetCommandByNearAddress(tmp) || link_list()->GetLinkByToAddress(ltNone, tmp)) {
				is_ok = false;
				break;
			}
		}
		if (!is_ok)
			break;
		switch (value_size) {
		case osDWord:
			{
				uint32_t dw = file.ReadDWord();
				value = (mode == 1) ? DWordToInt64(dw) : dw;
			}
			break;
		case osQWord:
			value = file.ReadQWord();
			break;
		}
		if (mode == 2)
			value = add_value - value;
		else
			value = add_value + value;
		if (file.cpu_address_size() == osDWord)
			value = static_cast<uint32_t>(value);
		if ((file.segment_list()->GetMemoryTypeByAddress(value) & mtExecutable) == 0)
			break;
		if (value >= address)
			break;
		if (table_count > 0 && break_case_list_.find(case_address) != break_case_list_.end())
			break;
		value_list.push_back(value);
	}

	if (value_list.empty())
		return false;

	file.Seek(pos);
	c = count();
	for (i = 0; i < value_list.size(); i++) {
		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "Case"));
		command->ReadValueFromFile(file, value_size);
		address = command->next_address();

		CommandLink *link = command->AddLink(0, ltCase, value_list[i]);
		link->set_parent_command(parent_command);
		if (add_value)
			link->set_sub_value(add_value);
		if (mode == 2)
			link->set_is_inverse(true);
	}

	command = item(c);
	command->set_alignment(OperandSizeToValue(value_size));
	command->include_option(roCreateNewBlock);

	return true;
}

bool IntelFunction::ParseSEH3(IArchitecture &file, uint64_t address)
{
	if (!file.AddressSeek(address))
		return false;

	uint32_t state;
	uint64_t pos, value;
	size_t i, c, table_count;
	IntelCommand *command;

	pos = file.Tell();
	for (table_count = 0;; table_count++) {
		state = file.ReadDWord();
		if (state != (uint32_t)-1 && state >= table_count)
			break;

		bool is_ok = true;
		for (i = 0; i < 2; i++) {
			value = file.ReadDWord();
			if (value) {
				if ((file.segment_list()->GetMemoryTypeByAddress(value) & mtExecutable) == 0) {
					is_ok = false;
					break;
				}
			} else if (i == 1) {
				is_ok = false;
				break;
			}
		}
		if (!is_ok)
			break;
	}

	if (!table_count)
		return false;

	file.Seek(pos);
	c = count();
	for (i = 0; i < table_count; i++) {
		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "State"));
		command->ReadValueFromFile(file, osDWord);
		address = command->next_address();

		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "Filter"));
		value = command->ReadValueFromFile(file, osDWord);
		if (value) {
			command->AddLink(0, ltMemSEHBlock, value);
			command->include_option(roExternal);
		}
		address = command->next_address();

		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "Handler"));
		value = command->ReadValueFromFile(file, osDWord);
		if (value)
			command->AddLink(0, ltMemSEHBlock, value);
		address = command->next_address();
	}

	command = item(c);
	command->set_alignment(OperandSizeToValue(osDWord));
	command->include_option(roCreateNewBlock);

	for (i = c; i < count(); i++) {
		command = item(i);
		command->exclude_option(roClearOriginalCode);
	}
	return true;
}

bool IntelFunction::ParseSEH4(IArchitecture &file, uint64_t address)
{
	if (!file.AddressSeek(address))
		return false;

	uint32_t state;
	uint64_t pos, value;
	size_t i, c, table_count;
	IntelCommand *command;

	pos = file.Tell();
	file.ReadDWord();
	file.ReadDWord();
	file.ReadDWord();
	file.ReadDWord();
	for (table_count = 0;; table_count++) {
		state = file.ReadDWord();
		if (state != (uint32_t)-2 && (size_t)state >= table_count)
			break;

		bool is_ok = true;
		for (i = 0; i < 2; i++) {
			value = file.ReadDWord();
			if (value) {
				if ((file.segment_list()->GetMemoryTypeByAddress(value) & mtExecutable) == 0) {
					is_ok = false;
					break;
				}
			} else if (i == 1) {
				is_ok = false;
				break;
			}
		}
		if (!is_ok)
			break;
	}

	if (!table_count)
		return false;

	file.Seek(pos);
	c = count();

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "GSCookieOffset"));
	command->ReadValueFromFile(file, osDWord);
	address = command->next_address();

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "GSCookieXOROffset"));
	command->ReadValueFromFile(file, osDWord);
	address = command->next_address();

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "EHCookieOffset"));
	command->ReadValueFromFile(file, osDWord);
	address = command->next_address();

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "EHCookieXOROffset"));
	command->ReadValueFromFile(file, osDWord);
	address = command->next_address();

	for (i = 0; i < table_count; i++) {
		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "State"));
		command->ReadValueFromFile(file, osDWord);
		address = command->next_address();

		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "Filter"));
		value = command->ReadValueFromFile(file, osDWord);
		if (value) {
			command->AddLink(0, ltMemSEHBlock, value);
			command->include_option(roExternal);
		}
		address = command->next_address();

		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "Handler"));
		value = command->ReadValueFromFile(file, osDWord);
		if (value)
			command->AddLink(0, ltMemSEHBlock, value);
		address = command->next_address();
	}

	command = item(c);
	command->set_alignment(OperandSizeToValue(osDWord));
	command->include_option(roCreateNewBlock);

	for (i = c; i < count(); i++) {
		command = item(i);
		command->exclude_option(roClearOriginalCode);
	}
	return true;
}

bool IntelFunction::ParseCxxSEH(IArchitecture &file, uint64_t address)
{
	if (!file.AddressSeek(address))
		return false;

	uint64_t pos, unwind_map_entry, try_block_entry, catches_entry, value, map_entry, action_entry;
	uint32_t magic, max_state, try_blocks, catches, map_count;
	IntelCommand *command;
	CommandLink *link;
	size_t i, j, c;

	uint64_t add_value = (cpu_address_size() == osDWord) ? 0 : file.image_base();
	pos = file.Tell();
	magic = file.ReadDWord();
	if (magic != 0x19930520 && magic != 0x19930521 && magic != 0x19930522)
		return false;

	if (GetCommandByAddress(address))
		return true;

	file.Seek(pos);

	c = count();

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "Magic"));
	command->ReadValueFromFile(file, osDWord);
	command->set_alignment(OperandSizeToValue(osDWord));
	command->include_option(roCreateNewBlock);
	address = command->next_address();

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "MaxState"));
	max_state = static_cast<uint32_t>(command->ReadValueFromFile(file, osDWord));
	address = command->next_address();

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "UnwindMapEntry"));
	unwind_map_entry = command->ReadValueFromFile(file, osDWord);
	if (unwind_map_entry) {
		unwind_map_entry += add_value;
		link = command->AddLink(0, ltOffset, unwind_map_entry);
		link->set_sub_value(add_value);
	}
	address = command->next_address();

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "TryBlocks"));
	try_blocks = static_cast<uint32_t>(command->ReadValueFromFile(file, osDWord));
	address = command->next_address();

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "TryBlockMapEntry"));
	try_block_entry = command->ReadValueFromFile(file, osDWord);
	if (try_block_entry) {
		try_block_entry += add_value;
		link = command->AddLink(0, ltOffset, try_block_entry);
		link->set_sub_value(add_value);
	}
	address = command->next_address();

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "IPMapEntries"));
	map_count = static_cast<uint32_t>(command->ReadValueFromFile(file, osDWord));
	address = command->next_address();

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "IPtoStateMap"));
	map_entry = command->ReadValueFromFile(file, osDWord);
	if (map_entry) {
		map_entry += add_value;
		link = command->AddLink(0, ltOffset, map_entry);
		link->set_sub_value(add_value);
	}
	address = command->next_address();

	if (file.cpu_address_size() == osQWord) {
		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "UnwindHelp"));
		command->ReadValueFromFile(file, osDWord);
		address = command->next_address();
	}

	if (magic >= 0x19930521) {
		command = Add(address);
		command->ReadValueFromFile(file, osDWord);
		command->set_comment(CommentInfo(ttComment, "ESTypeList"));
		address = command->next_address();

		if (magic == 0x19930522) {
			command = Add(address);
			command->ReadValueFromFile(file, osDWord);
			command->set_comment(CommentInfo(ttComment, "Flags"));
			//address = command->next_address();
		}
	}

	if (max_state && file.AddressSeek(unwind_map_entry)) {
		for (i = 0; i < max_state; i++) {
			command = Add(unwind_map_entry);
			command->set_comment(CommentInfo(ttComment, "ToState"));
			command->ReadValueFromFile(file, osDWord);
			unwind_map_entry = command->next_address();

			command = Add(unwind_map_entry);
			command->set_comment(CommentInfo(ttComment, "Action"));
			action_entry = command->ReadValueFromFile(file, osDWord);
			if (action_entry) {
				action_entry += add_value;
				link = command->AddLink(0, ltMemSEHBlock, action_entry);
				link->set_parsed(true);
				link->set_sub_value(add_value);
			}
			unwind_map_entry = command->next_address();
		}
	}

	if (try_blocks && file.AddressSeek(try_block_entry)) {
		for (i = 0; i < try_blocks; i++) {
			command = Add(try_block_entry);
			command->set_comment(CommentInfo(ttComment, "TryLow"));
			command->ReadValueFromFile(file, osDWord);
			try_block_entry = command->next_address();

			command = Add(try_block_entry);
			command->set_comment(CommentInfo(ttComment, "TryHigh"));
			command->ReadValueFromFile(file, osDWord);
			try_block_entry = command->next_address();

			command = Add(try_block_entry);
			command->set_comment(CommentInfo(ttComment, "CatchHigh"));
			command->ReadValueFromFile(file, osDWord);
			try_block_entry = command->next_address();

			command = Add(try_block_entry);
			command->set_comment(CommentInfo(ttComment, "Catches"));
			catches = static_cast<uint32_t>(command->ReadValueFromFile(file, osDWord));
			try_block_entry = command->next_address();

			command = Add(try_block_entry);
			command->set_comment(CommentInfo(ttComment, "HandlerArray"));
			catches_entry = command->ReadValueFromFile(file, osDWord);
			if (catches_entry) {
				catches_entry += add_value;
				link = command->AddLink(0, ltOffset, catches_entry);
				link->set_sub_value(add_value);
			}
			try_block_entry = command->next_address();

			pos = file.Tell();
			if (catches && file.AddressSeek(catches_entry)) {
				for (j = 0; j < catches; j++) {
					command = Add(catches_entry);
					command->set_comment(CommentInfo(ttComment, "Adjectives"));
					command->ReadValueFromFile(file, osDWord);
					catches_entry = command->next_address();

					command = Add(catches_entry);
					command->set_comment(CommentInfo(ttComment, "Type"));
					command->ReadValueFromFile(file, osDWord);
					catches_entry = command->next_address();

					command = Add(catches_entry);
					command->set_comment(CommentInfo(ttComment, "CatchObj"));
					command->ReadValueFromFile(file, osDWord);
					catches_entry = command->next_address();

					command = Add(catches_entry);
					command->set_comment(CommentInfo(ttComment, "Handler"));
					value = command->ReadValueFromFile(file, osDWord);
					if (value) {
						value += add_value;
						link = command->AddLink(0, ltExtSEHHandler, value);
						link->set_sub_value(add_value);
					}
					catches_entry = command->next_address();

					if (cpu_address_size() == osQWord) {
						command = Add(catches_entry);
						command->set_comment(CommentInfo(ttComment, "Frame"));
						command->ReadValueFromFile(file, osDWord);
						catches_entry = command->next_address();
					}
				}
				file.Seek(pos);
			}
		}
	}

	if (map_count && file.AddressSeek(map_entry)) {
		AddressRange *last_range = NULL;
		for (i = 0; i < map_count; i++) {
			command = Add(map_entry);
			command->set_comment(CommentInfo(ttComment, "Ip"));
			value = command->ReadValueFromFile(file, osDWord) + add_value;
			map_entry = command->next_address();

			if (last_range && last_range->begin() < value)
				last_range->set_end(value);
			last_range = range_list()->Add(value, 0, command, NULL, NULL);

			command = Add(map_entry);
			command->set_comment(CommentInfo(ttComment, "State"));
			command->ReadValueFromFile(file, osDWord);
			map_entry = command->next_address();
		}
	}

	for (i = c; i < count(); i++) {
		command = item(i);
		command->exclude_option(roClearOriginalCode);
	}

	return true;
}

bool IntelFunction::ParseCompressedCxxSEH(IArchitecture &file, uint64_t address, uint64_t begin)
{
	// FIXME
	return false;

	if (file.cpu_address_size() != osQWord || !file.AddressSeek(address))
		return false;

	uint64_t pos, unwind_map_entry, try_block_entry, catches_entry, value, map_entry, action_entry;
	uint32_t max_state, try_blocks, catches, map_count;
	IntelCommand *command;
	CommandLink *link;
	size_t old_count, i, j, k, c;

	uint64_t add_value = (cpu_address_size() == osDWord) ? 0 : file.image_base();

	pos = file.Tell();
	uint8_t header_flags = file.ReadByte();
	if (header_flags & 4) {
		command = Add(address);
		command->ReadCompressedValue(file);
		delete command;
	}

	if (header_flags & 8) {
		value = file.ReadDWord();
		if (value && (file.segment_list()->GetMemoryTypeByAddress(value + add_value) & mtReadable) == 0)
			return false;
	}
	if (header_flags & 0x10) {
		value = file.ReadDWord();
		if (value && (file.segment_list()->GetMemoryTypeByAddress(value + add_value) & mtReadable) == 0)
			return false;
	}
	value = file.ReadDWord();
	if (file.AddressSeek(value + add_value)) {
		map_entry = value + add_value;
		command = Add(map_entry);
		map_count = command->ReadCompressedValue(file);

		value = begin;
		for (i = 0; i < map_count; i++) {
			uint32_t ip = command->ReadCompressedValue(file);
			command->ReadCompressedValue(file);
			value += ip;
			if ((file.segment_list()->GetMemoryTypeByAddress(value) & mtExecutable) == 0) {
				delete command;
				return false;
			}
		}
		delete command;
	} else 
		return false;

	if (GetCommandByAddress(address))
		return true;

	file.Seek(pos);

	old_count = count();

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "Header"));
	command->ReadValueFromFile(file, osByte);
	command->include_option(roCreateNewBlock);
	address = command->next_address();

	if (header_flags & 4) {
		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "Flags"));
		command->ReadCompressedValue(file);
		address = command->next_address();
	}

	unwind_map_entry = 0;
	if (header_flags & 8) {
		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "UnwindMapEntry"));
		unwind_map_entry = command->ReadValueFromFile(file, osDWord);
		if (unwind_map_entry) {
			unwind_map_entry += add_value;
			link = command->AddLink(0, ltOffset, unwind_map_entry);
			link->set_sub_value(add_value);
		}
		address = command->next_address();
	}

	try_block_entry = 0;
	if (header_flags & 0x10) {
		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "TryBlockMapEntry"));
		try_block_entry = command->ReadValueFromFile(file, osDWord);
		if (try_block_entry) {
			try_block_entry += add_value;
			link = command->AddLink(0, ltOffset, try_block_entry);
			link->set_sub_value(add_value);
		}
		address = command->next_address();
	}

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "IPtoStateMap"));
	map_entry = command->ReadValueFromFile(file, osDWord);
	if (map_entry) {
		map_entry += add_value;
		link = command->AddLink(0, ltOffset, map_entry);
		link->set_sub_value(add_value);
	}
	address = command->next_address();

	if (header_flags & 1) {
		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "Frame"));
		command->ReadCompressedValue(file);
		address = command->next_address();
	}

	if (unwind_map_entry && file.AddressSeek(unwind_map_entry)) {
		command = Add(unwind_map_entry);
		command->set_comment(CommentInfo(ttComment, "MaxState"));
		max_state = command->ReadCompressedValue(file);
		unwind_map_entry = command->next_address();

		for (i = 0; i < max_state; i++) {
			command = Add(unwind_map_entry);
			command->set_comment(CommentInfo(ttComment, "NextOffset"));
			uint32_t offset = command->ReadCompressedValue(file);
			unwind_map_entry = command->next_address();

			uint8_t type = offset & 3;
			if (type) {
				command = Add(unwind_map_entry);
				command->set_comment(CommentInfo(ttComment, "Action"));
				action_entry = command->ReadValueFromFile(file, osDWord);
				if (action_entry) {
					action_entry += add_value;
					link = command->AddLink(0, ltMemSEHBlock, action_entry);
					link->set_parsed(true);
					link->set_sub_value(add_value);
				}
				unwind_map_entry = command->next_address();
			}

			if (type == 1 || type == 2) {
				command = Add(unwind_map_entry);
				command->set_comment(CommentInfo(ttComment, "Object"));
				command->ReadCompressedValue(file);
				unwind_map_entry = command->next_address();
			}
		}
	}

	if (try_block_entry && file.AddressSeek(try_block_entry)) {
		command = Add(try_block_entry);
		command->set_comment(CommentInfo(ttComment, "TryBlocks"));
		try_blocks = command->ReadCompressedValue(file);
		try_block_entry = command->next_address();

		for (i = 0; i < try_blocks; i++) {
			command = Add(try_block_entry);
			command->set_comment(CommentInfo(ttComment, "TryLow"));
			command->ReadCompressedValue(file);
			try_block_entry = command->next_address();

			command = Add(try_block_entry);
			command->set_comment(CommentInfo(ttComment, "TryHigh"));
			command->ReadCompressedValue(file);
			try_block_entry = command->next_address();

			command = Add(try_block_entry);
			command->set_comment(CommentInfo(ttComment, "CatchHigh"));
			command->ReadCompressedValue(file);
			try_block_entry = command->next_address();

			command = Add(try_block_entry);
			command->set_comment(CommentInfo(ttComment, "HandlerArray"));
			catches_entry = command->ReadValueFromFile(file, osDWord) + add_value;
			link = command->AddLink(0, ltOffset, catches_entry);
			link->set_sub_value(add_value);
			try_block_entry = command->next_address();

			pos = file.Tell();
			if (file.AddressSeek(catches_entry)) {
				command = Add(catches_entry);
				command->set_comment(CommentInfo(ttComment, "Catches"));
				catches = command->ReadCompressedValue(file);
				catches_entry = command->next_address();

				for (j = 0; j < catches; j++) {
					command = Add(catches_entry);
					command->set_comment(CommentInfo(ttComment, "Header"));
					uint8_t header = static_cast<uint8_t>(command->ReadValueFromFile(file, osByte));
					catches_entry = command->next_address();

					if (header & 1) {
						command = Add(catches_entry);
						command->set_comment(CommentInfo(ttComment, "Adjectives"));
						command->ReadCompressedValue(file);
						catches_entry = command->next_address();
					}

					if (header & 2) {
						command = Add(catches_entry);
						command->set_comment(CommentInfo(ttComment, "Type"));
						command->ReadValueFromFile(file, osDWord);
						catches_entry = command->next_address();
					}

					if (header & 4) {
						command = Add(catches_entry);
						command->set_comment(CommentInfo(ttComment, "CatchObj"));
						command->ReadCompressedValue(file);
						catches_entry = command->next_address();
					}

					command = Add(catches_entry);
					command->set_comment(CommentInfo(ttComment, "Handler"));
					value = command->ReadValueFromFile(file, osDWord);
					if (value) {
						value += add_value;
						link = command->AddLink(0, ltExtSEHHandler, value);
						link->set_sub_value(add_value);
					}
					catches_entry = command->next_address();

					switch ((header >> 4) & 3) {
					case 1:
						c = 1;
						break;
					case 2:
						c = 2;
						break;
					default:
						c = 0;
						break;
					}
					for (k = 0; k < c; k++) {
						command = Add(catches_entry);
						command->set_comment(CommentInfo(ttComment, "ContinuationAddress"));
						if (header & 8) {
							value = command->ReadValueFromFile(file, osDWord) + add_value;
							link = command->AddLink(0, ltMemSEHBlock, value);
							link->set_sub_value(add_value);
						}
						else {
							command->include_option(roFillNop);
							value = command->ReadCompressedValue(file) + begin;
							link = command->AddLink(0, ltMemSEHBlock, value);
							link->set_base_function_info(function_info_list()->GetItemByAddress(begin));
						}

						catches_entry = command->next_address();
					}
				}
				file.Seek(pos);
			}
		}
	}

	if (file.AddressSeek(map_entry)) {
		command = Add(map_entry);
		command->set_comment(CommentInfo(ttComment, "IPMapEntries"));
		map_count = command->ReadCompressedValue(file);
		map_entry = command->next_address();

		value = begin;
		AddressRange *last_range = NULL;
		for (i = 0; i < map_count; i++) {
			command = Add(map_entry);
			command->set_comment(CommentInfo(ttComment, "Ip"));
			value += command->ReadCompressedValue(file);
			command->include_option(roFillNop);
			map_entry = command->next_address();

			if (last_range)
				last_range->set_end(value);
			last_range = range_list()->Add(value, 0, command, NULL, NULL);

			command = Add(map_entry);
			command->set_comment(CommentInfo(ttComment, "State"));
			command->ReadCompressedValue(file);
			map_entry = command->next_address();
		}
	}

	for (i = old_count; i < count(); i++) {
		command = item(i);
		command->exclude_option(roClearOriginalCode);
	}

	return true;
}

bool IntelFunction::ParseScopeSEH(IArchitecture &file, uint64_t address, uint32_t table_count)
{
	if (!file.AddressSeek(address))
		return false;

	IntelCommand *command;
	CommandLink *link;
	size_t i;
	uint64_t value;
	uint64_t image_base = file.image_base();

	uint64_t pos = file.Tell();

	for (i = 0; i < table_count; i++) { //-V756
		for (size_t j = 0; j < 4; j++) {
			value = file.ReadDWord();
			if ((j == 0 || j == 1) && (file.segment_list()->GetMemoryTypeByAddress(value + image_base) & mtExecutable) == 0)
				return false;
		}
	}

	if (GetCommandByAddress(address))
		return true;

	file.Seek(pos);

	size_t c = count();

	for (i = 0; i < table_count; i++) {
		IntelCommand *begin_entry = command = Add(address);
		begin_entry->set_comment(CommentInfo(ttComment, "Begin"));
		uint64_t begin_address = begin_entry->ReadValueFromFile(file, osDWord) + image_base;
		address = begin_entry->next_address();

		IntelCommand *end_entry = Add(address);
		end_entry->set_comment(CommentInfo(ttComment, "End"));
		uint64_t end_address = end_entry->ReadValueFromFile(file, osDWord) + image_base;
		address = end_entry->next_address();

		range_list()->Add(begin_address, end_address, begin_entry, end_entry, NULL);

		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "Filter"));
		value = command->ReadValueFromFile(file, osDWord);
		if (value > 1) {
			value += image_base;
			pos = file.Tell();
			if (ParseDelphiSEH(file, value)) {
				link = command->AddLink(0, ltOffset, value);
			} else {
				link = command->AddLink(0, ltMemSEHBlock, value);
				command->include_option(roExternal);
			}
			link->set_sub_value(image_base);
			file.Seek(pos);
		}
		address = command->next_address();

		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "Handler"));
		value = command->ReadValueFromFile(file, osDWord);
		if (value) {
			value += image_base;
			link = command->AddLink(0, ltMemSEHBlock, value);
			link->set_sub_value(image_base);
		}
		address = command->next_address();
	};

	for (i = c; i < count(); i++) {
		command = item(i);
		command->exclude_option(roClearOriginalCode);
	}

	return true;
}

bool IntelFunction::ParseNewSEH(IArchitecture &file, uint64_t address)
{
	size_t i;
	IntelCommand *command;

	IntelFunction func(NULL, cpu_address_size(), this);
	func.ReadFromFile(file, address);
	command = func.GetCommandByAddress(address);
	if (command) {
		for (i = func.IndexOf(command) + 1; i < func.count(); i++) {
			command = func.item(i);
			if (command->type() == cmJmp
				&& command->operand(0).type == otValue
				&& (command->operand(0).value < address || func.GetCommandByAddress(command->operand(0).value) == NULL)) {
				command = func.item(i - 1);
				if (command->type() == cmMov
					&& command->operand(0).type == otRegistr
					&& command->operand(0).registr == regEAX
					&& command->operand(1).type == otValue) {
					return ParseCxxSEH(file, command->operand(1).value);
				}
			}
		}
	}

	return false;
}

bool IntelFunction::ParseVB6SEH(IArchitecture &file, uint64_t address)
{
	if (!file.AddressSeek(address))
		return false;

	uint64_t pos = file.Tell();

	size_t i, k, table_count;
	uint32_t flags;
	uint64_t value;
	IntelCommand *command;
	//CommandLink *link;

	flags = file.ReadDWord();
	switch (flags >> 16) {
	case 0x04:
	case 0x08:
	case 0x0c:
	case 0x10:
	case 0x14:
		break;
	default:
		return false;
	}

	k = (flags & 0xffff0007) == 0x80001 ? 1 : 3;
	for (table_count = 0;; table_count++) {
		bool is_ok = true;
		for (i = 0; i < k; i++) {
			value = file.ReadDWord();
			if (value != 0 && (file.segment_list()->GetMemoryTypeByAddress(value) & mtExecutable) == 0) {
				is_ok = false;
				break;
			}
		}
		if (!is_ok)
			break;
	}

	if (!table_count)
		return false;

	file.Seek(pos);

	size_t c = count();

	command = Add(address);
	command->ReadValueFromFile(file, osDWord);
	address = command->next_address();

	for (i = 0; i < k; i++) {
		command = Add(address);
		value = command->ReadValueFromFile(file, osDWord);
		if (value)
			command->AddLink(0, ltVBMemSEHBlock, value);
		address = command->next_address();
	}

	if (flags & 0x30) {
		command = Add(address);
		uint64_t ext_info = command->ReadValueFromFile(file, osDWord);
		address = command->next_address();

		command = Add(address);
		uint64_t address_info = command->ReadValueFromFile(file, osDWord);
		address = command->next_address();

		if (ext_info && file.AddressSeek(ext_info)) {
			address = ext_info;

			command = Add(address);
			command->ReadValueFromFile(file, osDWord);
			address = command->next_address();

			command = Add(address);
			command->ReadValueFromFile(file, osDWord);
			address = command->next_address();

			command = Add(address);
			value = command->ReadValueFromFile(file, osDWord);
			if (value)
				command->AddLink(0, ltVBMemSEHBlock, value);
			address = command->next_address();
		}

		if (address_info && file.AddressSeek(address_info)) {
			address = address_info;

			command = Add(address);
			size_t array_count = static_cast<size_t>(command->ReadValueFromFile(file, osDWord));
			address = command->next_address();

			for (i = 0; i < array_count; i++) {
				command = Add(address);
				value = command->ReadValueFromFile(file, osDWord);
				if (value)
					command->AddLink(0, ltVBMemSEHBlock, value);
				address = command->next_address();
			}
		}
	}

	for (i = c; i < count(); i++) {
		command = item(i);
		command->exclude_option(roClearOriginalCode);
	}

	return true;
}

bool IntelFunction::ParseDelphiSEH(IArchitecture &file, uint64_t address)
{
	if (!file.AddressSeek(address))
		return false;

	IntelCommand *command;
	size_t i, j;
	uint64_t value;

	size_t c = count();
	uint64_t image_base = file.image_base();
	uint64_t pos = file.Tell();

	uint32_t table_count = file.ReadDWord();
	for (i = 0; i < table_count; i++) {
		for (j = 0; j < 2; j++) {
			value = file.ReadDWord();
			if (!value)
				continue;

			value += image_base;
			if ((file.segment_list()->GetMemoryTypeByAddress(value) & (j == 1 ? mtExecutable : mtReadable)) == 0)
				return false;
		}
	}

	file.Seek(pos);

	command = Add(address);
	command->ReadValueFromFile(file, osDWord);
	command->set_comment(CommentInfo(ttComment, "Count"));
	address = command->next_address();

	for (size_t i = 0; i < table_count; i++) {
		command = Add(address);
		command->ReadValueFromFile(file, osDWord);
		command->set_comment(CommentInfo(ttComment, "Type"));
		address = command->next_address();

		command = Add(address);
		value = command->ReadValueFromFile(file, osDWord);
		if (value) {
			value += image_base;
			CommandLink *link = command->AddLink(0, ltMemSEHBlock, value);
			link->set_sub_value(image_base);
		}
		command->set_comment(CommentInfo(ttComment, "Handler"));
		address = command->next_address();
	}

	for (i = c; i < count(); i++) {
		command = item(i);
		command->exclude_option(roClearOriginalCode);
	}

	return true;
}

bool IntelFunction::ParseBCBSEH(IArchitecture &file, uint64_t address, uint64_t next_address, uint8_t version)
{
	if (!file.AddressSeek(address))
		return false;

	uint64_t base_address = address;
	IntelCommand *command;
	size_t c = count();

	if (version == 2) {
		command = Add(address);
		command->ReadValueFromFile(file, osDWord);
		command->set_comment(CommentInfo(ttComment, "ThrowLst"));
		address = command->next_address();
	}

	command = Add(address);
	command->ReadValueFromFile(file, osDWord);
	command->set_comment(CommentInfo(ttComment, "VirtCondOffs"));
	address = command->next_address();

	command = Add(address);
	uint64_t bp_offset = command->ReadValueFromFile(file, osDWord);
	command->set_comment(CommentInfo(ttComment, "BPoffs"));

	//std::vector<uint16_t> ctx_list;
	{
		uint64_t bcb_seh_operand = IntelOperand(otMemory | otRegistr | otValue, osWord, regEBP, bp_offset + 0x10).encode();
		IntelFunction tmp(NULL, file.cpu_address_size(), this);
		address = next_address;
		for (;;) {
			command = NULL;
			if (file.segment_list()->GetMemoryTypeByAddress(address) & mtExecutable) {
				if (file.AddressSeek(address)) {
					command = tmp.ParseCommand(file, address);
					if (command && command->type() == cmMov && command->operand(0).encode() == bcb_seh_operand && command->operand(1).type == otValue) {
						uint16_t bcb_ctx = static_cast<uint16_t>(command->operand(1).value);
						size_t old_count = link_list()->count();
						IntelCommand *orig = command;
						while (bcb_ctx) {
							address = base_address + bcb_ctx;

							if (GetCommandByAddress(address))
								break;

							if (!file.AddressSeek(address))
								break;

							command = Add(address);
							bcb_ctx = static_cast<uint16_t>(command->ReadValueFromFile(file, osWord));
							command->set_comment(CommentInfo(ttComment, "Outer"));
							address = command->next_address();

							command = Add(address);
							uint16_t kind = static_cast<uint16_t>(command->ReadValueFromFile(file, osWord));
							command->set_comment(CommentInfo(ttComment, "Kind"));
							address = command->next_address();

							uint64_t value;
							switch (kind) {
							case 0:
								command = Add(address);
								command->ReadValueFromFile(file, osDWord);
								command->set_comment(CommentInfo(ttComment, "Reserved"));
								address = command->next_address();

								command = Add(address);
								value = command->ReadValueFromFile(file, osDWord);
								if (value)
									command->AddLink(0, ltMemSEHBlock, value);
								command->set_comment(CommentInfo(ttComment, "Handler"));
								break;
							case 1:
							case 2:
								command = Add(address);
								value = command->ReadValueFromFile(file, osDWord);
								if (kind == 1 && value)
									command->AddLink(0, ltMemSEHBlock, value);
								command->set_comment(CommentInfo(ttComment, "Filter"));
								address = command->next_address();

								command = Add(address);
								value = command->ReadValueFromFile(file, osDWord);
								if (value)
									command->AddLink(0, ltMemSEHBlock, value);
								command->set_comment(CommentInfo(ttComment, "Handler"));
								break;
							case 3:
								{
									command = Add(address);
									address = command->ReadValueFromFile(file, osDWord);
									command->set_comment(CommentInfo(ttComment, "Table"));
									command->AddLink(0, ltOffset, address);

									if (file.AddressSeek(address)) {
										command = Add(address);
										command->ReadValueFromFile(file, osDWord);
										command->set_comment(CommentInfo(ttComment, "ArgAddr"));
										address = command->next_address();

										command = Add(address);
										command->ReadValueFromFile(file, osDWord);
										command->set_comment(CommentInfo(ttComment, "ArgSize"));
										address = command->next_address();

										while (true) {
											command = Add(address);
											value = command->ReadValueFromFile(file, osDWord);
											if (value) {
												command->AddLink(0, ltMemSEHBlock, value);
											} else {
												delete command;
												break;
											}
											command->set_comment(CommentInfo(ttComment, "Handler"));
											address = command->next_address();

											command = Add(address);
											command->ReadValueFromFile(file, osDWord);
											command->set_comment(CommentInfo(ttComment, "TypeID"));
											address = command->next_address();

											command = Add(address);
											command->ReadValueFromFile(file, osDWord);
											command->set_comment(CommentInfo(ttComment, "Flags"));
											address = command->next_address();

											command = Add(address);
											command->ReadValueFromFile(file, osDWord);
											command->set_comment(CommentInfo(ttComment, "CctrAddr"));
											address = command->next_address();

											command = Add(address);
											command->ReadValueFromFile(file, osDWord);
											command->set_comment(CommentInfo(ttComment, "CctrMask"));
											address = command->next_address();
										}
									}
								}
								break;
							case 4:
								break;
							case 5:
								command = Add(address);
								command->ReadValueFromFile(file, osDWord);
								command->set_comment(CommentInfo(ttComment, "MinCount"));
								address = command->next_address();

								command = Add(address);
								command->ReadValueFromFile(file, osDWord);
								command->set_comment(CommentInfo(ttComment, "Table"));
								break;
							}
						}
						for (size_t i = old_count; i < link_list()->count(); i++) {
							CommandLink *src_link = link_list()->item(i);
							CommandLink *dst_link = src_link->Clone(tmp.link_list());
							tmp.link_list()->AddObject(dst_link);
							dst_link->set_from_command(tmp.Add(src_link->from_command()->address()));
						}
						command = orig;
					}
				}
			}
			if (!command || command->is_end() || (command->options() & roBreaked) != 0) {
				address = tmp.GetNextAddress(file);
				if (!address)
					break;
			} else {
				address = command->next_address();
			}
		}
	}

	for (size_t i = c; i < count(); i++) {
		command = item(i);
		command->exclude_option(roClearOriginalCode);
	}

	return true;
}

IntelCommand *IntelFunction::ParseString(IArchitecture &file, uint64_t address, size_t len)
{
	if (!file.AddressSeek(address))
		return NULL;

	IntelCommand *command = Add(address);
	command->ReadArray(file, len);
	command->exclude_option(roNeedCompile);
	return command;
}

void IntelFunction::ParseBeginCommands(IArchitecture &file)
{
	if (type() == otMarker || type() == otAPIMarker) {
		CompilerFunction *func = file.compiler_function_list()->GetFunctionByLowerAddress(address());
		if (func && (func->type() == cfCxxSEH || func->type() == cfCxxSEH3 || func->type() == cfCxxSEH4 || func->type() == cfBCBSEH || func->type() == cfVB6SEH)) {
			IntelFunction tmp(NULL, cpu_address_size());
			tmp.ReadFromFile(file, func->address());
			if (tmp.GetCommandByAddress(address())) {
				switch (func->type()) {
				case cfCxxSEH:
					ParseNewSEH(file, func->value(0));
					break;
				case cfCxxSEH3:
					ParseSEH3(file, func->value(0));
					break;
				case cfCxxSEH4:
					ParseSEH4(file, func->value(0));
					break;
				case cfBCBSEH:
					ParseBCBSEH(file, func->value(0), address(), static_cast<uint8_t>(func->value(1)));
					break;
				case cfVB6SEH:
					ParseVB6SEH(file, func->value(0));
					break;
				}
			}
		}
	}
}

void IntelFunction::ParseEndCommands(IArchitecture &file)
{
	if (type() == otMarker) {
		uint64_t len_address = address() + 1;
		if (file.AddressSeek(len_address)) {
			uint8_t len = file.ReadByte();
			ParseString(file, len_address + 1, len);
		}
	}

	if (type() == otMarker || type() == otAPIMarker) {
		std::vector<ICommand *> entry_command_list;
		std::vector<ICommand *> exclude_command_list;
		size_t i, j, k;

		/*
		for (i = 0; i < link_list()->count(); i++) {
			CommandLink *link = link_list()->item(i);
			if (link->type() == ltMemSEHBlock || link->type() == ltExtSEHHandler) {
				IntelCommand *command = GetCommandByAddress(link->to_address());
				if (command && std::find(entry_command_list.begin(), entry_command_list.end(), command) == entry_command_list.end())
					entry_command_list.push_back(command);
			}
		}
		*/

		for (i = 0; i < file.end_marker_list()->count(); i++) {
			MarkerCommand *marker_command = file.end_marker_list()->item(i);
			IntelCommand *command = GetCommandByNearAddress(marker_command->address());
			if (command) {
				if (marker_command->type() == otMarker) {
					uint64_t len_address = command->address() + 1;
					if (file.AddressSeek(len_address)) {
						uint8_t len = file.ReadByte();
						command = ParseString(file, len_address + 1, len);
					}
				} else {
					if (!command->is_end())
						command->include_option(roBreaked);
				}
				command = GetCommandByAddress(command->next_address());
				if (command && std::find(entry_command_list.begin(), entry_command_list.end(), command) == entry_command_list.end())
					entry_command_list.push_back(command);
			} else {
				for (size_t j = 0; j < link_list()->count(); j++) {
					CommandLink *link = link_list()->item(j);
					if ((link->type() == ltJmp || link->type() == ltJmpWithFlag) && link->to_address() && link->to_address() > link->from_command()->address() && marker_command->address() > link->from_command()->next_address() && marker_command->address() < link->to_address()) {
						command = GetCommandByAddress(link->to_address());
						if (command && std::find(entry_command_list.begin(), entry_command_list.end(), command) == entry_command_list.end())
							entry_command_list.push_back(command);
					}
				}
			}
		}

		Sort();
		for (i = 0; i < entry_command_list.size(); i++) {
			ICommand *entry_command = entry_command_list[i];

			size_t n = IndexOf(entry_command);
			if (n > 0) {
				IntelCommand *command = item(n - 1);
				if (!command->is_end())
					command->include_option(roBreaked);
			}
			for (j = n; j < count(); j++) {
				IntelCommand *command = item(j);

				if (std::find(exclude_command_list.begin(), exclude_command_list.end(), command) != exclude_command_list.end())
					break;

				exclude_command_list.push_back(command);

				for (k = 0; k < link_list()->count(); k++) {
					CommandLink *link = link_list()->item(k);
					if (link->parent_command() == command && std::find(entry_command_list.begin(), entry_command_list.end(), link->from_command()) == entry_command_list.end())
						entry_command_list.push_back(link->from_command());
				}

				CommandLink *link = command->link();
				if (link && link->to_address()) {
					IntelCommand *link_command = GetCommandByAddress(link->to_address());
					if (link_command && std::find(entry_command_list.begin(), entry_command_list.end(), link_command) == entry_command_list.end())
						entry_command_list.push_back(link_command);
				}

				if (command->is_end())
					break;
			}
		}
		
		for (i = 0; i < exclude_command_list.size(); i++) {
			ICommand *command = exclude_command_list[i];

			for (j = 0; j < range_list()->count(); j++) {
				AddressRange *range = range_list()->item(j);
				if (range->begin_entry() == command)
					range->set_begin_entry(NULL);
				if (range->end_entry() == command)
					range->set_end_entry(NULL);
				if (range->size_entry() == command)
					range->set_size_entry(NULL);
			}
			for (j = 0; j < function_info_list()->count(); j++) {
				FunctionInfo *info = function_info_list()->item(j);
				if (info->entry() == command)
					info->set_entry(NULL);
				for (k = 0; k < info->count(); k++) {
					AddressRange *range = info->item(k);
					if (range->begin_entry() == command)
						range->set_begin_entry(NULL);
					if (range->end_entry() == command)
						range->set_end_entry(NULL);
					if (range->size_entry() == command)
						range->set_size_entry(NULL);
				}
			}

			if (command->link())
				delete command->link();
			delete command;
		}
	}
}

uint64_t IntelFunction::GetNextAddress(IArchitecture &file)
{
	uint64_t res = BaseFunction::GetNextAddress(file);
	if (res)
		return res;

	size_t c = link_list()->count();
	for (size_t i = 0; i < c; i++) {
		CommandLink *link = link_list()->item(i);
		switch (link->type()) {
		case ltJmp:
			if (type() == otMarker && !link->parsed() && link->to_address() == address() + 0x12) {
				link->set_parsed(true);
				return link->to_address();
			}
			break;
		case ltDualSEHBlock:
			if (!link->next_command()) {
				IntelCommand *command = GetCommandByAddress(link->to_address());
				if (command) {
					IntelCommand *next_command = GetCommandByAddress(command->next_address());
					if (next_command)
						link->set_next_command(next_command);
					else
						return command->next_address();
				}
			}
			break;
		case ltExtSEHHandler:
			if (!link->next_command()) {
				size_t k = IndexOf(GetCommandByAddress(link->to_address()));
				if (k == NOT_ID)
					continue;

				std::set<size_t> stack;
				stack.insert(k);
				while (!stack.empty()) {
					k = *stack.begin();

					for (size_t j = k; j < count(); j++) {
						std::set<size_t>::const_iterator it = stack.find(j);
						if (it != stack.end())
							stack.erase(it);

						IntelCommand *command = item(j);
						if (command->options() & roBreaked)
							break;

						if (command->type() == cmJmpWithFlag && command->operand(0).type == otValue) {
							IntelCommand *to_command = GetCommandByAddress(command->operand(0).value);
							if (to_command) {
								k = IndexOf(to_command);
								if (k != NOT_ID && k > j)
									stack.insert(k);
							}
						}

						if (command->type() != cmRet && command->type() != cmJmp)
							continue;

						if (command->type() == cmJmp && command->operand(0).type == otValue) {
							IntelCommand *tmp = GetCommandByAddress(command->operand(0).value - 8);
							if (tmp && tmp->type() == cmPush && tmp->operand(0).type == otValue) {
								IntelCommand *next = GetCommandByAddress(tmp->next_address());
								if (next && next->type() == cmAdd && next->operand(0).type == (otMemory | otBaseRegistr) && next->operand(0).base_registr == regESP && next->operand(1).type == otRegistr && next->operand(1).registr == regEBX) {
									link->set_next_command(tmp);
									if (!tmp->link())
										tmp->AddLink(0, ltSEHBlock, tmp->operand(0).value);
								}
							}

							IntelCommand *to_command = GetCommandByAddress(command->operand(0).value);
							if (to_command) {
								k = IndexOf(to_command);
								if (k != NOT_ID && k > j) {
									j = k - 1;
									continue;
								}
							}
						}

						for (size_t n = j; n > k; n--) {
							command = item(n - 1);
							if (command->operand(0).type == otRegistr && command->operand(0).registr == regEAX && command->operand(0).size == cpu_address_size() &&
								((command->type() == cmLea && command->operand(1).type == (otMemory | otValue)) || (command->type() == cmMov && command->operand(1).type == otValue))) {
								link->set_next_command(command);
								if (!command->link())
									command->AddLink(1, ltSEHBlock, command->operand(1).value);
								break;
							}
						}
						break;
					}
				}
			}
		}
	}
	if (link_list()->count() > c)
		return GetNextAddress(file);

	return 0;
}

uint64_t IntelFunction::GetRegistrValue(uint8_t reg, size_t end_index)
{
	std::map<uint64_t, IntelCommand *> address_list;
	IntelCommand *mov_command = NULL;
	IntelCommandInfoList command_info_list(cpu_address_size());
	for (size_t i = 0; i <= end_index; i++) {
		IntelCommand *command = item(i);
		if (command->is_data())
			continue;

		std::map<uint64_t, IntelCommand *>::iterator it = address_list.find(command->address());
		if (it != address_list.end()) {
			if (mov_command && it->second) {
				if (mov_command != it->second && !mov_command->is_equal(*it->second))
					mov_command = NULL;
			} else {
				mov_command = it->second;
			}
		}

		if (i == end_index)
			break;

		CommandLink *link = command->link();
		if (link && link->type() != ltOffset && link->to_address()) {
			std::map<uint64_t, IntelCommand *>::iterator it = address_list.find(link->to_address());
			if (it != address_list.end()) {
				if (it->second != mov_command)
					it->second = NULL;
			} else {
				address_list[link->to_address()] = mov_command;
			}
		}

		if (command->is_end() || (command->options() & roBreaked) != 0)
			mov_command = NULL;
		else if (command->GetCommandInfo(command_info_list) && command_info_list.GetInfo(atWrite, otRegistr, reg))
			mov_command = command;
	}

	return (mov_command && mov_command->type() == cmLea && mov_command->operand(1).type == (otValue | otMemory)) ? mov_command->operand(1).value : (uint64_t)-1;
}

uint64_t IntelFunction::GetRegistrMaxValue(uint8_t reg, size_t end_index, IArchitecture &file)
{
	IntelCommandInfoList command_info_list(cpu_address_size());
	IntelCommand *jmp_command = NULL;
	IntelOperand find_operand = IntelOperand(otRegistr, cpu_address_size(), reg);
	for (size_t i = end_index; i > 0; i--) {
		IntelCommand *command = item(i - 1);
		if ((command->options() & roBreaked) || command->is_end()) {
			CommandLink *link = link_list()->GetLinkByToAddress(ltJmpWithFlag, item(i)->address());
			if (!link)
				link = link_list()->GetLinkByToAddress(ltJmp, item(i)->address());
			if (link) {
				command = reinterpret_cast<IntelCommand *>(link->from_command());
				if (link->type() == ltJmpWithFlag && command->flags() == (fl_C | fl_Z) && (command->options() & roInverseFlag) == 0)
					jmp_command = command;
				size_t index = IndexOf(command);
				if (index != NOT_ID) {
					i = index + 1;
					continue;
				}
			}
			break;
		}
		switch (command->type()) {
		case cmJmpWithFlag:
			if (command->flags() == (fl_C | fl_Z) && (command->options() & roInverseFlag))
				jmp_command = command;
			break;
		case cmCmp:
			if (command->operand(0) == find_operand) {
				if (command->operand(1).type == otValue && jmp_command)
					return command->operand(1).value;
			}
			break;
		case cmMovsx: case cmMovsxd:
			if (command->operand(0) == find_operand)
				find_operand = command->operand(1);
			break;
		case cmMov:
		case cmMovzx:
			if (command->operand(0) == find_operand) {
				find_operand = command->operand(1);
				if ((command->operand(1).type & otMemory) && command->operand(1).size == osByte) {
					uint64_t max_count = GetRegistrMaxValue(command->operand(1).registr, i - 1, file);
					if (max_count != (uint64_t)-1) {
						uint64_t base_address = 0;
						if (command->operand(1).type & otBaseRegistr) {
							if (cpu_address_size() == osQWord) {
								base_address = GetRegistrValue(command->operand(1).base_registr, i);
							}
							else {
								base_address = file.compiler_function_list()->GetRegistrValue(command->address(), IntelOperand(otRegistr, cpu_address_size(), command->operand(1).base_registr).encode());
							}
							if (base_address == (uint64_t)-1)
								break;
						}
						if (!file.AddressSeek(base_address + command->operand(1).value))
							break;
						uint8_t res = 0;
						for (uint64_t j = 0; j <= max_count; j++) {
							uint8_t b = file.ReadByte();
							if (b > res)
								res = b;
						}
						return res;
					}
				}
			}
			break;
		case cmCall:
			if (command->operand(0).type != otValue || command->operand(0).value != command->next_address())
				command = NULL;
			break;
		case cmAnd:
			if (command->operand(0).type == otRegistr && command->operand(0).registr == find_operand.registr && static_cast<uint32_t>(command->operand(1).value) == 0xffffffff)
				break;
			// fall-through
		default:
			if (!command->GetCommandInfo(command_info_list))
				command = NULL;
			else if ((find_operand.type & otRegistr) && command_info_list.GetInfo(atWrite, otRegistr, find_operand.registr))
				command = NULL;
			else if ((find_operand.type & otBaseRegistr) && command_info_list.GetInfo(atWrite, otRegistr, find_operand.base_registr))
				command = NULL;
			break;
		}
		if (!command)
			break;
	}
	return (uint64_t)-1;
}

CompilerFunction *IntelFunction::ParseCompilerFunction(IArchitecture &file, uint64_t address)
{
	CompilerFunction *compiler_function = file.compiler_function_list()->GetFunctionByAddress(address);
	if (!compiler_function && (file.segment_list()->GetMemoryTypeByAddress(address) & mtExecutable)) {
		IFunction *tmp_parent = this;
		size_t stack_depth = 0;
		bool in_parent_list = false;
		while (tmp_parent) {
			if (tmp_parent->GetCommandByAddress(address)) {
				in_parent_list = true;
				break;
			}
			tmp_parent = tmp_parent->parent();
			if ((stack_depth++) > 1000)
				return NULL;
		}
		if (in_parent_list)
			return NULL;

		IntelFunction func(NULL, cpu_address_size(), this);
		func.ReadFromFile(file, address);
		IntelCommand *entry = func.GetCommandByAddress(address);
		if (entry) {
			std::set<size_t> entry_stack;
			std::set<IntelCommand *> end_command_list;
			std::set<IntelCommand *> parsed_command_list;

			entry_stack.insert(func.IndexOf(entry));
			while (!entry_stack.empty()) {
				for (size_t i = *entry_stack.begin(); i < func.count(); i++) {
					IntelCommand *command = func.item(i);
					std::set<size_t>::const_iterator it = entry_stack.find(i);
					if (it != entry_stack.end())
						entry_stack.erase(it);

					if (parsed_command_list.find(command) != parsed_command_list.end())
						break;
					parsed_command_list.insert(command);

					switch (command->type()) {
					case cmRet:
					case cmIret:
						if (cpu_address_size() == osQWord && i > 0) {
							IntelCommand *prev = func.item(i - 1);
							if (prev->type() == cmMov && prev->operand(0).type == otRegistr && prev->operand(0).registr == regESP) {
								// mov rsp, xxxx
								command->include_option(roBreaked);
							}
						}
						end_command_list.insert(command);
						break;
					case cmJmpWithFlag:
						{
							IntelCommand *link_command = func.GetCommandByAddress(command->operand(0).value);
							if (link_command)
								entry_stack.insert(func.IndexOf(link_command));
						}
						break;
					case cmJmp:
						{
							bool is_end = true;
							compiler_function = file.compiler_function_list()->GetFunctionByAddress(command->address());
							if (compiler_function && (compiler_function->options() & coNoReturn) != 0)
								command->include_option(roBreaked);

							if (command->operand(0).type == (otValue | otMemory)) {
								if (IRelocation *reloc = file.relocation_list() ? file.relocation_list()->GetRelocationByAddress(command->operand(0).value) : NULL) {
									if (reloc->symbol()) {
										compiler_function = func.ParseCompilerFunction(file, reloc->symbol()->address());
										if (compiler_function && (compiler_function->options() & coNoReturn) != 0)
											command->include_option(roBreaked);
									}
								}
							}
							else if (command->operand(0).type == otValue) {
								IntelCommand *link_command = func.GetCommandByAddress(command->operand(0).value);
								if (link_command) {
									entry_stack.insert(func.IndexOf(link_command));
									is_end = false;
								}
								else {
									compiler_function = func.ParseCompilerFunction(file, command->operand(0).value);
									if (compiler_function && (compiler_function->options() & coNoReturn) != 0)
										command->include_option(roBreaked);
								}
							}
							else if (command->link() && (command->link()->type() == ltSwitch || command->link()->type() == ltOffset)) {
								ICommand *parent_command;
								if (command->link()->type() == ltSwitch)
									parent_command = command;
								else {
									parent_command = func.GetCommandByAddress(command->link()->to_address());
									parent_command = (parent_command && parent_command->link()) ? parent_command->link()->parent_command() : NULL;
								}

								if (parent_command) {
									is_end = false;
									for (size_t j = 0; j < func.link_list()->count(); j++) {
										CommandLink *link = func.link_list()->item(j);
										if (link->parent_command() == parent_command) {
											IntelCommand *link_command = func.GetCommandByAddress(link->to_address());
											if (link_command)
												entry_stack.insert(func.IndexOf(link_command));
										}
									}
								}
							}

							if (is_end)
								end_command_list.insert(command);
						}
						break;
					}

					if (command->options() & roBreaked) {
						end_command_list.insert(command);
						break;
					}

					if (command->is_end())
						break;
				}
			}

			compiler_function = file.compiler_function_list()->Add(cfNone, address);
			if (!end_command_list.empty()) {
				size_t no_return_count = 0;
				for (std::set<IntelCommand *>::const_iterator it = end_command_list.begin(); it != end_command_list.end(); it++) {
					IntelCommand *tmp_command = *it;
					if (tmp_command->options() & roBreaked)
						no_return_count++;
				}

				if (no_return_count == end_command_list.size())
					compiler_function->include_option(coNoReturn);
			}
		}
	}

	return compiler_function;
}

IntelCommand *IntelFunction::ParseCommand(IArchitecture &file, uint64_t address, bool dump_mode)
{
	CommandLink *command_link; 
	IntelCommand *command, *prev;
	size_t i, c;
	CommandLinkList *links;
	IImportFunction *import_function;
	CompilerFunction *compiler_function;
	uint64_t base_address;

	if (dump_mode) {
		command = Add(address);
		if (!file.AddressSeek(address))
			command->InitUnknown();
		else if ((file.selected_segment()->memory_type() & mtExecutable) == 0)
			command->ReadValueFromFile(file, osByte);
		else {
			command->ReadFromFile(file);
			switch (command->type()) {
			case cmJmp:
			case cmCall:
			case cmJmpWithFlag: case cmJCXZ: case cmLoop: case cmLoope: case cmLoopne:
				if ((command->options() & roFar) == 0 && command->operand(0).type == otValue)
					command->AddLink(0, ltNone, command->operand(0).value);
				break;
			}
		}
		return command;
	} else {
		if (!file.AddressSeek(address))
			return NULL;
	}

	command = Add(address);
	command->ReadFromFile(file);

	links = link_list();
	switch (command->type()) {
		case cmDB:
			command->include_option(roInvalidOpcode);
			break;

		case cmAdd:
			if (command->dump_size() == 2 && command->dump(0) == 0 && command->dump(1) == 0) {
				delete command;
				command = NULL;
			}
			break;

		case cmCall:
			if ((command->options() & roFar) == 0) {
				if (command->operand(0).type == otValue && !command->operand(0).relocation)
					command->AddLink(0, ltCall, command->operand(0).value);
				else
					command->AddLink(-1, ltCall);

				if (command->operand(0).type == (otValue | otMemory)) {
					// check import
					import_function = file.import_list()->GetFunctionByAddress(command->operand(0).value);
					if (import_function != NULL && (import_function->options() & ioNoReturn) != 0)
						command->include_option(roBreaked);
				} else if (command->operand(0).type == otValue) {
					// check compiler function
					compiler_function = ParseCompilerFunction(file, command->operand(0).value);
					if (compiler_function) {
						if (compiler_function->options() & coNoReturn)
							command->include_option(roBreaked);

						switch (compiler_function->type()) {
						case cfInitBCBSEH:
							if (compiler_function->value(0)) {
								CompilerFunction *func = file.compiler_function_list()->GetFunctionByLowerAddress(address);
								if (func && func->type() == cfBCBSEH) 
									ParseBCBSEH(file, func->value(0), command->next_address(), static_cast<uint8_t>(func->value(1)));
							}
							break;
						case cfSEH4Prolog:
							if (count() > 1) {
								prev = item(count() - 2);
								if (prev->type() == cmPush && prev->operand(0).type == otValue) {
									if (ParseSEH4(file, prev->operand(0).value))
										prev->AddLink(0, ltOffset, prev->operand(0).value);
								}
							}
						}
					}
				}
			}
			break;

		case cmJmp:
			if ((command->options() & roFar) == 0) {
				if (command->operand(0).type == otValue) { // jmp xxxx
					if (!command->operand(0).relocation)
						command->AddLink(0, ltJmp, command->operand(0).value);

					if (cpu_address_size() == osDWord) {
						if (count() > 1) {
							i = count() - 2;
							prev = item(i);
							if (prev->type() == cmPush && prev->operand(0).type == otValue) {
								command_link = links->GetLinkByToAddress(ltVBMemSEHBlock, command->operand(0).value);
								if (command_link || (file.AddressSeek(command->operand(0).value) && file.ReadByte() == 0xc3))
									prev->AddLink(0, ltFinallyBlock, prev->operand(0).value);
							}
						}

						command_link = links->GetLinkByToAddress(ltSEHBlock, command->address());
						if (command_link) {
							i = count();
							if (ParseFilterSEH(file, command->next_address())) {
								command_link->set_type(ltFilterSEHBlock);
								command_link->set_parent_command(item(i));
							} else {
								command_link->set_type(ltDualSEHBlock);
							}
						}
					}
				} else if (command->operand(0).type == (otValue | otMemory | otRegistr) && command->operand(0).size == cpu_address_size() && command->operand(0).scale_registr == (cpu_address_size() == osDWord ? 2 : 3)) { // jmp dword ptr [reg*4 + xxxx]
					if (ParseSwitch(file, command->operand(0).value, command->operand(0).size, 0, command, 0, static_cast<size_t>(GetRegistrMaxValue(command->operand(0).registr, IndexOf(command), file))))
						command->AddLink(0, ltSwitch, command->operand(0).value);
					else if (count() == 0)
						return ParseCommand(file, this->address(), dump_mode);
				} else if (command->operand(0).type == otRegistr && count() > 1) { // jmp reg
					prev = NULL;
					IntelCommandInfoList command_info(cpu_address_size());
					if (count() > 2) {
						for (i = count() - 2; i > 0; i--) {
							IntelCommand *tmp = item(i);
							if (!tmp->GetCommandInfo(command_info) || command_info.GetInfo(atWrite, otBaseRegistr, regEIP))
								break;
							if (command_info.GetInfo(atWrite, otRegistr, command->operand(0).registr)) {
								prev = tmp;
								break;
							}
						}
					}
					if (prev) {
						if ((prev->type() == cmAdd || prev->type() == cmSub)
							&& prev->operand(0).type == otRegistr
							&& prev->operand(0).size == cpu_address_size()
							&& prev->operand(0).registr == command->operand(0).registr) {
							uint8_t base_registr;
							base_address = 0;
							if (prev->operand(1).type == otRegistr) {
								base_registr = prev->operand(1).registr;
								prev = NULL;
								for (c = i; c > 0; c--) {
									IntelCommand *tmp = item(c - 1);
									if (tmp->type() == cmMov && tmp->operand(0).type == otRegistr && tmp->operand(1).type == otRegistr && tmp->operand(0).registr == base_registr)
										base_registr = tmp->operand(1).registr;
									else if (tmp->type() == cmLea && tmp->operand(0).type == otRegistr && tmp->operand(1).type == (otMemory | otValue) && tmp->operand(0).registr == base_registr)
										base_address = tmp->operand(1).value;
									else if ((tmp->type() == cmMov || tmp->type() == cmMovsxd)
										&& tmp->operand(0).type == otRegistr
										&& tmp->operand(0).registr == command->operand(0).registr) {
										i = c - 1;
										prev = tmp;
										break;
									}
									else {
										if (!tmp->GetCommandInfo(command_info) || command_info.GetInfo(atWrite, otRegistr, command->operand(0).registr))
											break;
									}
								}
							}
							else {
								base_registr = prev->operand(0).registr;
							}
							if (prev) {
								if ((prev->operand(1).type & (otMemory | otBaseRegistr | otRegistr)) == (otMemory | otBaseRegistr | otRegistr)
									&& prev->operand(1).scale_registr == 2
									&& prev->operand(1).size == osDWord) { // add/mov/movsx reg, [reg1 + reg2*4 + xxxx]
									if (!base_address) {
										if (cpu_address_size() == osQWord) {
											base_address = GetRegistrValue(prev->operand(1).base_registr, i);
										}
										else {
											IntelOperand base_operand = IntelOperand(otRegistr, cpu_address_size(), base_registr);
											if (i > 0) {
												IntelCommand *tmp = item(i - 1);
												if (tmp->type() == cmMov
													&& tmp->operand(0).type == otRegistr
													&& tmp->operand(0).registr == base_registr) {
													base_operand = tmp->operand(1);
												}
											}
											base_address = file.compiler_function_list()->GetRegistrValue(command->address(), base_operand.encode());
										}
									}
									if (base_address != (uint64_t)-1) {
										size_t mode;
										switch (prev->type()) {
										case cmMovsxd:
											mode = 1;
											break;
										case cmSub:
											mode = 2;
											break;
										default:
											mode = 0;
											break;
										}
										if (ParseSwitch(file, base_address + prev->operand(1).value, osDWord, base_address, command, mode, static_cast<size_t>(GetRegistrMaxValue(prev->operand(1).registr, IndexOf(prev), file)))) {
											command_link = prev->AddLink(1, ltSwitch, base_address + prev->operand(1).value);
											command_link->set_sub_value(base_address);
											command->AddLink(-1, ltOffset, command_link->to_address());
										}
										else if (count() == 0)
											return ParseCommand(file, this->address(), dump_mode);
									}
								}
								else if (prev->type() == cmAdd
									&& prev->operand(1).type == (otMemory | otRegistr | otValue)
									&& prev->operand(1).scale_registr == 2
									&& prev->operand(1).size == osDWord
									&& prev->operand(0).registr == base_registr) { // add reg, [reg1*4 + xxxx]
									if (cpu_address_size() == osQWord) {
										base_address = GetRegistrValue(base_registr, i);
									}
									else {
										IntelOperand base_operand = IntelOperand(otRegistr, cpu_address_size(), base_registr);
										if (i > 0) {
											IntelCommand *tmp = item(i - 1);
											if (tmp->type() == cmMov
												&& tmp->operand(0).type == otRegistr
												&& tmp->operand(0).registr == base_registr) {
												base_operand = tmp->operand(1);
											}
										}
										base_address = file.compiler_function_list()->GetRegistrValue(command->address(), base_operand.encode());
									}
									if (base_address != (uint64_t)-1) {
										if (ParseSwitch(file, prev->operand(1).value, osDWord, base_address, command, 0, static_cast<size_t>(GetRegistrMaxValue(prev->operand(1).registr, IndexOf(prev), file)))) {
											command_link = prev->AddLink(1, ltSwitch, prev->operand(1).value);
											command->AddLink(-1, ltOffset, command_link->to_address());
										}
										else if (count() == 0)
											return ParseCommand(file, this->address(), dump_mode);
									}
								}
								else if (prev->type() == cmMov
									&& prev->operand(1).type == (otMemory | otRegistr | otValue)
									&& prev->operand(1).scale_registr == 2
									&& prev->operand(1).size == osDWord
									&& prev->operand(0).registr == command->operand(0).registr) { // mov reg, [reg1*4 + xxxx]
									if (cpu_address_size() == osQWord) {
										base_address = GetRegistrValue(base_registr, i + 1);
									}
									else {
										IntelOperand base_operand = IntelOperand(otRegistr, cpu_address_size(), base_registr);
										IntelCommand *tmp = item(i + 1);
										if (tmp->type() == cmMov
											&& tmp->operand(0).type == otRegistr
											&& tmp->operand(0).registr == base_registr) {
											base_operand = tmp->operand(1);
										}
										base_address = file.compiler_function_list()->GetRegistrValue(command->address(), base_operand.encode());
									}
									if (base_address != (uint64_t)-1) {
										if (ParseSwitch(file, prev->operand(1).value, osDWord, base_address, command, 0, static_cast<size_t>(GetRegistrMaxValue(prev->operand(1).registr, IndexOf(prev), file)))) {
											command_link = prev->AddLink(1, ltSwitch, prev->operand(1).value);
											command->AddLink(-1, ltOffset, command_link->to_address());
										}
										else if (count() == 0)
											return ParseCommand(file, this->address(), dump_mode);
									}
								}
							}
						}
						else if (prev->type() == cmMov && prev->operand(1).type == (otValue | otMemory | otRegistr) && prev->operand(1).size == cpu_address_size() && prev->operand(1).scale_registr == (cpu_address_size() == osDWord ? 2 : 3)) { // mov reg1, dword ptr [reg*4 + xxxx]
							if (ParseSwitch(file, prev->operand(1).value, prev->operand(1).size, 0, command, 0, static_cast<size_t>(GetRegistrMaxValue(prev->operand(1).registr, IndexOf(prev), file)))) {
								command_link = prev->AddLink(1, ltSwitch, prev->operand(1).value);
								command->AddLink(-1, ltOffset, command_link->to_address());
							}
							else if (count() == 0)
								return ParseCommand(file, this->address(), dump_mode);
						}
					}
				}
			}
			break;

		case cmPush:
			if (cpu_address_size() == osDWord) {
				if (command->operand(0).type == otValue) { // push xxxx
					if (count() > 1) {
						i = count() - 2;
						prev = item(i);
						if (prev->type() == cmMov 
							&& prev->operand(0).type == (otMemory | otRegistr) 
							&& prev->base_segment() == segFS
							&& prev->operand(1).type == otRegistr 
							&& prev->operand(1).registr != regESP) // mov fs:[reg], reg1
								command->AddLink(0, ltFinallyBlock, command->operand(0).value);
					}
				} else if ((command->operand(0).type & otMemory) != 0 && command->base_segment() == segFS) { // push fs:[xxxx]
					if (count() >= 2) {
						i = count() - 2;
						prev = item(i);
						if (prev->type() == cmPush && prev->operand(0).type == otValue) // push xxxx
							prev->AddLink(0, ltSEHBlock, prev->operand(0).value);
					}
				}
			}
			break;

		case cmMov:
			if (cpu_address_size() == osDWord) {
				if (command->base_segment() == segFS) {
					if (command->operand(0).type == otRegistr 
						&& command->operand(1).type == (otMemory | otValue)
						&& command->operand(1).value == 0) { // mov reg, fs:[00000000]

						uint64_t mem_offset = 0;
						uint8_t mem_registr = 0;
						{
							IntelCommand tmp(NULL, cpu_address_size());
							uint64_t pos = file.Tell();
							for (i = 0; i < 10; i++) {
								tmp.ReadFromFile(file);
								if (tmp.type() == cmPush
									|| tmp.type() == cmDB
									|| tmp.type() == cmJmp
									|| tmp.type() == cmJmpWithFlag
									|| tmp.type() == cmRet
									|| tmp.type() == cmIret
									|| tmp.type() == cmCall)
									break;
								if (tmp.type() == cmMov) {
									if (tmp.operand(1).type == otRegistr && tmp.operand(1).registr == command->operand(0).registr && tmp.operand(0).type == (otMemory | otRegistr | otValue)) {
										mem_offset = tmp.operand(0).value;
										mem_registr = tmp.operand(0).registr;
									}
									break;
								}
							}
							file.Seek(pos);
						}

						c = 0;
						for (i = count(); i > 0; i--) {
							prev = item(i - 1);
							if (prev->type() == cmJmp 
								|| prev->type() == cmJmpWithFlag 
								|| prev->type() == cmRet 
								|| prev->type() == cmIret 
								|| prev->type() == cmCall)
								break;

							if (prev->type() == cmPush ||
								(mem_offset && prev->type() == cmMov && prev->operand(0).type == (otMemory | otRegistr | otValue) && prev->operand(0).value == mem_offset + 4 && prev->operand(0).registr == mem_registr && prev->operand(1).type == otValue)) {
								c++;
								if (mem_offset)
									mem_offset += 4;
								size_t k = (prev->type() == cmPush) ? 0 : 1;
								if (c == 1) {
									if (ParseNewSEH(file, prev->operand(k).value)) {
										prev->AddLink((int)k, ltOffset, prev->operand(k).value);
										break;
									}
								} else if (c == 2) {
									uint64_t version = 0;
									if (i > 1) {
										IntelCommand *tmp = item(i - 2);
										if (tmp->type() == cmPush && tmp->operand(0).type == otValue)
											version = tmp->operand(0).value;
									}

									if (version == (uint64_t)-2 && ParseSEH4(file, prev->operand(k).value))
										prev->AddLink((int)k, ltOffset, prev->operand(k).value);
									else if (version == (uint64_t)-1 && ParseSEH3(file, prev->operand(k).value))
										prev->AddLink((int)k, ltOffset, prev->operand(k).value);
									break;
								}
							}
						}
					}
				} else if (command->operand(0).type == (otMemory | otRegistr | otValue) 
							&& command->operand(0).registr == regEBP 
							&& command->operand(0).size == osDWord
							&& command->operand(1).type == otValue) { // mov [ebp + xxxx], xxxx
					CompilerFunction *func =  file.compiler_function_list()->GetFunctionByAddress(address);
					if (func && func->type() == cfVB6SEH) {
						if (ParseVB6SEH(file, func->value(0)))
							command->AddLink(1, ltOffset, func->value(0));
					}
				}
			}
			break;

		case cmInt:
			if (command->operand(0).value == 3)
				command->include_option(roBreaked);
			else if (file.owner()->format_name() == "PE") {
				if (command->operand(0).value == 0x29) // __failfast
					command->include_option(roBreaked);
			}
			break;

		case cmHlt:
		case cmUd2:
			command->include_option(roBreaked);
			break;

		case cmJmpWithFlag: case cmJCXZ: case cmLoop: case cmLoope: case cmLoopne:
			command->AddLink(0, ltJmpWithFlag, command->operand(0).value);
			break;
	}

	return command;
}

IntelCommand *IntelFunction::ReadValidCommand(IArchitecture &file, uint64_t address)
{
	size_t i, f, d;
	IntelCommand *command;
	IFixupList *fixup_list; 
	ISectionList *segment_list; 
	const IFixup *fixup; 
	bool invalid_fixup;
	IntelOperand operand;

	command = ParseCommand(file, address, true);
	if (!command)
		return NULL;

	fixup_list = file.fixup_list();
	segment_list = file.segment_list();

	if (fixup_list->count() > 0) {
		// need to check fixups for all value operands
		d = 0;
		while (d < command->dump_size()) {
			fixup = fixup_list->GetFixupByNearAddress(address + d);
			if (fixup) {
				invalid_fixup = true;
				f = static_cast<size_t>(fixup->address() - address);
				for (i = 0; i < 3; i++) {
					operand = command->operand(i);
					if (operand.type & otValue) {
						if (command->type() == cmCall || command->type() == cmJmp || command->type() == cmJmpWithFlag) {
							if ((operand.type & otMemory) == 0)
								break;
						}
						if (f == operand.value_pos) {
							invalid_fixup = false;
							break;
						}
					}
				}
				if (invalid_fixup)
					return NULL;
				d += OperandSizeToValue(fixup->size());
			} else {
				d++;
			}
		}
	}

	/*
	for (i = 0; i < 3; i++) {
		operand = command->operand(i);
		if (operand.type == (otMemory | otValue)) {
			// check fixup
			if (fixup_list->count() > 0 && operand.fixup == NULL && !operand.is_large_value)
				return NULL;
			// check segment type
			if ((segment_list->GetMemoryTypeByAddress(operand.value) & mtReadable) == 0)
				return NULL;
		}
	}
	*/

	if (command->type() == cmCall || command->type() == cmJmp || command->type() == cmJmpWithFlag) {
		operand = command->operand(0);
		// check segment type for value operand
		if (operand.type == otValue && (segment_list->GetMemoryTypeByAddress(command->operand(0).value) & mtExecutable) == 0)
			return NULL;
	}

	if (cpu_address_size() == osQWord) {
		// calc REX preffixes count
		f = 0;
		for (i = 0; i < command->command_pos(); i++) {
			if ((command->dump(i) & 0xF0) == 0x40) {
				f++;
			} else {
				if (f)
					break;
			}
		}
		if (f > 1)
			return NULL;
	}

	return command;
}

uint64_t IntelFunction::ParseParam(IArchitecture &file, size_t index, uint64_t &param_reference)
{
	size_t i;
	IntelCommand *command;
	bool need_push_value;
	uint8_t registr;
	IntelOperand operand;
	IntelCommandInfoList command_info(cpu_address_size());

	CallingConvention calling_convention = file.calling_convention();
	bool use_stack = false;
	switch (calling_convention) {
	case ccMSx64:
		registr = regECX;
		break;
	case ccABIx64:
		registr = regEDI;
		break;
	default:
		registr = 0xFF;
		use_stack = true;
	}

	need_push_value = true;
	for (i = index; i > 0; i--) {
		command = item(i - 1);

		// unknown command
		if (!command->GetCommandInfo(command_info))
			return 0;

		// commands change EIP can no be found between API`s param and API`s call
		if (command_info.GetInfo(atWrite, otBaseRegistr, regEIP))
			return 0;

		param_reference = command->address();
		if (!use_stack) {
			if (command->type() == cmLea && command->operand(0).size == cpu_address_size() && command->operand(0).type == otRegistr && command->operand(0).registr == registr) {
				// lea reg, [xxxx]
				operand = command->operand(1);
				if (operand.type == (otMemory | otValue) && operand.is_large_value)
					return operand.value;
				return 0;
			} else if (command->type() == cmMov && (command->operand(0).size == cpu_address_size() || (command->operand(0).size == osDWord && cpu_address_size() == osQWord)) && command->operand(0).type == otRegistr && command->operand(0).registr == registr) {
				// mov reg, xxxx
				operand = command->operand(1);
				if (operand.type == otValue) {
					return operand.value;
				} else if (operand.type == otRegistr) {
					registr = operand.registr;
				} else {
					return 0;
				}
			} else if (command_info.GetInfo(atWrite, otRegistr, registr)) {
				return 0;
			}
	
		} else {
			if ((command->type() == cmPush && need_push_value) || // push xxxx
				(command->type() == cmMov && command->operand(0).size == cpu_address_size() && 
					// mov [esp], xxxx
					((command->operand(0).type == (otMemory | otBaseRegistr) && command->operand(0).base_registr == regESP && need_push_value) ||
					// mov reg, xxxx
					(command->operand(0).type == otRegistr && command->operand(0).registr == registr && !need_push_value))
					)) {
				operand = command->operand(command->type() == cmMov);
				if (operand.type == otValue) {
					return operand.value;
				} else if (operand.type == otRegistr) {
					need_push_value = false;
					registr = operand.registr;
				} else {
					return 0;
				}
			} else if (!need_push_value && command->type() == cmLea && command->operand(0).size == cpu_address_size() && command->operand(0).type == otRegistr && command->operand(0).registr == registr && command->operand(1).type == (otValue | otRegistr | otMemory)) {
				// lea reg, [reg + xxxx]
				IntelOperand base_operand = IntelOperand(otRegistr, cpu_address_size(), command->operand(1).registr);
				if (i > 1) {
					IntelCommand *tmp = item(i - 2);
					if (tmp->type() == cmMov
						&& tmp->operand(0).type == otRegistr 
						&& tmp->operand(0).registr == base_operand.registr) {
						base_operand = tmp->operand(1);
					}
				}
				uint64_t base_address = file.compiler_function_list()->GetRegistrValue(command->address(), base_operand.encode());
				if (base_address != (uint64_t)-1)
					return base_address + command->operand(1).value;
			} else if (!need_push_value && command_info.GetInfo(atWrite, otRegistr, registr)) {
				return 0;
			}
		}
	}

	return 0;
}

void IntelFunction::ReadMarkerCommands(IArchitecture &file, MarkerCommandList &command_list, uint64_t address, uint32_t options)
{
	uint64_t param_address, param_reference, call_start, call_end, tmp_address;
	IntelCommand *command;
	ICommand *link_command;
	uint8_t api_reg;
	std::vector<size_t> stack;
	size_t i, j, cur_index;
	bool need_parse_backward, first_call;

	command_list.clear();
	call_start = address;
	call_end = address + 1;

	if (options & moForward) {
		// forward searching
		if (count() == 0)
			return;

		command = item(0);
		if (command->operand(0).type != otRegistr)
			return;

		api_reg = command->operand(0).registr;
		ReadFromFile(file, address);

		command = GetCommandByAddress(address);
		if (!command)
			return;

		cur_index = IndexOf(command) + 1;
		need_parse_backward = false;
		first_call = true;
		IntelCommandInfoList command_info_list(cpu_address_size());
		while (cur_index < count()) {
			command = item(cur_index);
			bool is_end = command->is_end();
			if ((command->options() & roBreaked) == 0) {
				if (command->type() == cmCall && command->operand(0).type == otRegistr && command->operand(0).registr == api_reg) {
					// call reg
					if (options & moNeedParam) {
						param_address = ParseParam(file, cur_index, param_reference);
						if (!param_address && first_call) {
							need_parse_backward = true;
							call_start = command->address();
							call_end = command->next_address();
						} else {
							command_list.Add(command->address(), command->next_address(), param_reference, param_address);
						}
						first_call = false;
					} else {
						command_list.Add(command->address(), command->next_address(), 0, 0);
					}
				} else if ((command->type() == cmJmp || command->type() == cmJmpWithFlag || command->type() == cmLoop) && command->link()) {
					// add link to stack
					link_command = GetCommandByAddress(command->link()->to_address());
					if (link_command) {
						i = IndexOf(link_command);
						if (i != NOT_ID)
							stack.push_back(i);
					}
				} else if (command->GetCommandInfo(command_info_list)) {
					if (command_info_list.GetInfo(atWrite, otRegistr, api_reg)) {
						std::vector<IntelCommand *> exclude_command_list;
						exclude_command_list.push_back(command);
						for (i = 0; i < exclude_command_list.size(); i++) {
							for (j = IndexOf(exclude_command_list[i]); j < count(); j++) {
								command = item(j);

								if (std::find(exclude_command_list.begin(), exclude_command_list.end(), command) == exclude_command_list.end())
									exclude_command_list.push_back(command);

								for (size_t k = 0; k < link_list()->count(); k++) {
									CommandLink *link = link_list()->item(k);
									if (link->parent_command() == command && std::find(exclude_command_list.begin(), exclude_command_list.end(), link->from_command()) == exclude_command_list.end())
										exclude_command_list.push_back(reinterpret_cast<IntelCommand *>(link->from_command()));
								}

								CommandLink *link = command->link();
								if (link && link->to_address()) {
									IntelCommand *link_command = GetCommandByAddress(link->to_address());
									if (link_command && std::find(exclude_command_list.begin(), exclude_command_list.end(), link_command) == exclude_command_list.end())
										exclude_command_list.push_back(link_command);
								}

								if (command->is_end())
									break;
							}
						}
						for (i = 0; i < exclude_command_list.size(); i++) {
							exclude_command_list[i]->include_option(roBreaked);
						}
						is_end = true;
					}
				} else {
					is_end = true;
				}
			} else {
				is_end = true;
			}

			// the end of branch
			if (is_end) {
				// delete processed indexes
				for (i = stack.size(); i > 0; i--) {
					if (stack[i - 1] <= cur_index)
						stack.erase(stack.begin() + i - 1);
				}
				if (stack.empty())
					break;

				// calc minimum index from stack
				cur_index = stack[0];
				for (i = 0; i < stack.size(); i++) {
					if (cur_index > stack[i])
						cur_index = stack[i];
				}
			} else {
				cur_index++;
			}
		}

		if (!need_parse_backward)
			return;
	}

	if ((options & moNeedParam) == 0)
		return;

	// backward searching
	SignatureList param_signatures;
	if (cpu_address_size() == osDWord) {
		for (i = 0; i < file.compiler_function_list()->count(); i++) {
			if (file.compiler_function_list()->item(i)->type() == cfBaseRegistr) {
				param_signatures.Add("8B");    // mov reg, [reg + xxxx]
				break;
			}
		}
		param_signatures.Add("68");    // push xxxx
		param_signatures.Add("B?");    // mov reg, xxxx
		param_signatures.Add("8D8?");    // lea reg, [xxxx]
		param_signatures.Add("C70424");    // mov [esp], xxxx
	} else {
		param_signatures.Add("4?8D");    // lea reg, [xxxx]
		param_signatures.Add("B?");    // mov reg, xxxx
	}

	for (i = 0; i < param_signatures.count(); i++) {
		Signature *sign = param_signatures.item(i);
		for (j = 0x100; j > 0; j--) {
			if (!file.AddressSeek(address - j))
				continue;
			uint8_t b;
			file.Read(&b, sizeof(b));
			if (!sign->SearchByte(b))
				continue;
			
			clear();
			tmp_address = address - j - sign->size() + 1;
			while (tmp_address < address) {
				command = ReadValidCommand(file, tmp_address);
				// these commands can no be found between API`s param and API`s call
				if (command == NULL 
					|| command->type() == cmDB 
					|| command->type() == cmRet
					|| command->type() == cmIret
					|| command->type() == cmJmp
					|| command->type() == cmEnter) {
						tmp_address = 0;
						break;
				}
				tmp_address = command->next_address();
			}

			if (tmp_address != address)
				continue;

			size_t index = count();
			if (options & moSkipLastCall) {
				if (count() > 1) {
					command = item(count() - 1);
					if (command->type() == cmPush && command->operand(0).type == otRegistr && command->operand(0).registr == regEAX) {
						command = item(count() - 2);
						if (command->type() == cmCall)
							index -= 2;
					}
				}
			}

			param_address = ParseParam(file, index, param_reference);
			if (param_address && (file.segment_list()->GetMemoryTypeByAddress(param_address) & mtReadable)) {
				command_list.Add(call_start, call_end, param_reference, param_address);
				return;
			}
		}
	}
}

IntelCommand *IntelFunction::CreateCommand()
{
	return new IntelCommand(this, cpu_address_size());
}

void IntelFunction::CreateBlocks()
{
	CommandBlock *cur_block = NULL;
	for (size_t i = 0; i < count(); i++) {
		IntelCommand *command = item(i);
		if (command->block() || (command->options() & roNeedCompile) == 0) {
			cur_block = NULL;
			continue;
		}

		if ((!cur_block || (command->options() & roCreateNewBlock) || item(cur_block->end_index())->is_data() != command->is_data()))
			cur_block = AddBlock(i, true);

		cur_block->set_end_index(i);

		command->set_block(cur_block);
		if (command->type() == cmJmp || command->type() == cmRet || command->type() == cmIret)
			cur_block = NULL;
	}
}

bool IntelFunction::Init(const CompileContext &ctx)
{
	if (need_compile()) {
		ICommand *command;
		CommandLink *link;
		size_t i, j, k;
		std::vector<ICommand *> entry_command_list;
		std::vector<ICommand *> exclude_command_list;

		// exclude duplicates of exception handlers
		for (i = 0; i < link_list()->count(); i++) {
			link = link_list()->item(i);
			if (link->type() == ltExtSEHHandler || link->type() == ltMemSEHBlock) {
				command = GetCommandByAddress(link->to_address());
				if (command && std::find(entry_command_list.begin(), entry_command_list.end(), command) == entry_command_list.end()) {
					ICommand *tmp = ctx.file->function_list()->GetCommandByAddress(command->address(), true);
					if (tmp && tmp != command)
						entry_command_list.push_back(command);
				}
			}
		}

		for (i = 0; i < entry_command_list.size(); i++) {
			ICommand *entry_command = entry_command_list[i];
			if (!entry_command)
				continue;

			for (j = IndexOf(entry_command); j < count(); j++) {
				command = item(j);

				if (std::find(exclude_command_list.begin(), exclude_command_list.end(), command) != exclude_command_list.end())
					break;

				std::vector<ICommand *>::iterator it = std::find(entry_command_list.begin(), entry_command_list.end(), command);
				if (it != entry_command_list.end())
					*it = NULL;

				exclude_command_list.push_back(command);

				for (k = 0; k < link_list()->count(); k++) {
					link = link_list()->item(k);
					if (link->parent_command() == command && std::find(entry_command_list.begin(), entry_command_list.end(), link->from_command()) == entry_command_list.end())
						entry_command_list.push_back(link->from_command());
				}

				link = command->link();
				if (link && link->to_address()) {
					ICommand *link_command = GetCommandByAddress(link->to_address());
					if (link_command && std::find(entry_command_list.begin(), entry_command_list.end(), link_command) == entry_command_list.end())
						entry_command_list.push_back(link_command);
				}

				if (command->is_data() || command->is_end() || (command->options() & roBreaked) != 0)
					break;
			}
		}

		for (i = 1; i < count(); i++) {
			command = item(i - 1);
			if (!command->is_end() && std::find(exclude_command_list.begin(), exclude_command_list.end(), item(i)) != exclude_command_list.end())
				command->include_option(roBreaked);
		}

		for (i = 0; i < exclude_command_list.size(); i++) {
			command = exclude_command_list[i];
			if (command->link())
				delete command->link();
			delete command;
			if (entry() == command)
				set_entry(NULL);
		}

		for (i = 0; i < function_info_list()->count(); i++) {
			FunctionInfo *info = function_info_list()->item(i);
			if (!info->entry())
				continue;

			if (info->entry()->comment().value == "LPStart Encoding") {
				size_t c = IndexOf(info->entry());
				for (j = c + 1; j < count(); j++) {
					IntelCommand *command = item(j);
					if (!command->is_data() || (command->options() & roCreateNewBlock))
						break;

					if (command->comment().value == "TTable Offset") {
						command->CompileToNative();
						if (command->link())
							command->link()->set_sub_value(command->link()->sub_value() + command->dump_size() - command->original_dump_size());
					} else if (command->comment().value == "Call Site Encoding" && command->dump_size() == 1 && command->dump(0) == DW_EH_PE_uleb128) {
						uint8_t call_size_encoding = DW_EH_PE_udata4;
						command->set_dump(&call_size_encoding, sizeof(call_size_encoding));

						IntelCommand *call_site_entry = item(j + 1);
						size_t call_site_length = static_cast<uint32_t>(call_site_entry->operand(0).value);
						size_t new_call_site_length = 0;
						for (k = j + 2; k < count(); k++) {
							command = item(k);
							call_site_length -= command->dump_size();
							if (command->comment().value != "Action") {
								command->Init(cmDD, IntelOperand(command->operand(0)));
								command->CompileToNative();
							}
							new_call_site_length += command->dump_size();
							if (!call_site_length)
								break;
						}
						call_site_entry->set_operand_value(0, new_call_site_length);
						call_site_entry->CompileToNative();
						break;
					}
				}
			}
		}
	}

	return BaseFunction::Init(ctx);
}

bool IntelFunction::Prepare(const CompileContext &ctx)
{
	IArchitecture *file = from_runtime() ? ctx.runtime : ctx.file;
	if (type() == otString) {
		MapFunction *map_function = file->map_function_list()->GetFunctionByAddress(address());
		if (map_function) {
			for (size_t i = 0; i < count(); i++) {
				IntelCommand *command = item(i);
				command->exclude_option(roClearOriginalCode);

				if (command->address()) {
					uint64_t end_address = command->address() + command->original_dump_size();
					for (size_t j = 0; j < map_function->reference_list()->count(); j++) {
						Reference *reference = map_function->reference_list()->item(j);
						if (reference->tag() != 1)
							continue;

						if (command->address() <= reference->operand_address() && end_address > reference->operand_address())
							end_address = reference->operand_address();
					}
					if (end_address > command->address())
						ctx.manager->Add(command->address(), static_cast<size_t>(end_address - command->address()), file->segment_list()->GetMemoryTypeByAddress(command->address()));
				}
			}
		}
	} else if (address() && count() > 0) {
		for (size_t i = 0; i < count(); i++) {
			IntelCommand *command = item(i);
			if (command->options() & roInvalidOpcode) {
				ctx.file->Notify(mtError, command, string_format(language[lsCommandNotSupported].c_str(), command->text().c_str()));
				return false;
			}

			uint64_t next_address = command->address() + command->original_dump_size();
			if (command->type() == cmCall && (command->options() & roFar) == 0 && command->operand(0).type == otValue && command->operand(0).value != next_address) {
				CompilerFunction *compiler_function = file->compiler_function_list()->GetFunctionByAddress(next_address);
				if (compiler_function && compiler_function->type() == cfBaseRegistr) {
					delete command->link();
					IntelOperand operand;
					operand.decode(compiler_function->value(0));
					command->Init(cmLea, operand, IntelOperand(otMemory | otValue, operand.size, 0, next_address, (cpu_address_size() == osDWord) ? NEED_FIXUP : LARGE_VALUE));
					command->CompileToNative();
				}
			}
			if (!command->is_data() && ((command->options() & roBreaked) || is_breaked_address(next_address))) {
				// need add JMP after breaked commands
				IntelCommand *jmp_command = new IntelCommand(this, cpu_address_size(), cmJmp, IntelOperand(otValue, cpu_address_size(), 0, next_address));
				jmp_command->AddLink(0, ltJmp, next_address);
				jmp_command->set_address_range(function_info_list()->GetRangeByAddress(next_address));
				jmp_command->CompileToNative();
				InsertObject(i + 1, jmp_command);
			}
			if (is_breaked_address(next_address))
				break;
		}

		if (ctx.runtime && compilation_type() != ctMutation && address() && entry_type() != etNone) {
			size_t i, c;
			IntelCommand *command, *jmp_command, *loop_command, *antitrace_command;
			ICommand *loader_data_command = NULL;
			uint64_t loader_data_address = 0;

			IntelLoaderData *loader_data = reinterpret_cast<IntelFunctionList*>(ctx.file->function_list())->loader_data();
			if (loader_data) {
				loader_data_command = loader_data->entry();
			} else {
				loader_data_address = ctx.runtime->export_list()->GetAddressByType(atLoaderData);
				if (!loader_data_address)
					return false;
			}

			c = count();
			AddCommand(cmPushf);
			AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEAX));
			AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regECX));
			AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEBX));
			AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEDX));

			// anti trace
			antitrace_command = NULL;
			if (ctx.runtime && (ctx.options.flags & cpCheckDebugger)) {
				Data data;
				data.PushByte(0xf3); // rep
				data.PushByte(0xf3); // rep
				data.PushByte(0xf3); // rep
				data.PushByte(0xf3); // rep
				data.PushByte(0xf3); // rep
				data.PushByte(0x9c); // pushf
				command = AddCommand(data);
				command->AddLink(-1, ltNative);
				AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEAX));
				AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, fl_T));
				antitrace_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
				antitrace_command->set_flags(fl_Z);
				antitrace_command->include_option(roInverseFlag);
				antitrace_command->AddLink(0, ltJmpWithFlag);
			}

			// add CPU hash check
			AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, 1));
			command = AddCommand(cmCpuid);
			command->include_option(roNoNative);

			// Athlon bug
			AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regEAX));
			AddCommand(cmAnd, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otValue, osDWord, 0, 0xff0));
			AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otValue, osDWord, 0, 0xfe0));
			jmp_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
			jmp_command->set_flags(fl_Z);
			jmp_command->include_option(roInverseFlag);
			jmp_command->AddLink(0, ltJmpWithFlag);
			AddCommand(cmXor, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, 0x20));
			command = AddCommand(cmNop);
			jmp_command->link()->set_to_command(command);

			AddCommand(cmAnd, IntelOperand(otRegistr, osDWord, regEBX), IntelOperand(otValue, osDWord, 0, 0x00ffffff));
			AddCommand(cmAdd, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otRegistr, osDWord, regEBX));
			if (ctx.file->owner()->format_name() == "PE") {
				PEArchitecture *pe = reinterpret_cast<PEArchitecture *>(ctx.file);
				if (pe->image_type() != itDriver) {
					size_t osbuild_offset;
					if (cpu_address_size() == osDWord) {
						command = AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEBX), IntelOperand(otMemory | otValue, cpu_address_size(), 0, 0x30));
						command->set_base_segment(segFS);
						osbuild_offset = offsetof(PEB32, OSBuildNumber);
					} else {
						command = AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEBX), IntelOperand(otMemory | otValue, cpu_address_size(), 0, 0x60));
						command->set_base_segment(segGS);
						osbuild_offset = offsetof(PEB64, OSBuildNumber);
					}
					AddCommand(cmMovzx, IntelOperand(otRegistr, osDWord, regEBX), IntelOperand(otMemory | otRegistr | otValue, osWord, regEBX, osbuild_offset));
					AddCommand(cmShl, IntelOperand(otRegistr, osDWord, regEBX), IntelOperand(otValue, osWord, 0, 7));
					AddCommand(cmAdd, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otRegistr, osDWord, regEBX));
				}
			}
			command = AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEDX), IntelOperand(otMemory | otValue, cpu_address_size(), 0, loader_data_address, NEED_FIXUP));
			command->AddLink(1, ltOffset, loader_data_command);
			AddCommand(cmXor, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otRegistr, osDWord, regEDX));
			AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otRegistr | otValue, osDWord, regEDX, ctx.runtime_var_index[VAR_CPU_COUNT] * OperandSizeToValue(cpu_address_size())));
			AddCommand(cmXor, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otValue, osDWord, 0, ctx.runtime_var_salt[VAR_CPU_COUNT]));
			AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size(), regEDX), IntelOperand(otValue, cpu_address_size(), 0, ctx.runtime_var_index[VAR_CPU_HASH] * OperandSizeToValue(cpu_address_size())));

			command = AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regEBX), IntelOperand(otMemory | otRegistr, osDWord, regEDX, 0));
			AddCommand(cmXor, IntelOperand(otRegistr, osDWord, regEBX), IntelOperand(otValue, osDWord, 0, ctx.runtime_var_salt[VAR_CPU_HASH]));
			AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otRegistr, osDWord, regEBX));

			jmp_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
			jmp_command->set_flags(fl_Z);
			jmp_command->AddLink(0, ltJmpWithFlag);

			AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size(), regEDX), IntelOperand(otValue, cpu_address_size(), 0, OperandSizeToValue(cpu_address_size())));
			AddCommand(cmDec, IntelOperand(otRegistr, osDWord, regECX));
			loop_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
			loop_command->set_flags(fl_Z);
			loop_command->include_option(roInverseFlag);
			loop_command->AddLink(0, ltJmpWithFlag, command);

			command = AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEDX));
			if (antitrace_command)
				antitrace_command->link()->set_to_command(command);
			AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEBX));
			AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regECX));
			AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEAX));
			AddCommand(cmPopf);
			AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, 0xdeadc0de));
			AddCommand(cmPush, IntelOperand(otValue, cpu_address_size(), 0, 0));
			AddCommand(cmRet);

			command = AddCommand(cmNop);
			jmp_command->link()->set_to_command(command);
			AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEDX));
			AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEBX));
			AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regECX));
			AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEAX));
			AddCommand(cmPopf);
			command = AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size(), 0, address()));
			command->AddLink(0, ltJmp, address());

			for (i = c; i < count(); i++) {
				command = item(i);
				command->CompileToNative();
			}

			set_entry(item(c));
		}
	}

	return BaseFunction::Prepare(ctx);
}

bool IntelFunction::PrepareExtCommands(const CompileContext &ctx)
{
	size_t i;
	MemoryManager &manager = *ctx.manager;

	ExtCommandList *ext_list = ext_command_list();
	if (type() != otString) {
		if (address() && !entry()) {
			ctx.file->Notify(mtError, (count()) ? item(0) : NULL, "There are no data for compilation");
			return false;
		}
		if (entry() && entry_type() != etNone)
			ext_list->Add((entry_type() == etDefault) ? address() : 0, entry());
	}

	ext_list->Sort();
	for (i = ext_list->count(); i > 0; i--) {
		ExtCommand *ext_command = ext_list->item(i - 1);
		if (!ext_command->command() || is_breaked_address(ext_command->address()))
			continue;

		if (ext_command->address()) {
			if (!manager.Alloc(5, mtNone, ext_command->address())) {
				ctx.file->Notify(mtError, ext_command->command(), ext_command->address() == address() ? language[lsMinimalFunctionSize] : language[lsNotEnoughPlace]);
				return false;
			}
		}
		ext_command->command()->include_section_option(rtLinkedToExt);
	}

	return true;
}

void IntelFunction::GetFreeRegisters(size_t index, CommandInfoList &free_registr_list) const
{
	CommandInfoList used_registr_list;
	IntelCommandInfoList command_info_list(cpu_address_size());

	uint16_t free_flags = 0;
	bool free_flags_extracted = false;
	free_registr_list.clear();
	for (size_t i = index; i < count(); i++) {
		IntelCommand *command = item(i);

		bool is_end;
		if (command->GetCommandInfo(command_info_list)) {
			if (!free_flags_extracted) {
				if (command_info_list.change_flags()) {
					free_flags = command_info_list.change_flags();
					free_flags_extracted = true;
				}
				if (command_info_list.need_flags()) {
					free_flags &= ~command_info_list.need_flags();
					free_flags_extracted = true;
				}
			}

			for (size_t j = 0; j < command_info_list.count(); j++) {
				CommandInfo *command_info = command_info_list.item(j);
				if ((command_info->operand_type() == otRegistr || command_info->operand_type() == otHiPartRegistr) && command_info->value() != regESP && command_info->value() != regEIP) {
					OperandSize reg_size = command_info->size();
					if (command_info->operand_type() == otHiPartRegistr)
						reg_size = (reg_size == osByte) ? osWord : osQWord;
					uint8_t reg = command_info->value();

					if (command_info->type() == atRead) {
						used_registr_list.Add(atRead, reg, otRegistr, reg_size);
					} else if (!used_registr_list.GetInfo(atRead, otRegistr, reg) && (command_info->operand_type() != otHiPartRegistr || free_registr_list.GetInfo(atWrite, otRegistr, reg))) {
						free_registr_list.Add(atWrite, reg, otRegistr, reg_size);
					}
				}
			}
			is_end = command_info_list.GetInfo(atWrite, otBaseRegistr, regEIP) != NULL;
		} else {
			is_end = true;
		}

		if (is_end)
			break;
	}
	free_registr_list.set_change_flags(free_flags);
}

void IntelFunction::Mutate(const CompileContext &ctx, bool for_virtualization)
{
	#define osRandom (OperandSize)0x80
	#define osRandomStartWord (OperandSize)0x81

	enum {
		regFree = 0xf,
		flRandom = 0xff
	};

	size_t i, j, insert_count;
	IntelCommand *command, *new_command;

	std::vector<IntelCommand *> template_command_list;
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmMov, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmMov, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmMovsx, IntelOperand(otRegistr, osWord, regFree), IntelOperand(otRegistr, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmMovsx, IntelOperand(otRegistr, osDWord, regFree), IntelOperand(otRegistr, osWord)));
	if (cpu_address_size() == osQWord) {
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmMovsx, IntelOperand(otRegistr, osQWord, regFree), IntelOperand(otRegistr, osWord)));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmMovsxd, IntelOperand(otRegistr, osQWord, regFree), IntelOperand(otRegistr, osDWord)));
	}
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmMovzx, IntelOperand(otRegistr, osWord, regFree), IntelOperand(otRegistr, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmMovzx, IntelOperand(otRegistr, osDWord, regFree), IntelOperand(otRegistr, osWord)));
	if (cpu_address_size() == osQWord)
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmMovzx, IntelOperand(otRegistr, osQWord, regFree), IntelOperand(otRegistr, osWord)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmNot, IntelOperand(otRegistr, osRandom, regFree)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmNeg, IntelOperand(otRegistr, osRandom, regFree)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmInc, IntelOperand(otRegistr, osRandom, regFree)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmDec, IntelOperand(otRegistr, osRandom, regFree)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmCmp, IntelOperand(otRegistr, osRandom), IntelOperand(otRegistr, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmCmp, IntelOperand(otRegistr, osRandom), IntelOperand(otValue, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmTest, IntelOperand(otRegistr, osRandom), IntelOperand(otRegistr, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmTest, IntelOperand(otRegistr, osRandom), IntelOperand(otValue, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmAnd, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmAnd, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmOr, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmOr, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmXor, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmXor, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmAdd, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmAdd, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmAdc, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmAdc, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmSub, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmSub, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmShl, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osByte, regECX)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmShl, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmShr, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osByte, regECX)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmShr, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmSal, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osByte, regECX)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmSal, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmSar, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osByte, regECX)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmSar, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmRol, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osByte, regECX)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmRol, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmRor, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osByte, regECX)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmRor, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmShrd, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otRegistr, osRandomStartWord), IntelOperand(otRegistr, osByte, regECX)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmShrd, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otRegistr, osRandomStartWord), IntelOperand(otValue, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmShld, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otRegistr, osRandomStartWord), IntelOperand(otRegistr, osByte, regECX)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmShld, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otRegistr, osRandomStartWord), IntelOperand(otValue, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmBt, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otRegistr, osRandomStartWord)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmBt, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otValue, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmBtc, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otRegistr, osRandomStartWord)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmBtc, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otValue, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmBtr, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otRegistr, osRandomStartWord)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmBtr, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otValue, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmBts, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otRegistr, osRandomStartWord)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmBts, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otRegistr, osRandomStartWord)));

	command = new IntelCommand(this, cpu_address_size(), cmSetXX, IntelOperand(otRegistr, osByte, regFree));
	command->set_flags(flRandom);
	template_command_list.push_back(command);

	command = new IntelCommand(this, cpu_address_size(), cmCmov, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otRegistr, osRandomStartWord));
	command->set_flags(flRandom);
	template_command_list.push_back(command);

	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmClc));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmStc));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmCmc));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmCbw));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmCwde));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmCwd));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmCdq));
	if (cpu_address_size() == osQWord) {
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmCdqe));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmCqo));
	}
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmLahf));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmBswap, IntelOperand(otRegistr, osRandomStartWord, regFree)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmXchg, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osRandom, regFree)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmXadd, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osRandom, regFree)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmJmp, IntelOperand(otValue, cpu_address_size())));

	// FIXME
	/*
	command = new IntelCommand(this, cpu_address_size(), cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
	command->set_flags(flRandom);
	template_command_list.push_back(command);
	*/

	if (for_virtualization) {
		/*
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmJCXZ, IntelOperand(otValue, cpu_address_size())));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmLoop, IntelOperand(otValue, cpu_address_size())));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmLoope, IntelOperand(otValue, cpu_address_size())));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmLoopne, IntelOperand(otValue, cpu_address_size())));
		*/
	} else {
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmSbb, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osRandom)));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmSbb, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osRandom)));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmRcl, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osByte, regECX)));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmRcl, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osByte)));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmRcr, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osByte, regECX)));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmRcr, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osByte)));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmBsr, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otRegistr, osRandomStartWord)));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmBsf, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otRegistr, osRandomStartWord)));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmRdtsc));
	}

	size_t link_count = link_list()->count();

	for (i = 0; i < count(); i++) {
		command = item(i);

		switch (command->type()) {
		case cmJmp:
		case cmJmpWithFlag:
			if (command->dump_size() < 5)
				command->CompileToNative();
			break;
		case cmJCXZ:
		case cmLoop:
		case cmLoope:
		case cmLoopne:
			if (!for_virtualization) {
				uint64_t next_address = command->next_address();
				uint64_t to_address = command->link()->to_address();
				AddressRange *address_range = command->address_range();

				new_command = new IntelCommand(this, cpu_address_size(), cmJmp, IntelOperand(otValue, cpu_address_size(), 0, 0));
				new_command->include_option(roNoProgress);
				new_command->AddLink(0, ltJmp, command);
				new_command->CompileToNative();
				new_command->set_address_range(address_range);
				InsertObject(i++, new_command);

				CommandBlock *block = AddBlock(i++, true);
				block->set_end_index(block->start_index() + 2);
				command->set_block(block);

				new_command = new IntelCommand(this, cpu_address_size(), cmJmp, IntelOperand(otValue, cpu_address_size(), 0, next_address));
				new_command->include_option(roNoProgress);
				new_command->AddLink(0, ltJmp, item(i));
				new_command->CompileToNative();
				new_command->set_address_range(address_range);
				new_command->set_block(block);
				InsertObject(i++, new_command);

				new_command = new IntelCommand(this, cpu_address_size(), cmJmp, IntelOperand(otValue, cpu_address_size(), 0, to_address));
				new_command->include_option(roNoProgress);
				new_command->AddLink(0, ltJmp, to_address);
				new_command->CompileToNative();
				new_command->set_address_range(address_range);
				new_command->set_block(block);
				InsertObject(i++, new_command);
				if (command->link()) {
					if (command->link()->to_command()) {
						new_command->link()->set_to_command(command->link()->to_command());
						command->link()->set_to_command(new_command);
					}
				}
			}
			break;
		case cmCall:
			if ((command->options() & roFar) == 0 && command->operand(0).type == otValue && command->operand(0).value == command->next_address()) {
				if (cpu_address_size() == osDWord) {
					command->Init(cmPush, IntelOperand(otValue, cpu_address_size(), 0, command->next_address(), NEED_FIXUP));
					command->CompileToNative();
					if (command->link()) {
						delete command->link();
						link_count--;
					}
				} else {
					uint64_t next_address = command->next_address();
					AddressRange *address_range = command->address_range();

					command->Init(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEAX));
					command->CompileToNative();
					if (command->link()) {
						delete command->link();
						link_count--;
					}

					command = new IntelCommand(this, cpu_address_size(), cmLea, IntelOperand(otRegistr, cpu_address_size(), regEAX), IntelOperand(otMemory | otValue, cpu_address_size(), 0, next_address, LARGE_VALUE));
					command->include_option(roNoProgress);
					command->CompileToNative();
					command->set_address_range(address_range);
					InsertObject(i++, command);

					command = new IntelCommand(this, cpu_address_size(), cmXchg, IntelOperand(otMemory | otRegistr, cpu_address_size(), regESP), IntelOperand(otRegistr, cpu_address_size(), regEAX));
					command->include_option(roNoProgress);
					command->CompileToNative();
					command->set_address_range(address_range);
					InsertObject(i++, command);
				}
			}
			break;
		case cmDC:
			command->CompileToNative();
			break;
		}
	}

	IntelCommandInfoList command_info_list(cpu_address_size());
	CommandInfoList free_registr_list;
	std::vector<IntelCommand *> garbage_command_list;
	insert_count = 0;

	std::list<ICommand *> new_command_list;
	for (i = 0; i < count(); i++) {
		command = item(i);
		new_command_list.push_back(command);

		if ((command->options() & roNoProgress) == 0)
			ctx.file->StepProgress();

		if (is_breaked_address(command->address()))
			continue;

		AddressRange *address_range = command->address_range();
		uint32_t src_options = command->options();

		if (command->block()) {
			CommandBlock *block = command->block();
			for (j = block->start_index() + 1; j <= block->end_index(); j++) {
				new_command_list.push_back(item(j));
			}
			i = block->end_index();
			if (insert_count) {
				block->set_start_index(block->start_index() + insert_count);
				block->set_end_index(block->end_index() + insert_count);
			}
			ctx.file->StepProgress(block->end_index() - block->start_index());
			continue;
		} else if ((command->options() & roNeedCompile) == 0)
			continue;

		bool is_end;
		if (command->GetCommandInfo(command_info_list)) {
			GetFreeRegisters(i + 1, free_registr_list);
			// mutate command
			switch (command->type()) {
			case cmXor:
				if (command->operand(0).type == otRegistr && command->operand(1).type == otRegistr && command->operand(0).registr == command->operand(1).registr && (rand() & 1)) {
					// xor reg, reg -> sub reg, reg
					command->Init(cmSub, command->operand(0), command->operand(1));
					command->CompileToNative();
				}
				break;

			case cmCall:
				if ((command->options() & roFar) == 0 && (rand() & 1)) {
				}
				break;

			case cmAdd:
				if (command->operand(0).type == otRegistr && command->operand(0).size == cpu_address_size() 
					&& ((command->operand(1).type == otRegistr && command->operand(1).registr != regESP) || (command->operand(1).type == otValue && cpu_address_size() != osQWord)) 
					&& (rand() & 1)) {
					if ((command_info_list.change_flags() & free_registr_list.change_flags()) == command_info_list.change_flags()) {
						// add reg, xxxx -> lea reg, [reg + xxxx]
						IntelOperand second_operand = command->operand(1);
						second_operand.type |= otMemory;
						if ((second_operand.type & otValue) && (command->operand(0).registr != regESP)) {
							second_operand.type |= otRegistr;
							second_operand.registr = command->operand(0).registr;
						} else {
							second_operand.type |= otBaseRegistr;
							second_operand.base_registr = command->operand(0).registr;
							if ((second_operand.base_registr & 7) == regEBP) {
								second_operand.type |= otValue;
								second_operand.value_size = osByte;
								second_operand.value = 0;
							}
						}

						command->Init(cmLea, command->operand(0), second_operand);
						command->CompileToNative();
					}
				}
				break;

			case cmSub:
				if (command->operand(0).type == otRegistr && command->operand(0).size == cpu_address_size() 
					&& (command->operand(1).type == otValue && cpu_address_size() != osQWord)
					&& (rand() & 1)) {
					if ((command_info_list.change_flags() & free_registr_list.change_flags()) == command_info_list.change_flags()) {
						// sub reg, xxxx -> lea reg, [reg - xxxx]
						IntelOperand second_operand = command->operand(1);
						second_operand.type |= otMemory;
						if (command->operand(0).registr != regESP) {
							second_operand.type |= otRegistr;
							second_operand.registr = command->operand(0).registr;
						} else {
							second_operand.type |= otBaseRegistr;
							second_operand.base_registr = command->operand(0).registr;
						}
						second_operand.value = 0 - second_operand.value;

						command->Init(cmLea, command->operand(0), second_operand);
						command->CompileToNative();
					}
				}
				break;

			case cmJmp:
				if (!for_virtualization && (command->options() & roFar) == 0 && command->operand(0).type != otValue && (rand() & 1)) {
					// jmp xxxx -> push xxxx, ret
					command->Init(cmPush, command->operand(0));
					command->CompileToNative();

					command = new IntelCommand(this, cpu_address_size(), cmRet);
					command->include_option(roNoProgress);
					command->CompileToNative();
					command->set_address_range(address_range);

					new_command_list.push_back(command);
					insert_count++;
				}
				break;
			}
			is_end = command_info_list.GetInfo(atWrite, otBaseRegistr, regEIP) != NULL;
		} else {
			is_end = true;
		}

		if (!is_end) {
			// add garbage code
			garbage_command_list.clear();
			for (j = 0; j < template_command_list.size(); j++) {
				command = template_command_list[j];
				if (!command->GetCommandInfo(command_info_list))
					continue;

				bool is_ok = true;
				for (size_t k = 0; k < command_info_list.count() && is_ok; k++) {
					CommandInfo *command_info = command_info_list.item(k);
					if (command_info->type() == atWrite && (command_info->operand_type() == otRegistr || command_info->operand_type() == otHiPartRegistr)) {
						if (command_info->value() == regFree) {
							if (!free_registr_list.count())
								is_ok = false;
						} else if (command_info->value() == regEFX) {
							if ((command_info_list.change_flags() & free_registr_list.change_flags()) != command_info_list.change_flags())
								is_ok = false;
						} else {
							OperandSize registr_size;
							if (command_info->operand_type() == otHiPartRegistr) {
								switch (command_info->size()) {
								case osByte:
									registr_size = osWord;
									break;
								case osWord:
									registr_size = osDWord;
									break;
								default:
									registr_size = osQWord;
									break;
								}
							} else {
								registr_size = command_info->size();
							}

							CommandInfo *free_registr = free_registr_list.GetInfo(atWrite, otRegistr, command_info->value());
							if (!free_registr || free_registr->size() < registr_size)
								is_ok = false;
						}
					}
				}
				if (is_ok)
					garbage_command_list.push_back(command);
			}

			size_t c = rand() % 4;
			for (size_t m = 0; m < c && !garbage_command_list.empty(); m++) {
				j = rand() % garbage_command_list.size();
				command = garbage_command_list[j];
				garbage_command_list.erase(garbage_command_list.begin() + j);

				IntelOperand operand[3];
				uint8_t registr[3];
				OperandSize min_size = osByte;
				OperandSize max_size = cpu_address_size();
				bool is_ok = true;
				uint8_t max_registr = 0;
				for (size_t k = 0; k < _countof(operand) && is_ok; k++) {
					IntelOperand tmp = command->operand(k);
					if (tmp.type == otNone)
						continue;

					if (tmp.size == osRandomStartWord && min_size < osWord)
						min_size = osWord;

					if (tmp.type == otRegistr) {
						if (tmp.registr == regFree) {
							if (free_registr_list.count()) {
								CommandInfo *free_registr = free_registr_list.item(rand() % free_registr_list.count());
								registr[k] = free_registr->value();
								if (max_size > free_registr->size())
									max_size = free_registr->size();
							} else {
								is_ok = false;
								break;
							}
						} else if (tmp.registr == 0) {
							registr[k] = rand() % ((cpu_address_size() == osDWord) ? 8 : 16);
						} else {
							registr[k] = tmp.registr;
						}
						if (max_registr < registr[k])
							max_registr = registr[k];
						if (cpu_address_size() == osDWord && registr[k] > 3 && min_size < osWord)
							min_size = osWord;
						if (tmp.size & osRandom) {
							if (min_size > max_size)
								is_ok = false;
						} else if (tmp.size < min_size || tmp.size > max_size)
							is_ok = false;
					}
				}

				if (is_ok) {
					OperandSize random_size = min_size;
					for (int size = min_size; size <= max_size; size++) {
						random_size = static_cast<OperandSize>(size);
						if (rand() & 1)
							break;
					}

					for (size_t k = 0; k < _countof(operand) && is_ok; k++) {
						IntelOperand tmp = command->operand(k);
						if (tmp.size & osRandom)
							tmp.size = random_size;
						if (tmp.type == otRegistr) {
							if (tmp.size == osByte && (tmp.registr == regFree || tmp.registr == 0) && max_size > osByte && max_registr < 4 && (rand() & 1))
								tmp.type = otHiPartRegistr;
							tmp.registr = registr[k];
						} else if (tmp.type == otValue) {
							switch (tmp.size) {
							case osByte:
								tmp.value = ByteToInt64(rand32() & 0xff);
								tmp.value_size = osByte;
								break;
							case osWord:
								tmp.value = WordToInt64(rand32() & 0xffff);
								tmp.value_size = osWord;
								break;
							default:
								tmp.value = DWordToInt64(rand32());
								tmp.value_size = osDWord;
								break;
							}
						}
						operand[k] = tmp;
					}
					uint16_t flags = command->flags();
					uint32_t options = command->options();
					command = new IntelCommand(this, cpu_address_size(), static_cast<IntelCommandType>(command->type()), operand[0], operand[1], operand[2]);
					if (flags) {
						if (flags == flRandom) {
							switch (rand() % 8) {
							case 0: flags = fl_O; break;
							case 1: flags = fl_C; break;
							case 2: flags = fl_Z; break;
							case 3: flags = fl_C | fl_Z; break;
							case 4: flags = fl_S; break;
							case 5: flags = fl_P; break;
							case 6: flags = fl_S | fl_O; break;
							default: flags = fl_Z | fl_S | fl_O; break;
							}
							if (rand() & 1)
								options |= roInverseFlag;
						}
						command->set_flags(flags);
						if (options & roInverseFlag)
							command->include_option(roInverseFlag);
					}
					command->include_option(roNoProgress);
					if (src_options & roNeedCRC)
						command->include_option(roNeedCRC);
					command->CompileToNative();
					command->set_address_range(address_range);
					new_command_list.push_back(command);
					insert_count++;

					switch (command->type()) {
					case cmJmpWithFlag:
						// FIXME
						/*
						command->AddLink(0, ltJmpWithFlag, item(i + 1));
						*/
						break;
					case cmJmp:
						command->AddLink(0, ltJmp, item(i + 1));
						break;
					}
				}
			}
		}
	}

	for (i = link_count; i < link_list()->count(); i++) {
		link_list()->item(i)->from_command()->PrepareLink(ctx);
	}

	for (i = 0; i < template_command_list.size(); i++) {
		delete template_command_list[i];
	}

	assign(new_command_list);
}

void IntelFunction::CompileToNative(const CompileContext &ctx)
{
	size_t i, j;
	size_t c = link_list()->count();
	for (i = 0; i < c; i++) {
		CommandLink *link = link_list()->item(i);
		IntelCommand *to_command = reinterpret_cast<IntelCommand *>(link->to_command());
		if (!to_command)
			continue;

		switch (link->type()) {
		case ltDualSEHBlock:
			{
				CommandBlock *block = AddBlock(count(), true);
				size_t k = IndexOf(to_command);
				IntelCommand *next_command = item(k + 1);
				IntelCommand *src_command = to_command;
				IntelCommand *dst_command = src_command->Clone(this);
				AddObject(dst_command);
				CommandLink *src_link = src_command->link();
				if (src_link) {
					CommandLink *dst_link = src_link->Clone(link_list());
					dst_link->set_from_command(dst_command);
					dst_link->set_to_command(src_link->to_command());
					link_list()->AddObject(dst_link);
				}
				IntelCommand *command = new IntelCommand(this, cpu_address_size(), cmJmp, IntelOperand(otValue, cpu_address_size(), 0, to_command->next_address()));
				AddObject(command);
				command->AddLink(0, ltJmp, next_command);

				for (size_t j = block->start_index(); j < count(); j++) {
					IntelCommand *command = item(j);
					command->set_block(block);
					command->CompileToNative();
				}
				block->set_end_index(count() - 1);

				link->set_to_command(item(block->start_index()));
			}
			break;
		case ltFilterSEHBlock:
			{
				CommandBlock *block = AddBlock(count(), true);
				size_t k = IndexOf(to_command);
				IntelCommand *next_command = item(k + 1);
				size_t n = static_cast<size_t>(next_command->operand(0).value * 2 + 2);
				for (j = 0; j < n; j++) {
					IntelCommand *src_command = item(k + j);
					IntelCommand *dst_command = src_command->Clone(this);
					AddObject(dst_command);
					CommandLink *src_link = src_command->link();
					if (src_link) {
						CommandLink *dst_link = src_link->Clone(link_list());
						dst_link->set_from_command(dst_command);
						dst_link->set_to_command(src_link->to_command());
						link_list()->AddObject(dst_link);
					}
				}

				for (size_t j = block->start_index(); j < count(); j++) {
					IntelCommand *command = item(j);
					command->set_block(block);
					command->CompileToNative();
				}
				block->set_end_index(count() - 1);

				link->set_to_command(item(block->start_index()));
			}
			break;
		}
	}

	Mutate(ctx, false);

	CreateBlocks();
	for (i = 0; i < ext_command_list()->count(); i++) {
		ExtCommand *ext_command = ext_command_list()->item(i);
		if (!ext_command->command() || is_breaked_address(ext_command->address()))
			continue;

		CommandBlock *block = AddBlock(count(), true);
		block->set_address(ext_command->address());

		IntelCommand *command = AddCommand(ext_command->use_call() ? cmCall : cmJmp, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltJmp, ext_command->command());
		command->CompileToNative();
		command->set_block(block);
	}
}

/**
* IntelStackValue
*/

IntelStackValue::IntelStackValue(IntelStack *owner, ValueType type, uint64_t value)
	: IObject(), owner_(owner), type_(type), value_(value), is_modified_(false)
{

}

IntelStackValue::~IntelStackValue()
{
	if (owner_)
		owner_->RemoveObject(this);
}

void IntelStackValue::Calc(IntelCommandType command_type, uint16_t command_flags, bool inverse_flags, OperandSize size, uint64_t op2, IntelFlagsValue *flags)
{
	if (type_ != vtValue)
		throw std::runtime_error("Runtime error at Calc");

	uint64_t op1 = value_;
	uint64_t result;
	switch (command_type) {
	case cmAdd:
		result = op1 + op2;
		break;
	case cmAdc:
		result = op1 + op2 + ((flags->value() & fl_C) ? 1 : 0);
		break;
	case cmCmp:
	case cmSub:
		result = op1 - op2;
		break;
	case cmSbb:
		result = op1 - op2 - ((flags->value() & fl_C) ? 1 : 0);
		break;
	case cmTest:
	case cmAnd:
		result = op1 & op2;
		break;
	case cmOr:
		result = op1 | op2;
		break;
	case cmXor:
		result = op1 ^ op2;
		break;
	case cmSetXX:
		result = flags->Check(command_flags) ? 1 : 0;
		if (inverse_flags)
			result = result ? 0 : 1;
		break;
	case cmCmov:
		if (flags->Check(command_flags) != (inverse_flags == false))
			return;

		result = op2;
		break;
	case cmShr:
		op2 &= (size == osQWord) ? 0x3f : 0x1f;
		if (!op2)
			return;

		switch (size) {
		case osByte:
			result = static_cast<uint8_t>(op1) >> op2;
			break;
		case osWord:
			result = static_cast<uint16_t>(op1) >> op2;
			break;
		case osDWord:
			result = static_cast<uint32_t>(op1) >> op2;
			break;
		default:
			result = op1 >> op2;
			break;
		}
		break;
	case cmSar:
		op2 &= (size == osQWord) ? 0x3f : 0x1f;
		if (!op2)
			return;

		switch (size) {
		case osByte:
			result = static_cast<int8_t>(op1) >> op2;
			break;
		case osWord:
			result = static_cast<int16_t>(op1) >> op2;
			break;
		case osDWord:
			result = static_cast<int32_t>(op1) >> op2;
			break;
		default:
			result = static_cast<int64_t>(op1) >> op2;
			break;
		}
		break;
	case cmShl:
	case cmSal:
		op2 &= (size == osQWord) ? 0x3f : 0x1f;
		if (!op2)
			return;

		switch (size) {
		case osByte:
			result = static_cast<uint8_t>(op1) << op2;
			break;
		case osWord:
			result = static_cast<uint16_t>(op1) << op2;
			break;
		case osDWord:
			result = static_cast<uint32_t>(op1) << op2;
			break;
		default:
			result = op1 << op2;
			break;
		}
		break;
	case cmRol:
		op2 &= (size == osQWord) ? 0x3f : 0x1f;
		if (!op2)
			return;

		switch (size) {
		case osByte:
			result = _rotl8(static_cast<uint8_t>(op1), static_cast<uint8_t>(op2));
			break;
		case osWord:
			result = _rotl16(static_cast<uint16_t>(op1), static_cast<uint8_t>(op2));
			break;
		case osDWord:
			result = _rotl32(static_cast<uint32_t>(op1), static_cast<uint8_t>(op2));
			break;
		default:
			result = _rotl64(op1, static_cast<uint8_t>(op2));
			break;
		}
		break;
	case cmRor:
		op2 &= (size == osQWord) ? 0x3f : 0x1f;
		if (!op2)
			return;

		switch (size) {
		case osByte:
			result = _rotr8(static_cast<uint8_t>(op1), static_cast<uint8_t>(op2));
			break;
		case osWord:
			result = _rotr16(static_cast<uint16_t>(op1), static_cast<uint8_t>(op2));
			break;
		case osDWord:
			result = _rotr32(static_cast<uint32_t>(op1), static_cast<uint8_t>(op2));
			break;
		default:
			result = _rotr64(op1, static_cast<uint8_t>(op2));
			break;
		}
		break;
	case cmMov:
	case cmLea:
	case cmMovsx:
	case cmMovsxd:
	case cmMovzx:
		result = op2;
		break;
	case cmCbw:
		result = static_cast<int64_t>(static_cast<int8_t>(op2));
		break;
	case cmCwde:
		result = static_cast<int64_t>(static_cast<int16_t>(op2));
		break;
	case cmCdqe:
		result = static_cast<int64_t>(static_cast<int32_t>(op2));
		break;
	case cmCwd:
		result = (static_cast<int16_t>(op2) < 0) ? (uint64_t)-1 : 0;
		break;
	case cmCdq:
		result = (static_cast<int32_t>(op2) < 0) ? (uint64_t)-1 : 0;
		break;
	case cmCqo:
		result = (static_cast<int64_t>(op2) < 0) ? (uint64_t)-1 : 0;
		break;
	case cmNot:
		result = ~op1;
		break;
	case cmNeg:
		result = 0 - op1;
		break;
	case cmBt:
		op2 &= (OperandSizeToValue(size) * 8 - 1);
		result = op1;
		break;
	case cmBtr:
		op2 &= (OperandSizeToValue(size) * 8 - 1);
		result = op1 & ~((uint64_t)1 << op2);
		break;
	case cmBtc:
		op2 &= (OperandSizeToValue(size) * 8 - 1);
		result = op1 ^ ((uint64_t)1 << op2);
		break;
	case cmBts:
		op2 &= (OperandSizeToValue(size) * 8 - 1);
		result = op1 | ((uint64_t)1 << op2);
		break;
	case cmBswap:
		switch (size) {
		case osDWord:
			result = __builtin_bswap32(static_cast<uint32_t>(op1));
			break;
		case osQWord:
			result = __builtin_bswap64(op1);
			break;
		default:
			throw std::runtime_error("Runtime error at Calc");
		}
		break;
	default:
		throw std::runtime_error("Runtime error at Calc");
	}

	if (flags)
		flags->Calc(command_type, size, op1, op2, result);

	if (command_type == cmCmp || command_type == cmTest || command_type == cmBt)
		return;

	memcpy(&value_, &result, OperandSizeToValue(size));
}

/**
* IntelFlagsValue
*/

IntelFlagsValue::IntelFlagsValue()
	: IObject(), mask_(0), value_(0)
{

}

uint16_t IntelFlagsValue::GetRandom() const
{
	std::vector<uint16_t> list;

	if (mask_ & fl_Z)
		list.push_back(fl_Z);
	if (mask_ & fl_S)
		list.push_back(fl_S);
	if (mask_ & fl_C)
		list.push_back(fl_C);
	if (mask_ & fl_O)
		list.push_back(fl_O);
	if ((mask_ & (fl_C | fl_Z)) == (fl_C | fl_Z))
		list.push_back(fl_C | fl_Z);
	if ((mask_ & (fl_S | fl_O)) == (fl_S | fl_O))
		list.push_back(fl_S | fl_O);
	if ((mask_ & (fl_Z | fl_S | fl_O)) == (fl_Z | fl_S | fl_O))
		list.push_back(fl_Z | fl_S | fl_O);

	return list.empty() ? 0 : list[rand() % list.size()];
}

bool IntelFlagsValue::Check(uint16_t flags) const
{
	bool s, z, o;

	switch (flags) {
	case (fl_S | fl_O):
		s = (value_ & fl_S) != 0;
		o = (value_ & fl_O) != 0;
		return s != o;
	case (fl_Z | fl_S | fl_O):
		z = (value_ & fl_Z) != 0;
		s = (value_ & fl_S) != 0;
		o = (value_ & fl_O) != 0;
		return z || (s != o);
	default:
		return (value_ & flags) != 0;
	}
}

void IntelFlagsValue::exclude(uint16_t mask)
{
	mask_ &= ~mask;
	value_ &= ~mask;
}

void IntelFlagsValue::Calc(IntelCommandType command_type, OperandSize size, uint64_t op1, uint64_t op2, uint64_t result)
{
	uint64_t tmp;
	uint64_t sign_mask = (uint64_t)1 << (OperandSizeToValue(size) * 8 - 1);
	uint64_t value_mask = sign_mask | (sign_mask - 1);
	uint16_t prev_value = value_;

	switch (command_type) {
	case cmAdd:
	case cmAdc:
		exclude(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		mask_ |= fl_C;
		if (command_type == cmAdc && (prev_value & fl_C)) {
			if ((result & value_mask) <= (op1 & value_mask))
				value_ |= fl_C;
		}
		else {
			if ((result & value_mask) < (op1 & value_mask))
				value_ |= fl_C;
		}

		mask_ |= fl_O;
		if ((~(op1 ^ op2) & (op2 ^ result)) & sign_mask)
			value_ |= fl_O;
		break;
	case cmCmp:
	case cmSub:
	case cmSbb:
		exclude(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		mask_ |= fl_C;
		if (command_type == cmSbb && (prev_value & fl_C)) {
			if ((op1 & value_mask) <= (result & value_mask))
				value_ |= fl_C;
		}
		else {
			if ((op1 & value_mask) < (op2 & value_mask))
				value_ |= fl_C;
		}

		mask_ |= fl_O;
		if (((op1 ^ op2) & (op1 ^ result)) & sign_mask)
			value_ |= fl_O;
		break;
	case cmNeg:
		exclude(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		mask_ |= fl_C;
		if (result & value_mask)
			value_ |= fl_C;

		mask_ |= fl_O;
		if ((result & value_mask) == sign_mask)
			value_ |= fl_O;
		break;
	case cmOr:
	case cmXor:
	case cmAnd:
	case cmTest:
		exclude(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		mask_ |= fl_C;
		mask_ |= fl_O;
		break;
	case cmShr:
		exclude(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		switch (size) {
		case osByte:
			tmp = static_cast<uint8_t>(op1) >> (op2 - 1);
			break;
		case osWord:
			tmp = static_cast<uint16_t>(op1) >> (op2 - 1);
			break;
		case osDWord:
			tmp = static_cast<uint32_t>(op1) >> (op2 - 1);
			break;
		default:
			tmp = op1 >> (op2 - 1);
			break;
		}
		mask_ |= fl_C;
		if (tmp & 1)
			value_ |= fl_C;

		if (op2 == 1) {
			mask_ |= fl_O;
			if (op1 & sign_mask)
				value_ |= fl_O;
		}
		break;

	case cmSar:
		exclude(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		switch (size) {
		case osByte:
			tmp = static_cast<int8_t>(op1) >> (op2 - 1);
			break;
		case osWord:
			tmp = static_cast<int16_t>(op1) >> (op2 - 1);
			break;
		case osDWord:
			tmp = static_cast<int32_t>(op1) >> (op2 - 1);
			break;
		default:
			tmp = op1 >> (op2 - 1);
			break;
		}
		mask_ |= fl_C;
		if (tmp & 1)
			value_ |= fl_C;

		if (op2 == 1)
			mask_ |= fl_O;
		break;

	case cmShl:
	case cmSal:
		exclude(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		switch (size) {
		case osByte:
			tmp = static_cast<uint8_t>(op1) << (op2 - 1);
			break;
		case osWord:
			tmp = static_cast<uint16_t>(op1) << (op2 - 1);
			break;
		case osDWord:
			tmp = static_cast<uint32_t>(op1) << (op2 - 1);
			break;
		default:
			tmp = op1 << (op2 - 1);
			break;
		}
		mask_ |= fl_C;
		if (tmp & sign_mask)
			value_ |= fl_C;

		if (op2 == 1) {
			mask_ |= fl_O;
			if (((result & sign_mask) != 0) != ((value_ & fl_C) != 0))
				value_ |= fl_O;
		}
		break;


	case cmRcl:
	case cmRcr:
		exclude(fl_O | fl_C);

		// TODO
		return;
	case cmRol:
		exclude(fl_O | fl_C);

		mask_ |= fl_C;
		if (result & 1)
			value_ |= fl_C;

		if (op2 == 1) {
			mask_ |= fl_O;
			if (((result & sign_mask) != 0) != ((value_ & fl_C) != 0))
				value_ |= fl_O;
		}
		return;
	case cmRor:
		exclude(fl_O | fl_C);

		mask_ |= fl_C;
		if (result & sign_mask)
			value_ |= fl_C;

		if (op2 == 1) {
			mask_ |= fl_O;
			if (((result & sign_mask) != 0) != (((result << 1) & sign_mask) != 0))
				value_ |= fl_O;
		}
		return;
	case cmStc:
		mask_ |= fl_C;
		value_ |= fl_C;
		return;
	case cmClc:
		mask_ |= fl_C;
		value_ &= ~fl_C;
		return;
	case cmCmc:
		if (mask_ & fl_C)
			value_ ^= fl_C;
		return;
	case cmBt:
	case cmBtr:
	case cmBtc:
	case cmBts:
		exclude(fl_O | fl_S | fl_A | fl_P | fl_C); // fl_Z is unaffected

		mask_ |= fl_C;
		if ((op1 >> op2) & 1)
			value_ |= fl_C;
		return;
	default:
		return;
	}

	mask_ |= fl_Z;
	if ((result & value_mask) == 0)
		value_ |= fl_Z;

	mask_ |= fl_S;
	if (result & sign_mask)
		value_ |= fl_S;
}

/**
* IntelStack
*/

IntelStack::IntelStack()
	: ObjectList<IntelStackValue>()
{

}

IntelStackValue *IntelStack::Add(ValueType type, uint64_t value)
{
	IntelStackValue *res = new IntelStackValue(this, type, value);
	AddObject(res);
	return res;
};

IntelStackValue *IntelStack::Insert(size_t index, ValueType type, uint64_t value)
{
	IntelStackValue *res = new IntelStackValue(this, type, value);
	InsertObject(index, res);
	return res;
}

IntelStackValue *IntelStack::GetRegistr(uint8_t reg) const
{
	for (size_t i = 0; i < count(); i++) {
		IntelStackValue *res = item(i);
		if (res->type() == vtRegistr && res->value() == reg)
			return res;
	}
	return NULL;
}

IntelStackValue *IntelStack::GetRandom(uint32_t types)
{
	std::vector<IntelStackValue *> list;
	for (size_t i = 0; i < count(); i++) {
		IntelStackValue *stack_item = item(i);
		if (stack_item->type() & types) {
			if (stack_item->type() == vtRegistr && (stack_item->value() == regEFX || stack_item->value() == regEmpty))
				continue;

			list.push_back(stack_item);
		}
	}
	return list.empty() ? NULL : list[rand() % list.size()];
}

/**
* IntelRegistrStorage
*/

IntelRegistrStorage::IntelRegistrStorage()
	: IntelStack()
{

}

IntelRegistrValue *IntelRegistrStorage::item(size_t index) const
{
	return reinterpret_cast<IntelRegistrValue *>(IntelStack::item(index));
}

IntelRegistrValue *IntelRegistrStorage::GetRegistr(uint8_t reg) const
{
	for (size_t i = 0; i < count(); i++) {
		IntelRegistrValue *res = item(i);
		if (res->registr() == reg)
			return res;
	}
	return NULL;
};

IntelRegistrValue *IntelRegistrStorage::Add(uint8_t reg, uint64_t value)
{
	IntelRegistrValue *res = GetRegistr(reg);
	if (res)
		res->set_value(value);
	else {
		res = new IntelRegistrValue(this, reg, value);
		AddObject(res);
	}
	return res;
}

/**
* IntelObfuscation
*/

IntelObfuscation::IntelObfuscation()
	: IObject(), func_(NULL)
{

}

IntelCommand *IntelObfuscation::AddCommand(IntelCommandType command_type, IntelOperand operand1, IntelOperand operand2, IntelOperand operand3)
{
	if (command_type != cmLea && registr_values_.count()) {
		for (size_t i = 0; i < 2; i++) {
			IntelOperand *operand = (i == 0) ? &operand1 : &operand2;
			uint16_t type = operand->type & (otMemory | otBaseRegistr | otRegistr);
			if (type == (otMemory | otBaseRegistr) || type == (otMemory | otRegistr)) {
				IntelRegistrValue *reg_value = registr_values_.item(rand() % registr_values_.count());
				if ((operand->type & otRegistr) && !operand->scale_registr) {
					operand->base_registr = operand->registr;
					operand->type -= otRegistr;
					operand->type |= otBaseRegistr;
				}
				if (operand->type & otBaseRegistr) {
					operand->scale_registr = rand() & 3;
					uint64_t tmp = operand->value - (reg_value->value() << operand->scale_registr);
					if (DWordToInt64(static_cast<uint32_t>(tmp)) == tmp) {
						operand->type |= (otRegistr | otValue);
						operand->registr = reg_value->registr();
						operand->value = tmp;
						operand->value_size = osDWord;
					}
				}
			}
		}
	}

	IntelCommand *command = new IntelCommand(func_, func_->cpu_address_size(), command_type, operand1, operand2, operand3);
	command_list_.push_back(command);
	return command;
}

void IntelObfuscation::AddRestoreStackItem(IntelStackValue *stack_item)
{
	if (stack_item && stack_item->type() == vtRegistr && stack_item->value() != regEmpty) {
		if (stack_item->is_modified()) {
			uint8_t reg = static_cast<uint8_t>(stack_item->value());
			OperandSize cpu_address_size = func_->cpu_address_size();
			uint64_t value = (stack_.count() - 1 - stack_.IndexOf(stack_item)) * OperandSizeToStack(cpu_address_size);

			if (reg == regEFX) {
				AddCommand(cmPush, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, value));
				AddCommand(cmPopf, IntelOperand(otNone, cpu_address_size, 0));

				flags_.clear();
			}
			else {
				AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, value));

				IntelRegistrValue *reg_value = registr_values_.GetRegistr(reg);
				if (reg_value)
					delete reg_value;
			}
		}
		stack_item->set_value(regEmpty);
		stack_item->set_is_modified(false);
	}
}

void IntelObfuscation::AddRestoreRegistr(uint8_t reg)
{
	if (IntelStackValue *stack_item = stack_.GetRegistr(reg))
		AddRestoreStackItem(stack_item);
}

void IntelObfuscation::AddRestoreStack(size_t to_index)
{
	size_t i;
	for (i = stack_.count(); i > to_index; i--) {
		IntelStackValue *stack_item = stack_.item(i - 1);
		AddRestoreStackItem(stack_item);
	}
	size_t value = 0;
	OperandSize cpu_address_size = func_->cpu_address_size();
	for (i = stack_.count(); i > to_index; i--) {
		delete stack_.item(i - 1);
		value += OperandSizeToStack(cpu_address_size);
	}
	if (value)
		AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, value));
}

void IntelObfuscation::Compile(IntelFunction *func, size_t index)
{
	func_ = func;
	flags_.clear();
	stack_.clear();
	registr_values_.clear();

	size_t i, j, old_count;
	IntelCommand *command;
	IntelStackValue *stack_item;
	IntelRegistrValue *reg_value;
	uint8_t reg;
	OperandSize cpu_address_size = func_->cpu_address_size();
	bool need_update;
	IntelOperand new_operand[3];

	while (index < func_->count()) {
		command = func_->item(index);
		func_->erase(index);

		if (command->section_options() & (rtLinkedToInt | rtLinkedToExt))
			AddRestoreStack(0);

		old_count = command_list_.size();

		AddRandomCommands();

		if (stack_.count()) {
			switch (command->type()) {
			case cmPop:
				reg = command->operand(0).registr;

				command->Init(cmMov, IntelOperand(otRegistr, cpu_address_size, reg), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, stack_.count() * OperandSizeToStack(cpu_address_size)));

				stack_item = stack_.GetRegistr(reg);
				if (stack_item)
					stack_item->set_value(regEmpty);

				reg_value = registr_values_.GetRegistr(reg);
				if (reg_value)
					delete reg_value;

				stack_.Insert(0, vtRegistr, regEmpty);
				break;

			case cmPush:
			case cmPushf:
				stack_item = stack_.item(0);
				AddRestoreStackItem(stack_item);
				delete stack_item;

				if (command->type() == cmPushf) {
					AddCommand(cmPushf, IntelOperand(otNone, cpu_address_size, 0));
					command->Init(cmPop, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, stack_.count() * OperandSizeToStack(cpu_address_size)));
				}
				else {
					IntelOperand first_operand = command->operand(0);
					if (first_operand.type == otValue) {
						if (first_operand.value_size == osQWord)
							first_operand.value_size = osDWord;
					}
					else if (first_operand.type == otRegistr)
						AddRestoreRegistr(first_operand.registr);

					command->Init(cmMov, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, stack_.count() * OperandSizeToStack(cpu_address_size)), first_operand);
					if (command->link() && command->link()->operand_index() == 0)
						command->link()->set_operand_index(1);
				}
				break;

			case cmCall:
				if ((command->options() & roUseAsJmp) && command->link()) {
					size_t ret_pos = rand() % stack_.count();

					for (j = stack_.count(); j > 0; j--) {
						IntelStackValue *stack_item = stack_.item(j - 1);
						AddRestoreStackItem(stack_item);
					}
					uint64_t value = (stack_.count() - ret_pos - 1) * OperandSizeToStack(cpu_address_size);
					if (value)
						AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, value));

					stack_.clear();

					command_list_.push_back(command);

					j = command_list_.size();
					AddRandomCommands();

					stack_item = stack_.GetRegistr(regEFX);
					if (!stack_item) {
						AddCommand(cmPushf, IntelOperand(otNone, func_->cpu_address_size(), 0));
						stack_item = stack_.Add(vtRegistr, regEFX);
					}
					stack_item->set_is_modified(true);

					IntelCommand *add_command = AddCommand(cmAdd, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, stack_.count() * OperandSizeToStack(cpu_address_size)),
						IntelOperand(otValue, cpu_address_size, 0, 0));

					flags_.clear();

					CommandLink *link = add_command->AddLink(1, ltDelta, command->link()->to_command());
					link->set_parent_command(command);
					link->set_sub_value(5);

					command->link()->set_to_command(command_list_[j]);

					AddRandomCommands();

					command = new IntelCommand(func_, cpu_address_size, cmRet, ret_pos ? IntelOperand(otValue, osWord, 0, ret_pos * OperandSizeToStack(cpu_address_size)) : IntelOperand());
				}
				AddRestoreStack(0);
				break;
			case cmRet:
			case cmJmp:
			case cmJmpWithFlag:
				AddRestoreStack(0);
				break;
			}
		}

		if (command_list_.size() > old_count && command->section_options() & (rtLinkedToInt | rtLinkedToExt)) {
			IntelCommand *dst_command = command_list_[old_count];
			IntelCommandType dst_type = (IntelCommandType)dst_command->type();
			IntelOperand dst_operand[3];
			for (i = 0; i < _countof(dst_operand); i++) {
				dst_operand[i] = dst_command->operand(i);
			}
			uint16_t dst_flags = dst_command->flags();
			uint32_t dst_options = dst_command->options();
			CommandLink *dst_link = dst_command->link();
			if (dst_link)
				dst_link->set_from_command(NULL);

			dst_command->Init(static_cast<IntelCommandType>(command->type()), command->operand(0), command->operand(1), command->operand(2));
			dst_command->set_flags(command->flags());
			dst_command->exclude_option((CommandOption)UINT32_MAX);
			dst_command->include_option((CommandOption)command->options());
			if (command->link())
				command->link()->set_from_command(dst_command);

			command->Init(dst_type, dst_operand[0], dst_operand[1], dst_operand[2]);
			command->set_flags(dst_flags);
			command->exclude_option((CommandOption)UINT32_MAX);
			command->include_option((CommandOption)dst_options);
			if (dst_link)
				dst_link->set_from_command(command);

			command_list_[old_count] = command;
			command = dst_command;
		}

		command_list_.push_back(command);
	}

	for (i = 0; i < command_list_.size(); i++) {
		command = command_list_[i];

		// optimize operands
		need_update = false;
		for (j = 0; j < _countof(new_operand); j++) {
			IntelOperand *operand = &new_operand[j];
			*operand = command->operand(j);

			if ((operand->type & (otMemory | otValue)) == (otMemory | otValue) && (operand->type & (otBaseRegistr | otRegistr))) {
				if (operand->fixup || operand->is_large_value)
					continue;

				if (command->link() && command->link()->operand_index() == (int)j)
					continue;

				if (operand->value_size != osByte && ByteToInt64(static_cast<uint8_t>(operand->value)) == operand->value) {
					operand->value_size = osByte;
					need_update = true;
				}
			}
		}
		if (need_update)
			command->Init(static_cast<IntelCommandType>(command->type()), new_operand[0], new_operand[1], new_operand[2]);

		command->CompileToNative();
		if (command->link() && !command->link()->to_command()) {
			std::map<IntelCommand *, size_t>::const_iterator it = jmp_command_list_.find(command);
			if (it != jmp_command_list_.end()) {
				IntelCommand *to_command;
				if (command->type() == cmJmpWithFlag && (command->options() & roUseAsJmp) == 0) {
					while (true) {
						j = rand() % command_list_.size();
						if (j == it->second || j == it->second + 1)
							continue;
						to_command = command_list_[j];
						break;
					}
				}
				else
					to_command = command_list_[it->second];
				command->link()->set_to_command(to_command);
			}
		}

		func_->AddObject(command);
	}
}

#define NEED_STORE_FLAGS reinterpret_cast<IntelStackValue *>(-1)

void IntelObfuscation::AddRandomCommands()
{
	size_t i, j, c;
	IntelCommand *new_command, *last_command;
	std::vector<IntelCommandType> template_command_list;
	IntelCommandType command_type;
	uint8_t reg;
	OperandSize cpu_address_size = func_->cpu_address_size();
	uint8_t registr_count = (cpu_address_size == osDWord) ? 8 : 16;
	IntelStackValue *stack_item;
	IntelRegistrValue *reg_value;
	uint16_t command_flags;
	uint64_t source_value;
	OperandSize size;

	c = 30 + (rand() % 10);
	for (i = 0; i < c; i++) {

		last_command = command_list_.empty() ? NULL : command_list_.back();

		template_command_list.clear();
		template_command_list.push_back(cmPush);
		if (stack_.count()) {
			template_command_list.push_back(cmPop);
			if (stack_.count() < 20) {
				template_command_list.push_back(cmPush);
				if (last_command && last_command->type() != cmCall) {
					template_command_list.push_back(cmCall);
					template_command_list.push_back(cmCall);
					template_command_list.push_back(cmCall);
					template_command_list.push_back(cmCall);

					template_command_list.push_back(cmRet);
					template_command_list.push_back(cmRet);
					template_command_list.push_back(cmRet);
					template_command_list.push_back(cmRet);
					template_command_list.push_back(cmRet);
				}
			}
			template_command_list.push_back(cmLea);
			template_command_list.push_back(cmMov);
			template_command_list.push_back(cmMovsx);
			template_command_list.push_back(cmMovzx);

			template_command_list.push_back(cmCbw);
			template_command_list.push_back(cmCwde);
			template_command_list.push_back(cmCwd);
			template_command_list.push_back(cmCdq);
			if (cpu_address_size == osQWord) {
				template_command_list.push_back(cmCdqe);
				template_command_list.push_back(cmCqo);
			}
			template_command_list.push_back(cmBswap);

			if (last_command && (last_command->type() != cmCmp || flags_.mask() == 0)) {
				template_command_list.push_back(cmAdd);
				template_command_list.push_back(cmSub);
				template_command_list.push_back(cmNeg);
				template_command_list.push_back(cmCmp);

				template_command_list.push_back(cmAnd);
				template_command_list.push_back(cmTest);
				template_command_list.push_back(cmXor);
				template_command_list.push_back(cmOr);
				template_command_list.push_back(cmNot);

				template_command_list.push_back(cmShr);
				template_command_list.push_back(cmShl);
				template_command_list.push_back(cmSal);
				template_command_list.push_back(cmSar);
				template_command_list.push_back(cmRol);
				template_command_list.push_back(cmRor);
			}

			template_command_list.push_back(cmBt);
			template_command_list.push_back(cmBtr);
			template_command_list.push_back(cmBtc);
			template_command_list.push_back(cmBts);

			if (flags_.mask()) {
				template_command_list.push_back(cmJmpWithFlag);
				template_command_list.push_back(cmJmpWithFlag);
				template_command_list.push_back(cmJmpWithFlag);
				template_command_list.push_back(cmJmpWithFlag);
				template_command_list.push_back(cmJmpWithFlag);

				template_command_list.push_back(cmSetXX);
				template_command_list.push_back(cmCmov);
				if (flags_.mask() & fl_C) {
					if (last_command && last_command->type() != cmCmc && last_command->type() != cmClc && last_command->type() != cmStc) {
						template_command_list.push_back((flags_.value() & fl_C) ? cmClc : cmStc);
						template_command_list.push_back(cmCmc);
					}
					template_command_list.push_back(cmAdc);
					template_command_list.push_back(cmSbb);
				}
			}
		}

		command_type = template_command_list[rand() % template_command_list.size()];
		switch (command_type) {
		case cmPush:
			if (rand() & 1) {
				reg = rand() % registr_count;
				if (reg == regESP)
					reg = regEFX;

				if (!registr_values_.GetRegistr(reg)) {
					if (stack_.GetRegistr(reg))
						break;
				}

				if (reg == regEFX)
					AddCommand(cmPushf, IntelOperand(otNone, func_->cpu_address_size(), 0));
				else
					AddCommand(cmPush, IntelOperand(otRegistr, func_->cpu_address_size(), reg));

				reg_value = registr_values_.GetRegistr(reg);
				if (reg_value)
					stack_.Add(reg_value->type(), reg_value->value());
				else
					stack_.Add(vtRegistr, reg);
			}
			else {
				uint64_t value = DWordToInt64(rand32());
				AddCommand(cmPush, IntelOperand(otValue, cpu_address_size, 0, value));
				stack_.Add(vtValue, value);
			}
			break;

		case cmPop:
			AddRestoreStack(stack_.count() - 1);
			break;

		case cmCall:
			stack_.Add(vtReturnAddress, command_list_.size());

			new_command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size, 0));
			new_command->AddLink(0, ltCall);
			new_command->include_option(roUseAsJmp);

			jmp_command_list_[new_command] = command_list_.size();
			break;

		case cmRet:
			if (IntelStackValue *ret_item = stack_.GetRandom(vtReturnAddress)) {
				size_t ret_pos = stack_.IndexOf(ret_item);
				IntelCommand *call_command = command_list_[static_cast<size_t>(ret_item->value())];
				j = static_cast<size_t>(call_command->operand(2).value);
				if (j == 0) {
					stack_item = stack_.GetRegistr(regEFX);
					if (!stack_item) {
						AddCommand(cmPushf, IntelOperand(otNone, func_->cpu_address_size(), 0));
						stack_item = stack_.Add(vtRegistr, regEFX);
					}
					stack_item->set_is_modified(true);

					call_command->set_operand_value(2, command_list_.size());

					AddCommand(cmAdd, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, (stack_.count() - 1 - ret_pos) * OperandSizeToStack(cpu_address_size)),
						IntelOperand(otValue, cpu_address_size, 0, DWordToInt64(rand32())));

					flags_.clear();
				}
				else {
					IntelCommand *add_command = command_list_[j];
					CommandLink *link = add_command->AddLink(1, ltDelta);
					link->set_parent_command(call_command);
					link->set_sub_value(5);

					AddRestoreStack(ret_pos + 1);
					delete ret_item;

					source_value = 0;
					for (j = stack_.count(); j > 0; j--) {
						stack_item = stack_.item(j - 1);
						if (stack_item->type() == vtValue || stack_item->type() == vtReturnAddress || (stack_item->type() == vtRegistr && stack_item->value() == regEmpty)) {
							if (rand() & 1)
								break;

							delete stack_item;
							source_value += OperandSizeToStack(cpu_address_size);
						} else 
							break;
					}
					if (source_value)
						AddCommand(cmRet, IntelOperand(otValue, osWord, 0, source_value));
					else
						AddCommand(cmRet);

					jmp_command_list_[add_command] = command_list_.size();
				}
			}
			break;

		case cmJmpWithFlag:
			command_flags = flags_.GetRandom();
			if (!command_flags)
				break;

			new_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size, 0));
			new_command->AddLink(0, ltJmpWithFlag);
			new_command->set_flags(command_flags);
			if (rand() & 1)
				new_command->include_option(roInverseFlag);

			if (flags_.Check(new_command->flags()) == ((new_command->options() & roInverseFlag) == 0))
				new_command->include_option(roUseAsJmp);

			jmp_command_list_[new_command] = command_list_.size();
			break;

		case cmCbw:
		case cmCwde:
		case cmCdqe:
			reg_value = registr_values_.GetRegistr(regEAX);
			if (!reg_value)
				break;

			AddCommand(command_type);

			switch (command_type) {
			case cmCbw:
				size = osWord;
				break;
			case cmCwde:
				size = osDWord;
				break;
			default:
				size = osQWord;
				break;
			}

			reg_value->Calc(command_type, 0, false, size, reg_value->value(), &flags_);
			if (cpu_address_size == osQWord && size == osDWord)
				reg_value->set_value(static_cast<uint32_t>(reg_value->value()));
			break;

		case cmCwd:
		case cmCdq:
		case cmCqo:
			reg_value = registr_values_.GetRegistr(regEAX);
			if (!reg_value)
				break;

			source_value = reg_value->value();

			switch (command_type) {
			case cmCwd:
				size = osWord;
				break;
			case cmCdq:
				size = osDWord;
				break;
			default:
				size = osQWord;
				break;
			}

			reg_value = registr_values_.GetRegistr(regEDX);
			if (!reg_value) {
				if (size != cpu_address_size)
					break;

				stack_item = stack_.GetRegistr(regEDX);
				if (!stack_item) {
					AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, regEDX));
					stack_item = stack_.Add(vtRegistr, regEDX);
				}
				stack_item->set_is_modified(true);

				reg_value = registr_values_.Add(regEDX, 0);
			}

			AddCommand(command_type);

			reg_value->Calc(command_type, 0, false, size, source_value, &flags_);
			if (cpu_address_size == osQWord && size == osDWord)
				reg_value->set_value(static_cast<uint32_t>(reg_value->value()));
			break;

		case cmStc:
		case cmCmc:
		case cmClc:
			if (flags_.mask() & fl_C) {
				stack_item = stack_.GetRegistr(regEFX);
				if (!stack_item)
					break;
				stack_item->set_is_modified(true);

				flags_.Calc(command_type, cpu_address_size, 0, 0, 0);
				AddCommand(command_type);
			}
			break;

		default:
			if (IntelStackValue *first_item = stack_.GetRandom(vtRegistr | vtValue)) {
				source_value = 0;

				command_flags = 0;
				bool inverse_flags = false;
				IntelStackValue *flags_item = NULL;

				if (command_type == cmSetXX || command_type == cmCmov) {
					command_flags = flags_.GetRandom();
					if (!command_flags)
						break;

					if (rand() & 1)
						inverse_flags = true;
				} 
				else switch (command_type) {
				case cmXor:
				case cmAnd:
				case cmTest:
				case cmOr:
				case cmNeg:
				case cmAdd:
				case cmAdc:
				case cmSub:
				case cmSbb:
				case cmCmp:
				case cmRor:
				case cmRol:
				case cmShr:
				case cmShl:
				case cmSar:
				case cmSal:
				case cmDec:
				case cmInc:
				case cmBt:
				case cmBtr:
				case cmBtc:
				case cmBts:
					flags_item = stack_.GetRegistr(regEFX);
					if (!flags_item)
						flags_item = NEED_STORE_FLAGS;
					break;
				}

				IntelOperand first_operand, second_operand;

				switch (rand() % 4) {
				case 0:
					first_operand.size = osByte;
					break;
				case 1:
					first_operand.size = osWord;
					break;
				case 2:
					first_operand.size = osDWord;
					break;
				default:
					first_operand.size = cpu_address_size;
					break;
				}

				if (first_item->type() == vtRegistr) {
					first_operand.type = otRegistr;
					first_operand.registr = static_cast<uint8_t>(first_item->value());

					if (!registr_values_.GetRegistr(first_operand.registr)) {
						command_type = cmMov;
						first_operand.size = cpu_address_size;
					}
				}
				else {
					first_operand.type = otMemory | otBaseRegistr | otValue;
					first_operand.base_registr = regESP;
					first_operand.value = (stack_.count() - 1 - stack_.IndexOf(first_item)) * OperandSizeToStack(cpu_address_size);
					if (flags_item == NEED_STORE_FLAGS)
						first_operand.value += OperandSizeToStack(cpu_address_size);
				}

				if (command_type == cmLea) {
					if (first_operand.type != otRegistr || !registr_values_.count())
						break;

					first_operand.size = cpu_address_size;
					second_operand.size = first_operand.size;

					reg_value = registr_values_.item(rand() % registr_values_.count());

					second_operand.type = otMemory | otRegistr | otValue;
					second_operand.registr = reg_value->registr();
					second_operand.scale_registr = rand() & 3;

					source_value = reg_value->value();
					if (second_operand.scale_registr)
						source_value = source_value << second_operand.scale_registr;

					if (rand() & 1) {
						reg_value = registr_values_.item(rand() % registr_values_.count());
						second_operand.type |= otBaseRegistr;
						second_operand.base_registr = reg_value->registr();
						source_value = source_value + reg_value->value();
					}

					second_operand.value_size = second_operand.size;
					switch (second_operand.size) {
					case osByte:
						second_operand.value = ByteToInt64(rand32());
						break;
					case osWord:
						second_operand.value = WordToInt64(rand32());
						break;
					default:
						second_operand.value = DWordToInt64(rand32());
						second_operand.value_size = osDWord;
						break;
					}
					source_value = source_value + second_operand.value;
				}
				else if (command_type == cmSetXX) {
					first_operand.size = osByte;
				}
				else if (command_type == cmShr || command_type == cmShl || command_type == cmSal || command_type == cmSar || command_type == cmRol || command_type == cmRor) {
					second_operand.size = osByte;
					switch (rand() % 2) {
					case 0:
						reg_value = registr_values_.GetRegistr(regECX);
						if (reg_value) {
							second_operand.type = otRegistr;
							second_operand.registr = reg_value->registr();

							source_value = reg_value->value();
							break;
						}
					default:
						second_operand.type = otValue;
						second_operand.value = static_cast<uint8_t>(rand());
						if (!second_operand.value)
							second_operand.value = 1;
						second_operand.value_size = second_operand.size;

						source_value = second_operand.value;
						break;
					}
				}
				else if (command_type != cmNot && command_type != cmNeg && command_type != cmBswap) {
					second_operand.size = first_operand.size;
					switch (rand() % 3) {
					case 0:
						if (registr_values_.count()) {
							reg_value = registr_values_.item(rand() % registr_values_.count());
							source_value = reg_value->value();

							second_operand.type = otRegistr;
							second_operand.registr = reg_value->registr();
							break;
						}
					case 1:
						if (first_operand.type == otRegistr) {
							stack_item = stack_.GetRandom(otValue);
							if (stack_item) {
								source_value = stack_item->value();

								second_operand.type = otMemory | otBaseRegistr | otValue;
								second_operand.base_registr = regESP;
								second_operand.value = (stack_.count() - 1 - stack_.IndexOf(stack_item)) * OperandSizeToStack(cpu_address_size);
								if (flags_item == NEED_STORE_FLAGS)
									second_operand.value += OperandSizeToStack(cpu_address_size);
								break;
							}
						}
					default:
						second_operand.type = otValue;
						second_operand.value_size = second_operand.size;
						switch (second_operand.size) {
						case osByte:
							second_operand.value = ByteToInt64(rand32());
							break;
						case osWord:
							second_operand.value = WordToInt64(rand32());
							break;
						case osQWord:
							if (command_type == cmMov && first_operand.type == otRegistr) {
								second_operand.value = rand64();
								break;
							}
						default:
							second_operand.value = DWordToInt64(rand32());
							second_operand.value_size = osDWord;
							break;
						}

						source_value = second_operand.value;
					}
				}

				if (command_type == cmCmov) {
					if (first_operand.type != otRegistr || first_operand.size == osByte || second_operand.type == otValue)
						break;
				}
				else if (command_type == cmMovsx || command_type == cmMovzx) {
					if (first_operand.type != otRegistr || first_operand.size == osByte || second_operand.type == otValue)
						break;

					second_operand.size = rand() & 1 ? osByte : osWord;
					if (first_operand.size == osQWord && command_type == cmMovsx && (rand() & 1)) {
						command_type = cmMovsxd;
						second_operand.size = osDWord;
					}

					if (command_type == cmMovzx) {
						switch (second_operand.size) {
						case osByte:
							source_value = static_cast<uint8_t>(source_value);
							break;
						case osWord:
							source_value = static_cast<uint16_t>(source_value);
							break;
						case osDWord:
							source_value = static_cast<uint32_t>(source_value);
							break;
						}
					}
					else {
						switch (second_operand.size) {
						case osByte:
							source_value = ByteToInt64(static_cast<uint8_t>(source_value));
							break;
						case osWord:
							source_value = WordToInt64(static_cast<uint16_t>(source_value));
							break;
						case osDWord:
							source_value = DWordToInt64(static_cast<uint32_t>(source_value));
							break;
						}
					}
				}
				else if (command_type == cmBt || command_type == cmBtr || command_type == cmBtc || command_type == cmBts) {
					if (first_operand.size == osByte || first_operand.type != otRegistr || (second_operand.type & otMemory))
						break;

					if (second_operand.type == otValue) {
						second_operand.size = osByte;
						second_operand.value_size = osByte;
						second_operand.value = static_cast<uint8_t>(second_operand.value);
						source_value = second_operand.value;
					}
				}
				else if (command_type == cmBswap) {
					if (first_operand.size == osByte || first_operand.size == osWord || first_operand.type != otRegistr)
						break;
				}

				if (cpu_address_size == osDWord) {
					if (first_operand.type == otRegistr && first_operand.size == osByte && first_operand.registr >= 4)
						break;
					if (second_operand.type == otRegistr && second_operand.size == osByte && second_operand.registr >= 4)
						break;
				}

				if (flags_item == NEED_STORE_FLAGS) {
					AddCommand(cmPushf, IntelOperand(otNone, func_->cpu_address_size(), 0));
					flags_item = stack_.Add(vtRegistr, regEFX);
				}
				if (flags_item)
					flags_item->set_is_modified(true);

				new_command = AddCommand(command_type, first_operand, second_operand);
				if (command_flags) {
					new_command->set_flags(command_flags);
					if (inverse_flags)
						new_command->include_option(roInverseFlag);
				}

				if (first_operand.type == otRegistr) {
					bool is_modified = (command_type != cmCmp && command_type != cmTest && command_type != cmBt);
					if (is_modified)
						first_item->set_is_modified(true);
					reg_value = registr_values_.GetRegistr(first_operand.registr);
					if (reg_value) {
						reg_value->Calc(command_type, command_flags, inverse_flags, first_operand.size, source_value, &flags_);
						if (is_modified) {
							if (cpu_address_size == osQWord && first_operand.size == osDWord)
								reg_value->set_value(static_cast<uint32_t>(reg_value->value()));
						}
					}
					else
						registr_values_.Add(first_operand.registr, source_value);
				}
				else {
					first_item->Calc(command_type, command_flags, inverse_flags, first_operand.size, source_value, &flags_);
				}
			}
			break;
		}
	}
}

IntelCommand *IntelFunction::AddGate(ICommand *to_command, AddressRange *address_range)
{
	size_t i;

	IntelVirtualMachine *virtual_machine = reinterpret_cast<IntelVirtualMachine *>(to_command->block()->virtual_machine());
	size_t old_count = count();

	IntelCommand *command = AddCommand(cmPush, IntelOperand(otValue, cpu_address_size()));
	CommandLink *link = command->AddLink(0, ltJmp, to_command);
	link->set_cryptor(virtual_machine->entry_cryptor());
	if (to_command && to_command->seh_handler())
		command->set_seh_handler(NEED_SEH_HANDLER);

	command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
	command->include_option(roUseAsJmp);
	command->AddLink(0, ltCall, virtual_machine->entry_command());
#ifndef DEMO
	if (false)
	if (virtual_machine->processor()->cpu_address_size() == cpu_address_size()) {
		IntelObfuscation engine;
		engine.Compile(this, old_count);
	}
#endif

	CommandBlock *cur_block = NULL;
	for (i = old_count; i < count(); i++) {
		if (!cur_block)
			cur_block = AddBlock(i, true);

		command = item(i);
		command->CompileToNative();
		command->set_block(cur_block);

		cur_block->set_end_index(i);
		if (command->is_end())
			cur_block = NULL;
	}

	IntelCommand *res = item(old_count);
	if (address_range) {
		cur_block = res->block();
		for (i = cur_block->start_index(); i <= cur_block->start_index(); i++) {
			command = item(i);
			command->set_address_range(address_range);
		}
	}

	return res;
}

IntelCommand *IntelFunction::AddShortGate(ICommand *to_command, AddressRange *address_range)
{
	CommandBlock *cur_block = AddBlock(count(), true);

	IntelCommand *res = AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size()));
	res->AddLink(0, ltJmp, to_command);
	if (to_command && to_command->seh_handler())
		res->set_seh_handler(NEED_SEH_HANDLER);

	cur_block->set_end_index(count() - 1);

	for (size_t i = cur_block->start_index(); i <= cur_block->end_index(); i++) {
		IntelCommand *command = item(i);
		command->CompileToNative();
		command->set_block(cur_block);
		if (address_range)
			command->set_address_range(address_range);
	}

	return res;
}

void IntelFunction::CompileToVM(const CompileContext &ctx)
{
	size_t i, j, c;
	IntelCommand *command;

	// create internal links
	c = link_list()->count();
	for (i = 0; i < count(); i++) {
		command = item(i);
		if (command->block() || (command->options() & roNeedCompile) == 0)
			continue;

		if (command->is_data()) {
			if (command->link() && command->link()->type() == ltCase) {
				// create blocks for CASEs
				CommandBlock *cur_block = NULL;
				for (j = i; j < count(); j++) {
					command = item(j);
					if (command->link() && command->link()->type() == ltCase) {
						if (command->block() || (command->options() & roNeedCompile) == 0 || is_breaked_address(command->address())) {
							cur_block = NULL;
							continue;
						}

						if (!cur_block || (command->options() & roCreateNewBlock)) {
							cur_block = AddBlock(j);
							cur_block->set_virtual_machine(virtual_machine(ctx.file->virtual_machine_list(), command));
						}
						cur_block->set_end_index(j);

						command->set_block(cur_block);

						command->CompileToVM(ctx);
					} else {
						break;
					}
				}
			} 
			continue;
		}

		if ((command->options() & roLockPrefix) && (command->options() & roNoNative) == 0) {
			command->AddLink(-1, ltNative);
			continue;
		} else {
			bool relocation_found = false;
			for (j = 0; j < 3; j++) {
				IntelOperand operand = command->operand(j) ;
				if (operand.type == otNone)
					break;

				if (operand.relocation) {
					relocation_found = true;
					break;
				}
			}
			if (relocation_found) {
				command->AddLink(-1, ltNative);
				continue;
			}
		}

		switch (command->type()) {
		case cmJmp: case cmCall: 
			if (command->options() & roFar)
				command->AddLink(-1, ltNative);
			break;
		case cmLods: case cmMovs: case cmScas: case cmCmps: case cmStos:
			if (command->preffix_command() == cmRep || command->preffix_command() == cmRepe || command->preffix_command() == cmRepne)
				command->AddLink(-1, ltNative);
			break;
		case cmCmov:
			command->AddLink(-1, ltJmpWithFlagNSNA);
			break;
		case cmXchg:
			if (((command->operand(0).type | command->operand(1).type) & otMemory) && (command->options() & roNoNative) == 0)
				command->AddLink(-1, ltNative);
			break;
		case cmFadd: case cmFsub: case cmFisub: case cmFsubr: case cmFdiv: case cmFmul: 
		case cmFcomp: case cmFild: case cmFld: case cmFstp: case cmFst:
			if (command->operand(0).type == otFPURegistr)
				command->AddLink(-1, ltNative);
			break;
		case cmPush: case cmPop: case cmMov: case cmMovsx: case cmMovsxd: case cmMovzx:
		case cmJmpWithFlag: case cmJCXZ: case cmLoop: case cmLoope: case cmLoopne:
		case cmRet: case cmIret: 
		case cmLea: case cmNop: case cmFnop:
		case cmNot: case cmNeg: case cmAdd: case cmAdc: case cmXadd:
		case cmSub: case cmCmp: case cmInc: case cmDec: case cmXlat: case cmSetXX:
		case cmAnd: case cmXor: case cmTest: case cmOr:
		case cmShld: case cmShrd:
		case cmRol: case cmRor: case cmRcl: case cmRcr:
		case cmShl: case cmSal: case cmShr: case cmSar:
		case cmCbw: case cmCwde: case cmCwd: case cmCdq: case cmCdqe: case cmCqo:
		case cmPushf: case cmPopf: case cmPusha: case cmPopa:
		case cmLahf: case cmSahf:
		case cmBt: case cmBtr: case cmBts: case cmBtc:
		case cmClc: case cmStc: case cmCmc: case cmCld: case cmStd:
		case cmBswap: case cmLeave:
		case cmImul: case cmMul: case cmDiv: case cmIdiv:
		case cmLes: case cmLds: case cmLfs: case cmLgs:
		case cmFstsw: case cmFldcw: case cmFstcw:
		case cmF2xm1: case cmFabs: case cmFclex: case cmFcos: case cmFdecstp: case cmFincstp:
		case cmFinit: case cmFldln2: case cmFldlg2: case cmFprem: case cmFprem1: case cmFptan:
		case cmFrndint: case cmFsin: case cmFtst: case cmFyl2x: case cmFpatan: case cmFldz: case cmFld1: case cmFldpi:
		case cmWait: case cmFchs: case cmFsqrt:
		case cmFistp: case cmFist: case cmRdtsc:
		case cmCrc:
			// do nothing
			break;

		default:
			if ((command->options() & roNoNative) == 0)
				command->AddLink(-1, ltNative);
			break;
		}
	}
	for (i = c; i < link_list()->count(); i++) {
		link_list()->item(i)->from_command()->PrepareLink(ctx);
	}

	// optimize flags 
	IntelCommand *flag_command = NULL;
	uint64_t flags = 0;
	IntelCommandInfoList command_info(cpu_address_size());
	for (i = 0; i < count(); i++) {
		command = item(i);

		if ((command->link() && command->link()->type() == ltNative) || !command->GetCommandInfo(command_info) || command_info.GetInfo(atWrite, otBaseRegistr, regEIP)) {
			flag_command = NULL;
			continue;
		}

		if (!flag_command) {
			if (command_info.change_flags()) {
				flag_command = command;
				flags = command_info.change_flags();
			}
		} else {
			if (command_info.need_flags()) {
				if ((command_info.need_flags() & flags) != 0) {
					flag_command = NULL;
					continue;
				}
			}
			if (command_info.change_flags()) {
				if ((command_info.change_flags() & flags) == flags) {
					flag_command->include_option(roNoSaveFlags);
					flag_command = command;
					flags = command_info.change_flags();
				}
			}
		}
	}

	// create VM blocks
	CommandBlock *cur_block = NULL;
	uint64_t cur_eip = (uint64_t)-1;
	for (i = 0; i < count(); i++) {
		command = item(i);
		if ((command->options() & roNoProgress) == 0)
			ctx.file->StepProgress();

		if (command->block() || (command->options() & roNeedCompile) == 0 || is_breaked_address(command->address())) {
			cur_block = NULL;
			continue;
		}

		bool is_data = command->is_data() && (!command->link() || command->link()->type() != ltNative);
		bool new_block = (!cur_block || (command->options() & roCreateNewBlock) || item(cur_block->end_index())->is_data() != is_data);
		if (new_block) {
			cur_block = AddBlock(i, is_data);
			if (!is_data)
				cur_block->set_virtual_machine(virtual_machine(ctx.file->virtual_machine_list(), command));
		}

		cur_block->set_end_index(i);

		command->set_block(cur_block);
		if (command->seh_handler())
			command->seh_handler()->set_deleted(true);
		if (is_data) {
			cur_eip = (uint64_t)-1;
		} else {
			if (command->block()->virtual_machine()->backward_direction())
				command->include_section_option(rtBackwardDirection);
			if (new_block || (command->section_options() & (rtLinkedToInt | rtLinkedToExt))) {
				command->AddExtSection(ctx, NULL);
				cur_eip = (uint64_t)-1;
			}
			cur_eip = command->AddStoreEIPSection(ctx, cur_eip);
			if (command->section_options() & rtLinkedToExt)
				command->AddStoreExtRegistersSection(ctx);
		}
		if (command->options() & roNeedCompile) {
			if (is_data) {
				command->CompileToNative();
			} else {
				command->CompileToVM(ctx);
			}
		}

		if (!is_data) {
			if ((command->section_options() & rtEndSection) == 0 && i < count() - 1 && (item(i + 1)->section_options() & (rtLinkedToInt | rtLinkedToExt))) 
				command->AddExtSection(ctx, item(i + 1));
		}

		if (command->section_options() & rtCloseSection)
			cur_block = NULL;
	}

	// create gates for external commands
	ExtCommandList *ext_list = ext_command_list();
	for (i = 0; i < ext_list->count(); i++) {
		ExtCommand *ext_command = ext_list->item(i);
		if (!ext_command->command() || is_breaked_address(ext_command->address()))
			continue;

		command = AddGate(ext_command->command(), ext_command->command()->address_range());
		
		if (ext_command->address()) {
			command = AddShortGate(command, NULL);
			command->block()->set_address(ext_command->address());
		}

		if (entry() == ext_command->command())
			set_entry(command);
	}
}

bool IntelFunction::Compile(const CompileContext &ctx)
{
	switch (compilation_type()) {
	case ctMutation: //bian yi
		CompileToNative(ctx);
		break;
	case ctVirtualization: //xu ni hua
		CompileToVM(ctx);
		break;
	case ctUltra://xu ni hua + bian yi
		Mutate(ctx, true);
		CompileToVM(ctx);
		break;
	default:
		return false;
	}

	return BaseFunction::Compile(ctx);
}

void IntelFunction::AfterCompile(const CompileContext &ctx)
{
	size_t i, j, c;
	IntelCommand *command, *from_command, *gate_command, *native_command;
	CommandBlock *block;
	CommandLink *link;

	if (compilation_type() == ctMutation) {
		for (i = 0; i < link_list()->count(); i++) {
			link = link_list()->item(i);
			if (!link->to_command())
				continue;

			from_command = reinterpret_cast<IntelCommand *>(link->from_command());
			if ((from_command->section_options() & rtLinkedFromOtherType) && !link->to_command()->is_data())
				link->set_to_command(AddGate(link->to_command(), NULL));

			switch (link->type()) {
			case ltMemSEHBlock: case ltExtSEHHandler: case ltVBMemSEHBlock:
				if (from_command->address()) {
					block = AddBlock(count(), true);
					command = from_command->Clone(this);
					AddObject(command);
					command->set_block(block);
					block->set_address(command->address());

					CommandLink *dst_link = command->AddLink(0, ltOffset, link->to_command());
					dst_link->set_sub_value(link->sub_value());
				}
				break;
			}
		}
	} else {
		// create native gates for links
		c = count();
		for (i = 0; i < c; i++) {
			from_command = item(i);
			link = from_command->link();
			if (!link)
				continue;

			IntelCommand *to_command = reinterpret_cast<IntelCommand *>(link->to_command());
			ICommand *next_command = link->next_command();
			IntelCommand *parent_command = reinterpret_cast<IntelCommand *>(link->parent_command());

			if (to_command && to_command->block() && (to_command->block()->type() & mtExecutable) == 0) {
				// to VM block
				switch (link->type()) {
				case ltGateOffset:
					link->set_to_command(AddGate(to_command, to_command->address_range()));
					break;
				case ltMemSEHBlock: case ltExtSEHHandler: case ltVBMemSEHBlock:
					if (to_command) {
						if (from_command->address()) {
							block = AddBlock(count(), true);
							native_command = from_command->Clone(this);
							AddObject(native_command);
							native_command->set_block(block);
							block->set_address(native_command->address());
						}
						else {
							native_command = NULL;
						}

						gate_command = AddGate(to_command, to_command->address_range());

						if (native_command) {
							CommandLink *dst_link = native_command->AddLink(0, ltOffset, gate_command);
							dst_link->set_sub_value(link->sub_value());
						}

						link->set_to_command(gate_command);
					}
					break;
				}
			}

			if (from_command->block() && (from_command->block()->type() & mtExecutable) == 0) {
				// from VM block
				switch (link->type()) {
				case ltSEHBlock: case ltFinallyBlock: case ltExtSEHBlock:
					if (to_command)
						link->AddGateCommand(AddGate(to_command, to_command->address_range()));
					break;

				case ltCall:
					if (next_command && (from_command->options() & roInternal) == 0) {
						if (from_command->address_range()) {
							Data data;
							data.PushByte(rand());
							command = AddCommand(data);
							command->set_address_range(from_command->address_range());
							gate_command = AddGate(next_command, next_command->address_range());
							command->set_block(gate_command->block());
							command->block()->set_start_index(command->block()->start_index() - 1);
						}
						else {
							gate_command = AddGate(next_command, next_command->address_range());
						}
					}
					else {
						gate_command = NULL;
					}

					link->AddGateCommand(gate_command);
					break;

				case ltNative:
					native_command = from_command->Clone(this);
					AddObject(native_command);

					if (next_command) {
						gate_command = AddGate(next_command, native_command->address_range());
					}
					else {
						gate_command = AddShortGate(NULL, native_command->address_range());
						gate_command->set_operand_value(0, from_command->address() + from_command->original_dump_size());
						gate_command->CompileToNative();
					}
					block = gate_command->block();
					block->set_start_index(block->start_index() - 1);
					native_command->set_block(block);

					link->AddGateCommand(native_command);
					break;

				case ltDualSEHBlock:
					if (to_command) {
						block = AddBlock(count(), true);
						gate_command = reinterpret_cast<IntelCommand *>(to_command->Clone(this));
						AddObject(gate_command);
						CommandLink *src_link = to_command->link();
						if (src_link) {
							CommandLink *dst_link = src_link->Clone(link_list());
							dst_link->set_from_command(gate_command);
							dst_link->set_to_command(src_link->to_command());
							link_list()->AddObject(dst_link);
						}
						command = new IntelCommand(this, cpu_address_size(), cmJmp, IntelOperand(otValue, cpu_address_size(), 0, link->to_address() + 5));
						AddObject(command);
						command->AddLink(0, ltJmp, next_command);
						block->set_end_index(count() - 1);

						if (gate_command->link()->to_command())
							gate_command->link()->set_to_command(AddGate(gate_command->link()->to_command(), gate_command->address_range()));

						if (command->link()->to_command())
							command->link()->set_to_command(AddGate(command->link()->to_command(), command->address_range()));

						for (j = block->start_index(); j <= block->end_index(); j++) {
							command = item(j);
							command->set_block(block);
							command->CompileToNative();
						}

						link->AddGateCommand(gate_command);
					}
					break;

				case ltFilterSEHBlock:
					if (to_command) {
						block = AddBlock(count(), true);
						size_t index = IndexOf(to_command);
						size_t n = 2 + static_cast<uint32_t>(reinterpret_cast<IntelCommand *>(link->parent_command())->operand(0).value) * 2;
						for (j = 0; j < n; j++) {
							native_command = item(index + j);
							command = native_command->Clone(this);
							AddObject(command);
							CommandLink *src_link = native_command->link();
							if (src_link) {
								CommandLink *dst_link = src_link->Clone(link_list());
								dst_link->set_from_command(command);
								dst_link->set_to_command(src_link->to_command());
								link_list()->AddObject(dst_link);
							}
							command->set_block(block);
						}
						block->set_end_index(count() - 1);
						for (j = block->start_index(); j <= block->end_index(); j++) {
							CommandLink *src_link = item(j)->link();
							if (!src_link || !src_link->to_command())
								continue;

							src_link->set_to_command(AddGate(src_link->to_command(), src_link->from_command()->address_range()));
						}
						gate_command = item(block->start_index());
						link->AddGateCommand(gate_command);
					}
					break;

				case ltCase:
					if (to_command) {
						block = AddBlock(count());
						block->set_virtual_machine(parent_command->block()->virtual_machine());

						command = AddCommand(cmJmp);
						command->AddLink(-1, ltNone);
						command->include_section_option(rtLinkedToInt);
						command->set_block(block);
						if (command->block()->virtual_machine()->backward_direction())
							command->include_section_option(rtBackwardDirection);

						command->AddBeginSection(ctx);
						if (from_command->section_options() & rtLinkedFrom) {
							command->AddVMCommand(ctx, cmPush, otValue, cpu_address_size(), 0, voLinkCommand | voFixup);
							command->AddEndSection(ctx, cmJmp, 0);
						}
						else {
							command->AddVMCommand(ctx, cmPush, otValue, cpu_address_size(), 0, voLinkCommand | voFixup);
							command->AddEndSection(ctx, cmRet);
						}
						link->AddGateCommand(command);
					}
					break;
				}
			}
		}
	}

	for (i = 0; i < count(); i++) {
		command = item(i);
		if (!command->block())
			continue;

		for (j = 0; j < 3; j++) {
			IntelOperand operand = command->operand(j);
			if (operand.type == otNone)
				break;

			IFixup *fixup = operand.fixup;
			if (fixup && fixup != NEED_FIXUP) {
				if (command->options() & roClearOriginalCode)
					fixup->set_deleted(true);
				if (command->block()->type() & mtExecutable) {
					if (command->block()->address()) {
						fixup->set_deleted(false);
					}
					else {
						fixup = fixup->Clone(ctx.file->fixup_list());
						ctx.file->fixup_list()->AddObject(fixup);
						fixup->set_deleted(false);
						command->set_operand_fixup(j, fixup);
					}
				}
				else {
					for (size_t k = 0; k < command->count(); k++) {
						IntelVMCommand *vm_command = command->item(k);
						if (vm_command->fixup()) {
							fixup = fixup->Clone(ctx.file->fixup_list());
							ctx.file->fixup_list()->AddObject(fixup);
							fixup->set_deleted(false);
							vm_command->set_fixup(fixup);
						}
					}
				}
			}
		}
	}

	if (function_info_list()->count()) {
		std::set<AddressRange *> range_list;

		for (i = 0; i < block_list()->count(); i++) {
			CommandBlock *block = block_list()->item(i);
			if ((block->type() & mtExecutable) == 0)
				continue;

			AddressRange *block_range = item(block->start_index())->address_range();
			if (block_range)
				range_list.insert(block_range);

			for (j = block->start_index(); j <= block->end_index(); j++) {
				AddressRange *range = item(j)->address_range();
				if (range && range != block_range)
					range_list.insert(range);
			}
		}

		for (i = 0; i < function_info_list()->count(); i++) {
			FunctionInfo *info = function_info_list()->item(i);
			for (size_t j = 0; j < info->count(); j++) {
				AddressRange *range = info->item(j);
				if (range_list.find(range) == range_list.end()) {
					Data data;
					data.PushByte(rand());

					CommandBlock *block = AddBlock(count(), true);
					ICommand *command = AddCommand(data);
					command->set_block(block);
					command->set_address_range(range);
				}
			}
		}
	}
}

void IntelFunction::CompileInfo(const CompileContext &ctx)
{
	BaseFunction::CompileInfo(ctx);

	size_t i;
	FunctionInfo *info;
	AddressRange *range;
	uint64_t base_value;
	IntelCommand *command;

	for (i = 0; i < range_list()->count(); i++) {
		range = range_list()->item(i);
		info = range->link_info();
		if (!info)
			continue;

		switch (info->base_type()) {
		case btImageBase:
			base_value = ctx.file->image_base();
			break;
		case btFunctionBegin:
			base_value = info->begin();
			break;
		default:
			base_value = info->base_value();
			break;
		}

		if (range->begin_entry()) {
			command = reinterpret_cast<IntelCommand *>(range->begin_entry());
			if (command->type() == cmDC) {
				AddressRange *prev = NULL;
				for (size_t j = 0; j < i; j++) {
					AddressRange *tmp = range_list()->item(j);
					if (tmp->link_info() == info && tmp->original_end() == range->original_begin() && tmp->begin_entry()) {
						prev = tmp;
						break;
					}
				}
				base_value = prev ? prev->begin() : info->begin();
			}
			command->set_operand_value(0, range->begin() - base_value);
			command->CompileToNative();
		}
		if (range->end_entry()) {
			command = reinterpret_cast<IntelCommand *>(range->end_entry());
			command->set_operand_value(0, range->end() - base_value);
			command->CompileToNative();
		}
		if (range->size_entry()) {
			command = reinterpret_cast<IntelCommand *>(range->size_entry());
			command->set_operand_value(0, range->end() - range->begin());
			if (command->type() == cmDB) {
				uint32_t size = static_cast<uint32_t>(command->operand(0).value);
				Data data;
				if (command->comment().value == "UWOP_EPILOG") {
					uint32_t offset = static_cast<uint8_t>(info->end() - range->begin());
					UNWIND_CODE unwind_code;
					unwind_code.FrameOffset = static_cast<uint16_t>(command->dump_value(0, osWord));
					if (unwind_code.OpInfo & 1) {
						unwind_code.CodeOffset = static_cast<uint8_t>(offset);
						data.PushWord(unwind_code.FrameOffset);
					} else {
						unwind_code.CodeOffset = static_cast<uint8_t>(size);
						data.PushWord(unwind_code.FrameOffset);
						unwind_code.CodeOffset = static_cast<uint8_t>(offset);
						unwind_code.OpInfo = static_cast<uint8_t>(offset >> 8);
						data.PushWord(unwind_code.FrameOffset);
					}
					command->set_dump(data.data(), data.size());
				} else if (command->comment().value.substr(0, 18) == "DW_CFA_advance_loc") {
					if (size <= 0x3f) {
						data.PushByte(DW_CFA_advance_loc | (size & 0x3f));
					}
					else if (size <= 0xff) {
						data.PushByte(DW_CFA_advance_loc1);
						data.PushByte(static_cast<uint8_t>(size));
					}
					else if (size <= 0xffff) {
						data.PushByte(DW_CFA_advance_loc2);
						data.PushWord(static_cast<uint16_t>(size));
					}
					else {
						data.PushByte(DW_CFA_advance_loc4);
						data.PushDWord(size);
					}
					command->set_dump(data.data(), data.size());
				}
			} else 
				command->CompileToNative();
		}
	}
}

void IntelFunction::CompileLinks(const CompileContext &ctx)
{
	BaseFunction::CompileLinks(ctx);

	bool need_encrypt = (ctx.options.flags & cpEncryptBytecode) != 0;
	for (size_t i = 0; i < block_list()->count(); i++) {
		CommandBlock *block = block_list()->item(i);

		// skip native blocks
		if (block->type() & mtExecutable)
			continue;

		IntelVirtualMachine *virtual_machine = reinterpret_cast<IntelVirtualMachine *>(block->virtual_machine());
		virtual_machine->CompileBlock(*block, need_encrypt);
	}
}

void IntelFunction::AddWatermarkReference(uint64_t address, const std::string &value)
{
	IntelCommand *ref_command = GetCommandByAddress(address);
	if (!ref_command || value.empty())
		return;

	uint32_t key = rand32();
	uint16_t len = static_cast<uint16_t>(value.size());
	Data data;
	data.PushDWord(key);
	data.PushWord(len);
	for (size_t i = 0; i < value.size(); i++) {
		data.PushByte(value[i] ^ static_cast<uint8_t>(_rotl32(key, (int)i) + i));
	}
	IntelCommand *data_command = AddCommand(data);

	switch (ref_command->type()) {
	case cmLea:
		{
			IntelCommand *mem_command = AddCommand(cpu_address_size() == osDWord ? cmDD : cmDQ, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
			mem_command->AddLink(0, ltOffset, data_command);
			mem_command->CompileToNative();

			ref_command->AddLink(1, ltOffset, mem_command);
		}
		break;
	case cmMov:
		ref_command->Init(cmLea, ref_command->operand(0), ref_command->operand(1));
		ref_command->AddLink(1, ltOffset, data_command);
		break;
	default:
		throw std::runtime_error("Unknown reference command");
	}
}

void IntelFunction::ReadFromBuffer(Buffer &buffer, IArchitecture &file)
{
	BaseFunction::ReadFromBuffer(buffer, file);

	size_t i, j, k;
	IntelCommand *command;
	bool syscall_found = false;

	for (i = 0; i < count(); i++) {
		command = item(i);
		if (command->type() == cmCpuid || command->type() == cmSbb)
			command->include_option(roNoNative);
		else if (command->type() == cmPopf) {
			Data data;
			command->CompileToNative();
			for (k = 0; k < command->dump_size(); k++) {
				data.PushByte(command->dump(k));
			}
			command->Init(cmNop);

			for (j = i; j < count(); j++) {
				command = item(j);
				if (command->type() == cmCpuid || command->type() == cmRdtsc) {
					command->CompileToNative();
					for (k = 0; k < command->dump_size(); k++) {
						data.PushByte(command->dump(k));
					}
					data.PushByte(0x90);
					command->Init(data);
					command->AddLink(-1, ltNative);
					break;
				}
			}
		} else if (command->operand(1).type == otValue && static_cast<uint32_t>(command->operand(1).value) == FACE_SYSCALL) {
			command->set_operand_value(1, 0);
			command->CompileToNative();
			IntelOperand operand = command->operand(0);
			IntelCommandInfoList command_info_list(cpu_address_size());
			size_t cur_index = i + 1;
			std::vector<size_t> stack;

			while (cur_index < count()) {
				command = item(cur_index);
				bool is_end = command->is_end();
				if (command->type() == cmMov) {
					if (operand.type == otRegistr && command->operand(1) == operand) {
						operand = command->operand(0);
						cur_index++;
						continue;
					}
				} else if (command->type() == cmCall) {
					if (command->operand(0) == operand) {
						command->Init(cmSyscall, command->operand(0));
						command->CompileToNative();
						command->include_option(roNoNative);
						syscall_found = true;
					}
					if (operand.type != otRegistr || operand.registr == regEAX)
						is_end = true;
				} else if ((command->type() == cmJmp || command->type() == cmJmpWithFlag) && command->link()) {
					IntelCommand *link_command = GetCommandByAddress(command->link()->to_address());
					if (link_command) {
						k = IndexOf(link_command);
						if (k != NOT_ID)
							stack.push_back(k);
					}
				}
				if (command->GetCommandInfo(command_info_list)) {
					if (operand.type == otRegistr && command_info_list.GetInfo(atWrite, otRegistr, operand.registr))
						is_end = true;
				} else {
					is_end = true;
				}

				if (is_end) {
					for (k = stack.size(); k > 0; k--) {
						if (stack[k - 1] <= cur_index)
							stack.erase(stack.begin() + k - 1);
					}
					if (stack.empty())
						break;

					cur_index = stack[0];
					for (k = 0; k < stack.size(); k++) {
						if (cur_index > stack[k])
							cur_index = stack[k];
					}
				} else {
					cur_index++;
				}
			}
		}
	}

	if (syscall_found) {
		CallingConvention calling_convention = file.calling_convention();
		for (i = 0; i < count(); i++) {
			command = item(i);
			if (command->type() != cmSyscall)
				continue;

			IntelCommand *next_command = item(i + 1);
			if (next_command->type() == cmAdd && next_command->operand(0).type == otRegistr && next_command->operand(0).registr == regESP)
				continue;

			k = 0;
			for (j = i; j > 0; j--) {
				IntelCommand *param_command = item(j - 1);

				switch (param_command->type()) {
				case cmPush:
					if (calling_convention == ccStdcall) {
						k++;
					}
					else {
						param_command = NULL;
					}
					break;
				case cmMov: case cmLea: case cmXor: case cmMovsxd:
					if (calling_convention == ccMSx64) {
						if (param_command->operand(0).type == otRegistr) {
							switch (param_command->operand(0).registr) {
							case regECX:
								k = std::max<size_t>(k, 1);
								break;
							case regEDX:
								k = std::max<size_t>(k, 2);
								break;
							case regR8:
								k = std::max<size_t>(k, 3);
								break;
							case regR9:
								k = std::max<size_t>(k, 4);
								break;
							}
						}
						else if (param_command->operand(0).type == (otMemory | otBaseRegistr | otValue) && param_command->operand(0).base_registr == regESP) {
							switch (param_command->operand(0).value) {
							case 0x20:
								k = std::max<size_t>(k, 5);
								break;
							case 0x28:
								k = std::max<size_t>(k, 6);
								break;
							case 0x30:
								k = std::max<size_t>(k, 7);
								break;
							case 0x38:
								k = std::max<size_t>(k, 8);
								break;
							case 0x40:
								k = std::max<size_t>(k, 9);
								break;
							case 0x48:
								k = std::max<size_t>(k, 10);
								break;
							default:
								if (param_command->operand(0).value >= 0x50)
									k = NOT_ID;
								break;
							}
						}
					}
					break;
				case cmCall: case cmJmp: case cmJmpWithFlag: case cmRet:
					param_command = NULL;
					break;
				}
				if (!param_command || link_list()->GetLinkByToAddress(ltNone, param_command->address()))
					break;
			}
			if (k == NOT_ID)
				continue;

			command->include_option(roInternal);
			command->set_operand_value(2, k);
		}
	}

	if (file.owner()->format_name() != "PE" && compilation_type() != ctMutation && cpu_address_size() == osQWord) {
		// clang can use stack less than RSP
		bool is_use_rbp = false;
		uint64_t delta_rsp = 0;
		uint64_t sub_rsp_value = 0;
		for (j = 0; j < count(); j++) {
			command = item(j);
			switch (command->type()) {
			case cmMov:
				if (command->operand(0).type == otRegistr && command->operand(0).registr == regEBP && command->operand(1).type == otRegistr && command->operand(1).registr == regESP) {
					is_use_rbp = true;
				} else if (is_use_rbp && ((command->operand(0).type == (otMemory | otRegistr | otValue) && command->operand(0).registr == regEBP) 
										|| ((command->operand(0).type & (otMemory | otBaseRegistr | otValue)) == (otMemory | otBaseRegistr | otValue) && command->operand(0).base_registr == regEBP))) {
					uint64_t value = command->operand(0).value;
					if (static_cast<int64_t>(value) < 0 && 0 - value > delta_rsp) {
						sub_rsp_value = std::max((0 - value) - delta_rsp, sub_rsp_value);
					}
				} else if (((command->operand(0).type == (otMemory | otRegistr | otValue) && command->operand(0).registr == regESP) 
										|| ((command->operand(0).type & (otMemory | otBaseRegistr | otValue)) == (otMemory | otBaseRegistr | otValue) && command->operand(0).base_registr == regESP))) {
					uint64_t value = command->operand(0).value;
					if (static_cast<int64_t>(value) < 0)
						sub_rsp_value = std::max((0 - value), sub_rsp_value);
				}
				break;
			case cmPush:
				if (is_use_rbp)
					delta_rsp += OperandSizeToValue(cpu_address_size());
				break;
			case cmSub:
				if (is_use_rbp && command->operand(0).type == otRegistr && command->operand(0).registr == regESP && command->operand(1).type == otValue) {
					delta_rsp += command->operand(1).value;
				}
				break;
			}
		}
		if (sub_rsp_value) {
			size_t push_index = 0;
			size_t pop_index = 0;
			for (j = 0; j < count(); j++) {
				IntelCommand *command = item(j);

				for (i = 0; i < 3; i++) {
					IntelOperand operand = command->operand(i);
					if (operand.type == otNone)
						break;

					if (((operand.type & (otMemory | otRegistr)) == (otMemory | otRegistr) && operand.registr == regESP)
						|| ((operand.type & (otMemory | otBaseRegistr)) == (otMemory | otBaseRegistr) && operand.base_registr == regESP)) {
						command->set_operand_value(i, operand.value + sub_rsp_value);
						command->CompileToNative();
					}
				}

				switch (command->type()) {
				case cmPush:
					push_index = j;
					break;
				case cmMov:
					if (command->operand(0).type == otRegistr && command->operand(0).registr == regEBP && command->operand(1).type == otRegistr && command->operand(1).registr == regESP)
						push_index = j;
					break;
				case cmPop:
				case cmRet:
					if (!pop_index)
						pop_index = j;
					break;
				}
			}

			command = new IntelCommand(this, cpu_address_size(), cmSub, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, sub_rsp_value));
			command->CompileToNative();
			InsertObject(push_index + 1, command);

			if (pop_index > push_index)
				pop_index++;

			IntelCommand *pop_command = item(pop_index);

			command = new IntelCommand(this, cpu_address_size(), static_cast<IntelCommandType>(pop_command->type()), pop_command->operand(0), pop_command->operand(1));
			command->CompileToNative();
			InsertObject(pop_index + 1, command);

			pop_command->Init(cmAdd, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, sub_rsp_value));
			pop_command->CompileToNative();
		}
	}

#ifdef CHECKED
	for (i = 0; i < count(); i++) {
		item(i)->update_hash();
	}
#endif
}

/**
 * SectionCryptor
 */

SectionCryptor::SectionCryptor(SectionCryptorList *owner, OperandSize cpu_address_size)
	: owner_(owner), parent_cryptor_(NULL)
{
	size_t i;

	registr_order_.push_back(regEFX);
	registr_order_.push_back(regEAX);
	registr_order_.push_back(regECX);
	registr_order_.push_back(regEDX);
	registr_order_.push_back(regEBX);
	registr_order_.push_back(regEBP);
	registr_order_.push_back(regESI);
	registr_order_.push_back(regEDI);
	if (cpu_address_size == osQWord) {
		for (i = 8; i < 16; i++) {
			registr_order_.push_back((uint8_t)i);
		}
	}
	for (i = 0; i < registr_order_.size(); i++) {
		std::swap(registr_order_[i], registr_order_[rand() % registr_order_.size()]);
	}
}

SectionCryptor::~SectionCryptor()
{
	if (owner_)
		owner_->RemoveObject(this);
}

void SectionCryptor::set_end_cryptor(SectionCryptor *cryptor) 
{ 
	if (cryptor == this || cryptor->end_cryptor() == this)
		return;

	if (parent_cryptor_)
		parent_cryptor_->set_end_cryptor(cryptor);
	else
		parent_cryptor_ = cryptor;
}

SectionCryptor *SectionCryptor::end_cryptor()
{ 
	SectionCryptor *cur_cryptor = this;
	while (cur_cryptor->parent_cryptor_) {
		cur_cryptor = cur_cryptor->parent_cryptor_;
	}
	return cur_cryptor;
}

/**
 * SectionCryptorList
 */

SectionCryptorList::SectionCryptorList(IFunction *owner)
	: ObjectList<SectionCryptor>(), owner_(owner)
{

}

SectionCryptor *SectionCryptorList::Add()
{
	SectionCryptor *section_cryptor = new SectionCryptor(this, owner_->cpu_address_size());
	AddObject(section_cryptor);
	return section_cryptor;
}

/**
 * IntelFileHelper
 */

IntelFileHelper::IntelFileHelper()
	: IObject(), marker_index_(0)
{
	marker_name_list_ = new MapFunctionList(NULL);
}

IntelFileHelper::~IntelFileHelper()
{
	delete marker_name_list_;
}

void IntelFileHelper::AddMarker(IArchitecture &file, uint64_t address, uint64_t name_reference, uint64_t name_address, ObjectType type, uint8_t tag, bool is_unicode)
{
	if (type == otUnknown)
		return;

	std::string marker_name;
	MapFunction *map_function;
	size_t name_length = 0;
	if (name_address) {
		// read marker name
		if (file.AddressSeek(name_address)) {
			if (is_unicode) {
				os::unicode_string wname;
				for (;;) {
					os::unicode_char w = file.ReadWord();
					if (w == 0)
						break;
					wname.push_back(w);
				}
				name_length = (wname.size() + 1) * sizeof(os::unicode_char);
				marker_name = os::ToUTF8(wname);
			} else {
				for (;;) {
					char c = file.ReadByte();
					if (c == 0)
						break;
					marker_name.push_back(c);
				}
				name_length = marker_name.size() + 1;
				marker_name = file.ANSIToUTF8(marker_name);
			}
		}

		map_function = marker_name_list_->GetFunctionByAddress(name_address);
		if (!map_function) {
			map_function = marker_name_list_->Add(name_address, name_address + name_length, otString, marker_name);
			// need add marker name to string_list for string references searching
			string_list_.push_back(map_function);
		}
		map_function->reference_list()->Add(name_reference, 0);
	}

	std::string name = marker_name.empty() ? string_format("VMProtectMarker%d", ++marker_index_) : string_format("VMProtectMarker \"%s\"", marker_name.c_str());

	map_function = file.map_function_list()->GetFunctionByAddress(address);
	if (!map_function) {
		map_function = file.map_function_list()->Add(address, 0, type, name);
	} else {
		map_function->set_type(type);
		map_function->set_name(name);
	}
	map_function->set_name_address(name_address);
	map_function->set_name_length(name_length);
	switch (tag & 0x7f) {
	case 1:
		map_function->set_compilation_type(ctVirtualization);
		break;
	case 2:
		map_function->set_compilation_type(ctMutation);
		break;
	case 3:
		map_function->set_compilation_type(ctUltra);
		break;
	}
	if (tag & 0x80)
		map_function->set_lock_to_key(true);
}

void IntelFileHelper::AddString(IArchitecture &file, uint64_t address, uint64_t reference, bool is_unicode)
{
	uint64_t end_address;
	std::string name;
	os::unicode_string wname;
	char c;
	os::unicode_char w;
	MapFunction *map_function;

	if (!file.AddressSeek(address))
		return;

	// read string from file
	if (is_unicode) {
		for (;;) {
			w = file.ReadWord();
			if (w == 0)
				break;
			wname.push_back(w);
		}
		end_address = address + (wname.size() + 1) * sizeof(w);
		name = os::ToUTF8(wname);
	} else {
		for (;;) {
			c = file.ReadByte();
			if (c == 0)
				break;
			name.push_back(c);
		}
		end_address = address + name.size() + 1;
		name = file.ANSIToUTF8(name);
	}
	name = "string \"" + name + "\"";

	map_function = file.map_function_list()->Add(address, end_address, otString, name);
	map_function->reference_list()->Add(reference, address);

	if (std::find(string_list_.begin(), string_list_.end(), map_function) == string_list_.end())
		string_list_.push_back(map_function);
}

void IntelFileHelper::AddEndMarker(IArchitecture &file, uint64_t address, uint64_t next_address, ObjectType type)
{
	file.end_marker_list()->Add(address, next_address, 0, 0, type);
}

void IntelFileHelper::Parse(IArchitecture &file)
{
	SignatureList asm_signatures, import_signatures, string_signatures, compiler_function_signatures;
	ISectionList *segment_list;
	size_t i, k, j, r, n, pointer_size, c;
	ISection *segment;
	uint64_t read_size, address, buf_address, operand_address, tmp_address, pointer_value, last_operand_address;
	uint8_t buf[4096], b, registr;
	Signature *sign;
	IntelFunctionList function_list(NULL);
	IntelFunction command_list(NULL, file.cpu_address_size());
	IntelCommand *command, *tmp_command;
	IImportFunction *import_function;
	IntelOperand operand, tmp_operand;
	IFixupList *fixup_list;
	IImportList *import_list;
	std::map<uint64_t, IImportFunction *> jmp_references;
	MarkerCommandList marker_command_list;
	MarkerCommand *marker_command;
	MapFunction *map_function;
	MapFunctionList *map_function_list;
	CompilerFunctionList *compiler_function_list;
	bool is_data_reference;
	std::map<uint64_t, IImportFunction *> call_import_function_map;

	asm_signatures.Add("EB10564D50726F7465637420626567696E0?");	// "VMProtect begin"
	asm_signatures.Add("EB0E564D50726F7465637420656E6400");	// "VMProtect end"

	import_signatures.Add("FF15");  // call dword ptr [xxxx]
	import_signatures.Add("FF25");  // jmp dword ptr [xxxx]
	import_signatures.Add("FF2425");// jmp dword ptr [xxxx]
	import_signatures.Add("E8");    // call xxxx
	import_signatures.Add("A1");    // mov eax, [xxxx]
	import_signatures.Add((file.cpu_address_size() == osQWord) ? "4?8B" : "8B");  // mov reg, [xxxx]
	import_signatures.Add((file.cpu_address_size() == osQWord) ? "4?8D" : "8D");  // lea reg, [xxxx]
	uint64_t plt_got_address = 0;

	if (file.cpu_address_size() == osDWord) {
		// patch TlsAlloc in Delphi6
		compiler_function_signatures.Add("5352BA????????89C38B5203B8????????8B12B905000000", cfPatchImport);

		// base registr
		compiler_function_signatures.Add("E8000000005?", cfBaseRegistr);

		// get base registr
		compiler_function_signatures.Add("8B1C24C3", cfGetBaseRegistr);
		compiler_function_signatures.Add("8B3424C3", cfGetBaseRegistr);
		compiler_function_signatures.Add("8B0424C3", cfGetBaseRegistr);
		compiler_function_signatures.Add("8B0C24C3", cfGetBaseRegistr);
		compiler_function_signatures.Add("8B1424C3", cfGetBaseRegistr);

		// DllFunctionCall in VB6
		compiler_function_signatures.Add("A1????????0BC07402FFE068????????B8????????FFD0FFE0", cfDllFunctionCall);

		// CxxSEH
		compiler_function_signatures.Add("6AFF68????????64A100000000", cfCxxSEH);
		compiler_function_signatures.Add("6AFF68????????68????????64A100000000", cfCxxSEH3);
		compiler_function_signatures.Add("6AFE68????????68????????64A100000000", cfCxxSEH4);
		compiler_function_signatures.Add("68????????64FF3500000000", cfSEH4Prolog);

		// VB6SEH
		compiler_function_signatures.Add("83EC??68????????64A1000000005064892500000000", cfVB6SEH);
		compiler_function_signatures.Add("81EC??????68????????64A1000000005064892500000000", cfVB6SEH);

		// __InitExceptBlockLDTC in BCB
		compiler_function_signatures.Add("538BDD03580?8943088D44240889430CC74304????????66C74310000066C743120000C7431C000000006467A1000089036467891E00005BC3", cfInitBCBSEH);

		// _pei386_runtime_relocator in MinGW
		compiler_function_signatures.Add("C705????????01000000B8????????2D????????83F8077EDDBB????????83F80B7E618B3D????????85FF750B8B35????????85F6743D", cfRelocatorMinGW);
		compiler_function_signatures.Add("C705????????01000000E8????????8D04408D04851E00000083E0F0E8????????C705????????0000000029C48D44241F83E0F0A3????????B8????????2D????????83F8070F8E??00000083F80B0F8E??010000A1????????85C00F85??000000A1????????85C00F85??000000", cfRelocatorMinGW);
		compiler_function_signatures.Add("C705????????01000000E8????????8D04408D04851E000000C1E804C1E004E8????????C705????????0000000029C48D44241F83E0F0A3????????B8????????2D????????83F807", cfRelocatorMinGW);

		if (file.owner()->format_name() == "ELF") {
			import_signatures.Add("E9");    // jmp xxxx
			if (ELFDirectory *plt_got = reinterpret_cast<ELFArchitecture &>(file).command_list()->GetCommandByType(DT_PLTGOT)) {
				plt_got_address = plt_got->value();
				import_signatures.Add("FFA3");  // jmp dword ptr [ebx + xxxx]
			}
		}
	}
	else {
		compiler_function_signatures.Add("554889E55DE9????????", cfJmpFunction);
	}

	segment_list = file.segment_list();
	fixup_list = file.fixup_list();
	import_list = file.import_list();
	map_function_list = file.map_function_list();
	compiler_function_list = file.compiler_function_list();

	for (i = 0; i < import_list->count(); i++) {
		IImport *import = import_list->item(i);
		for (j = 0; j < import->count(); j++) {
			import_function = import->item(j);
			if (import_function->options() & ioIsRelative) {
				import_function->map_function()->reference_list()->Add(import_function->address(), import_function->address() + 1);
				jmp_references[import_function->address()] = import_function;
			}
		}
	}

	j = 0; 
	for (i = 0; i < segment_list->count(); i++) {
		segment = segment_list->item(i);
		if (!segment->need_parse())
			continue;

		j += static_cast<size_t>(segment->physical_size());
		if (compiler_function_signatures.count() && (segment->memory_type() & mtExecutable))
			j += static_cast<size_t>(segment->physical_size());
	}
	std::string arch_name = (file.owner()->visible_count() > 1) ? string_format(" (%s)", file.name().c_str()) : "";
	file.StartProgress(string_format("%s %s%s...", language[lsLoading].c_str(), os::ExtractFileName(file.owner()->file_name().c_str()).c_str(), arch_name.c_str()), j);

	if (compiler_function_signatures.count()) {
		// search compiler functions
		for (i = 0; i < segment_list->count(); i++) {
			segment = segment_list->item(i);
			if (!segment->need_parse() || (segment->memory_type() & mtExecutable) == 0)
				continue;

			compiler_function_signatures.InitSearch();
			read_size = 0;
			while (read_size < segment->physical_size()) {
				file.Seek(segment->physical_offset() + read_size);
				n = file.Read(buf, std::min(static_cast<size_t>(segment->physical_size() - read_size), sizeof(buf)));
				file.StepProgress(n);
				for (k = 0; k < n; k++) {
					b = buf[k];
					buf_address = segment->address() + read_size + k + 1;

					for (j = 0; j < compiler_function_signatures.count(); j++) {
						sign = compiler_function_signatures.item(j);
						if (sign->SearchByte(b)) {
							address = buf_address - sign->size();
							CompilerFunctionType func_type = static_cast<CompilerFunctionType>(sign->tag());
							switch (func_type) {
							case cfBaseRegistr:
								{
									IntelOperand base_operand = IntelOperand(otRegistr, command_list.cpu_address_size(), b & 7);
									uint64_t value = 0;
									command = command_list.ReadValidCommand(file, address + sign->size());
									if (command) {
										if (command->type() == cmMov && command->operand(1).type == otRegistr && command->operand(1).registr == base_operand.registr && (command->operand(0).type & otMemory))
											base_operand = command->operand(0); // mov [xxxx], reg
										else {
											if (command->type() == cmAdd && command->operand(0).type == otRegistr && command->operand(0).registr == base_operand.registr && command->operand(1).type == otValue)
												value = command->operand(1).value; // add reg, xxxx

											IntelCommandInfoList command_info_list(file.cpu_address_size());
											std::set<uint64_t> address_list;
											address_list.insert(command->next_address());
											while (!address_list.empty()) {
												tmp_address = *address_list.begin();
												for (;;) {
													std::set<uint64_t>::const_iterator it = address_list.find(tmp_address);
													if (it != address_list.end())
														address_list.erase(it);

													command = command_list.ReadValidCommand(file, tmp_address);
													if (!command || (command->options() & roBreaked) || command->is_data())
														break;

													if ((command->type() == cmJmp && command->operand(0).type == otValue) || command->type() == cmJmpWithFlag) {
														if (command->operand(0).value > tmp_address)
															address_list.insert(command->operand(0).value);
													}

													if (command->type() == cmJmp || command->type() == cmRet || command->type() == cmIret || command->type() == cmCall)
														break;

													if (!command->GetCommandInfo(command_info_list) || command_info_list.GetInfo(atWrite, otRegistr, base_operand.registr))
														break;

													if (command->type() == cmMov && command->operand(1).type == otRegistr && command->operand(1).registr == base_operand.registr && (command->operand(0).type & otMemory)) {
														base_operand = command->operand(0); // mov [xxxx], reg
														address_list.clear();
														break;
													}

													tmp_address = command->next_address();
												}
											}
										}
									}
									address += 5;
									CompilerFunction *compiler_function = compiler_function_list->Add(func_type, address);
									compiler_function->add_value(base_operand.encode());
									if (value)
										compiler_function->add_value(value);
								}
								break;

							case cfDllFunctionCall:
								command_list.ReadFromFile(file, address);
								if (command_list.count() == 8) {
									if (file.AddressSeek(command_list.item(4)->operand(0).value)) {
										std::string dll_name;
										std::string func_name;
										uint32_t dll_name_address = file.ReadDWord();
										uint32_t func_name_address = file.ReadDWord();
										if (file.AddressSeek(dll_name_address))
											dll_name = file.ReadString();
										if (file.AddressSeek(func_name_address))
											func_name = file.ReadString();
										std::transform(dll_name.begin(), dll_name.end(), dll_name.begin(), tolower);
										if (dll_name.find('.') == NOT_ID)
											dll_name += ".dll";
										if (dll_name == "vmprotectsdk32.dll") {
											const ImportInfo *import_info = file.import_list()->GetSDKInfo(func_name);
											if (import_info) {
												CompilerFunction *compiler_function = compiler_function_list->Add(func_type, address);
												compiler_function->add_value(import_info->encode());
												compiler_function->add_value(dll_name_address);
												compiler_function->add_value(dll_name.size() + 1);
												compiler_function->add_value(func_name_address);
												compiler_function->add_value(func_name.size() + 1);
											}
										}
									}
								}
								break;

							case cfCxxSEH:
							case cfCxxSEH3:
							case cfCxxSEH4:
								command = command_list.ReadValidCommand(file, address + 2);
								if (command) {
									CompilerFunction *compiler_function = compiler_function_list->Add(func_type, address);
									compiler_function->add_value(command->operand(0).value);
								}
								break;

							case cfVB6SEH:
								{
									command = command_list.ReadValidCommand(file, address);
									uint64_t offset = 4 - command->operand(1).value;
									for (;;) {
										command = command_list.ReadValidCommand(file, address);
										if (!command || command->is_end())
											break;

										if (command->operand(0).type == (otMemory | otRegistr | otValue) 
											&& command->operand(0).registr == regEBP 
											&& command->operand(0).size == osDWord
											&& command->operand(0).value == offset
											&& command->operand(1).type == otValue) { // mov [ebp + xxxx], xxxx
											CompilerFunction *compiler_function = compiler_function_list->Add(cfVB6SEH, command->address());
											compiler_function->add_value(command->operand(1).value);
											break;
										}
										address = command->next_address();
									}
								}
								break;

							case cfInitBCBSEH:
								{
									CompilerFunction *compiler_function = compiler_function_list->Add(cfInitBCBSEH, address);
									if (file.AddressSeek(address + 5)) {
										b = file.ReadByte();
										if (b == 8)
											compiler_function->add_value(2);
										else if (b == 4)
											compiler_function->add_value(1);
									}
								}
								break;

							case cfRelocatorMinGW:
								{
									command_list.clear();
									size_t d;
									switch (sign->size()) {
									case 73:
										d = 11;
										break;
									case 111:
										d = 10;
										break;
									default:
										d = 0;
										break;
									}

									while (command_list.count() < 13 + d) {
										command = command_list.ReadValidCommand(file, address);
										if (!command)
											break;

										address = command->next_address();
									}

									if (command_list.count() == 13 + d) {
										CompilerFunction *compiler_function = compiler_function_list->Add(cfRelocatorMinGW, address);
										compiler_function->add_value(command_list.item(0)->operand(0).value);
										compiler_function->add_value(command_list.item(d + 2)->operand(1).value);
										compiler_function->add_value(command_list.item(d + 1)->operand(1).value);
									}
								}
								break;

							case cfPatchImport:
								command = command_list.ReadValidCommand(file, address + 2);
								if (command && file.AddressSeek(command->operand(1).value + 3)) {
									import_function = import_list->GetFunctionByAddress(file.ReadDWord());
									if (import_function)
										import_function->include_option(ioHasDataReference);
								}
								break;

							case cfJmpFunction:
								command = command_list.ReadValidCommand(file, address + 5);
								if (command && file.segment_list()->GetMemoryTypeByAddress(command->operand(0).value) & mtExecutable) {
									CompilerFunction *compiler_function = compiler_function_list->Add(cfJmpFunction, address);
									compiler_function->add_value(command->operand(0).value);
								}
								break;

							case cfGetBaseRegistr:
								command = command_list.ReadValidCommand(file, address);
								if (command) {
									CompilerFunction *compiler_function = compiler_function_list->Add(cfGetBaseRegistr, address);
									compiler_function->add_value(command->operand(0).registr);
								}
								break;

							default:
								compiler_function_list->Add(func_type, address);
								break;
							}
						}
					}
				}
				read_size += n;
			}
		}
	}

	pointer_size = OperandSizeToValue(file.cpu_address_size());
	for (i = 0; i < segment_list->count(); i++) {
		segment = segment_list->item(i);
		if (!segment->need_parse())
			continue;

		asm_signatures.InitSearch();
		import_signatures.InitSearch();
		read_size = 0;
		pointer_value = 0;
		last_operand_address = 0;
		while (read_size < segment->physical_size()) {
			file.Seek(segment->physical_offset() + read_size);
			n = file.Read(buf, std::min(static_cast<size_t>(segment->physical_size() - read_size), sizeof(buf)));
			file.StepProgress(n);
			for (k = 0; k < n; k++) {
				b = buf[k];
				buf_address = segment->address() + read_size + k + 1;

				if (segment->memory_type() & mtExecutable) {
					// search asm markers
					for (j = 0; j < asm_signatures.count(); j++) {
						sign = asm_signatures.item(j);
						if (sign->SearchByte(b)) {
							address = buf_address - sign->size();
							switch (j) {
							case 0:
								AddMarker(file, address, 0, 0, otMarker, b, false);
								break;
							case 1:
								AddEndMarker(file, address, address + sign->size(), otMarker);
								break;
							}
						}
					}

					// search references to import
					for (j = 0; j < import_signatures.count(); j++) {
						sign = import_signatures.item(j);
						if (sign->SearchByte(b)) {
							address = buf_address - sign->size();
							command_list.clear();
							command = command_list.ReadValidCommand(file, address);
							if (!command)
								continue;

							IntelCommandType ref_command = static_cast<IntelCommandType>(command->type());
							operand = command->operand((ref_command == cmJmp || ref_command == cmCall) ? 0 : 1);
							if ((operand.type & otValue) == 0)
								continue;

							operand_address = address + operand.value_pos;
							uint64_t next_address = command->next_address();

							import_function = NULL;
							if (j == 3 && !operand.relocation) {
								// check compiler function
								CompilerFunction *compiler_function = compiler_function_list->GetFunctionByAddress(operand.value);
								if (compiler_function) {
									switch (compiler_function->type()) {
									case cfGetBaseRegistr:
										registr = static_cast<uint8_t>(compiler_function->value(0));
										compiler_function = compiler_function_list->Add(cfBaseRegistr, next_address);
										compiler_function->add_value(IntelOperand(otRegistr, command_list.cpu_address_size(), registr).encode());
										tmp_address = command->next_address();
										for (;;) {
											tmp_command = command_list.ReadValidCommand(file, tmp_address);
											if (tmp_command && tmp_command->type() == cmAdd && tmp_command->operand(0).type == otRegistr) {
												if (tmp_command->operand(0).registr == registr) {
													compiler_function->add_value(tmp_command->operand(1).value);
													break;
												}
												tmp_address = tmp_command->next_address();
											} else {
												break;
											}
										}
										break;

									case cfDllFunctionCall:
										compiler_function->include_option(coUsed);
										ImportInfo sdk_info;
										sdk_info.decode(compiler_function->value(0));
										switch (sdk_info.type) {
										case atBegin:
											{
												b = 0;
												if (sdk_info.options & ioHasCompilationType)
													b = 1 + sdk_info.compilation_type;
												if (sdk_info.options & ioLockToKey)
													b |= 0x80;

												command_list.ReadMarkerCommands(file, marker_command_list, address, moNeedParam | moSkipLastCall);
												if (marker_command_list.count() == 0) {
													AddMarker(file, address, 0, 0, otAPIMarker, b, true);
												} else {
													marker_command_list.Sort();
													for (r = 0; r < marker_command_list.count(); r++) {
														marker_command = marker_command_list.item(r);
														AddMarker(file, marker_command->address(),
																	marker_command->name_reference(),
																	marker_command->name_address(),
																	otAPIMarker, b, true);
													}
												}
											}
											break;

										case atEnd:
											AddEndMarker(file, address, next_address, otAPIMarker);
											break;
										case atDecryptStringW:
											command_list.ReadMarkerCommands(file, marker_command_list, address, moNeedParam | moSkipLastCall);
											for (r = 0; r < marker_command_list.count(); r++) {
												marker_command = marker_command_list.item(r);
												AddString(file, marker_command->name_address(), marker_command->name_reference(), true);
											}
											break;
										}
										break;

									case cfInitBCBSEH:
										{
											uint8_t version = static_cast<uint8_t>(compiler_function->value(0));
											if (version) {
												for (size_t d = 0x30; d > 0; d--) {
													if (!file.AddressSeek(address - d))
														continue;
			
													command_list.clear();
													tmp_address = address - d;
													while (tmp_address < address) {
														command = command_list.ReadValidCommand(file, tmp_address);
														// these commands can no be found between API`s param and API`s call
														if (command == NULL 
															|| command->type() == cmDB 
															|| command->type() == cmRet
															|| command->type() == cmIret
															|| command->type() == cmJmp
															|| command->type() == cmEnter) {
																tmp_address = 0;
																break;
														}
														tmp_address = command->next_address();
														if (command->type() == cmCall)
															command_list.clear();
													}

													if (tmp_address != address)
														continue;

													for (size_t c = command_list.count(); c > 0; c--) {
														command = command_list.item(i);
														if (command->type() == cmMov && command->operand(0).type == otRegistr && command->operand(0).registr == regEAX) {
															if (command->operand(1).type == otValue) {
																compiler_function = compiler_function_list->Add(cfBCBSEH, address);
																compiler_function->add_value(command->operand(1).value);
																compiler_function->add_value(version);
															}
															d = 1;
														}
													}
												}
											}
										}
										break;

									case cfJmpFunction:
										operand.value = compiler_function->value(0);
										break;
									}
								}

								// try to search import_function by jmp references
								std::map<uint64_t, IImportFunction *>::const_iterator it = jmp_references.find(operand.value);
								if (it != jmp_references.end())
									import_function = it->second;

								if (!import_function) {
									tmp_address = operand.value;
									for (;;) {
										// try parse jmp branches
										tmp_command = command_list.ReadValidCommand(file, tmp_address);
										if (tmp_command) {
											if (tmp_command->type() == cmJmp && (tmp_command->options() & roFar) == 0) {
												// jmp xxxx
												tmp_operand = tmp_command->operand(0);
												if (tmp_operand.type == otValue) {
													if (command_list.GetCommandByNearAddress(tmp_operand.value) == NULL) {
														tmp_address = tmp_operand.value;
														continue;
													}
												}
												else if (tmp_operand.type == (otMemory | otValue)) {
													import_function = import_list->GetFunctionByAddress(tmp_operand.value);
												}
											}
											else if (tmp_command->type() == cmNop) {
												// rep nop xxxx
												tmp_address = tmp_command->next_address();
												continue;
											}
										}
										break;
									}
								}
							} else if (j == 8)
								import_function = import_list->GetFunctionByAddress(plt_got_address + operand.value);
							else
								import_function = import_list->GetFunctionByAddress(operand.relocation ? operand_address : operand.value);

							if (import_function) {
								if ((ref_command == cmJmp || j == 3) && (import_function->options() & ioNoReturn)) {
									tmp_address = (j == 3) ? command->operand(0).value : address;
									CompilerFunction *compiler_function = compiler_function_list->GetFunctionByAddress(tmp_address);
									if (!compiler_function)
										compiler_function = compiler_function_list->Add(cfNone, tmp_address);
									compiler_function->include_option(coNoReturn);
								}

								// check data reference to import function
								if (ref_command == cmMov) {
									is_data_reference = true;
									registr = command->operand(0).registr;
									tmp_address = command->next_address();
									while (segment_list->GetMemoryTypeByAddress(tmp_address) & mtExecutable) {
										command = command_list.ReadValidCommand(file, tmp_address);
										if (!command)
											break;

										tmp_address = command->next_address();
										if (command->operand(0).type == otRegistr && command->operand(0).registr == registr) {
											if (command->type() == cmJmp || command->type() == cmCall)
												is_data_reference = false;
											break;
										} else if (command->type() == cmJmp && command->operand(0).type == otValue && command->operand(0).value >= tmp_address) {
											tmp_address = command->operand(0).value;
										} else if (command->type() == cmDB
													|| command->type() == cmJmp
													|| command->type() == cmCall
													|| command->type() == cmRet
													|| command->type() == cmIret)
											break;
									}
									if (is_data_reference)
										import_function->include_option(ioHasDataReference);
								}

								switch (import_function->type()) {
								case atBegin:
									if (ref_command != cmJmp) {
										command_list.ReadMarkerCommands(file, marker_command_list, address, moNeedParam | (ref_command == cmMov ? moForward : 0));

										b = 0;
										if ((import_function->options() & ioHasCompilationType) != 0)
											b = 1 + import_function->compilation_type();
										if ((import_function->options() & ioLockToKey) != 0)
											b |= 0x80;

										if (marker_command_list.count() == 0) {
											AddMarker(file, address, 0, 0, otAPIMarker, b, false);
										} else {
											marker_command_list.Sort();
											for (r = 0; r < marker_command_list.count(); r++) {
												marker_command = marker_command_list.item(r);
												AddMarker(file, marker_command->address(),
															marker_command->name_reference(),
															marker_command->name_address(),
															otAPIMarker, b, false);
											}
										}
									}
									break;

								case atEnd:
									if (ref_command == cmMov) {
										command_list.ReadMarkerCommands(file, marker_command_list, address, (ref_command == cmMov ? moForward : 0)); //-V547
										if (marker_command_list.count()) {
											marker_command_list.Sort();
											for (r = 0; r < marker_command_list.count(); r++) {
												marker_command = marker_command_list.item(r);
												AddEndMarker(file, marker_command->address(),
															marker_command->operand_address(),
															otAPIMarker);
											}
										}
									} else if (ref_command != cmJmp)
										AddEndMarker(file, address, next_address, otAPIMarker);
									break;

								case atDecryptStringA: case atDecryptStringW:
									command_list.ReadMarkerCommands(file, marker_command_list, address, moNeedParam | (ref_command == cmMov ? moForward : 0));
									for (r = 0; r < marker_command_list.count(); r++) {
										marker_command = marker_command_list.item(r);
										AddString(file, marker_command->name_address(), marker_command->name_reference(), import_function->type() == atDecryptStringW);
										call_import_function_map[marker_command->address()] = import_function;
									}										
									break;
								}
								if (j == 3 || j == 7) {
									if (import_function->address() == operand_address)
										import_function->map_function()->reference_list()->Add(address, operand_address);
								} else {
									last_operand_address = operand_address;
									import_function->map_function()->reference_list()->Add(address, operand_address);
									// add jmp_reference for next searching
									if (ref_command == cmJmp)
										jmp_references[address] = import_function;
								}
							}
						}
					}
				}

				// check data reference
				pointer_value >>= 8;
				pointer_value |= static_cast<uint64_t>(b) << ((pointer_size - 1) * 8);
				if (buf_address >= segment->address() + pointer_size - 1) {
					tmp_address = buf_address - pointer_size;
					if ((segment_list->GetMemoryTypeByAddress(pointer_value) & mtReadable) && (fixup_list->count() == 0 || fixup_list->GetFixupByAddress(tmp_address))) {
						import_function = import_list->GetFunctionByAddress(pointer_value);
						if (import_function && last_operand_address != tmp_address)
							import_function->include_option(ioHasDataReference);
					}
				}
			}
			read_size += n;
		}
	}

	// search references to strings
	if (string_list_.size() > 0) {
		if (file.cpu_address_size() == osQWord) {
			string_signatures.Add("4?8D"); // lea reg, [xxxxxxxx]
			string_signatures.Add("48B?"); // mov reg, xxxxxxxx
		} else {
			string_signatures.Add("B?");  // mov reg, xxxxxxxx
			string_signatures.Add("C7");  // mov [xxxxxxxx], xxxxxxxx
			string_signatures.Add("8D");  // lea reg, [xxxxxxxx]
			string_signatures.Add("68");  // push xxxxxxxx
		}

		for (i = 0; i < segment_list->count(); i++) {
			segment = segment_list->item(i);
			if (!segment->need_parse() || (segment->memory_type() & mtExecutable) == 0)
				continue;

			string_signatures.InitSearch();
			read_size = 0;
			while (read_size < segment->physical_size()) {
				file.Seek(segment->physical_offset() + read_size);
				n = file.Read(buf, std::min(static_cast<size_t>(segment->physical_size() - read_size), sizeof(buf)));
				for (k = 0; k < n; k++) {
					b = buf[k];
					buf_address = segment->address() + read_size + k + 1;

					for (j = 0; j < string_signatures.count(); j++) {
						sign = string_signatures.item(j);
						if (sign->SearchByte(b)) {
							address = buf_address - sign->size();
							command_list.clear();
							command = command_list.ReadValidCommand(file, address);
							if (!command)
								continue;

							uint64_t delta_offset = (uint64_t)-1;
							if (command->operand(0).type == otRegistr) {
								tmp_command = command_list.ReadValidCommand(file, command->next_address());
								if (tmp_command && tmp_command->type() == cmLea && tmp_command->operand(1).type == (otMemory | otRegistr | otValue) && tmp_command->operand(1).registr == command->operand(0).registr)
									delta_offset = tmp_command->operand(1).value;
							}

							operand = command->operand(command->type() != cmPush);
							if ((operand.type & otValue) == 0)
								continue;

							tmp_command = command_list.ReadValidCommand(file, command->next_address());
							if (tmp_command && tmp_command->type() == cmJmp && tmp_command->operand(0).type == otValue) {
								tmp_command = command_list.ReadValidCommand(file, tmp_command->operand(0).value);
								if (tmp_command && tmp_command->type() == cmCall) {
									std::map<uint64_t, IImportFunction *>::const_iterator it = call_import_function_map.find(tmp_command->address());
									if (it != call_import_function_map.end()) {
										import_function = it->second;
										if (import_function->type() == atDecryptStringA || import_function->type() == atDecryptStringW) {
											uint64_t param_reference;
											if (command_list.ParseParam(file, 1, param_reference))
												AddString(file, operand.value, command->address(), import_function->type() == atDecryptStringW);
										}
									}
								}
							}

							for (r = 0; r < string_list_.size(); r++) {
								map_function = string_list_[r];
								bool is_match = false;
								if (map_function->address() <= operand.value && map_function->end_address() > operand.value)
									is_match = true;
								else for (c = 0; c < map_function->equal_address_list()->count(); c++) {
									Reference *reference = map_function->equal_address_list()->item(c);
									if (reference->address() <= operand.value && reference->operand_address() > operand.value) {
										is_match = true;
										break;
									}
								}

								if (is_match) {
									if (map_function->reference_list()->GetReferenceByAddress(address) == NULL && (delta_offset == (uint64_t)-1 || delta_offset < map_function->end_address() - map_function->address()))
										map_function->reference_list()->Add(address, operand.value, 1);
									break;
								}
							}
						}
					}
				}
				read_size += n; 
			}
		}

		// check references to marker_names
		for (i = 0; i < map_function_list->count(); i++) {
			map_function = map_function_list->item(i);
			if (map_function->type() == otAPIMarker) {
				MapFunction *name_function = NULL;
				for (j = 0; j < string_list_.size(); j++) {
					if (string_list_[j]->address() == map_function->name_address() || string_list_[j]->equal_address_list()->GetReferenceByAddress(map_function->name_address())) {
						name_function = string_list_[j];
						break;
					}
				}
				if (name_function && name_function->reference_list()->count() > 1) {
					uint64_t end_name_address = map_function->name_address() + map_function->name_length();
					for (j = 0; j < name_function->reference_list()->count(); j++) {
						Reference *reference = name_function->reference_list()->item(j);
						if (reference->tag() != 1)
							continue;

						if (map_function->name_address() <= reference->operand_address() && end_name_address > reference->operand_address())
							end_name_address = reference->operand_address();
					}
					if (end_name_address > map_function->name_address())
						map_function->set_name_length(static_cast<size_t>(end_name_address - map_function->name_address()));
					else
						map_function->set_name_address(0);
				}
			}
		}
	}

	// check import functions without references
	for (i = 0; i < import_list->count(); i++) {
		IImport *import = import_list->item(i);
		for (j = 0; j < import->count(); j++) {
			import_function = import->item(j);
			if ((import_function->options() & ioHasDataReference) == 0 && import_function->map_function()->reference_list()->count() == 0)
				import_function->include_option(ioNoReferences);
		}
	}

	file.EndProgress();
};

/**
 * IntelFunctionList
 */

IntelFunctionList::IntelFunctionList(IArchitecture *owner)
	: BaseFunctionList(owner), import_(NULL), crc_table_(NULL), loader_data_(NULL), runtime_crc_table_(NULL)
{
	crc_cryptor_ = new ValueCryptor();
}

IntelFunctionList::IntelFunctionList(IArchitecture *owner, const IntelFunctionList &src)
	: BaseFunctionList(owner, src), import_(NULL), crc_table_(NULL), loader_data_(NULL), runtime_crc_table_(NULL)
{
	crc_cryptor_ = new ValueCryptor();
}

IntelFunctionList::~IntelFunctionList()
{
	delete crc_cryptor_;
}

IntelFunctionList *IntelFunctionList::Clone(IArchitecture *owner) const
{
	IntelFunctionList *list = new IntelFunctionList(owner, *this);
	return list;
}

IntelFunction *IntelFunctionList::Add(const std::string &name, CompilationType compilation_type, uint32_t compilation_options, bool need_compile, Folder *folder)
{
	IntelFunction *func = new IntelFunction(this, name, compilation_type, compilation_options, need_compile, folder);
	AddObject(func);
	return func;
}

IntelFunction *IntelFunctionList::CreateFunction(OperandSize cpu_address_size)
{
	return new IntelFunction(this, cpu_address_size);
}

IntelFunction *IntelFunctionList::item(size_t index) const
{ 
	return reinterpret_cast<IntelFunction *>(BaseFunctionList::item(index));
}

IntelFunction *IntelFunctionList::GetFunctionByAddress(uint64_t address) const
{ 
	return reinterpret_cast<IntelFunction *>(BaseFunctionList::GetFunctionByAddress(address));
}

IntelSDK *IntelFunctionList::AddSDK(OperandSize cpu_address_size)
{
	IntelSDK *func = new IntelSDK(this, cpu_address_size);
	AddObject(func);
	return func;
}

IntelImport *IntelFunctionList::AddImport(OperandSize cpu_address_size)
{
	IntelImport *func = new IntelImport(this, cpu_address_size);
	AddObject(func);
	return func;
}

IntelRuntimeData *IntelFunctionList::AddRuntimeData(OperandSize cpu_address_size)
{
	IntelRuntimeData *func = new IntelRuntimeData(this, cpu_address_size);
	AddObject(func);
	return func;
}

IntelCRCTable *IntelFunctionList::AddCRCTable(OperandSize cpu_address_size)
{
	IntelCRCTable *func = new IntelCRCTable(this, cpu_address_size);
	AddObject(func);
	return func;
}

IntelLoaderData *IntelFunctionList::AddLoaderData(OperandSize cpu_address_size)
{
	IntelLoaderData *func = new IntelLoaderData(this, cpu_address_size);
	AddObject(func);
	return func;
}

IntelFunction *IntelFunctionList::AddWatermark(OperandSize cpu_address_size, Watermark *watermark, int copy_count)
{
	IntelFunction *func = new IntelFunction(this, cpu_address_size);
	func->set_compilation_type(ctMutation);
	func->set_memory_type(mtNone);
	func->AddWatermark(watermark, copy_count);
	AddObject(func);
	return func;
}

IntelRuntimeCRCTable *IntelFunctionList::AddRuntimeCRCTable(OperandSize cpu_address_size)
{
	IntelRuntimeCRCTable *func = new IntelRuntimeCRCTable(this, cpu_address_size);
	AddObject(func);
	return func;
}

IntelVirtualMachineProcessor *IntelFunctionList::AddProcessor(OperandSize cpu_address_size)
{
	IntelVirtualMachineProcessor *func = new IntelVirtualMachineProcessor(this, cpu_address_size);
	AddObject(func);
	return func;
}

void IntelFunctionList::ReadFromBuffer(Buffer &buffer, IArchitecture &file)
{
	BaseFunctionList::ReadFromBuffer(buffer, file);

	// add loader stubs
	size_t c = count();
	for (size_t i = 0; i < c; i++) {
		IntelFunction *func = item(i);
		if (func->tag() != ftLoader)
			continue;

		for (size_t j = 0; j < func->count(); j++) {
			IntelCommand *command = func->item(j);
			if (command->type() == cmCall && command->operand(0).type == otValue) {
				uint64_t address = command->operand(0).value;
				if (address == command->next_address() || GetFunctionByAddress(address))
					continue;

				IntelFunction *new_func = reinterpret_cast<IntelFunction *>(AddByAddress(address, ctMutation, 0, false, NULL));
				if (new_func) {
					new_func->set_tag(ftLoader);
					for (size_t k = 0; k < new_func->count(); k++) {
						IntelCommand *command = new_func->item(k);
						command->exclude_option(roClearOriginalCode);
#ifdef CHECKED
						command->update_hash();
#endif
					}
				}
			}
		}
	}
}

bool IntelFunctionList::Prepare(const CompileContext &ctx)
{
	IntelFunction *func;
	IntelCommand *command;
	size_t i, j;
	OperandSize cpu_address_size = ctx.file->cpu_address_size();

	crc_cryptor_->clear();
	crc_cryptor_->set_size(osDWord);
	crc_cryptor_->Add(ccXor, rand32());
	
	if ((ctx.options.flags | ctx.options.sdk_flags) & cpMemoryProtection) {
		crc_table_ = AddCRCTable(cpu_address_size);
	} else {
		crc_table_ = NULL;
	}

	if (ctx.runtime) {
		// remove CalcCRC function
		IntelFunctionList *function_list = reinterpret_cast<IntelFunctionList *>(ctx.runtime->function_list());
		uint64_t calc_crc_address = ctx.runtime->export_list()->GetAddressByType(atCalcCRC);
		if (!calc_crc_address)
			return false;
		func = function_list->GetFunctionByAddress(calc_crc_address);
		if (!func)
			return false;
		func->set_need_compile(false);
		for (i = 0; i < function_list->count(); i++) {
			func = function_list->item(i);
			for (j = 0; j < func->count(); j++) {
				command = func->item(j);
				if (command->type()== cmCall && command->operand(0).type == otValue && command->operand(0).value == calc_crc_address) {
					delete command->link();
					command->Init(cmCrc);
#ifdef CHECKED
					command->update_hash();
#endif
				}
			}
		}

		if (ctx.runtime->segment_list()->count() > 0) {
			// add runtime functions
			for (i = 0; i < function_list->count(); i++) {
				func = function_list->item(i);

				if (func->need_compile()) {
					func = func->Clone(this);
					AddObject(func);

					if (func->type() == otString) {
						for (j = 0; j < func->count(); j++) {
							command = func->item(j);
							for (size_t k = 0; k < MESSAGE_COUNT; k++) {
								os::unicode_string unicode_message = 
#ifdef VMP_GNU
									os::FromUTF8(default_message[k]);
#else
									default_message[k];
#endif
								if (command->CompareDump(reinterpret_cast<const uint8_t*>(unicode_message.c_str()), (unicode_message.size() + 1) * sizeof(os::unicode_char))) {
									os::unicode_string str = os::FromUTF8(ctx.options.messages[k]);
									command->set_dump(reinterpret_cast<const uint8_t*>(str.c_str()), (str.size() + 1) * sizeof(os::unicode_char));
								} else {
									std::string message = 
#ifdef VMP_GNU								
										default_message[k];
#else									
										os::ToUTF8(default_message[k]);
#endif
									if (command->CompareDump(reinterpret_cast<const uint8_t*>(message.c_str()), message.size() + 1)) {
										std::string str = ctx.options.messages[k];
										command->set_dump(reinterpret_cast<const uint8_t*>(str.c_str()), str.size() + 1);
									}
								}
							}
						}
					}

					for (j = 0; j < func->count(); j++) {
						func->item(j)->CompileToNative();
					}
				} else {
					// need delete import references
					for (j = 0; j < ctx.runtime->map_function_list()->count(); j++) {
						ReferenceList *reference_list = ctx.runtime->map_function_list()->item(j)->reference_list();
						for (size_t k = reference_list->count(); k > 0; k--) {
							Reference *reference = reference_list->item(k - 1);
							command = func->GetCommandByNearAddress(reference->address());
							if (command && (command->options() & roClearOriginalCode))
								delete reference;
						}
					}
					if (!func->FreeByManager(ctx))
						return false;
				}
			}

			AddRuntimeData(cpu_address_size);
		}
	}

	if (ctx.options.flags & cpImportProtection) {
		import_ = AddImport(cpu_address_size);
	} else {
		import_ = NULL;
	}

	AddSDK(cpu_address_size);

	if (ctx.runtime && ctx.runtime->segment_list()->count() == 0) {
		loader_data_ = AddLoaderData(cpu_address_size);
	} else {
		loader_data_ = NULL;
	}

	AddWatermark(cpu_address_size, ctx.options.watermark, ctx.runtime ? 8 : 10);

	return BaseFunctionList::Prepare(ctx);
}

void IntelFunctionList::CompileLinks(const CompileContext &ctx)
{
	if (ctx.options.flags & cpMemoryProtection) {
		runtime_crc_table_ = AddRuntimeCRCTable(ctx.file->cpu_address_size());
		runtime_crc_table_->Compile(ctx);
	} else {
		runtime_crc_table_ = NULL;
	}

	BaseFunctionList::CompileLinks(ctx);
}

bool IntelFunctionList::GetRuntimeOptions() const
{
	for (size_t i = 0; i < count(); i++) {
		IntelFunction *func = item(i);
		if (func->tag() != ftLoader)
			continue;

		for (size_t j = 0; j < func->count(); j++) {
			IntelCommand *command = func->item(j);

			if (command->link() && command->link()->to_address()) {
				if (!GetCommandByAddress(command->link()->to_address(), false))
					return true;
			} else {
				for (size_t k = 0; k < 3; k++) {
					IntelOperand operand = command->operand(k);
					if (operand.type == otNone)
						break;

					if ((operand.type & otValue) && (operand.fixup || operand.is_large_value)) {
						if (owner()->image_base() == operand.value || owner()->import_list()->GetFunctionByAddress(operand.value))
							continue;

						if (!GetCommandByAddress(operand.value, false))
							return true;
					}
				}
			}
		}
	}
	return false;
}

/**
 * PEIntelFunctionList
 */

PEIntelFunctionList::PEIntelFunctionList(IArchitecture *owner)
	: IntelFunctionList(owner)
{

}

PEIntelFunctionList::PEIntelFunctionList(IArchitecture *owner, const PEIntelFunctionList &src)
	: IntelFunctionList(owner, src)
{

}

PEIntelFunctionList *PEIntelFunctionList::Clone(IArchitecture *owner) const
{
	PEIntelFunctionList *list = new PEIntelFunctionList(owner, *this);
	return list;
}

IntelSDK *PEIntelFunctionList::AddSDK(OperandSize cpu_address_size)
{
	IntelSDK *func = new PEIntelSDK(this, cpu_address_size);
	AddObject(func);
	return func;
}

PEIntelExport *PEIntelFunctionList::AddExport(OperandSize cpu_address_size)
{
	PEIntelExport *func = new PEIntelExport(this, cpu_address_size);
	AddObject(func);
	return func;
}

void PEIntelFunctionList::ReadFromBuffer(Buffer &buffer, IArchitecture &file)
{
	IntelFunctionList::ReadFromBuffer(buffer, file);

	if (file.cpu_address_size() == osDWord && reinterpret_cast<PEArchitecture&>(file).image_type() == itDriver) {
		// add exception handler
		IntelFunction *except_handler = NULL;
		for (size_t i = 0; i < count(); i++) {
			IntelFunction *func = item(i);
			if (func->tag() != ftLoader)
				continue;

			for (size_t j = 0; j < func->count(); j++) {
				IntelCommand *command = func->item(j);
				if (command->base_segment() == segFS && command->operand(0).type == otRegistr && command->operand(1).type == (otMemory | otValue) && command->operand(1).value == 0) {
					// mov reg, fs:[00000000]
					command = func->item(j - 1);
					uint64_t address = command->operand(0).value;
					command->AddLink(0, ltOffset, address);
					if (!GetFunctionByAddress(address)) {
						IntelFunction *new_func = reinterpret_cast<IntelFunction *>(AddByAddress(address, ctMutation, 0, false, NULL));
						if (new_func) {
							new_func->set_tag(ftLoader);
							for (size_t k = 0; k < new_func->count(); k++) {
								IntelCommand *command = new_func->item(k);
								command->exclude_option(roClearOriginalCode);
								if (command->seh_handler())
									command->set_seh_handler(NEED_SEH_HANDLER);
#ifdef CHECKED
								command->update_hash();
#endif
							}
						}
					}
				}
			}
		}
	}
}

bool PEIntelFunctionList::Prepare(const CompileContext &ctx)
{
	if (ctx.runtime) {
		PEArchitecture *file = reinterpret_cast<PEArchitecture *>(ctx.file);
		if (file->image_type() == itDriver) {
			IntelFunctionList *function_list = reinterpret_cast<IntelFunctionList *>(ctx.runtime->function_list());
			for (size_t i = 0; i < function_list->count(); i++) {
				IntelFunction *func = function_list->item(i);
				for (size_t j = 0; j < func->count(); j++) {
					IntelCommand *command = func->item(j);
					for (size_t k = 0; k < 3; k++) {
						IntelOperand operand = command->operand(k);
						if (operand.type == otNone)
							break;

						if ((operand.type & otValue) == 0)
							continue;

						uint32_t value = static_cast<uint32_t>(operand.value);
						if ((value & 0xFFFF0000) == 0xFACE0000) {
							switch (value) {
							case FACE_NON_PAGED_POOL_NX:
								// NonPagedPoolNx
								command->set_operand_value(k, file->operating_system_version() >= 0x060002 ? 512 : 0);
								command->CompileToNative();
								break;
							case FACE_DEFAULT_MDL_PRIORITY:
								// MdlMappingNoExecute | HighPagePriority
								command->set_operand_value(k, file->operating_system_version() >= 0x060002 ? 0x40000020 : 0x20); 
								command->CompileToNative();
								break;
							}
						}
					}
				}
			}
		}

		if (file->entry_point()) {
			IntelFunction *entry_point_func = GetFunctionByAddress(file->entry_point());
			if (entry_point_func) {
				entry_point_func->set_entry_type(etNone);
				entry_point_func->entry()->include_section_option(rtLinkedToInt);
			}
		}
	}

	return IntelFunctionList::Prepare(ctx);
}

/**
 * IntelSDK
 */

IntelSDK::IntelSDK(IFunctionList *owner, OperandSize cpu_address_size)
	: IntelFunction(owner, cpu_address_size)
{
	set_compilation_type(ctMutation);
}

bool IntelSDK::Init(const CompileContext &ctx)
{
	MapFunctionList *map_function_list;
	MapFunction *map_function;
	IFunctionList *function_list;
	size_t i, c, j, k, /*old_count,*/ n, f;
	uint64_t address;
	IArchitecture *file;
	IImportList *import_list;
	IImport *import;
	IImportFunction *import_function;
	IntelCommand *command, *ret_command, *mem_command, *api_entry;
	CommandBlock *block;
	uint64_t api_address;
	std::map<APIType, IntelCommand*> map_api_entry;

	CallingConvention calling_convention = ctx.file->calling_convention();

	f = (ctx.runtime && ctx.runtime->segment_list()->count() > 0) ? 2 : 1;
	for (n = 0; n < f; n++) {
		file = (n == 0) ? ctx.file : ctx.runtime;
		map_function_list = file->map_function_list();
		function_list = file->function_list();
		for (i = 0; i < map_function_list->count(); i++) {
			map_function = map_function_list->item(i);
			switch (map_function->type()) {
			case otAPIMarker:
				// need clear marker name
				if (map_function->name_address())
					ctx.manager->Add(map_function->name_address(), map_function->name_length(), file->segment_list()->GetMemoryTypeByAddress(map_function->name_address()));
				break;
			case otMarker:
				// need clear "VMProtect begin" from asm markers
				ICommand *command = function_list->GetCommandByAddress(map_function->address() + 2, true);
				if (!command)
					ctx.manager->Add(map_function->address() + 2, 0x10, file->segment_list()->GetMemoryTypeByAddress(map_function->name_address()));
				break;
			}
		}

		// need clear "VMProtect end" from asm markers
		for (i = 0; i < file->end_marker_list()->count(); i++) {
			MarkerCommand *marker_command = file->end_marker_list()->item(i);
			if (marker_command->type() != otMarker)
				continue;

			ICommand *command = function_list->GetCommandByAddress(marker_command->address() + 2, true);
			if (!command)
				ctx.manager->Add(marker_command->address() + 2, 0x0e, file->segment_list()->GetMemoryTypeByAddress(map_function->name_address()));
		}

		for (i = 0; i < file->compiler_function_list()->count(); i++) {
			CompilerFunction *compiler_function = file->compiler_function_list()->item(i);
			if (compiler_function->type() == cfDllFunctionCall) {
				// clear names
				ctx.manager->Add(compiler_function->value(1), static_cast<size_t>(compiler_function->value(2)));
				ctx.manager->Add(compiler_function->value(3), static_cast<size_t>(compiler_function->value(4)));

				if ((compiler_function->options() & coUsed) == 0)
					continue;

				address = compiler_function->address();
				command = reinterpret_cast<IntelCommand *>(ctx.file->function_list()->GetCommandByNearAddress(address, true));
				if (command) {
					delete command->link();
				} else {
					if (!file->AddressSeek(address))
						return false;

					block = AddBlock(count(), true);
					block->set_address(address);

					command = Add(address);
					command->ReadFromFile(*file);
					command->set_block(block);
					command->include_option(roFillNop);
					command->exclude_option(roClearOriginalCode);
				}

				// need delete fixups
				for (k = 0; k < 3; k++) {
					IntelOperand operand = command->operand(k);
					if (operand.type == otNone)
						break;

					IFixup *fixup = operand.fixup;
					if (fixup && fixup != NEED_FIXUP)
						fixup->set_deleted(true);
				}
				// need clear operands
				command->Init(static_cast<IntelCommandType>(command->type()));

				APIType function_type = static_cast<APIType>(compiler_function->value(0) & 0xff);
				switch (function_type) {
				case atBegin:
					command->Init(cmRet, IntelOperand(otValue, osWord, 0, OperandSizeToValue(cpu_address_size())));
					break;
				case atEnd:
					command->Init(cmRet);
					break;
				default:
					if (!ctx.runtime)
						return false;
					api_address = ctx.runtime->export_list()->GetAddressByType(function_type);
					if (!api_address)
						return false;

					command->Init(cmJmp, IntelOperand(otValue, cpu_address_size(), 0, api_address));
					command->AddLink(0, ltJmp, api_address);
					break;
				}

				command->CompileToNative();
			}
		}

		import_list = file->import_list();
		for (i = 0; i < import_list->count(); i++) {
			import = import_list->item(i);
			if (!import->is_sdk())
				continue;

			for (j = 0; j < import->count(); j++) {
				import_function = import->item(j);

				map_function = import_function->map_function();
				for (c = 0; c < map_function->reference_list()->count(); c++) {
					address = map_function->reference_list()->item(c)->address();

					command = reinterpret_cast<IntelCommand *>(ctx.file->function_list()->GetCommandByNearAddress(address, true));
					if (command) {
						delete command->link();
					} else {
						if (!file->AddressSeek(address))
							return false;

						block = AddBlock(count(), true);
						block->set_address(address);

						command = Add(address);
						command->ReadFromFile(*file);
						command->set_block(block);
						command->include_option(roFillNop);
						command->exclude_option(roClearOriginalCode);
					}

					if (command->type() != cmMov) {
						// need delete fixups
						for (k = 0; k < 3; k++) {
							IntelOperand operand = command->operand(k);
							if (operand.type == otNone)
								break;

							IFixup *fixup = operand.fixup;
							if (fixup && fixup != NEED_FIXUP)
								fixup->set_deleted(true);
						}
						// need clear operands
						command->Init(static_cast<IntelCommandType>(command->type()));
					}

					switch (import_function->type()) {
						case atBegin:
							switch (command->type()) {
							case cmCall:
								if (calling_convention == ccStdcall) {
									command->Init(cmLea, IntelOperand(otRegistr, cpu_address_size(), regESP), 
														IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regESP, OperandSizeToValue(cpu_address_size())));
								} else {
									command->Init(cmNop);
								}
								break;
							case cmMov:
								if (calling_convention == ccStdcall) {
									ret_command = AddCommand(cmRet, IntelOperand(otValue, osWord, 0, OperandSizeToValue(cpu_address_size())));
								} else {
									ret_command = AddCommand(cmRet);
								}

								mem_command = AddCommand((cpu_address_size() == osDWord) ? cmDD : cmDQ, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
								mem_command->AddLink(0, ltOffset, ret_command);

								command->AddLink(1, ltOffset, mem_command);
								break;
							default:
								if (calling_convention == ccStdcall) {
									command->Init(cmRet, IntelOperand(otValue, osWord, 0, OperandSizeToValue(cpu_address_size())));
								} else {
									command->Init(cmRet);
								}
								break;
							}
							break;

						case atEnd:
							switch (command->type()) {
							case cmCall:
								command->Init(cmNop);
								break;
							case cmMov:
								ret_command = AddCommand(cmRet);

								mem_command = AddCommand((cpu_address_size() == osDWord) ? cmDD : cmDQ, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
								mem_command->AddLink(0, ltOffset, ret_command);

								command->AddLink(1, ltOffset, mem_command);
								break;
							default:
								command->Init(cmRet);
								break;
							}
							break;

						case atDecryptStringA:
						case atDecryptStringW:
						case atFreeString:
						case atIsDebuggerPresent:
						case atIsVirtualMachinePresent:
						case atIsValidImageCRC:
						case atActivateLicense:
						case atDeactivateLicense:
						case atGetOfflineActivationString:
						case atGetOfflineDeactivationString:
						case atSetSerialNumber:
						case atGetSerialNumberState:
						case atGetSerialNumberData:
						case atGetCurrentHWID:
						case atIsProtected:
							api_entry = NULL;
							api_address = 0;
							if (!ctx.runtime || ctx.runtime->segment_list()->count() == 0) {
								std::map<APIType, IntelCommand*>::const_iterator it = map_api_entry.find(import_function->type());
								if (it != map_api_entry.end())
									api_entry = it->second;
								else { 
									switch (import_function->type()) {
									case atDecryptStringA:
									case atDecryptStringW:
										if (calling_convention == ccMSx64)
											api_entry = AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEAX), IntelOperand(otRegistr, cpu_address_size(), regECX));
										else if (calling_convention == ccABIx64)
											api_entry = AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEAX), IntelOperand(otRegistr, cpu_address_size(), regEDI));
										else
											api_entry = AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEAX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regESP, OperandSizeToValue(cpu_address_size())));
										if (calling_convention == ccStdcall)
											AddCommand(cmRet, IntelOperand(otValue, osWord, 0, OperandSizeToValue(cpu_address_size())));
										else
											AddCommand(cmRet);
										break;
									case atFreeString:
										api_entry = AddCommand(cmXor, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otRegistr, osDWord, regEAX));
										if (calling_convention == ccStdcall)
											AddCommand(cmRet, IntelOperand(otValue, osWord, 0, OperandSizeToValue(cpu_address_size())));
										 else
											AddCommand(cmRet);
										break;
									case atIsProtected:
										api_entry = AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, 1));
										AddCommand(cmRet);
										break;
									default:
										// other APIs can not work without runtime
										return false;
									}
									map_api_entry[import_function->type()] = api_entry;
								}
							} else {
								api_address = ctx.runtime->export_list()->GetAddressByType(import_function->type());
								if (!api_address)
									return false;
							}

							switch (command->type()) {
							case cmCall:
								command->Init(cmCall, IntelOperand(otValue, cpu_address_size(), 0, api_address));
								if (api_entry)
									command->AddLink(0, ltCall, api_entry);
								else
									command->AddLink(0, ltCall, api_address);
								break;
							case cmMov:
								mem_command = AddCommand((cpu_address_size() == osDWord) ? cmDD : cmDQ, IntelOperand(otValue, cpu_address_size(), 0, api_address, NEED_FIXUP));
								if (api_entry)
									mem_command->AddLink(0, ltOffset, api_entry);
								else
									mem_command->AddLink(0, ltOffset, api_address);
								command->AddLink(1, ltOffset, mem_command);
								break;
							default:
								command->Init(cmJmp, IntelOperand(otValue, cpu_address_size(), 0, api_address));
								if (api_entry)
									command->AddLink(0, ltJmp, api_entry);
								else
									command->AddLink(0, ltJmp, api_address);
								break;
							}
							break;

						default:
							throw std::runtime_error("Unknown API from SDK: " + import_function->name());
					}

					command->CompileToNative();
				}
			}
		}
	}

	for (i = 0; i < count(); i++) {
		item(i)->CompileToNative();
	}

	return IntelFunction::Init(ctx);
}

/**
 * PEIntelSDK
 */

PEIntelSDK::PEIntelSDK(IFunctionList *parent, OperandSize cpu_address_size)
	: IntelSDK(parent, cpu_address_size)
{

}

bool PEIntelSDK::Init(const CompileContext &ctx)
{
	if (!IntelSDK::Init(ctx))
		return false;

	PEArchitecture *file = reinterpret_cast<PEArchitecture *>(ctx.file);
	if (file->import_list()->has_sdk() && ctx.runtime == NULL) {
		// remove SDK from import
		PEDirectory *dir = file->command_list()->GetCommandByType(IMAGE_DIRECTORY_ENTRY_IMPORT);
		if (!dir)
			return false;

		size_t i, j;
		IntelCommand *command;
		uint64_t address = dir->address();

		CommandBlock *block = AddBlock(count(), true);
		block->set_address(address);

		for (i = 0; i < file->import_list()->count(); i++) {
			PEImport *import = file->import_list()->item(i);
			if (import->is_sdk()) {
				import->FreeByManager(*ctx.manager, true);
			} else {
				if (!file->AddressSeek(address))
					return false;

				for (j = 0; j < 5; j++) {
					command = Add(0);
					command->ReadValueFromFile(*file, osDWord);
					command->include_option(roWritable);
				}
			}
			address += 5 * sizeof(uint32_t);
		}
		for (j = 0; j < 5; j++) {
			command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
			command->CompileToNative();
		}
		block->set_end_index(count() - 1);

		for (i = block->start_index(); i <= block->end_index(); i++) {
			item(i)->set_block(block);
		}
	}

	return true;
}

/**
 * PEIntelExport
 */

PEIntelExport::PEIntelExport(IFunctionList *owner, OperandSize cpu_address_size)
	: IntelFunction(owner, cpu_address_size), size_(0)
{
	set_compilation_type(ctMutation);
}

bool PEIntelExport::Init(const CompileContext &ctx)
{
	PEArchitecture *file = reinterpret_cast<PEArchitecture *>(ctx.file);
	size_ = file->export_list()->WriteToData(*this, file->image_base());
	if (count())
		set_entry(item(0));

	return IntelFunction::Init(ctx);
}

bool PEIntelExport::Compile(const CompileContext &ctx)
{
	CreateBlocks();
	block_list()->CompileBlocks(*ctx.manager);
	CompileLinks(ctx);
	return true;
}

/**
 * IntelImport
 */

IntelImport::IntelImport(IFunctionList *owner, OperandSize cpu_address_size)
	: IntelFunction(owner, cpu_address_size)
{
	set_compilation_type(ctMutation);
}

IntelCommand *IntelImport::GetIATCommand(PEImportFunction *import_function) const
{
	size_t i;

	for (i = 0; i < iat_info_list_.size(); i++) {
		if (iat_info_list_[i].import_function->address() == import_function->address()) {
			return iat_info_list_[i].command;
		}
	}

	return NULL;
}

bool IntelImport::Init(const CompileContext &ctx)
{
	IntelCommandType value_type, rand_type, ref_type;
	size_t i, j, n, k, c, index, r;
	PEImportList *import_list;
	PEImport *import;
	PEImportFunction *import_function;
	IATInfo iat_info;
	IntelCommand *command, *src_command, *iat_command, *ref_command;
	ReferenceList call_references;
	MapFunction *map_function;
	uint64_t address, rand_value;
	PEArchitecture *file;
	uint8_t mov_registr, rand_registr;
	bool is_mov_command;
	CommandLink *link;

	value_type = (cpu_address_size() == osDWord) ? cmDD : cmDQ;
	k = (ctx.runtime && ctx.runtime->segment_list()->count() > 0) ? 2 : 1;
	for (n = 0; n < k; n++) {
		file = reinterpret_cast<PEArchitecture *>((n == 0) ? ctx.file : ctx.runtime);
		import_list = file->import_list();
		for (i = 0; i < import_list->count(); i++) {
			import = import_list->item(i);

			// APIs processed by IntelSDK
			if (import->is_sdk()) 
				continue;

			if (import->excluded_from_import_protection())
				continue;

			for (j = 0; j < import->count(); j++) {
				import_function = import->item(j);

				if (import_function->options() & (ioHasDataReference | ioNoReferences))
					continue;

				iat_info.import_function = import_function;
				iat_info.command = NULL;
				iat_info.from_runtime = (n > 0);
				iat_info_list_.push_back(iat_info);
			}
		}
	}

	index = count();
	for (i = 0; i < iat_info_list_.size(); i++) {
		import_function = iat_info_list_[i].import_function;

		command = AddCommand(value_type, IntelOperand(otValue, cpu_address_size(), 0, (value_type == cmDD) ? rand32() : rand64()));
		// second operand is a key for decrypt IAT value
		command->set_operand_value(1, (import_function->options() & ioNative) ? 0 : DWordToInt64(rand32()));
		command->include_option(roCreateNewBlock);
		command->include_option(roWritable);

		iat_info_list_[i].command = command;

		map_function = import_function->map_function();

		call_references.clear();
		for (r = 0; r < 2; r++) {
			ReferenceList *reference_list = (r == 0) ? map_function->reference_list() : &call_references;

			for (n = 0; n < reference_list->count(); n++) {
				address = reference_list->item(n)->address();

				src_command = reinterpret_cast<IntelCommand *>(ctx.file->function_list()->GetCommandByNearAddress(address, true));
				iat_command = iat_info_list_[i].command;

				file = reinterpret_cast<PEArchitecture *>((iat_info_list_[i].from_runtime) ? ctx.runtime : ctx.file);

				if (file == NULL || !file->AddressSeek(address))
					return false;

				ref_command = Add(address);
				ref_command->ReadFromFile(*file);
				if (ref_command->type() == cmInt) {
					// reference command from runtime
					if (!src_command)
						throw std::runtime_error("Runtime error at Init");

					delete ref_command;
					ref_command = src_command->Clone(this);
					AddObject(ref_command);
				}

				// delete fixups
				for (k = 0; k < 3; k++) {
					IntelOperand operand = ref_command->operand(k);
					if (operand.type == otNone)
						break;

					IFixup *fixup = operand.fixup;
					if (fixup && fixup != NEED_FIXUP)
						fixup->set_deleted(true);
				}

				is_mov_command = (ref_command->type() == cmMov && ref_command->operand(0).type == otRegistr && ref_command->operand(0).size == cpu_address_size());
				ref_type = static_cast<IntelCommandType>(ref_command->type());
				mov_registr = ref_command->operand(0).registr;
				rand_registr = rand() % 8;
				if (rand_registr == regESP)
					rand_registr = regEAX;

				c = ref_command->original_dump_size();
				if (src_command == NULL && c > 5) {
					IntelCommand *push_command;
					switch (rand() % (is_mov_command ? 3 : 2)) {
					case 2:
						rand_type = cmPop;
						AddCommand(cmXchg, IntelOperand(otMemory | otRegistr, cpu_address_size(), regESP), IntelOperand(otRegistr, cpu_address_size(), mov_registr));
						push_command = AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), mov_registr));
						break;
					case 1:
						rand_type = cmPush;
						push_command = AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), rand_registr));
						AddCommand(cmXchg, IntelOperand(otMemory | otRegistr, cpu_address_size(), regESP), IntelOperand(otRegistr, cpu_address_size(), rand_registr));
						break;
					default:
						rand_type = cmNop;
						push_command = NULL;
						break;
					}
					if (push_command) {
						push_command->CompileToNative();
						c -= push_command->dump_size();
					}
				} else {
					rand_type = cmUnknown;
					c = 0;
				}

				if (is_mov_command && mov_registr == rand_registr) {
					if (c > 5) {
						AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), rand_registr));
						AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size(), rand_registr), 
							IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), rand_registr, c - 5));
						AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), rand_registr));
					}
				} else {
					AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), rand_registr));
					if (c > 5 && ref_type != cmJmp) {
						AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), rand_registr), 
							IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regESP, OperandSizeToValue(cpu_address_size())));
						AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size(), rand_registr), 
							IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), rand_registr, c - 5));
						AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regESP, OperandSizeToValue(cpu_address_size())),
							IntelOperand(otRegistr, cpu_address_size(), rand_registr));
					}
				}

				rand_value = file->segment_list()->item(0)->address() + rand32() % file->segment_list()->item(0)->size();
				if (cpu_address_size() == osDWord) {
					AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), rand_registr), 
						IntelOperand(otValue, cpu_address_size(), 0, rand_value, NEED_FIXUP));
				} else {
					AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size(), rand_registr), 
						IntelOperand(otMemory | otValue, cpu_address_size(), 0, rand_value, LARGE_VALUE));
				}

				// read random registr from IAT
				command = AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), rand_registr), 
					IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), rand_registr, 0x80000000));
				link = command->AddLink(1, ltOffset, iat_command);
				link->set_sub_value(rand_value);

				// decrypt API`s address in random registr
				AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size(), rand_registr), 
					IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), rand_registr, iat_command->operand(1).value));

				// restore random registr
				if (ref_type == cmJmp || ref_type == cmCall) {
					AddCommand(cmXchg, IntelOperand(otMemory | otRegistr, cpu_address_size(), regESP), IntelOperand(otRegistr, cpu_address_size(), rand_registr));
				} else if (is_mov_command && mov_registr != rand_registr){
					IntelOperand ref_operand = ref_command->operand(0);
					if ((ref_operand.type & otBaseRegistr) && ref_operand.base_registr == regESP) {
						ref_operand.type |= otValue;
						ref_operand.value += OperandSizeToValue(cpu_address_size());
					}

					AddCommand(cmMov, ref_operand, IntelOperand(otRegistr, ref_operand.size, rand_registr));
					AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), rand_registr));
				}

				if (ref_type == cmJmp) {
					AddCommand(cmRet, IntelOperand(otValue, osWord, 0, OperandSizeToValue(cpu_address_size())));
				} else {
					AddCommand(cmRet);
				}

				// clear operands
				ref_command->Init(cmNop);
				ref_command->set_address(0);
				ref_command->set_address_range(NULL);

				if (src_command) {
					delete src_command->link();
					src_command->Init(cmCall, IntelOperand(otValue, cpu_address_size()));
					if (ref_type == cmJmp)
						src_command->include_option(roUseAsJmp);
					src_command->AddLink(0, ltCall, ref_command);
				} else {
					c = ref_command->original_dump_size();
					if (rand_type == cmPush || rand_type == cmPop) {
						CommandBlock *block = AddBlock(index, true);
						block->set_address(address);

						command = new IntelCommand(this, cpu_address_size(), rand_type, IntelOperand(otRegistr, cpu_address_size(), (rand_type == cmPop) ? mov_registr : rand_registr));
						command->CompileToNative();
						command->set_block(block);
						InsertObject(index++, command);

						address += command->dump_size();
						c -= command->dump_size();
					}

					ctx.manager->Add(address, c, file->segment_list()->GetMemoryTypeByAddress(address), this);

					ext_command_list()->Add(address, ref_command, true);
				}

				if (ref_type == cmJmp) {
					address = reference_list->item(n)->address();

					for (j = 0; j < ctx.file->function_list()->count(); j++) {
						IntelFunction *func = reinterpret_cast<IntelFunction *>(ctx.file->function_list()->item(j));
						if (!func->need_compile())
							continue;

						for (k = 0; k < func->link_list()->count(); k++) {
							CommandLink *link = func->link_list()->item(k);
							if (link->type() != ltCall)
								continue;

							 command = reinterpret_cast<IntelCommand *>(link->from_command());
							 if (command->type() == cmCall && command->operand(0).type == otValue && command->operand(0).value == address)
								 call_references.Add(command->address(), 0);
						}
					}
				}
			}
		}
	}

	for (i = 0; i < count(); i++) {
		item(i)->CompileToNative();
	}

	return IntelFunction::Init(ctx);
}

/**
 * IntelCRCTable
 */

IntelCRCTable::IntelCRCTable(IFunctionList *owner, OperandSize cpu_address_size)
	: IntelFunction(owner, cpu_address_size)
{
	set_compilation_type(ctMutation);
}

bool IntelCRCTable::Init(const CompileContext &ctx)
{
	size_t i, c, n, f;

	c = 10;
	f = (ctx.runtime && ctx.runtime->segment_list()->count() > 0) ? 2 : 1;
	for (n = 0; n < f; n++) {
		IArchitecture *file = (n == 0) ? ctx.file : ctx.runtime;
		c += ctx.file->segment_list()->count();
		if ((ctx.options.flags & cpStripFixups) == 0)
			c += file->fixup_list()->count();
		if (ctx.options.flags & cpImportProtection) {
			IImportList *import_list = file->import_list();
			for (i = 0; i < import_list->count(); i++) {
				c += import_list->item(i)->count();
			}
		} else {
			c += file->import_list()->count();
		}
	}

	for (i = 0; i < c; i++) {
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
	}

	size_entry_ = AddCommand(cmDD, IntelOperand(otValue, osDWord));
	size_entry_->include_option(roCreateNewBlock);

	hash_entry_ = AddCommand(cmDD, IntelOperand(otValue, osDWord));
	hash_entry_->include_option(roCreateNewBlock);

	for (i = 0; i < count(); i++) {
		IntelCommand *command = item(i);
		command->CompileToNative();
		command->include_option(roWritable);
	}

	return IntelFunction::Init(ctx);
}

/**
 * IntelRuntimeCRCTable
 */

IntelRuntimeCRCTable::IntelRuntimeCRCTable(IFunctionList *owner, OperandSize cpu_address_size)
	: IntelFunction(owner, cpu_address_size), cryptor_(NULL)
{
	set_compilation_type(ctMutation);
}

void IntelRuntimeCRCTable::clear()
{
	region_info_list_.clear();
	IntelFunction::clear();
}

bool IntelRuntimeCRCTable::Compile(const CompileContext &ctx)
{
	IntelFunctionList *function_list = reinterpret_cast<IntelFunctionList *>(ctx.file->function_list());
	cryptor_ = function_list->crc_cryptor();

	size_t block_size, i, j, k, end_operand_index;
	uint64_t block_address;
	bool check_fixups = (ctx.options.flags & cpStripFixups) == 0;
	MemoryManager manager(ctx.file);

	for (i = 0; i < function_list->count(); i++) {
		IntelFunction *func = function_list->item(i);
		if (!func->need_compile())
			continue;

		for (j = 0; j < func->block_list()->count(); j++) {
			CommandBlock *block = func->block_list()->item(j);
			if (block->type() & mtExecutable) {
				// native block
				block_size = 0;
				block_address = 0;
				for (k = block->start_index(); k <= block->end_index(); k++) {
					IntelCommand *command = func->item(k);
					if (command->options() & roWritable)
						continue;

					if (block_address && (block_address + block_size) != command->address()) {
						if (block_size)
							manager.Add(block_address, block_size, mtReadable);
						block_address = 0;
						block_size = 0;
					}
					if (!block_address)
						block_address = command->address();

					end_operand_index = NOT_ID;
					for (size_t n = 0; n < 3; n++) {
						IntelOperand operand = command->operand(n);
						if (operand.type == otNone)
							break;

						if ((operand.type & otValue) && ((check_fixups && operand.fixup) || operand.relocation)) {
							end_operand_index = n;
							break;
						}
					}
					block_size += (end_operand_index == NOT_ID) ? command->dump_size() : command->operand(end_operand_index).value_pos;
				}
				if (block_size)
					manager.Add(block_address, block_size, mtReadable);
			} else {
				// VM block
				IntelCommand *command = func->item(block->end_index());
				block_size = 0;
				if (command->section_options() & rtBackwardDirection) {
					block_address = command->vm_address() - command->vm_dump_size();
					for (k = command->count(); k > 0; k--) {
						IntelVMCommand *vm_command = command->item(k - 1);
						if (check_fixups && vm_command->fixup())
							break;
						block_size += vm_command->dump_size();
					}
				} else {
					block_address = command->vm_address();
					for (k = 0; k < command->count(); k++) {
						IntelVMCommand *vm_command = command->item(k);
						if (check_fixups && vm_command->fixup())
							break;
						block_size += vm_command->dump_size();
					}
				}
				if (block_size)
					manager.Add(block_address, block_size, mtReadable);
			}
		}
	}
	if (manager.count() == 0)
		return true;

	manager.Pack();

	for (i = 0; i < manager.count(); i++) {
		MemoryRegion *region = manager.item(i);
		uint64_t block_address = region->address();

		size_t region_size, block_size;
		for (region_size = region->size(); region_size != 0; region_size -= block_size, block_address += block_size) {
			block_size = 0x1000 - (rand() & 0xff);
			if (block_size > region_size)
				block_size = region_size;

			region_info_list_.push_back(RegionInfo(block_address, static_cast<uint32_t>(block_size), false));
		}
	}

	for (i = 0; i < region_info_list_.size(); i++) {
		std::swap(region_info_list_[i], region_info_list_[rand() % region_info_list_.size()]);
	}

	size_t self_crc_offset = 0;
	size_t self_crc_size = 0;
	for (i = 0; i < region_info_list_.size(); i++) {
		self_crc_size += sizeof(CRCInfo::POD);
		if (self_crc_size > 0x1000 && (rand() & 1)) {
			region_info_list_.insert(region_info_list_.begin() + i + 1, RegionInfo(self_crc_offset, (uint32_t)self_crc_size, true));
			self_crc_offset += self_crc_size;
			self_crc_size = 0;
		}
	}
	if (self_crc_size)
		region_info_list_.push_back(RegionInfo(self_crc_offset, (uint32_t)self_crc_size, true));

	for (i = 0; i < region_info_list_.size(); i++) {
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
	}
	set_entry(item(0));
	for (i = 0; i < count(); i++) {
		item(i)->CompileToNative();
	}

	CreateBlocks();

	for (i = 0; i < block_list()->count(); i++) {
		block_list()->item(i)->Compile(*ctx.manager);
	}

	return true;
}

size_t IntelRuntimeCRCTable::WriteToFile(IArchitecture &file)
{
	size_t res = IntelFunction::WriteToFile(file);

	if (entry()) {
		uint64_t address = entry()->address();
		std::vector<CRCInfo> crc_info_list;
		std::vector<uint8_t> dump;
		for (size_t i = 0; i < region_info_list_.size(); i++) {
			RegionInfo region_info = region_info_list_[i];

			dump.resize(region_info.size);
			if (region_info.is_self_crc) {
				memcpy(&dump[0], reinterpret_cast<uint8_t *>(&crc_info_list[0]) + region_info.address, dump.size());
				region_info.address += address;
			} else {
				file.AddressSeek(region_info.address);
				file.Read(&dump[0], dump.size());
			}

			CRCInfo crc_info(static_cast<uint32_t>(region_info.address - file.image_base()), dump);
			if (cryptor_) {
				crc_info.pod.address = static_cast<uint32_t>(cryptor_->Encrypt(crc_info.pod.address));
				crc_info.pod.size = static_cast<uint32_t>(cryptor_->Encrypt(crc_info.pod.size));
			}
			crc_info.pod.hash = 0 - crc_info.pod.hash;
			crc_info_list.push_back(crc_info);
		}

		file.AddressSeek(address);
		file.Write(&crc_info_list[0], crc_info_list.size() * sizeof(CRCInfo::POD));
	}

	return res;
}

/**
 * IntelLoaderData
 */

IntelLoaderData::IntelLoaderData(IFunctionList *owner, OperandSize cpu_address_size)
	: IntelFunction(owner, cpu_address_size)
{
	set_compilation_type(ctMutation);
}

bool IntelLoaderData::Init(const CompileContext &ctx)
{
	IntelCommand *command = AddCommand(cpu_address_size(), 0);
	if (!command)
		return false;

	command->CompileToNative();
	command->include_option(roWritable);
	set_entry(command);
	set_entry_type(etNone);

	return IntelFunction::Init(ctx);
}

/**
 * IntelRuntimeData
 */

IntelRuntimeData::IntelRuntimeData(IFunctionList *owner, OperandSize cpu_address_size)
	: IntelFunction(owner, cpu_address_size), strings_entry_(NULL), strings_size_(0), resources_entry_(NULL), resources_size_(0),
	trial_hwid_entry_(NULL), trial_hwid_size_(0), data_key_(0)
#ifdef ULTIMATE
	, license_data_entry_(NULL), license_data_size_(0), files_entry_(NULL), files_size_(0),
	registry_entry_(NULL), registry_size_(0)
#endif	
{
	set_compilation_type(ctMutation);
	rc5_key_.Create();
}

bool IntelRuntimeData::CommandCompareHelper::operator()(const IntelCommand *left, IntelCommand *right) const
{
	return (left->address() < right->address());
}

bool IntelRuntimeData::Init(const CompileContext &ctx)
{
	IntelFunctionList *function_list;
	size_t i, j, index, k;
	std::vector<IntelCommand *> string_command_list;
	IntelCommand *command, *string_command;
	CommandLink *link;
	IntelCommand *key_entry;
	Data key;
	uint64_t image_base = ctx.file->image_base();

	key.PushBuff(rc5_key_.Value, sizeof(rc5_key_.Value));
	data_key_ = key.ReadDWord(0);

	resources_entry_ = NULL;
	resources_size_ = 0;
	if ((ctx.options.flags & cpResourceProtection) && ctx.file->resource_list() && ctx.file->resource_list()->count()) {
		PEArchitecture *file = reinterpret_cast<PEArchitecture *>(ctx.file);
		PEResourceList resource_list(NULL);
		for (i = 0; i < file->resource_list()->count(); i++) {
			PEResource *resource = file->resource_list()->item(i);
			if (resource->need_store())
				continue;

			resource_list.AddObject(resource->Clone(&resource_list));
		}

		if (resource_list.count()) {
			index = count();

			std::vector<PEResource *> list;
			PEResource *resource;

			// create resource list
			for (i = 0; i < resource_list.count(); i++) {
				list.push_back(resource_list.item(i));
			}

			for (i = 0; i < list.size(); i++) {
				resource = list[i];
				for (j = 0; j < resource->count(); j++) {
					list.push_back(resource->item(j));
				}
			}

			// create root directory
			uint32_t number_of_id_entries = 0;
			uint32_t number_of_named_entries = 0;
			for (i = 0; i < resource_list.count(); i++) {
				if (resource_list.item(i)->has_name()) {
					number_of_named_entries++;
				} else {
					number_of_id_entries++;
				}
			}
			AddCommand(osDWord, number_of_named_entries);
			AddCommand(osDWord, number_of_id_entries);

			for (i = 0; i < resource_list.count(); i++) {
				resource_list.item(i)->WriteEntry(*this);
			}

			for (i = 0; i < list.size(); i++) {
				list[i]->WriteHeader(*this);
			}

			resources_entry_ = item(index);
			resources_entry_->include_option(roCreateNewBlock);
			resources_size_ = static_cast<uint32_t>((count() - index) * OperandSizeToValue(osDWord));

			for (i = 0; i < list.size(); i++) {
				list[i]->WriteName(*this, index, data_key_);
			}

			for (i = 0; i < list.size(); i++) {
				list[i]->WriteData(*this, *file, data_key_);
			}
		}
	}

#ifdef ULTIMATE
	files_entry_ = NULL;
	files_size_ = 0;
	if (ctx.options.file_manager) {
		FileManager *file_manager = ctx.options.file_manager;
		if (!file_manager->OpenFiles())
			return false;

		std::vector<FileFolder *> folder_list;
		for (i = 0; i < file_manager->folder_list()->count(); i++) {
			folder_list.push_back(file_manager->folder_list()->item(i));
		}
		for (i = 0; i < folder_list.size(); i++) {
			FileFolder *file_folder = folder_list[i];
			for (j = 0; j < file_folder->count(); j++) {
				folder_list.push_back(file_folder->item(j));
			}
		}

		// create root directory
		index = count();
		AddCommand(osDWord, file_manager->count() + folder_list.size());

		for (i = 0; i < file_manager->count(); i++) {
			file_manager->item(i)->WriteEntry(*this);
		}
		for (i = 0; i < folder_list.size(); i++) {
			folder_list[i]->WriteEntry(*this);
		}

		files_entry_ = item(index);
		files_entry_->include_option(roCreateNewBlock);
		files_size_ = static_cast<uint32_t>((count() - index) * OperandSizeToValue(osDWord));

		for (i = 0; i < file_manager->count(); i++) {
			file_manager->item(i)->WriteName(*this, image_base, data_key_);
		}
		for (i = 0; i < folder_list.size(); i++) {
			folder_list[i]->WriteName(*this, image_base, data_key_);
		}

		for (i = 0; i < file_manager->count(); i++) {
			InternalFile *internal_file = file_manager->item(i);
			Notify(mtInformation, NULL, string_format("%s %s", language[lsLoading].c_str(), os::ExtractFileName(internal_file->absolute_file_name().c_str()).c_str()));
			internal_file->WriteData(*this, image_base, data_key_);
		}

		file_manager->CloseFiles();
	}

	registry_entry_ = NULL;
	registry_size_ = 0;
	if (ctx.options.file_manager && ctx.options.file_manager->server_count()) {
		index = count();

		// create root directory
		AddCommand(osDWord, 0);
		AddCommand(osDWord, 0);

		registry_entry_ = item(index);
		registry_entry_->include_option(roCreateNewBlock);
		for (i = index; i < count(); i++) {
			command = item(i);
			registry_size_ += (command->type() == cmDB) ? (uint32_t)command->dump_size() : OperandSizeToValue(command->operand(0).size);
		}

		i = AlignValue(registry_size_, 8);
		if (i > registry_size_) {
			Data tmp;
			tmp.resize(i - registry_size_, 0);
			AddCommand(tmp);
			registry_size_ = (uint32_t)i;
		}
	}
#endif

	function_list = reinterpret_cast<IntelFunctionList *>(ctx.file->function_list());
	for (i = 0; i < function_list->count(); i++) {
		IntelFunction *func = function_list->item(i);
		if (func->need_compile() && func->type() == otString) {
			for (j = 0; j < func->count(); j++) {
				string_command_list.push_back(func->item(j));
			}
		}
	}

	key_entry = AddCommand(key);
	key_entry->include_option(roCreateNewBlock);

	strings_entry_ = NULL;
	strings_size_ = 0;
	if (string_command_list.size()) {
		std::sort(string_command_list.begin(), string_command_list.end(), CommandCompareHelper());
		index = count();

		// create directory
		AddCommand(osDWord, string_command_list.size());

		for (i = 0; i < string_command_list.size(); i++) {
			string_command = string_command_list[i];

			// create string entry
			AddCommand(osDWord, string_command->address() - ctx.file->image_base());
			command = AddCommand(osDWord, 0);
			link = command->AddLink(0, ltOffset);
			link->set_sub_value(ctx.file->image_base());
			AddCommand(osDWord, string_command->dump_size());
		}
		strings_entry_ = item(index);
		strings_entry_->include_option(roCreateNewBlock);
		strings_size_ = static_cast<uint32_t>((count() - index) * OperandSizeToValue(osDWord));

		// create string values
		Data data;
		for (i = 0; i < string_command_list.size(); i++) {
			string_command = string_command_list[i];

			data.clear();
			for (j = 0; j < string_command->dump_size(); j++) {
				data.PushByte(string_command->dump(j) ^ static_cast<uint8_t>(_rotl32(data_key_, static_cast<int>(j)) + j));
			}

			command = AddCommand(data);
			command->include_option(roCreateNewBlock);

			item(index + 1 + i * 3 + 1)->link()->set_to_command(command);
		}
	}

#ifdef ULTIMATE
	license_data_entry_ = NULL;
	license_data_size_ = 0;
	if (ctx.options.licensing_manager) {
		Data license_data;
		if (ctx.options.licensing_manager->GetLicenseData(license_data)) {
			license_data_entry_ = AddCommand(license_data);
			license_data_entry_->include_option(roCreateNewBlock);
			license_data_size_ = static_cast<uint32_t>(license_data.size());
		}
	}
#endif

	VMProtectBeginVirtualization("Trial HWID");
	trial_hwid_entry_ = NULL;
	trial_hwid_size_ = 0;
#ifdef DEMO
	if (true)
#else
	if (ctx.options.flags & cpUnregisteredVersion)
#endif
	{
		size_t size = VMProtectGetCurrentHWID(NULL, 0);
		std::vector<char> hwid;
		hwid.resize(size);
		VMProtectGetCurrentHWID(hwid.data(), (int)hwid.size());

		std::vector<uint8_t> binary;
		binary.resize(size);
		Base64Decode(hwid.data(), hwid.size(), binary.data(), size);

		Data data;
		data.PushBuff(binary.data(), binary.size());
		data.resize(64);

		trial_hwid_size_ = static_cast<uint32_t>(std::min(size, data.size()));
		trial_hwid_entry_ = AddCommand(data);
		trial_hwid_entry_->include_option(roCreateNewBlock);
	}
#ifdef ULTIMATE
	else if (!ctx.options.hwid.empty()) {
		std::string hwid = ctx.options.hwid;
		size_t size = hwid.size();

		std::vector<uint8_t> binary;
		binary.resize(size);
		Base64Decode(hwid.data(), hwid.size(), binary.data(), size);
		if (size & 3) {
			Notify(mtError, NULL, "Invalid HWID");
			return false;
		}

		Data data;
		data.PushBuff(binary.data(), binary.size());
		data.resize(64);

		trial_hwid_size_ = static_cast<uint32_t>(std::min(size, data.size()));
		trial_hwid_entry_ = AddCommand(data);
		trial_hwid_entry_->include_option(roCreateNewBlock);
	}
#endif
	VMProtectEnd();

	for (i = 0; i < count(); i++) {
		item(i)->CompileToNative();
	}

	// setup faces for common runtime functions
	IntelCRCTable *intel_crc = reinterpret_cast<IntelFunctionList *>(ctx.file->function_list())->crc_table();
	for (k = 0; k < function_list->count(); k++) {
		IntelFunction *func = function_list->item(k);
		if (!func->from_runtime() || func->tag() == ftLoader)
			continue;

		for (i = 0; i < func->count(); i++) {
			IntelCommand *command = func->item(i);
			for (j = 0; j < 3; j++) {
				IntelOperand operand = command->operand(j);
				if (operand.type == otNone)
					break;

				if ((operand.type & otValue) == 0)
					continue;

				if (operand.size == osQWord && ((operand.value >> 32) & 0xFFFF0000) == 0xFACE0000) {
					command->Init(static_cast<IntelCommandType>(command->type()), command->operand(0), IntelOperand(otValue, operand.size, 0, operand.value >> 32));
					func->InsertObject(i + 1, new IntelCommand(func, func->cpu_address_size(), cmShl, command->operand(0), IntelOperand(otValue, osWord, 0, 32)));
					func->InsertObject(i + 2, new IntelCommand(func, func->cpu_address_size(), cmAdd, command->operand(0), IntelOperand(otValue, operand.size, 0, static_cast<uint32_t>(operand.value))));
					operand = command->operand(1);
				}

				uint32_t value = static_cast<uint32_t>(operand.value);
				// clang optimization
				if (value == FACE_RC5_P + FACE_RC5_Q) {
					command->set_operand_value(j, rc5_key_.P + rc5_key_.Q);
					command->CompileToNative();
					continue;
				}
				if (value == FACE_RC5_P + FACE_RC5_Q + FACE_RC5_Q) {
					command->set_operand_value(j, rc5_key_.P + rc5_key_.Q + rc5_key_.Q);
					command->CompileToNative();
					continue;
				}

				bool is_neg = false;
				if ((value & 0xFFFF0000) != 0xFACE0000) {
					value = 0 - value;
					is_neg = true;
				}

				if ((value & 0xFFFF0000) == 0xFACE0000) {
					switch (value) {
					case FACE_STRING_INFO:
						if (strings_entry_) {
							link = command->AddLink((int)j, ltOffset, strings_entry_);
							link->set_sub_value(image_base);
						} else {
							command->set_operand_value(j, 0);
							command->CompileToNative();
						}
						break;
					case FACE_RESOURCE_INFO:
						if (resources_entry_) {
							link = command->AddLink((int)j, ltOffset, resources_entry_);
							link->set_sub_value(image_base);
						} else {
							command->set_operand_value(j, 0);
							command->CompileToNative();
						}
						break;
					case FACE_KEY_INFO:
						if (key_entry) {
							link = command->AddLink((int)j, ltOffset, key_entry);
							link->set_sub_value(image_base);
						} else {
							command->set_operand_value(j, 0);
							command->CompileToNative();
						}
						break;
#ifdef ULTIMATE
					case FACE_STORAGE_INFO:
						if (files_entry_) {
							link = command->AddLink((int)j, ltOffset, files_entry_);
							link->set_sub_value(image_base);
						} else {
							command->set_operand_value(j, 0);
							command->CompileToNative();
						}
						break;
					case FACE_REGISTRY_INFO:
						if (registry_entry_) {
							link = command->AddLink((int)j, ltOffset, registry_entry_);
							link->set_sub_value(image_base);
						} else {
							command->set_operand_value(j, 0);
							command->CompileToNative();
						}
						break;
					case FACE_LICENSE_INFO:
						if (license_data_entry_) {
							link = command->AddLink((int)j, ltOffset, license_data_entry_);
							link->set_sub_value(image_base);
						} else {
							command->set_operand_value(j, 0);
							command->CompileToNative();
						}
						break;
					case FACE_LICENSE_INFO_SIZE:
						command->set_operand_value(j, license_data_size_);
						command->CompileToNative();
						break;
#else
					case FACE_STORAGE_INFO:
					case FACE_REGISTRY_INFO:
					case FACE_LICENSE_INFO:
					case FACE_LICENSE_INFO_SIZE:
						command->set_operand_value(j, 0);
						command->CompileToNative();
						break;
#endif
					case FACE_TRIAL_HWID:
						if (trial_hwid_entry_) {
							link = command->AddLink((int)j, ltOffset, trial_hwid_entry_);
							link->set_sub_value(image_base);
						} else {
							command->set_operand_value(j, 0);
							command->CompileToNative();
						}
						break;
					case FACE_TRIAL_HWID_SIZE:
						command->set_operand_value(j, trial_hwid_size_);
						command->CompileToNative();
						break;
					case FACE_RC5_P:
						command->set_operand_value(j, is_neg ? 0 - rc5_key_.P : rc5_key_.P);
						command->CompileToNative();
						break;
					case FACE_RC5_Q:
						command->set_operand_value(j, is_neg ? 0 - rc5_key_.Q : rc5_key_.Q);
						command->CompileToNative();
						break;
					case FACE_CRC_INFO_SALT:
						command->set_operand_value(j, function_list->crc_cryptor()->item(0)->value());
						command->CompileToNative();
						break;
					case FACE_IMAGE_BASE:
						if (command->operand(0).size != cpu_address_size()) {
							IntelOperand first = command->operand(0);
							IntelOperand second = command->operand(1);
							first.size = cpu_address_size();
							second.size = cpu_address_size();
							command->Init(static_cast<IntelCommandType>(command->type()), first, second);
						}
						command->set_operand_value(j, image_base);
						command->set_operand_fixup(j, NEED_FIXUP);
						command->CompileToNative();
						break;
					case FACE_CRC_TABLE_ENTRY:
						if (intel_crc) {
							link = command->AddLink((int)j, ltOffset, intel_crc->table_entry());
							link->set_sub_value(image_base);
						} else {
							command->set_operand_value(j, 0);
							command->CompileToNative();
						}
						break;
					case FACE_CRC_TABLE_SIZE:
						if (intel_crc) {
							link = command->AddLink((int)j, ltOffset, intel_crc->size_entry());
							link->set_sub_value(image_base);
						} else {
							command->set_operand_value(j, 0);
							command->CompileToNative();
						}
						break;
					case FACE_CRC_TABLE_HASH:
						if (intel_crc) {
							link = command->AddLink((int)j, ltOffset, intel_crc->hash_entry());
							link->set_sub_value(image_base);
						} else {
							command->set_operand_value(j, 0);
							command->CompileToNative();
						}
						break;
					case FACE_CORE_OPTIONS:
						{
							uint32_t options = 0;
							if (ctx.options.flags & cpInternalMemoryProtection)
								options |= CORE_OPTION_MEMORY_PROTECTION;
							if (ctx.options.flags & cpCheckDebugger)
								options |= CORE_OPTION_CHECK_DEBUGGER;
							command->set_operand_value(j, options);
						}
						command->CompileToNative();
						break;
					case FACE_VAR_IS_PATCH_DETECTED:
					case FACE_VAR_IS_DEBUGGER_DETECTED:
					case FACE_VAR_LOADER_CRC_INFO:
					case FACE_VAR_LOADER_CRC_INFO_SIZE:
					case FACE_VAR_LOADER_CRC_INFO_HASH:
					case FACE_VAR_CPU_HASH:
					case FACE_VAR_SESSION_KEY:
					case FACE_VAR_DRIVER_UNLOAD:
					case FACE_VAR_CRC_IMAGE_SIZE:
					case FACE_VAR_LOADER_STATUS:
					case FACE_VAR_SERVER_DATE:
					case FACE_VAR_OS_BUILD_NUMBER:
						command->set_operand_value(j, ctx.runtime_var_index[(value & 0xff) >> 4] * OperandSizeToValue(cpu_address_size()));
						command->CompileToNative();
						break;
					case FACE_VAR_IS_PATCH_DETECTED_SALT:
					case FACE_VAR_IS_DEBUGGER_DETECTED_SALT:
					case FACE_VAR_LOADER_CRC_INFO_SALT:
					case FACE_VAR_LOADER_CRC_INFO_SIZE_SALT:
					case FACE_VAR_LOADER_CRC_INFO_HASH_SALT:
					case FACE_VAR_CPU_HASH_SALT:
					case FACE_VAR_DRIVER_UNLOAD_SALT:
					case FACE_VAR_CRC_IMAGE_SIZE_SALT:
					case FACE_VAR_SERVER_DATE_SALT:
					case FACE_VAR_OS_BUILD_NUMBER_SALT:
						command->set_operand_value(j, ctx.runtime_var_salt[value & 0xff]);
						command->CompileToNative();
						break;
					}
				}
			}
		}
	}

	return IntelFunction::Init(ctx);
}

size_t IntelRuntimeData::WriteToFile(IArchitecture &file)
{
	size_t res = IntelFunction::WriteToFile(file);

	CipherRC5 cipher(rc5_key_);
	for (size_t i = 0; i < 6; i++) {
		IntelCommand *command;
		size_t size;

		switch (i) {
		case 0:
			command = resources_entry_;
			size = resources_size_;
			break;
		case 1:
			command = strings_entry_;
			size = strings_size_;
			break;
		case 2:
			command = trial_hwid_entry_;
			size = AlignValue(trial_hwid_size_, 8);
			break;
#ifdef ULTIMATE
		case 3:
			command = license_data_entry_;
			size = license_data_size_;
			break;
		case 4:
			command = files_entry_;
			size = files_size_;
			break;
		case 5:
			command = registry_entry_;
			size = registry_size_;
			break;
#endif
		default:
			command = NULL;
			size = 0;
		}

		if (size) {
			std::vector<uint8_t> buff;
			buff.resize(size);
			file.AddressSeek(command->address());
			uint64_t pos = file.Tell();
			file.Read(&buff[0], buff.size());
#ifdef ULTIMATE
			if (command == trial_hwid_entry_) {
				cipher.Encrypt(buff.data(), buff.size());
			} else if (command == license_data_entry_) {
				size_t crc_pos = buff.size() - 16;
				cipher.Encrypt(buff.data(), crc_pos);
				SHA1 sha1;
				sha1.Input(buff.data(), crc_pos);
				const uint8_t *p = sha1.Result();
				for (size_t j = crc_pos; j < buff.size(); j++) {
					buff[j] = p[j - crc_pos];
				}
				cipher.Encrypt(buff.data() + crc_pos, 16);
			} else
#endif
			{
				uint32_t *p = reinterpret_cast<uint32_t*>(buff.data());
				for (size_t j = 0; j < size / sizeof(uint32_t); j++) {
					p[j] ^= data_key_;
				}
			}
			file.Seek(pos);
			file.Write(buff.data(), buff.size());
		}
	}

	return res;
}

/**
 * BaseIntelLoader
 */

BaseIntelLoader::BaseIntelLoader(IntelFunctionList *owner, OperandSize cpu_address_size)
	: IntelFunction(owner, cpu_address_size), data_segment_address_(0), import_segment_address_(0)
{
	set_tag(ftLoader);
}

void BaseIntelLoader::AddAVBuffer(const CompileContext &ctx)
{
	IntelCommand *command;
	uint32_t sum = 0;
	CommandBlock *block = AddBlock(count(), true);
	for (size_t i = 0; i < 64; i++) {
		uint32_t value = (i == 0) ? 0 : rand32();
		sum += value;
		command = AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, value));
		command->CompileToNative();
		command->set_block(block);
	}
	block->set_end_index(count() - 1);
	command = item(block->start_index());
	command->set_operand_value(0, 0xB7896EB5 - sum);
	command->CompileToNative();
	uint64_t address = ctx.manager->Alloc((block->end_index() - block->start_index() + 1) * sizeof(uint32_t), mtReadable);
	block->set_address(address);
}

bool BaseIntelLoader::Prepare(const CompileContext &ctx)
{
	size_t i, j;

	if (ctx.file->virtual_machine_list()->count() > 1) {
		std::set<ICommand *> call_list;

		for (i = 0; i < count(); i++) {
			IntelCommand *command = item(i);
			if (command->type() == cmCall && (command->options() & roInternal)) {
				ICommand *to_command = command->link()->to_command();
				if (!to_command)
					continue;

				call_list.insert(to_command);
				command_group_.insert(item(i + 1));
			}
		}
		if (!call_list.empty()) {
			for (i = 0; i < count(); i++) {
				IntelCommand *command = item(i);
				if (command->type() == cmRet && (command->options() & roInternal)) {
					IntelCommand *block_command = NULL;
					for (j = i; j > 0; j--) {
						command = item(j - 1);
						if (!block_command) {
							if ((command->type() == cmCall && ((command->section_options() & rtLinkedFrom) || (command->options() & roInternal) == 0))
								|| command->type() == cmJmp || command->type() == cmJmpWithFlag || command->type() == cmCmov || command->type() == cmRet || command->is_data())
								block_command = item(j);
						}
						if (call_list.find(command) != call_list.end()) {
							command_group_.insert(block_command ? block_command : command);
							break;
						}
					}
				}
			}
		}
	}

	// prepare loader's VM
	std::vector<IFunction *> function_list = ctx.file->function_list()->processor_list();
	for (size_t k = 0; k < function_list.size(); k++) {
		IntelFunction *func = reinterpret_cast<IntelFunction*>(function_list[k]);
		for (i = 0; i < func->count(); i++) {
			IntelCommand *command = func->item(i);
			for (j = 0; j < 3; j++) {
				IntelOperand operand = command->operand(j);
				if (operand.type == otNone)
					break;

				if (operand.fixup)
					command->set_operand_fixup(j, NEED_FIXUP);
			}
		}
		for (i = 0; i < func->function_info_list()->count(); i++) {
			FunctionInfo *info = func->function_info_list()->item(i);
			for (size_t j = 0; j < info->count(); j++) {
				AddressRange *address_range = info->item(j);
				address_range->set_begin(0);
				address_range->set_end(0);
			}
		}
	}

	// prepare ranges
	function_list.push_back(this);
	for (i = 0; i < function_list.size(); i++) {
		IntelFunction *func = reinterpret_cast<IntelFunction*>(function_list[i]);
		func->range_list()->Prepare();
		func->function_info_list()->Prepare();
	}

	return PrepareExtCommands(ctx);
}

IVirtualMachine *BaseIntelLoader::virtual_machine(IVirtualMachineList *virtual_machine_list, ICommand *command) const
{
	if (command_group_.find(command) != command_group_.end()) {
		for (std::set<ICommand *>::const_iterator it = command_group_.begin(); it != command_group_.end(); it++) {
			command = *it;
			if (command->block())
				return command->block()->virtual_machine();
		}
	}

	return IntelFunction::virtual_machine(virtual_machine_list, command);
}

bool BaseIntelLoader::Compile(const CompileContext &ctx)
{
	size_t i, j;

	if (ctx.options.flags & cpMemoryProtection) {
		IntelVirtualMachineList *virtual_machine_list = reinterpret_cast<IntelVirtualMachineList*>(ctx.file->virtual_machine_list());
		virtual_machine_list->ClearCRCMap();
	}

	if (!IntelFunction::Compile(ctx))
		return false;
	IntelFunction::AfterCompile(ctx);

	std::vector<IFunction *> function_list = ctx.file->function_list()->processor_list();
	function_list.push_back(this);
	std::vector<CommandBlock*> data_block_list[2], block_list;
	for (i = 0; i < function_list.size(); i++) {
		IFunction *func = function_list[i];
		for (j = 0; j < func->block_list()->count(); j++) {
			CommandBlock *block = func->block_list()->item(j);
			uint32_t command_options = block->function()->item(block->start_index())->options();
			if (command_options & roImportSegment)
				data_block_list[0].push_back(block);
			else if (command_options & roDataSegment)
				data_block_list[1].push_back(block);
			else 
				block_list.push_back(block);
		}
	}

	for (i = 0; i < block_list.size(); i++) {
		std::swap(block_list[i], block_list[rand() % block_list.size()]);
	}

	if (ctx.file->runtime_function_list() && ctx.file->runtime_function_list()->count()) {
		// sort blocks by address range
		for (i = 0; i < block_list.size(); i++) {
			block_list[i]->set_sort_index(i);
		}
		std::sort(block_list.begin(), block_list.end(), CommandBlockListCompareHelper());
	}

	for (i = 0; i < block_list.size(); i++) {
		block_list[i]->Compile(*ctx.manager);
	}

	for (j = 0; j < 2; j++) {
		std::vector<CommandBlock*> *list = &data_block_list[j];
		if (list->empty())
			continue;

		MemoryRegion *last_region = ctx.manager->item(ctx.manager->count() - 1);
		uint64_t address = last_region->address();
		uint64_t segment_address = AlignValue(address, ctx.file->segment_alignment());
		if (j == 0)
			import_segment_address_ = segment_address;
		else 
			data_segment_address_ = segment_address;
		if (segment_address > address)
			last_region->Alloc(segment_address - address, mtNone);
		for (i = 0; i < ctx.manager->count(); i++) {
			MemoryRegion *region = ctx.manager->item(i);
			if (region->address() < segment_address)
				region->exclude_type(mtReadable);
		}
		for (i = 0; i < list->size(); i++) {
			list->at(i)->Compile(*ctx.manager);
		}
	}

	for (i = 0; i < function_list.size(); i++) {
		function_list[i]->CompileInfo(ctx);
	}

	if (ctx.options.flags & cpMemoryProtection) {
		IntelFunctionList *function_list = reinterpret_cast<IntelFunctionList *>(ctx.file->function_list());
		IntelRuntimeCRCTable *runtime_crc_table = function_list->runtime_crc_table();
		for (i = 0; i < function_list->count(); i++) {
			IntelFunction *func = function_list->item(i);
			if (func == runtime_crc_table || func->tag() == ftProcessor || func == this)
				continue;

			func->set_need_compile(false);
		}
		runtime_crc_table->clear();
		runtime_crc_table->Compile(ctx);
	}

	for (i = 0; i < function_list.size(); i++) {
		IFunction *func = function_list[i];
		if (func->compilation_type() != ctMutation)
			continue;

		func->CompileLinks(ctx);
	}

	for (i = 0; i < function_list.size(); i++) {
		IFunction *func = function_list[i];
		if (func->compilation_type() == ctMutation)
			continue;

		func->CompileLinks(ctx);
	}

	return true;
}

/**
 * PEIntelLoader
 */

PEIntelLoader::PEIntelLoader(IntelFunctionList *owner, OperandSize cpu_address_size)
	: BaseIntelLoader(owner, cpu_address_size), import_entry_(NULL), import_size_(0), iat_entry_(NULL), iat_size_(0), 
	name_entry_(NULL), resource_section_info_(NULL), resource_packer_info_(NULL), export_entry_(NULL), export_size_(0),
	tls_entry_(NULL), tls_size_(0), file_crc_entry_(NULL), file_crc_size_(0), loader_crc_entry_(NULL), loader_crc_size_(0), 
	delay_import_entry_(NULL), delay_import_size_(0), tls_call_back_entry_(NULL), iat_address_(0),
	loader_crc_size_entry_(NULL), loader_crc_hash_entry_(NULL), file_crc_size_entry_(NULL), security_cookie_(0), cfg_check_function_entry_(NULL)
{

}

Data EncryptString(const char *str, uint32_t key)
{
	Data data;
	for (size_t i = 0; ; i++) {
		data.PushByte(str[i] ^ static_cast<uint8_t>(_rotl32(key, (int)i) + i));
		if (!str[i])
			break;
	}
	return data;
}

Data EncryptString(const os::unicode_char *str, uint32_t key)
{
	Data data;
	for (size_t i = 0; ; i++) {
		data.PushWord(str[i] ^ static_cast<uint16_t>(_rotl32(key, (int)i) + i));
		if (!str[i])
			break;
	}
	return data;
}

bool PEIntelLoader::Prepare(const CompileContext &ctx)
{
	size_t i, j, k, index, old_count, import_index, orig_dll_count, file_dll_count, start_index;
	PEImportList new_import_list(NULL);
	PEImport *import;
	PEImportFunction *import_function;
	IntelCommandType value_command_type;
	IntelCommand *command, *iat_command, *src_command, *dst_command, *setup_image_entry, *free_image_entry;
	ImportInfo import_info;
	std::vector<ImportInfo> import_info_list;
	std::vector<ImportFunctionInfo> import_function_info_list;
	PEArchitecture *file, *runtime;
	CommandLink *link;
	IntelFunctionList *runtime_function_list;
	IntelFunction *func;
	std::map<uint64_t, PEImportFunction *> runtime_info_list;
	CommandLink *src_link, *dst_link;
	std::string dll_name;
	IntelImport *intel_import;
	IntelCRCTable *intel_crc;
	uint64_t loader_data_address, tls_index_address;

	file = reinterpret_cast<PEArchitecture *>(ctx.file);
	runtime = reinterpret_cast<PEArchitecture *>(ctx.runtime);
	intel_import = reinterpret_cast<IntelFunctionList *>(file->function_list())->import();
	intel_crc = reinterpret_cast<IntelFunctionList *>(file->function_list())->crc_table();
	IntelLoaderData *loader_data = reinterpret_cast<IntelFunctionList*>(file->function_list())->loader_data();
	loader_data_address = (loader_data) ? loader_data->entry()->address() : runtime->export_list()->GetAddressByType(atLoaderData);
	if (!loader_data_address)
		return false;

	// create AV signature buffer
	AddAVBuffer(ctx);
	start_index = count();

	ICommand *entry_point_command = NULL;
	if (file->entry_point()) {
		IFunction *entry_point_func = ctx.file->function_list()->GetFunctionByAddress(file->entry_point());
		if (entry_point_func)
			entry_point_command = entry_point_func->entry();
	}
	import_index = 0;
	file_dll_count = 0;
	k = (runtime->segment_list()->count() > 0) ? 2 : 1;
	for (j = 0; j < k; j++) {
		PEArchitecture *source_file = (j == 0) ? file : runtime;
		for (i = 0; i < source_file->import_list()->count(); i++) {
			import = source_file->import_list()->item(i);
			if (import->is_sdk())
				continue;

			new_import_list.AddObject(import->Clone(&new_import_list));
			import_index += import->count();
		}

		if (j == 0)
			file_dll_count = new_import_list.count();
	}

	// need move native APIs to the top of vector
	if (ctx.options.flags & cpImportProtection) {
		for (i = 0; i < new_import_list.count(); i++) {
			import = new_import_list.item(i);

			k = NOT_ID;
			for (j = 0; j < import->count(); j++) {
				import_function = import->item(j);
				if (import_function->options() & ioNative) {
					if (k == NOT_ID)
						continue;
					import->SwapObjects(k, j);
					k++;
				} else {
					if (k == NOT_ID)
						k = j;
				}
			}
		}
	}

	// add loader import
	std::map<uint64_t, PEImportFunction *> import_map;
	orig_dll_count = new_import_list.count();
	runtime_function_list = reinterpret_cast<IntelFunctionList *>(runtime->function_list());
	for (i = 0; i < runtime_function_list->count(); i++) {
		func = runtime_function_list->item(i);
		if (func->tag() != ftLoader)
			continue;

		for (j = 0; j < func->count(); j++) {
			command = func->item(j);
			import_function = NULL;
			switch (command->type()) {
			case cmCall:
			case cmJmp:
			case cmMov:
				k = (command->type() == cmMov) ? 1 : 0;
				if (command->operand(k).type == (otMemory | otValue))
					import_function = runtime->import_list()->GetFunctionByAddress(command->operand(k).value);
				break;
			}
			if (!import_function)
				continue;

			std::map<uint64_t, PEImportFunction *>::const_iterator it = import_map.find(import_function->address());
			PEImportFunction *new_import_function = (it != import_map.end()) ? it->second : NULL;
			if (!new_import_function) {
				dll_name = import_function->owner()->name();
				import = NULL;
				for (k = orig_dll_count; k < new_import_list.count(); k++) {
					if (new_import_list.item(k)->CompareName(dll_name)) {
						import = new_import_list.item(k);
						break;
					}
				}
				if (!import) {
					import = new PEImport(&new_import_list, dll_name);
					new_import_list.AddObject(import);
				}
				new_import_function = import_function->Clone(import);
				import->AddObject(new_import_function);
				import_map[import_function->address()] = new_import_function;
			}
			runtime_info_list[command->address()] = new_import_function;
		}
	}

	// create import directory
	for (i = 0; i < new_import_list.count(); i++) {
		import = new_import_list.item(i);

#ifdef ULTIMATE
		if (ctx.options.file_manager && i < file_dll_count) {
			bool is_delay_import = false;
			for (j = 0; j < ctx.options.file_manager->count(); j++) {
				if (import->CompareName(ctx.options.file_manager->item(j)->name())) {
					is_delay_import = true;
					break;
				}
			}

			if (is_delay_import) {
				import_info.original_first_thunk = NULL;
				import_info.name = NULL;
				import_info.first_thunk = NULL;

				import_info_list.push_back(import_info);
				continue;
			}
		}
#endif

		// IMAGE_IMPORT_DESCRIPTOR.OriginalFirstThunk
		command = AddCommand(cmDD, IntelOperand(otValue, osDWord)); 
		command->AddLink(0, ltOffset);
		import_info.original_first_thunk = command;

		// IMAGE_IMPORT_DESCRIPTOR.TimeDateStamp
		AddCommand(cmDD, IntelOperand(otValue, osDWord)); 

		// IMAGE_IMPORT_DESCRIPTOR.ForwarderChain
		AddCommand(cmDD, IntelOperand(otValue, osDWord)); 

		// IMAGE_IMPORT_DESCRIPTOR.Name
		command = AddCommand(cmDD, IntelOperand(otValue, osDWord)); 
		command->AddLink(0, ltOffset);
		import_info.name = command;

		// IMAGE_IMPORT_DESCRIPTOR.FirstThunk
		command = AddCommand(cmDD, IntelOperand(otValue, osDWord)); 
		command->AddLink(0, ltOffset);
		import_info.first_thunk = command;

		import_info_list.push_back(import_info);
	}

	// end of import directory
	for (j = 0; j < 5; j++) {
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
	}

	import_size_ = static_cast<uint32_t>((count() - start_index) * sizeof(uint32_t));
	import_entry_ = item(start_index);
	import_entry_->set_alignment(OperandSizeToValue(cpu_address_size()));

	// create IAT
	value_command_type = (cpu_address_size() == osDWord) ? cmDD : cmDQ;
	uint64_t ordinal_mask = (cpu_address_size() == osDWord) ? IMAGE_ORDINAL_FLAG32 : IMAGE_ORDINAL_FLAG64;
	size_t name_index = count();
	for (i = 0; i < new_import_list.count(); i++) {
		import = new_import_list.item(i);

		bool is_delay_import = (import_info_list[i].name == NULL);

		index = count();
		for (j = 0; j < import->count(); j++) {
			import_function = import->item(j);

			if (is_delay_import) {
				command = NULL;
			} else
			// for import protection need only one API for each DLL
			if ((ctx.options.flags & cpImportProtection) && i < orig_dll_count && (import_function->options() & ioNative) == 0 && j > 0) {
				command = NULL;
			} else if (import_function->is_ordinal()) {
				command = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, ordinal_mask | import_function->ordinal()));
			} else {
				command = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size()));
				command->AddLink(0, ltOffset);
			}
			ImportFunctionInfo import_function_info(import_function);
			import_function_info.name = command;

			import_function_info_list.push_back(import_function_info);
		}

		if (is_delay_import)
			continue;

		AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size()));

		import_info_list[i].original_first_thunk->link()->set_to_command(item(index));
	}
	name_entry_ = item(name_index);
	name_entry_->set_alignment(OperandSizeToValue(cpu_address_size()));

	size_t iat_index = count();
	for (i = 0, import_index = 0; i < new_import_list.count(); i++) {
		import = new_import_list.item(i);

		bool is_delay_import = (import_info_list[i].name == NULL);

		index = count();
		for (j = 0; j < import->count(); j++, import_index++) {
			import_function = import->item(j);

			if (is_delay_import) {
				command = NULL;
			} else
			// for import protection need only one API for each DLL
			if ((ctx.options.flags & cpImportProtection) && i < orig_dll_count && (import_function->options() & ioNative) == 0 && j > 0) {
				command = NULL;
			} else if (import_function->is_ordinal()) {
				command = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, ordinal_mask | import_function->ordinal()));
			} else {
				command = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size()));
				command->AddLink(0, ltOffset);
			}

			import_function_info_list[import_index].thunk = command;
		}

		if (is_delay_import)
			continue;

		AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size()));

		import_info_list[i].first_thunk->link()->set_to_command(item(index));
	}

	iat_entry_ = item(iat_index);
	iat_size_ = static_cast<uint32_t>((count() - iat_index) * OperandSizeToValue(cpu_address_size()));
	iat_entry_->set_alignment(file->segment_alignment());
	iat_entry_->include_option(roCreateNewBlock);

	if (iat_address_) {
		CommandBlock *block = AddBlock(iat_index, true);
		block->set_address(iat_address_);
		for (i = iat_index; i < count(); i++) {
			block->set_end_index(i);
			item(i)->set_block(block);
		}
	}
	else {
		// IAT size must be aligned by page size
		j = AlignValue(iat_size_, file->segment_alignment());
		if (j > iat_size_) {
			std::string buffer;
			buffer.resize(j - iat_size_, 0);
			AddCommand(buffer);
		}
	}

	// create import DLL names
	uint32_t string_key = rand32();
	for (i = 0; i < new_import_list.count(); i++) {
		import = new_import_list.item(i);

		bool is_delay_import = (import_info_list[i].name == NULL);

		if (is_delay_import) {
			command = AddCommand(EncryptString(import->name().c_str(), string_key));
			command->include_option(roCreateNewBlock);

			import_info_list[i].loader_name = command;
			continue;
		}

		if ((ctx.options.flags & cpImportProtection) && i < orig_dll_count) {
			command = AddCommand(EncryptString(import->name().c_str(), string_key));
			command->include_option(roCreateNewBlock);

			import_info_list[i].loader_name = command;
		}

		command = NULL;
		for (j = 0; j < i; j++) {
			if (new_import_list.item(j)->CompareName(import->name())) {
				command = reinterpret_cast<IntelCommand *>(import_info_list[j].name->link()->to_command());
				break;
			}
		}
		if (command == NULL) {
			command = AddCommand(import->name());
			command->include_option(roCreateNewBlock);
			command->set_alignment(sizeof(uint16_t));
		}

		import_info_list[i].name->link()->set_to_command(command);
	}

	// create import function names
	for (i = 0, import_index = 0; i < new_import_list.count(); i++) {
		import = new_import_list.item(i);

		bool is_delay_import = (import_info_list[i].name == NULL);

		for (j = 0; j < import->count(); j++, import_index++) {
			import_function = import->item(j);
			if (import_function->is_ordinal())
				continue;

			if (is_delay_import) {
				command = AddCommand(EncryptString(import_function->name().c_str(), string_key));
				command->include_option(roCreateNewBlock);

				import_function_info_list[import_index].loader_name = command;
				continue;
			}

			// for import protection need only one API for each DLL
			if ((ctx.options.flags & cpImportProtection) && i < orig_dll_count && (import_function->options() & ioNative) == 0) {
				command = AddCommand(EncryptString(import_function->name().c_str(), string_key));
				command->include_option(roCreateNewBlock);

				import_function_info_list[import_index].loader_name = command;

				if (j > 0)
					continue;
			}
			
			command = AddCommand(cmDW, IntelOperand(otValue, osWord));
			command->include_option(roCreateNewBlock);
			command->set_alignment(sizeof(uint16_t));

			AddCommand(import_function->name());

			import_function_info_list[import_index].name->link()->set_to_command(command);
			import_function_info_list[import_index].thunk->link()->set_to_command(command);
		}
	}

	// update links for PE structures
	for (i = 0; i < count(); i++) {
		link = item(i)->link();
		if (!link)
			continue;

		link->set_sub_value(file->image_base());
	}

	// create export
	export_entry_ = NULL;
	export_size_ = 0;
	if (ctx.options.flags & cpPack) {
		index = count();
		export_size_ = file->export_list()->WriteToData(*this, file->image_base());
		export_entry_ = (count() == index) ? AddCommand(osDWord, 0) : item(index);
	}

	// create delay import
	delay_import_entry_ = NULL;
	delay_import_size_ = 0;
	if (file->delay_import_list()->count()) {
		std::vector<ImportInfo> delay_import_info;
		PEDelayImport *delay_import;
		PEDelayImportFunction *delay_import_function;

		size_t delay_index = count();
		for (i = 0; i < file->delay_import_list()->count(); i++) {
			delay_import = file->delay_import_list()->item(i);

			index = count();
			AddCommand(osDWord, delay_import->flags());

			import_info.name = AddCommand(osDWord, 0);
			import_info.name->AddLink(0, ltOffset);

			AddCommand(osDWord, delay_import->module());
			AddCommand(osDWord, delay_import->iat());

			import_info.first_thunk = AddCommand(osDWord, 0);
			import_info.first_thunk->AddLink(0, ltOffset);

			AddCommand(osDWord, delay_import->bound_iat());
			AddCommand(osDWord, delay_import->unload_iat());
			AddCommand(osDWord, delay_import->time_stamp());

			for (j = index + 1; j < count() - 1; j++) {
				command = item(j);
				if (delay_import->flags() & 1) {
					if (command->link())
						command->link()->set_sub_value(file->image_base());
					else if (command->operand(0).value)
						command->set_operand_value(0, command->operand(0).value - file->image_base());
				} else {
					if (command->link() || command->operand(0).value)
						command->set_operand_fixup(0, NEED_FIXUP);
				}
			}

			delay_import_info.push_back(import_info);
		}

		// end of delay import
		for (j = 0; j < 8; j++) {
			AddCommand(osDWord, 0);
		}

		delay_import_entry_ = item(delay_index);
		delay_import_entry_->include_option(roCreateNewBlock);
		delay_import_entry_->set_alignment(OperandSizeToValue(osDWord));
		delay_import_size_ = static_cast<uint32_t>((count() - delay_index) * sizeof(uint32_t));

		for (i = 0; i < file->delay_import_list()->count(); i++) {
			delay_import = file->delay_import_list()->item(i);

			index = count();
			for (j = 0; j < delay_import->count(); j++) {
				delay_import_function = delay_import->item(j);
				if (delay_import_function->is_ordinal()) {
					command = AddCommand(cpu_address_size(), ordinal_mask | delay_import_function->ordinal());
				} else {
					command = AddCommand(cpu_address_size(), 0);
					link = command->AddLink(0, ltOffset);
					if (delay_import->flags() & 1)
						link->set_sub_value(file->image_base());
					else
						command->set_operand_fixup(0, NEED_FIXUP);
				}
			}
			AddCommand(cpu_address_size(), 0);

			command = item(index);
			delay_import_info[i].first_thunk->link()->set_to_command(command);
			delay_import_info[i].original_first_thunk = command;
		}

		for (i = 0; i < file->delay_import_list()->count(); i++) {
			delay_import = file->delay_import_list()->item(i);
			import_info = delay_import_info[i];

			command = AddCommand(delay_import->name());
			command->include_option(roCreateNewBlock);
			import_info.name->link()->set_to_command(command);

			index = IndexOf(import_info.original_first_thunk);
			for (j = 0; j < delay_import->count(); j++) {
				delay_import_function = delay_import->item(j);
				if (delay_import_function->is_ordinal())
					continue;

				command = AddCommand(osWord, 0);
				command->include_option(roCreateNewBlock);
				command->set_alignment(sizeof(uint16_t));
				AddCommand(delay_import_function->name());

				item(index + j)->link()->set_to_command(command);
			}
		}
	}

	// create tls structure
	tls_entry_ = NULL;
	tls_size_ = 0;
	tls_call_back_entry_ = NULL;
	tls_index_address = 0;
	if (file->tls_directory()->address() && (file->tls_directory()->count() || (ctx.options.flags & cpPack))) {
		size_t tls_index = count();

		PETLSDirectory *tls_directory = file->tls_directory();
		if (ctx.options.flags & cpPack) {
			if (file->AddressSeek(tls_directory->address_of_index()) && !file->selected_segment()->excluded_from_packing())
				tls_index_address = tls_directory->address_of_index();
		}

		AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, tls_directory->start_address_of_raw_data(), NEED_FIXUP));
		AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, tls_directory->end_address_of_raw_data(), NEED_FIXUP));
		AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, tls_directory->address_of_index(), NEED_FIXUP));
		IntelCommand *call_back_entry = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, 0));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, tls_directory->size_of_zero_fill()));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, tls_directory->characteristics()));

		tls_entry_ = item(tls_index);
		tls_entry_->include_option(roCreateNewBlock);
		tls_entry_->set_alignment(OperandSizeToValue(cpu_address_size()));
		for (i = tls_index; i < count(); i++) {
			command = item(i);
			tls_size_ += (command->type() == cmDB) ? (uint32_t)command->dump_size() : OperandSizeToValue(command->operand(0).size);
		}

		index = count();
		if (file->tls_directory()->count()) {
			tls_call_back_entry_ = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
			tls_call_back_entry_->AddLink(0, ltGateOffset);
		}
		for (i = 0; i < tls_directory->count(); i++) {
			AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, tls_directory->item(i)->address(), NEED_FIXUP));
		}
		if (count() > index) {
			AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, 0));
			call_back_entry->AddLink(0, ltOffset, item(index));
			call_back_entry->set_operand_fixup(0, NEED_FIXUP);
		}
	}

	// create watermarks
	AddWatermark(ctx.options.watermark, 2);

	// create section list for setting WRITABLE flag
	PESegment *section;
	std::vector<PESegment *> writable_section_list;
	uint64_t address;
	section = file->segment_list()->GetSectionByAddress(loader_data_address);
	if (section)
		writable_section_list.push_back(section);
	for (i = 0; i < orig_dll_count; i++) {
		import = new_import_list.item(i);
		for (j = 0; j < import->count(); j++) {
			import_function = import->item(j);
			address = import_function->address();
			if (ctx.options.flags & cpImportProtection) {
				iat_command = intel_import->GetIATCommand(import_function);
				if (iat_command)
					address = iat_command->address();
			}
			section = file->segment_list()->GetSectionByAddress(address);
			if (!section)
				continue;

			if (std::find(writable_section_list.begin(), writable_section_list.end(), section) == writable_section_list.end())
				writable_section_list.push_back(section);
		}
	}

	for (i = 0; i < file->relocation_list()->count(); i++) {
		PERelocation *relocation = file->relocation_list()->item(i);

		section = file->segment_list()->GetSectionByAddress(relocation->address());
		if (!section)
			continue;

		if (std::find(writable_section_list.begin(), writable_section_list.end(), section) == writable_section_list.end())
			writable_section_list.push_back(section);
	}
	
	std::vector<PackerInfo> packer_info_list;
	PEFixupList loader_fixup_list;
	bool pack_resources = false;
	IntelCommand *packer_props = NULL;
	if (ctx.options.flags & cpPack) {
		PackerInfo packer_info;
		for (i = 0; i < file->segment_list()->count(); i++) {
			section = file->segment_list()->item(i);
			if (section->excluded_from_packing())
				continue;

			bool can_be_packed = true;
			if ((section->memory_type() & (mtWritable | mtShared)) == (mtWritable | mtShared)) {
				can_be_packed = false;
			}

			if (!can_be_packed) {
				//file->Notify(mtWarning, NULL, string_format(language[lsSegmentCanNotBePacked].c_str(), section->name().c_str()));
				continue;
			}

			if (section->physical_size()) {
				packer_info.section = section;
				packer_info.address = section->address();
				packer_info.size = static_cast<size_t>(section->physical_size());
				packer_info.data = NULL;
				packer_info_list.push_back(packer_info);

				// need add packed section into WRITABLE section list
				if (std::find(writable_section_list.begin(), writable_section_list.end(), section) == writable_section_list.end())
					writable_section_list.push_back(section);
			}
		}

		if ((ctx.options.flags & cpStripFixups) == 0) {
			for (i = 0; i < file->fixup_list()->count(); i++) {
				PEFixup *fixup = file->fixup_list()->item(i);
				if (fixup->is_deleted())
					continue;

				section = file->segment_list()->GetSectionByAddress(fixup->address());
				if (!section || std::find(packer_info_list.begin(), packer_info_list.end(), section) == packer_info_list.end())
					continue;

				loader_fixup_list.AddObject(fixup->Clone(&loader_fixup_list));
				fixup->set_deleted(true);

				// need add section into WRITABLE section list
				if (std::find(writable_section_list.begin(), writable_section_list.end(), section) == writable_section_list.end())
					writable_section_list.push_back(section);
			}
		}

		// packing sections
		j = 0;
		for (i = 0; i < packer_info_list.size(); i++) {
			j += packer_info_list[i].size;
		}
		if (file->resource_list()->size() > file->resource_list()->store_size())
			j += file->resource_list()->size() - file->resource_list()->store_size();
		file->StartProgress(string_format("%s...", language[lsPacking].c_str()), j);

		Data data;
		Packer packer;

		if (!packer.WriteProps(&data))
			throw std::runtime_error("Packer error");
		packer_props = AddCommand(data);
		packer_props->include_option(roCreateNewBlock);

		for (i = 0; i < packer_info_list.size(); i++) {
			packer_info = packer_info_list[i];
			if (!file->AddressSeek(packer_info.address))
				return false;

			if (!packer.Code(file, packer_info.size, &data))
				throw std::runtime_error("Packer error");

			command = AddCommand(data);
			command->include_option(roCreateNewBlock);
			packer_info_list[i].data = command;
		}

		if (file->resource_list()->size() > file->resource_list()->store_size()) {
			Data res_data;
			file->resource_list()->WritePackData(res_data);

			if (!packer.Code(file, &res_data, &data))
				return false;

			command = AddCommand(data);
			command->include_option(roCreateNewBlock);

			packer_info.address = 0;
			packer_info.size = res_data.size();
			packer_info.data = command;
			packer_info.section = NULL;
			packer_info_list.push_back(packer_info);
			pack_resources = true;
		}
		
		// remove packed sections from file
		uint32_t physical_offset = 0;
		for (i = 0; i < file->segment_list()->count(); i++) {
			section = file->segment_list()->item(i);
			if (section->physical_offset() > 0 && section->physical_size() > 0) {
				physical_offset = static_cast<uint32_t>(section->physical_offset());
				break;
			}
		}

		for (i = 0; i < file->segment_list()->count(); i++) {
			section = file->segment_list()->item(i);
			uint32_t physical_size = section->physical_size();
			bool is_packed = false;
			std::vector<PackerInfo>::iterator it = std::find(packer_info_list.begin(), packer_info_list.end(), section);
			if (it != packer_info_list.end()) {
				physical_size = static_cast<uint32_t>(it->address - section->address());
				is_packed = true;
			}

			if (physical_size > 0 && section->physical_offset() != physical_offset) {
				uint8_t *buff = new uint8_t[physical_size];
				file->Seek(section->physical_offset());
				file->Read(buff, physical_size);
				file->Seek(physical_offset);
				file->Write(buff, physical_size);
				delete [] buff;
			}

			section->set_physical_offset(physical_offset);
			section->set_physical_size(physical_size);

			if (is_packed) {
				j = physical_offset + physical_size;
				file->Seek(j);
				physical_offset = (uint32_t)AlignValue(j, file->file_alignment());
				for (k = j; k < physical_offset; k++) {
					file->WriteByte(0);
				}
			} else {
				physical_offset += physical_size;
			}
		}
		file->Resize(physical_offset);
	}

	// create packer info for loader
	std::vector<LoaderInfo> loader_info_list;
	index = count();
	if (packer_props) {
		command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
		link = command->AddLink(0, ltOffset, packer_props);
		link->set_sub_value(file->image_base());
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, packer_props->dump_size()));

		for (i = 0; i < packer_info_list.size(); i++) {
			command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
			link = command->AddLink(0, ltOffset, packer_info_list[i].data);
			link->set_sub_value(file->image_base());

			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, packer_info_list[i].address - file->image_base()));
		}
	}
	if (pack_resources) {
		resource_packer_info_ = item(count() - 1);
	} else {
		resource_packer_info_ = NULL;
	}
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create file CRC info for loader
	index = count();
	if (((ctx.options.flags | ctx.options.sdk_flags) & cpMemoryProtection) && file->image_type() != itDriver) {
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
		for (i = 0; i < 10; i++) {
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
		}
	}
	file_crc_entry_ = (count() == index) ? NULL : item(index);
	if (file_crc_entry_)
		file_crc_entry_->include_option(roCreateNewBlock);
	file_crc_size_ = (uint32_t)((count() - index) * OperandSizeToValue(osDWord));
	loader_info_list.push_back(LoaderInfo(file_crc_entry_, file_crc_size_));

	file_crc_size_entry_ = file_crc_entry_ ? AddCommand(cmDD, IntelOperand(otValue, osDWord)) : NULL;
	if (file_crc_size_entry_)
		file_crc_size_entry_->include_option(roCreateNewBlock);

	// create header and loader CRC info for loader
	index = count();
	if (((ctx.options.flags | ctx.options.sdk_flags) & cpMemoryProtection) || (ctx.options.flags & cpLoaderCRC)) {
		// calc CRC blocks count
		k = 30 + new_import_list.count();
		if ((ctx.options.flags & cpStripFixups) == 0) {
			std::vector<IFunction *> function_list = ctx.file->function_list()->processor_list();
			function_list.push_back(this);
			for (i = 0; i < runtime_function_list->count(); i++) {
				func = runtime_function_list->item(i);
				if (func->tag() != ftLoader)
					continue;

				if (func->compilation_type() == ctMutation)
					function_list.push_back(func);
			}

			for (i = 0; i < function_list.size(); i++) {
				func = reinterpret_cast<IntelFunction *>(function_list[i]);
				for (j = 0; j < func->count(); j++) {
					command = func->item(j);
					for (size_t c = 0; c < 3; c++) {
						IntelOperand operand = command->operand(c);
						if (operand.type == otNone)
							break;
						if (operand.fixup)
							k++;
					}
				}
			}
		}
		for (i = 0; i < k; i++) {
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
		}
	}
	loader_crc_entry_ = (count() == index) ? NULL : item(index);
	if (loader_crc_entry_)
		loader_crc_entry_->include_option(roCreateNewBlock);
	loader_crc_size_ = static_cast<uint32_t>((count() - index) * OperandSizeToValue(osDWord));
	loader_info_list.push_back(LoaderInfo(loader_crc_entry_, loader_crc_size_));

	loader_crc_size_entry_ = loader_crc_entry_ ? AddCommand(cmDD, IntelOperand(otValue, osDWord)) : NULL;
	if (loader_crc_size_entry_)
		loader_crc_size_entry_->include_option(roCreateNewBlock);
	loader_crc_hash_entry_ = loader_crc_entry_ ? AddCommand(cmDD, IntelOperand(otValue, osDWord)) : NULL;
	if (loader_crc_hash_entry_)
		loader_crc_hash_entry_->include_option(roCreateNewBlock);

	// create section info for loader
	bool skip_writable_sections = (file->image_type() != itDriver);
	index = count();
	for (i = 0; i < writable_section_list.size(); i++) {
		section = writable_section_list[i];
		if (skip_writable_sections && section->memory_type() & mtWritable)
			continue;

		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, section->address() - file->image_base()));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, section->size()));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, section->flags()));
	}
	// add runtime's WRITABLE sections
	for (i = 0; i < runtime->segment_list()->count(); i++) {
		section = runtime->segment_list()->item(i);
		if (section->memory_type() & mtWritable) {
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, section->address() - file->image_base()));
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, section->size()));
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, section->flags()));
		}
	}
	if (pack_resources) {
		resource_section_info_ = AddCommand(cmDD, IntelOperand(otValue, osDWord));
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
	} else {
		resource_section_info_ = NULL;
	}
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create fixup info for loader
	if (loader_fixup_list.count() > 0) {
		Data data;
		loader_fixup_list.WriteToData(data, file->image_base());
		command = AddCommand(data);
	} else {
		command = NULL;
	}
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (command) ? command->dump_size() : 0));

	// create relocation info for loader
	if (file->relocation_list()->count() > 0) {
		Data data;
		file->relocation_list()->WriteToData(data, file->image_base());
		command = AddCommand(data);
	} else {
		command = NULL;
	}
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (command) ? command->dump_size() : 0));

	// create IAT info for loader
	index = count();
	for (i = 0, import_index = 0; i < orig_dll_count; i++) {
		import = new_import_list.item(i);
		if (import->count() == 0)
			continue;

		if (ctx.options.flags & cpImportProtection) {
			for (j = 0; j < import->count(); j++, import_index++) {
				import_function = import->item(j);
				if ((import_function->options() & ioNative) == 0)
					continue;

				iat_command = intel_import->GetIATCommand(import_function);

				command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
				link = command->AddLink(0, ltOffset, import_function_info_list[import_index].thunk);
				link->set_sub_value(file->image_base());

				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, ((iat_command) ? iat_command->address() : import_function->address()) - file->image_base()));
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, OperandSizeToValue(cpu_address_size())));
			}
		} else {
			import_function = import->item(0);
			command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
			link = command->AddLink(0, ltOffset, import_function_info_list[import_index].thunk);
			link->set_sub_value(file->image_base());

			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, import_function->address() - file->image_base()));
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, import->count() * OperandSizeToValue(cpu_address_size())));

			import_index += import->count();
		}
	}
	if (security_cookie_) {
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, security_cookie_ - file->image_base()));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, file->load_config_directory()->security_cookie() - file->image_base()));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, OperandSizeToValue(cpu_address_size())));
	}
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create import info for loader
	index = count();
	if (ctx.options.flags & cpImportProtection) {
		for (i = 0, import_index = 0; i < orig_dll_count; i++) {
			import = new_import_list.item(i);
			if (import->count() == 0)
				continue;

			if (import_info_list[i].name == NULL) {
				// delay import
				import_index += import->count();
				continue;
			}

			// DLL name
			command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
			link = command->AddLink(0, ltOffset, import_info_list[i].loader_name);
			link->set_sub_value(file->image_base());

			for (j = 0; j < import->count(); j++, import_index++) {
				import_function = import->item(j);
				if (import_function->options() & ioNative)
					continue;

				if (import_function->IsInternal(ctx))
					continue;

				iat_command = intel_import->GetIATCommand(import_function);

				// API name
				if (import_function->is_ordinal()) {
					AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, IMAGE_ORDINAL_FLAG32 | import_function->ordinal()));
				} else {
					command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
					link = command->AddLink(0, ltOffset, import_function_info_list[import_index].loader_name);
					link->set_sub_value(file->image_base());
				}

				// IAT
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, ((iat_command) ? iat_command->address() : import_function->address()) - file->image_base()));

				// decrypt value
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, (iat_command) ? iat_command->operand(1).value : 0));
			}

			// end of DLL
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
		}
	}
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create internal import info for loader
	index = count();
	for (i = 0; i < orig_dll_count; i++) {
		import = new_import_list.item(i);
		for (j = 0; j < import->count(); j++) {
			import_function = import->item(j);

			if (!import_function->IsInternal(ctx))
				continue;

			iat_command = (intel_import) ? intel_import->GetIATCommand(import_function) : NULL;

			address = runtime->export_list()->GetAddressByType(import_function->type());
			func = reinterpret_cast<IntelFunction*>(file->function_list()->GetFunctionByAddress(address));
			if (func && func->entry())
				address = func->entry()->address();

			// address
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, address - file->image_base()));
			// IAT
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, ((iat_command) ? iat_command->address() : import_function->address()) - file->image_base()));
			// decrypt value
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, (iat_command) ? iat_command->operand(1).value : 0));
		}
	}
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create memory CRC info for loader
	if (intel_crc) {
		command = intel_crc->table_entry();
		i = static_cast<size_t>(intel_crc->size_entry()->operand(0).value);
	} else {
		command = NULL;
		i = 0;
	}
	loader_info_list.push_back(LoaderInfo(command, i));

	// create delay import info for loader
	index = count();
#ifdef ULTIMATE
	for (i = 0, import_index = 0; i < orig_dll_count; i++) {
		import = new_import_list.item(i);
		if (import->count() == 0)
			continue;

		if (import_info_list[i].name) {
			import_index += import->count();
			continue;
		}

		// DLL name
		command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
		link = command->AddLink(0, ltOffset, import_info_list[i].loader_name);
		link->set_sub_value(file->image_base());

		for (j = 0; j < import->count(); j++, import_index++) {
			import_function = import->item(j);
			if (import_function->options() & ioNative)
				continue;

			if (import_function->IsInternal(ctx))
				continue;

			iat_command = (intel_import) ? intel_import->GetIATCommand(import_function) : NULL;

			// API name
			if (import_function->is_ordinal()) {
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, IMAGE_ORDINAL_FLAG32 | import_function->ordinal()));
			} else {
				command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
				link = command->AddLink(0, ltOffset, import_function_info_list[import_index].loader_name);
				link->set_sub_value(file->image_base());
			}

			// IAT
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, ((iat_command) ? iat_command->address() : import_function->address()) - file->image_base()));

			// decrypt value
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, (iat_command) ? iat_command->operand(1).value : 0));
		}

		// end of DLL
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
	}
#endif
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create strings for loader
	std::map<uint32_t, IntelCommand *> loader_string_list;
	loader_string_list[FACE_FILE_CORRUPTED] = AddCommand(EncryptString((ctx.options.flags & cpMemoryProtection) ? os::FromUTF8(ctx.options.messages[MESSAGE_FILE_CORRUPTED]).c_str() : os::unicode_string().c_str(), string_key));
	loader_string_list[FACE_DEBUGGER_FOUND] = AddCommand(EncryptString(os::FromUTF8(ctx.options.messages[MESSAGE_DEBUGGER_FOUND]).c_str(), string_key));
	loader_string_list[FACE_VIRTUAL_MACHINE_FOUND] = AddCommand(EncryptString(os::FromUTF8(ctx.options.messages[MESSAGE_VIRTUAL_MACHINE_FOUND]).c_str(), string_key));
	loader_string_list[FACE_INITIALIZATION_ERROR] = AddCommand(EncryptString(os::FromUTF8("Initialization error %d").c_str(), string_key));
	VMProtectBeginVirtualization("Loader Strings");
	loader_string_list[FACE_UNREGISTERED_VERSION] = AddCommand(EncryptString(
#ifdef DEMO
		true
#else
		(ctx.options.flags & cpUnregisteredVersion)
#endif
		? os::FromUTF8(VMProtectDecryptStringA("This application is protected with unregistered version of VMProtect.")).c_str() : os::unicode_string().c_str(), string_key));
	VMProtectEnd();
	loader_string_list[FACE_SICE_NAME] = AddCommand(EncryptString("sice.sys", string_key));
	loader_string_list[FACE_SIWVID_NAME] = AddCommand(EncryptString("siwvid.sys", string_key));
	loader_string_list[FACE_NTICE_NAME] = AddCommand(EncryptString("ntice.sys", string_key));
	loader_string_list[FACE_ICEEXT_NAME] = AddCommand(EncryptString("iceext.sys", string_key));
	loader_string_list[FACE_SYSER_NAME] = AddCommand(EncryptString("syser.sys", string_key));
	if (file->image_type() == itDriver) {
		loader_string_list[FACE_PROC_NOT_FOUND] = AddCommand(EncryptString(os::FromUTF8("The procedure entry point %c could not be located in the module %c").c_str(), string_key));
		loader_string_list[FACE_ORDINAL_NOT_FOUND] = AddCommand(EncryptString(os::FromUTF8("The ordinal %d could not be located in the module %c").c_str(), string_key));
		loader_string_list[FACE_DRIVER_FORMAT_VALUE] = AddCommand("%ws\n");
		loader_string_list[FACE_NTOSKRNL_NAME] = AddCommand(EncryptString("ntoskrnl.exe", string_key));
		loader_string_list[FACE_HAL_NAME] = AddCommand(EncryptString("hal.dll", string_key));
	} else {
		loader_string_list[FACE_PROC_NOT_FOUND] = AddCommand(EncryptString(os::FromUTF8("The procedure entry point %c could not be located in the dynamic link library %c").c_str(), string_key));
		loader_string_list[FACE_ORDINAL_NOT_FOUND] = AddCommand(EncryptString(os::FromUTF8("The ordinal %d could not be located in the dynamic link library %c").c_str(), string_key));
		loader_string_list[FACE_USER32_NAME] = AddCommand(EncryptString("user32.dll", string_key));
		loader_string_list[FACE_MESSAGE_BOX_NAME] = AddCommand(EncryptString("MessageBoxW", string_key));
		loader_string_list[FACE_KERNEL32_NAME] = AddCommand(EncryptString("kernel32.dll", string_key));
		loader_string_list[FACE_CLOSE_HANDLE_NAME] = AddCommand(EncryptString("CloseHandle", string_key));
		loader_string_list[FACE_IS_WOW64_PROCESS_NAME] = AddCommand(EncryptString("IsWow64Process", string_key));
		loader_string_list[FACE_WINE_GET_VERSION_NAME] = AddCommand(EncryptString("wine_get_version", string_key));
		loader_string_list[FACE_WTSAPI32_NAME] = AddCommand(EncryptString("wtsapi32.dll", string_key));
		loader_string_list[FACE_WTS_SEND_MESSAGE_NAME] = AddCommand(EncryptString("WTSSendMessageW", string_key));
		loader_string_list[FACE_NTDLL_NAME] = AddCommand(EncryptString("ntdll.dll", string_key));
		loader_string_list[FACE_NT_QUERY_INFORMATION_NAME] = AddCommand(EncryptString("NtQuerySystemInformation", string_key));
		loader_string_list[FACE_NT_SET_INFORMATION_THREAD_NAME] = AddCommand(EncryptString("NtSetInformationThread", string_key));
		loader_string_list[FACE_NT_QUERY_INFORMATION_PROCESS_NAME] = AddCommand(EncryptString("NtQueryInformationProcess", string_key));
		loader_string_list[FACE_SBIEDLL_NAME] = AddCommand(EncryptString("sbiedll.dll", string_key));
		loader_string_list[FACE_QUERY_VIRTUAL_MEMORY_NAME] = AddCommand(EncryptString("NtQueryVirtualMemory", string_key));
		loader_string_list[FACE_ENUM_SYSTEM_FIRMWARE_NAME] = AddCommand(EncryptString("EnumSystemFirmwareTables", string_key));
		loader_string_list[FACE_GET_SYSTEM_FIRMWARE_NAME] = AddCommand(EncryptString("GetSystemFirmwareTable", string_key));
		loader_string_list[FACE_NT_VIRTUAL_PROTECT_NAME] = AddCommand(EncryptString("NtProtectVirtualMemory", string_key));
		loader_string_list[FACE_NT_OPEN_FILE_NAME] = AddCommand(EncryptString("NtOpenFile", string_key));
		loader_string_list[FACE_NT_CREATE_SECTION_NAME] = AddCommand(EncryptString("NtCreateSection", string_key));
		loader_string_list[FACE_NT_OPEN_SECTION_NAME] = AddCommand(EncryptString("NtOpenSection", string_key));
		loader_string_list[FACE_NT_MAP_VIEW_OF_SECTION] = AddCommand(EncryptString("NtMapViewOfSection", string_key));
		loader_string_list[FACE_NT_UNMAP_VIEW_OF_SECTION] = AddCommand(EncryptString("NtUnmapViewOfSection", string_key));
		loader_string_list[FACE_NT_CLOSE] = AddCommand(EncryptString("NtClose", string_key));
		loader_string_list[FACE_NT_SET_INFORMATION_PROCESS_NAME] = AddCommand(EncryptString("NtSetInformationProcess", string_key));
		loader_string_list[FACE_NT_RAISE_HARD_ERROR_NAME] = AddCommand(EncryptString("NtRaiseHardError", string_key));
	}
	for (std::map<uint32_t, IntelCommand *>::const_iterator it = loader_string_list.begin(); it != loader_string_list.end(); it++) {
		it->second->include_option(roCreateNewBlock);
	}

	cfg_check_function_entry_ = NULL;
	if (file->load_config_directory()->cfg_check_function()) {
		// work around check in LdrpCfgProcessLoadConfig
		PESegment *segment = file->segment_list()->GetSectionByAddress(file->load_config_directory()->cfg_check_function());
		if (segment && std::find(packer_info_list.begin(), packer_info_list.end(), segment) != packer_info_list.end()) {
			CommandBlock *block = AddBlock(count(), true);
			cfg_check_function_entry_ = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, file->load_config_directory()->cfg_check_function(), NEED_FIXUP));
			cfg_check_function_entry_->set_block(block);
		}
	}

	// append loader
	old_count = count();
	std::vector<IntelCommand*> internal_entry_list;
	for (size_t n = 0; n < 2; n++) {
		for (i = 0; i < runtime_function_list->count(); i++) {
			func = runtime_function_list->item(i);
			if (func->tag() != ftLoader)
				continue;

			if (func->compilation_type() == ctMutation) {
				if (n != 0)
					continue;
			} else {
				if (n != 1)
					continue;
			}

			func->Init(ctx);

			size_t orig_function_info_count = function_info_list()->count();
			for (j = 0; j < func->function_info_list()->count(); j++) {
				FunctionInfo *info = func->function_info_list()->item(j);
				function_info_list()->AddObject(info->Clone(function_info_list()));
			}
			for (j = 0; j < func->range_list()->count(); j++) {
				AddressRange *range = func->range_list()->item(j);
				range_list()->AddObject(range->Clone(range_list()));
			}

			bool is_internal = (func->compilation_type() != ctMutation && func->entry_type() == etNone);
			for (j = 0; j < func->link_list()->count(); j++) {
				src_link = func->link_list()->item(j);
				if (src_link->type() != ltMemSEHBlock)
					continue;

				src_link->from_command()->set_address(0);
				if (!is_internal || (src_link->from_command()->options() & roExternal) == 0)
					continue;

				src_command = func->GetCommandByAddress(src_link->to_address());
				if (!src_command)
					continue;

				for (k = func->IndexOf(src_command); k < func->count(); k++) {
					src_command = func->item(k);
					if (src_command->type() == cmRet) {
						src_command->include_option(roExternal);
						break;
					}
				}
			}

			for (j = 0; j < func->count(); j++) {
				src_command = func->item(j);
				dst_command = src_command->Clone(this);
				AddressRange *address_range = src_command->address_range();
				if (address_range) {
					FunctionInfo *info = function_info_list()->item(orig_function_info_count + func->function_info_list()->IndexOf(address_range->owner()));
					dst_command->set_address_range(info->item(address_range->owner()->IndexOf(address_range)));
				}

				AddObject(dst_command);
				if (is_internal) {
					if (j == 0)
						internal_entry_list.push_back(dst_command);
					if (dst_command->type() == cmRet && (dst_command->options() & roExternal) == 0)
						dst_command->include_option(roInternal);
				}

				src_link = src_command->link();
				if (src_link) {
					dst_link = src_link->Clone(link_list());
					dst_link->set_from_command(dst_command);
					link_list()->AddObject(dst_link);
				
					if (src_link->parent_command())
						dst_link->set_parent_command(GetCommandByAddress(src_link->parent_command()->address()));
				}

				std::map<uint64_t, PEImportFunction *>::const_iterator it_import = runtime_info_list.find(dst_command->address());
				if (it_import != runtime_info_list.end()) {
					if (dst_command->type() == cmCall) {
						IntelOperand operand = dst_command->operand(0);
						dst_command->Init(cmMov, IntelOperand(otRegistr, operand.size, regEAX), operand);

						command = new IntelCommand(this, cpu_address_size(), cmCall, IntelOperand(otRegistr, operand.size, regEAX));
						if (dst_command->link())
							dst_command->link()->set_from_command(command);
						AddObject(command);
					}
					dst_link = dst_command->AddLink((dst_command->operand(1).type != otNone) ? 1 : 0, ltOffset);
					std::vector<ImportFunctionInfo>::iterator it = std::find(import_function_info_list.begin(), import_function_info_list.end(), it_import->second);
					if (it != import_function_info_list.end())
						dst_link->set_to_command(it->thunk);
				}

				command = dst_command;
				for (k = 0; k < 3; k++) {
					IntelOperand operand = command->operand(k);
					if (operand.type == otNone)
						break;

					if ((operand.type & otValue) == 0)
						continue;

					if ((operand.value & 0xFFFF0000) == 0xFACE0000) {
						switch (static_cast<uint32_t>(operand.value)) {
						case FACE_LOADER_OPTIONS:
							operand.value = 0;
							if (ctx.options.flags & cpMemoryProtection)
								operand.value |= LOADER_OPTION_CHECK_PATCH;
							if (ctx.options.flags & cpCheckDebugger)
								operand.value |= LOADER_OPTION_CHECK_DEBUGGER;
							if (ctx.options.flags & cpCheckKernelDebugger)
								operand.value |= LOADER_OPTION_CHECK_KERNEL_DEBUGGER;
							if (ctx.options.flags & cpCheckVirtualMachine)
								operand.value |= LOADER_OPTION_CHECK_VIRTUAL_MACHINE;
							if (file->image_type() == itExe)
								operand.value |= LOADER_OPTION_EXIT_PROCESS;
							command->set_operand_value(k, operand.value);
							command->CompileToNative();
							break;
						case FACE_LOADER_DATA:
							command->set_operand_value(k, loader_data_address - file->image_base());
							command->CompileToNative();
							break;
						case FACE_RUNTIME_ENTRY:
							command->set_operand_value(k, runtime->segment_list()->count() ? runtime->entry_point() - file->image_base() : 0);
							command->CompileToNative();
							break;
						case FACE_STRING_DECRYPT_KEY:
							command->set_operand_value(k, string_key);
							command->CompileToNative();
							break;
						case FACE_PACKER_INFO:
						case FACE_FILE_CRC_INFO:
						case FACE_LOADER_CRC_INFO:
						case FACE_SECTION_INFO:
						case FACE_FIXUP_INFO:
						case FACE_RELOCATION_INFO:
						case FACE_IAT_INFO:
						case FACE_IMPORT_INFO:
						case FACE_INTERNAL_IMPORT_INFO:
						case FACE_MEMORY_CRC_INFO:
						case FACE_DELAY_IMPORT_INFO:
							dst_command = loader_info_list[(operand.value & 0xff) >> 1].data;
							if (dst_command) {
								link = command->AddLink((int)k, ltOffset, dst_command);
								link->set_sub_value(file->image_base());
							} else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_PACKER_INFO_SIZE:
						case FACE_SECTION_INFO_SIZE:
						case FACE_FIXUP_INFO_SIZE:
						case FACE_RELOCATION_INFO_SIZE:
						case FACE_IAT_INFO_SIZE:
						case FACE_IMPORT_INFO_SIZE:
						case FACE_INTERNAL_IMPORT_INFO_SIZE:
						case FACE_MEMORY_CRC_INFO_SIZE:
						case FACE_DELAY_IMPORT_INFO_SIZE:
							command->set_operand_value(k, loader_info_list[(operand.value & 0xff) >> 1].size);
							command->CompileToNative();
							break;
						case FACE_LOADER_CRC_INFO_SIZE:
							if (loader_crc_size_entry_) {
								link = command->AddLink((int)k, ltOffset, loader_crc_size_entry_);
								link->set_sub_value(file->image_base());
							} else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_LOADER_CRC_INFO_HASH:
							if (loader_crc_hash_entry_) {
								link = command->AddLink((int)k, ltOffset, loader_crc_hash_entry_);
								link->set_sub_value(file->image_base());
							} else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_FILE_CRC_INFO_SIZE:
							if (file_crc_size_entry_) {
								link = command->AddLink((int)k, ltOffset, file_crc_size_entry_);
								link->set_sub_value(file->image_base());
							} else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_MEMORY_CRC_INFO_HASH:
							command->set_operand_value(k, intel_crc ? intel_crc->hash_entry()->operand(0).value : 0);
							command->CompileToNative();
							break;
						case FACE_CRC_INFO_SALT:
							command->set_operand_value(k, file->function_list()->crc_cryptor()->item(0)->value());
							command->CompileToNative();
							break;
						case FACE_IMAGE_BASE:
							if (command->operand(0).size != cpu_address_size()) {
								IntelOperand first = command->operand(0);
								IntelOperand second = command->operand(1);
								first.size = cpu_address_size();
								second.size = cpu_address_size();
								command->Init(static_cast<IntelCommandType>(command->type()), first, second);
							}
							command->set_operand_value(k, file->image_base());
							command->set_operand_fixup(k, NEED_FIXUP);
							command->CompileToNative();
							break;
						case FACE_FILE_BASE:
							if (command->operand(0).size != cpu_address_size()) {
								IntelOperand first = command->operand(0);
								IntelOperand second = command->operand(1);
								first.size = cpu_address_size();
								second.size = cpu_address_size();
								command->Init(static_cast<IntelCommandType>(command->type()), first, second);
							}
							command->set_operand_value(k, file->image_base());
							command->CompileToNative();
							break;
						case FACE_TLS_INDEX_INFO:
							command->set_operand_value(k, tls_index_address ? tls_index_address - file->image_base() : 0);
							command->CompileToNative();
							break;
						case FACE_VAR_IS_PATCH_DETECTED:
						case FACE_VAR_IS_DEBUGGER_DETECTED:
						case FACE_VAR_LOADER_CRC_INFO:
						case FACE_VAR_LOADER_CRC_INFO_SIZE:
						case FACE_VAR_LOADER_CRC_INFO_HASH:
						case FACE_VAR_CPU_HASH:
						case FACE_VAR_CPU_COUNT:
						case FACE_VAR_SESSION_KEY:
						case FACE_VAR_DRIVER_UNLOAD:
						case FACE_VAR_CRC_IMAGE_SIZE:
						case FACE_VAR_LOADER_STATUS:
						case FACE_VAR_SERVER_DATE:
						case FACE_VAR_OS_BUILD_NUMBER:
							command->set_operand_value(k, ctx.runtime_var_index[(operand.value & 0xff) >> 4] * OperandSizeToValue(cpu_address_size()));
							command->CompileToNative();
							break;
						case FACE_VAR_IS_PATCH_DETECTED_SALT:
						case FACE_VAR_IS_DEBUGGER_DETECTED_SALT:
						case FACE_VAR_LOADER_CRC_INFO_SALT:
						case FACE_VAR_LOADER_CRC_INFO_SIZE_SALT:
						case FACE_VAR_LOADER_CRC_INFO_HASH_SALT:
						case FACE_VAR_CPU_HASH_SALT:
						case FACE_VAR_CPU_COUNT_SALT:
						case FACE_VAR_DRIVER_UNLOAD_SALT:
						case FACE_VAR_CRC_IMAGE_SIZE_SALT:
						case FACE_VAR_SERVER_DATE_SALT:
						case FACE_VAR_OS_BUILD_NUMBER_SALT:
							command->set_operand_value(k, ctx.runtime_var_salt[operand.value & 0xff]);
							command->CompileToNative();
							break;
						default:
							std::map<uint32_t, IntelCommand *>::const_iterator it = loader_string_list.find(static_cast<uint32_t>(operand.value));
							if (it != loader_string_list.end()) {
								if (command->type() == cmMov) {
									operand = command->operand(0);
									operand.size = cpu_address_size();
									if (operand.type == otRegistr) {
										command->Init(cmLea, operand, IntelOperand(otMemory | otValue, cpu_address_size(), 0, 0, (cpu_address_size() == osDWord) ? NEED_FIXUP : LARGE_VALUE));
									} else {
										command->Init(cmMov, operand, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
									}
								} else {
									command->Init(cmPush, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
								}
								command->AddLink((int)k, ltOffset, it->second); 
							} else {
								throw std::runtime_error(string_format("Unknown loader string: %X", static_cast<uint32_t>(operand.value)));
							}
						}
					}
				}
			}
		}
		if (n == 0) {
			// create native blocks
			for (j = 0; j < count(); j++) {
				item(j)->include_option(roNoProgress);
			}
			CompileToNative(ctx);
			for (j = 0; j < count(); j++) {
				item(j)->exclude_option(roNoProgress);
			}
		}
	}
	for (i = 0; i < function_info_list()->count(); i++) {
		FunctionInfo *info = function_info_list()->item(i);
		if (info->entry())
			info->set_entry(GetCommandByAddress(info->entry()->address()));
		for (j = 0; j < info->count(); j++) {
			AddressRange *dest = info->item(j);
			for (k = 0; k < range_list()->count(); k++) {
				AddressRange *range = range_list()->item(k);
				if (range->begin() <= dest->begin() && range->end() > dest->begin())
					dest->AddLink(range);
			}
		}
	}
	for (i = 0; i < range_list()->count(); i++) {
		AddressRange *range = range_list()->item(i);
		if (range->begin_entry())
			range->set_begin_entry(GetCommandByAddress(range->begin_entry()->address()));
		if (range->end_entry())
			range->set_end_entry(GetCommandByAddress(range->end_entry()->address()));
		if (range->size_entry())
			range->set_size_entry(GetCommandByAddress(range->size_entry()->address()));
	}
	for (i = old_count; i < count(); i++) {
		command = item(i);
		dst_link = command->link();
		if (!dst_link) {
			// search references to LoaderAlloc/LoaderFree/FreeImage
			for (k = 0; k < 2; k++) {
				IntelOperand operand = command->operand(k);
				if (operand.type == otNone)
					break;

				if (cpu_address_size() == osDWord) {
					if (!operand.fixup)
						continue;
				} else {
					if (!operand.is_large_value)
						continue;
				}

				dst_command = reinterpret_cast<IntelCommand *>(GetCommandByAddress(operand.value));
				if (dst_command) {
					dst_link = command->AddLink((int)k, dst_command->block() ? ltOffset : ltGateOffset, dst_command);
					break;
				}
			}
		} else {
			if (dst_link->to_address())
				dst_link->set_to_command(GetCommandByAddress(dst_link->to_address()));
		}
	}
	setup_image_entry = GetCommandByAddress(runtime->export_list()->GetAddressByType(atSetupImage));
	if (!setup_image_entry)
		return false;

	free_image_entry = GetCommandByAddress(runtime->export_list()->GetAddressByType(atFreeImage));
	if (!free_image_entry)
		return false;

/*
BOOL LoaderDllMain(HANDLE module, DWORD reason, LPVOID reserved)
{
	BOOL status;
	if (reason == DLL_PROCESS_ATTACH) {
		status = SetupImage();
		if (status == TRUE) {
			status = DllMain(module, reason, reserved);
		} else {
			FreeImage();
		}
	} else {
		status = DllMain(module, reason, reserved);
		if (reason == DLL_PROCESS_DETACH)
			FreeImage();
	}
	return status;
}

NTSTATUS LoaderDriverEntry(driver_object, registry_path)
{
	NTSTATUS status = SetupImage(true, driver_object);
	if (status == STATUS_SUCCESS) {
		status = DriverEntry(driver_object, registry_path);
		if (status == STATUS_SUCCESS) {
			SetupImage(false, driver_object);
		} else {
			FreeImage(driver_object);
		}
	} else {
		FreeImage(driver_object);
	}
	return status;
}
*/

	// create entry commands
	std::vector<IntelCommand *> end_command_list;
	old_count = count();
	size_t stack = 0x20;
	if (file->image_type() != itExe && cpu_address_size() == osQWord) {
		AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regESP, OperandSizeToValue(cpu_address_size()) * 1), IntelOperand(otRegistr, cpu_address_size(), regECX));
		AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regESP, OperandSizeToValue(cpu_address_size()) * 2), IntelOperand(otRegistr, cpu_address_size(), regEDX));
		AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regESP, OperandSizeToValue(cpu_address_size()) * 3), IntelOperand(otRegistr, cpu_address_size(), regR8));
	}
	AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEBP));
	if (cpu_address_size() == osDWord) {
		AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, stack));
		AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEBP), IntelOperand(otRegistr, cpu_address_size(), regESP));
	} else {
		AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size(), regEBP), IntelOperand(otMemory | otRegistr| otValue, cpu_address_size(), regESP,  0 - static_cast<uint64_t>(stack)));
		AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, stack + 0x20));
	}

	IntelCommand *skip_loader_command = NULL;
	if (file->image_type() == itLibrary) {
		// check DLL_PROCESS_ATTACH
		AddCommand(cmCmp, IntelOperand(otMemory | otRegistr | otValue, osDWord, regEBP, stack + OperandSizeToValue(cpu_address_size()) * 3), IntelOperand(otValue, osDWord, 0, DLL_PROCESS_ATTACH));
		skip_loader_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
		skip_loader_command->set_flags(fl_Z);
		skip_loader_command->include_option(roInverseFlag);
		skip_loader_command->AddLink(0, ltJmpWithFlag);
	}

	// call SetupImage
	if (file->image_type() == itDriver) {
		if (cpu_address_size() == osQWord) {
			AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEDX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 2));
			AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otValue, osDWord, 0, true));
		} else {
			AddCommand(cmPush, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 2));
			AddCommand(cmPush, IntelOperand(otValue, cpu_address_size(), 0, true));
		}
	}
	command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
	command->AddLink(0, ltCall, setup_image_entry);

	// check loader error code
	AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, (file->image_type() == itDriver) ? 0 : TRUE));
	IntelCommand *check_loader_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
	check_loader_command->set_flags(fl_Z);
	check_loader_command->AddLink(0, ltJmpWithFlag);

	switch (file->image_type()) {
	case itExe:
		// call FreeImage
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, free_image_entry);

		// need convert FALSE into exit code
		AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, 0xDEADC0DE));
		break;
	case itLibrary:
		// do nothing
		break;
	case itDriver:
		AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP), IntelOperand(otRegistr, cpu_address_size(), regEAX));

		// call FreeImage
		if (cpu_address_size() == osQWord) {
			AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regECX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 2));
		} else {
			AddCommand(cmPush, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 2));
		}
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, free_image_entry);

		AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEAX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP));
		break;
	}

	command = AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size()));
	command->AddLink(0, ltJmp);
	end_command_list.push_back(command);

	command = AddCommand(cmNop);
	check_loader_command->link()->set_to_command(command);
	if (skip_loader_command)
		skip_loader_command->link()->set_to_command(command);

	// call file EntryPoint
	IntelCommand *jmp_entry_point_command = NULL;
	if (file->entry_point()) {
		switch (file->image_type()) {
		case itExe:
			AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, stack + ((cpu_address_size() == osQWord) ? 0x20 : 0)));
			AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEBP));
			jmp_entry_point_command = AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size(), 0, file->entry_point()));
			jmp_entry_point_command->AddLink(0, ltJmp, file->entry_point());
			break;

		case itLibrary:
			{
			// check loader status
			AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEAX), IntelOperand(otMemory | otValue, cpu_address_size(), 0, loader_data_address, (cpu_address_size() == osDWord) ? NEED_FIXUP : LARGE_VALUE));
			AddCommand(cmOr, IntelOperand(otRegistr, cpu_address_size(), regEAX), IntelOperand(otRegistr, cpu_address_size(), regEAX));
			IntelCommand *jmp_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
			jmp_command->set_flags(fl_Z);
			jmp_command->AddLink(0, ltJmpWithFlag);

			AddCommand(cmCmp, IntelOperand(otMemory | otRegistr | otValue, osDWord, regEAX, ctx.runtime_var_index[VAR_LOADER_STATUS] * OperandSizeToValue(cpu_address_size())), IntelOperand(otValue, osDWord, 0, TRUE));
			IntelCommand *jmp_status_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
			jmp_status_command->set_flags(fl_Z);
			jmp_status_command->include_option(roInverseFlag);
			jmp_status_command->AddLink(0, ltJmpWithFlag);

			// call EntryPoint
			if (cpu_address_size() == osQWord) {
				AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regR8), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 4));
				AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEDX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 3));
				AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regECX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 2));
			} else {
				AddCommand(cmPush, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 4));
				AddCommand(cmPush, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 3));
				AddCommand(cmPush, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 2));
			}
			jmp_entry_point_command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size(), 0, file->entry_point()));
			jmp_entry_point_command->AddLink(0, ltCall, file->entry_point());

			command = AddCommand(cmNop);
			jmp_command->link()->set_to_command(command);
			jmp_status_command->link()->set_to_command(command);
			}
			break;

		case itDriver:
			if (cpu_address_size() == osQWord) {
				AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEDX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 3));
				AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regECX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 2));
			} else {
				AddCommand(cmPush, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 3));
				AddCommand(cmPush, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 2));
			}
			jmp_entry_point_command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size(), 0, file->entry_point()));
			jmp_entry_point_command->AddLink(0, ltCall, file->entry_point());

			// store error code
			AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP), IntelOperand(otRegistr, cpu_address_size(), regEAX));

			{
			// check error code
			AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, 0));
			command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
			command->set_flags(fl_Z);
			command->include_option(roInverseFlag);
			command->AddLink(0, ltJmpWithFlag);
			IntelCommand *cmp_command = command;

			// call SetupImage
			if (cpu_address_size() == osQWord) {
				AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEDX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 2));
				AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otValue, osDWord, 0, false));
			} else {
				AddCommand(cmPush, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 2));
				AddCommand(cmPush, IntelOperand(otValue, cpu_address_size(), 0, false));
			}
			command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
			command->AddLink(0, ltCall, setup_image_entry);

			IntelCommand *jmp_command = AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size(), 0, 0));
			jmp_command->AddLink(0, ltJmp);

			command = AddCommand(cmNop);
			cmp_command->link()->set_to_command(command);

			// call FreeImage
			if (cpu_address_size() == osQWord) {
				AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regECX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 2));
			} else {
				AddCommand(cmPush, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 2));
			}
			command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
			command->AddLink(0, ltCall, free_image_entry);

			// restore error code
			command = AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEAX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP));
			jmp_command->link()->set_to_command(command);
			}
			break;
		}
	}

	if (file->image_type() == itLibrary) {
		// check DLL_PROCESS_DETACH
		AddCommand(cmCmp, IntelOperand(otMemory | otRegistr | otValue, osDWord, regEBP, stack + OperandSizeToValue(cpu_address_size()) * 3), IntelOperand(otValue, osDWord, 0, DLL_PROCESS_DETACH));
		command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
		command->set_flags(fl_Z);
		command->include_option(roInverseFlag);
		command->AddLink(0, ltJmpWithFlag);
		end_command_list.push_back(command);

		// call FreeImage
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, free_image_entry);

		AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, TRUE));
	}

	command = AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, stack + ((cpu_address_size() == osQWord) ? 0x20 : 0)));
	for (i = 0; i < end_command_list.size(); i++) {
		end_command_list[i]->link()->set_to_command(command);
	}
	AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEBP));

	IntelOperand ret_operand;
	if (cpu_address_size() == osDWord) {
		switch (file->image_type()) {
		case itDriver:
			ret_operand = IntelOperand(otValue, osWord, 0, 2 * OperandSizeToValue(cpu_address_size()));
			break;
		case itLibrary:
			ret_operand = IntelOperand(otValue, osWord, 0, 3 * OperandSizeToValue(cpu_address_size()));
			break;
		}
	}
	AddCommand(cmRet, ret_operand);
	if (jmp_entry_point_command && entry_point_command)
		jmp_entry_point_command->link()->set_to_command(entry_point_command);

	command = item(old_count);
	set_entry(command);

	if (tls_call_back_entry_) {
		index = count();

		AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEBP));
		if (cpu_address_size() == osDWord) {
			AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, stack));
			AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEBP), IntelOperand(otRegistr, cpu_address_size(), regESP));
		} else {
			AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size(), regEBP), IntelOperand(otMemory | otRegistr| otValue, cpu_address_size(), regESP, 0 - stack));
			AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, stack + 0x20));
		}

		// call loader
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, setup_image_entry);

		// check loader error code
		AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, (file->image_type() == itDriver) ? 0 : TRUE));
		IntelCommand *check_loader_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
		check_loader_command->set_flags(fl_Z);
		check_loader_command->AddLink(0, ltJmpWithFlag);

		// call FreeImage
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, free_image_entry);

		command = AddCommand(cmNop);
		check_loader_command->link()->set_to_command(command);

		AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, stack + ((cpu_address_size() == osQWord) ? 0x20 : 0)));
		AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEBP));

		IntelOperand ret_operand;
		if (cpu_address_size() == osDWord)
			ret_operand = IntelOperand(otValue, osWord, 0, 3 * OperandSizeToValue(cpu_address_size()));
		AddCommand(cmRet, ret_operand);

		tls_call_back_entry_->link()->set_to_command(item(index));
	}
	
	for (i = 0; i < count(); i++) {
		command = item(i);
		command->CompileToNative();
	}

	// search API calls
	for (i = 0; i < count(); i++) {
		command = item(i);
		if (command->block())
			continue;

		if (command->type() == cmCall) {
			if (command->operand(0).type == otValue)
				continue;
		} else if (command->type() != cmSyscall)
			continue;

		IntelCommand *next_command = item(i + 1);
		if (next_command->type() == cmAdd && next_command->operand(0).type == otRegistr && next_command->operand(0).registr == regESP)
			continue;

		k = 0;
		for (j = i; j > 0; j--) {
			IntelCommand *param_command = item(j - 1);

			switch (param_command->type()) {
			case cmPush:
				if (cpu_address_size() == osDWord) {
					k++;
				} else {
					param_command = NULL;
				}
				break;
			case cmMov: case cmLea: case cmXor: case cmMovsxd:
				if (cpu_address_size() == osQWord) {
					if (param_command->operand(0).type == otRegistr) {
						switch (param_command->operand(0).registr) {
						case regECX:
							k = std::max<size_t>(k, 1);
							break;
						case regEDX:
							k = std::max<size_t>(k, 2);
							break;
						case regR8:
							k = std::max<size_t>(k, 3);
							break;
						case regR9:
							k = std::max<size_t>(k, 4);
							break;
						}
					} else if (param_command->operand(0).type == (otMemory | otBaseRegistr | otValue) && param_command->operand(0).base_registr == regESP) {
						switch (param_command->operand(0).value) {
						case 0x20:
							k = std::max<size_t>(k, 5);
							break;
						case 0x28:
							k = std::max<size_t>(k, 6);
							break;
						case 0x30:
							k = std::max<size_t>(k, 7);
							break;
						case 0x38:
							k = std::max<size_t>(k, 8);
							break;
						case 0x40:
							k = std::max<size_t>(k, 9);
							break;
						case 0x48:
							k = std::max<size_t>(k, 10);
							break;
						default:
							if (param_command->operand(0).value >= 0x50)
								k = NOT_ID;
							break;
						}
					}
				}
				break;
			case cmCall: case cmJmp: case cmJmpWithFlag: case cmRet:
				param_command = NULL;
				break;
			}
			if (!param_command || link_list()->GetLinkByToAddress(ltNone, param_command->address()))
				break;
		}
		if (k == NOT_ID)
			continue;

		command->include_option(roInternal);
		command->set_operand_value(2, k);
	}

	if (entry_point_command && entry_point_command->block()->virtual_machine() && jmp_entry_point_command) {
		jmp_entry_point_command->include_option(roExternal);
		uint8_t id = entry_point_command->block()->virtual_machine()->id();
		IntelVirtualMachineList *virtual_machine_list = reinterpret_cast<IntelVirtualMachineList *>(ctx.file->virtual_machine_list());
		for (i = 0; i < virtual_machine_list->count(); i++) {
			IntelVirtualMachine *virtual_machine = virtual_machine_list->item(i);
			if (virtual_machine->processor()->cpu_address_size() == cpu_address_size())
				virtual_machine->AddExtJmpCommand(id);
		}
	}

	for (i = 0; i < link_list()->count(); i++) {
		CommandLink *link = link_list()->item(i);
		if (link->from_command()->type() == cmCall && std::find(internal_entry_list.begin(), internal_entry_list.end(), link->to_command()) != internal_entry_list.end())
			reinterpret_cast<IntelCommand*>(link->from_command())->include_option(roInternal);
		link->from_command()->PrepareLink(ctx);
	}

	return BaseIntelLoader::Prepare(ctx);
}

std::vector<uint64_t> PEIntelLoader::cfg_address_list() const
{
	std::vector<uint64_t> res;
	res.push_back(entry()->address());
	if (tls_call_back_entry_)
		res.push_back(tls_call_back_entry_->link()->to_command()->address());
	std::sort(res.begin(), res.end());
	return res;
}

/**
 * MacIntelFunctionList
 */

MacIntelFunctionList::MacIntelFunctionList(IArchitecture *owner)
	: IntelFunctionList(owner)
{

}

MacIntelFunctionList::MacIntelFunctionList(IArchitecture *owner, const MacIntelFunctionList &src)
	: IntelFunctionList(owner, src)
{

}

MacIntelFunctionList *MacIntelFunctionList::Clone(IArchitecture *owner) const
{
	MacIntelFunctionList *list = new MacIntelFunctionList(owner, *this);
	return list;
}

IntelSDK *MacIntelFunctionList::AddSDK(OperandSize cpu_address_size)
{
	IntelSDK *func = new MacIntelSDK(this, cpu_address_size);
	AddObject(func);
	return func;
}

bool MacIntelFunctionList::Prepare(const CompileContext &ctx)
{
	MacArchitecture *file = reinterpret_cast<MacArchitecture *>(owner());
	for (size_t i = 0; i < file->import_list()->count(); i++) {
		MacImport *import = file->import_list()->item(i);
		size_t old_count = import->count();
		for (size_t j = 0; j < old_count; j++) {
			MacImportFunction *import_func = import->item(j);
			IntelCommand *command = reinterpret_cast<IntelCommand *>(GetCommandByAddress(import_func->address(), true));
			if (!command)
				continue;

			import_func = import_func->Clone(import);
			import->AddObject(import_func);
			relocation_list_[import_func] = command;
		}
	}

	return IntelFunctionList::Prepare(ctx);
}

bool MacIntelFunctionList::Compile(const CompileContext &ctx)
{
	if (!IntelFunctionList::Compile(ctx))
		return false;

	MacArchitecture *file = reinterpret_cast<MacArchitecture *>(owner());
	for (std::map<MacImportFunction *, IntelCommand *>::const_iterator it = relocation_list_.begin(); it != relocation_list_.end(); it++) {
		MacImportFunction *import_func = it->first;
		IntelCommand *command = it->second;
		import_func->set_address(command->address());
	}

	return true;
}

/**
 * MacIntelSDK
 */

MacIntelSDK::MacIntelSDK(IFunctionList *parent, OperandSize cpu_address_size)
	: IntelSDK(parent, cpu_address_size)
{

}

/**
 * MacIntelLoader
 */

MacIntelLoader::MacIntelLoader(IntelFunctionList *owner, OperandSize cpu_address_size)
	: BaseIntelLoader(owner, cpu_address_size), import_entry_(NULL), import_size_(0), 
	jmp_table_entry_(NULL), jmp_table_size_(0), init_entry_(NULL), init_size_(0), term_entry_(NULL), term_size_(0), 
	file_crc_entry_(NULL), file_crc_size_(0), loader_crc_entry_(NULL), loader_crc_size_(0), file_entry_(NULL),
	patch_section_entry_(NULL), loader_crc_size_entry_(NULL), loader_crc_hash_entry_(NULL), file_crc_size_entry_(NULL),
	lazy_import_entry_(NULL), lazy_import_size_(0), thread_variables_entry_(NULL), thread_variables_size_(0),
	thread_data_entry_(NULL), thread_data_size_(0)
{

}

bool MacIntelLoader::Prepare(const CompileContext &ctx)
{
	MacArchitecture *file, *runtime;
	size_t i, j, k, index, orig_dll_count, old_count, start_index;
	IntelCommand *command, *src_command, *dst_command, *setup_image_entry, *free_image_entry;
	CommandLink *link, *src_link, *dst_link;
	IntelFunctionList *runtime_function_list;
	IntelFunction *func;
	MacImportFunction *import_function;
	MacImport *import;
	uint64_t address;
	std::map<uint64_t, MacImportFunction *> runtime_info_list;
	uint64_t loader_data_address;
	MacSegment *segment;

	file = reinterpret_cast<MacArchitecture *>(ctx.file);
	runtime = reinterpret_cast<MacArchitecture *>(ctx.runtime);
	IntelCRCTable *intel_crc = reinterpret_cast<IntelFunctionList *>(file->function_list())->crc_table();
	IntelLoaderData *loader_data = reinterpret_cast<IntelFunctionList*>(file->function_list())->loader_data();
	loader_data_address = (loader_data) ? loader_data->entry()->address() : runtime->export_list()->GetAddressByType(atLoaderData);
	if (!loader_data_address)
		return false;

	// create AV signature buffer
	AddAVBuffer(ctx);
	start_index = count();

	ICommand *entry_point_command = NULL;
	if (file->entry_point()) {
		IFunction *entry_point_func = ctx.file->function_list()->GetFunctionByAddress(file->entry_point());
		if (entry_point_func)
			entry_point_command = entry_point_func->entry();
	}

	segment = file->segment_list()->GetBaseSegment();
	uint64_t max_header_address = segment ? segment->address() + file->max_header_size() : 0;

	// parse objc segment
	Objc objc;
	std::vector<MacSegment *> objc_segment_list;
	if (objc.ReadFromFile(*file)) {
		objc_segment_list = objc.segment_list();
		for (i = 0; i < file->import_list()->count(); i++) {
			import = file->import_list()->item(i);
			for (j = 0; j < import->count(); j++) {
				import_function = import->item(j);
				MacSection *section = file->section_list()->GetSectionByAddress(import_function->address());
				if (section && find(objc_segment_list.begin(), objc_segment_list.end(), section->parent()) != objc_segment_list.end() && section->type() != S_NON_LAZY_SYMBOL_POINTERS)
					import_function->include_option(ioHasDirectReference);
			}
		}
	}

	// add loader import
	std::map<uint64_t, MacImportFunction *> import_map;
	MacImportList &new_import_list = *file->import_list();
	orig_dll_count = new_import_list.count();
	runtime_function_list = reinterpret_cast<IntelFunctionList *>(runtime->function_list());
	IntelCommandType value_command_type = (cpu_address_size() == osDWord) ? cmDD : cmDQ;
	index = count();
	int max_library_ordinal = 0;
	for (i = 0; i < new_import_list.count(); i++) {
		import = new_import_list.item(i);
		if (max_library_ordinal < import->library_ordinal())
			max_library_ordinal = import->library_ordinal();
	}
	for (i = 0; i < runtime_function_list->count(); i++) {
		func = runtime_function_list->item(i);
		if (func->tag() != ftLoader)
			continue;

		for (j = 0; j < func->count(); j++) {
			command = func->item(j);
			import_function = NULL;
			switch (command->type()) {
			case cmCall:
			case cmJmp:
			case cmMov:
				k = (command->type() == cmMov) ? 1 : 0;
				if (command->operand(k).type == (otMemory | otValue))
					import_function = runtime->import_list()->GetFunctionByAddress(command->operand(k).value);
				break;
			}
			if (!import_function)
				continue;

			std::map<uint64_t, MacImportFunction *>::const_iterator it = import_map.find(import_function->address());
			MacImportFunction *new_import_function = (it != import_map.end()) ? it->second : NULL;
			if (!new_import_function) {
				MacImport *src_import = reinterpret_cast<MacImport *>(import_function->owner());
				import = new_import_list.GetImportByName(src_import->name());
				if (!import) {
					import = new MacImport(&new_import_list, ++max_library_ordinal, src_import->name(), src_import->current_version(), src_import->compatibility_version());
					new_import_list.AddObject(import);
				}

				MacSymbol *symbol = import_function->symbol()->Clone(file->symbol_list());
				file->symbol_list()->AddObject(symbol);
				symbol->set_library_ordinal(import->library_ordinal());

				new_import_function = import->Add(0, BIND_TYPE_POINTER, 0, import_function->name(), 0, 0, false, symbol);
				import_map[import_function->address()] = new_import_function;
			}
			runtime_info_list[command->address()] = new_import_function;
		}
	}

	// create IAT
	old_count = file->indirect_symbol_list()->count();
	for (i = 0; i < file->import_list()->count(); i++) {
		import = file->import_list()->item(i);
		for (j = 0; j < import->count(); j++) {
			import_function = import->item(j);
			if (import_function->is_lazy() || (import_function->options() & ioHasDirectReference))
				continue;

			bool is_found = false;
			if (import_function->address()) {
				for (k = 0; k < old_count; k++) {
					MacIndirectSymbol *indirect_symbol = file->indirect_symbol_list()->item(k);
					if (indirect_symbol->symbol() == import_function->symbol()) {
						file->indirect_symbol_list()->AddObject(indirect_symbol->Clone(file->indirect_symbol_list()));
						indirect_symbol->set_symbol(NULL);
						indirect_symbol->set_value(INDIRECT_SYMBOL_ABS);
						is_found = true;
						break;
					}
				}
			}
			if (!is_found)
				file->indirect_symbol_list()->Add(0, 0, import_function->symbol());

			command = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size()));
			import_function_info_[import_function] = command;
		}
	}
	import_entry_ = item(start_index);
	import_entry_->set_operand_value(1, old_count);
	import_entry_->include_option(roCreateNewBlock);
	import_entry_->include_option(roDataSegment);
	import_entry_->set_alignment(OperandSizeToValue(cpu_address_size()));
	import_size_ = static_cast<uint32_t>((count() - start_index) * OperandSizeToValue(cpu_address_size()));

	// create jump table
	jmp_table_entry_ = NULL;
	jmp_table_size_ = 0;
	lazy_import_entry_ = NULL;
	lazy_import_size_ = 0;
	std::vector<MacImportFunction*> jmp_import_list;
	bool need_convert_runtime = (runtime->segment_list()->count() && !file->dyld_info()->cmd);
	for (i = 0; i < file->import_list()->count(); i++) {
		import = file->import_list()->item(i);
		for (j = 0; j < import->count(); j++) {
			import_function = import->item(j);
			if (import_function->options() & ioFromRuntime) {
				if (!need_convert_runtime || !import_function->is_lazy())
					continue;
			} else {
				if ((import_function->options() & ioIsRelative) == 0)
					continue;
			}

			jmp_import_list.push_back(import_function);
		}
	}
	if (!jmp_import_list.empty()) {
		index = count();
		size_t indirect_symbol_index = file->indirect_symbol_list()->count();
		address = ctx.manager->Alloc(jmp_import_list.size() * (cpu_address_size() == osDWord ? 5 : 6), mtReadable);

		CommandBlock *block = AddBlock(count(), true);
		block->set_address(address);

		for (i = 0; i < jmp_import_list.size(); i++) {
			import_function = jmp_import_list[i];

			file->indirect_symbol_list()->Add(0, 0, import_function->symbol());

			if (cpu_address_size() == osDWord) {
				command = AddCommand(cmJmp, IntelOperand(otValue, osDWord));
				command->CompileToNative();
				command->AddLink(0, ltJmp);
			}
			else {
				command = AddCommand(cmJmp, IntelOperand(otMemory | otValue, osQWord, 0, 0, LARGE_VALUE));
				command->CompileToNative();
				command->AddLink(0, ltOffset);
			}
			command->set_address(address);
			command->set_block(block);

			Data jmp;
			if (import_function->options() & ioIsRelative) {
				// jmp xxxx
				jmp.PushByte(0xe9);
				jmp.PushDWord(static_cast<uint32_t>(address - import_function->address() - 5));
			} else {
				// dd xxxx
				if (cpu_address_size() == osQWord)
					jmp.PushQWord(address);
				else
					jmp.PushDWord(static_cast<uint32_t>(address));

				segment = file->segment_list()->GetSectionByAddress(import_function->address());
				MacFixup *fixup = file->fixup_list()->AddDefault(cpu_address_size(), segment && (segment->memory_type() & mtExecutable) != 0);
				fixup->set_address(import_function->address());
			}

			file->AddressSeek(import_function->address());
			file->Write(jmp.data(), jmp.size());
			
			address += command->dump_size();
		}
		block->set_end_index(count() - 1);

		if (cpu_address_size() == osDWord) {
			old_count = count();
			Data data;
			data.resize(5, 0xf4);
			for (i = 0; i < jmp_import_list.size(); i++) {
				command = AddCommand(data);
				item(index + i)->link()->set_to_command(command);
			}

			jmp_table_entry_ = item(old_count);
			jmp_table_entry_->set_operand_value(1, indirect_symbol_index);
			jmp_table_entry_->include_option(roCreateNewBlock);
			jmp_table_entry_->include_option(roImportSegment);
			jmp_table_size_ = static_cast<uint32_t>(jmp_import_list.size() * data.size());
		} else {
			old_count = count();
			for (i = 0; i < jmp_import_list.size(); i++) {
				command = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
				command->AddLink(0, ltOffset);
				item(index + i)->link()->set_to_command(command);
			}

			lazy_import_entry_ = item(old_count);
			lazy_import_entry_->set_operand_value(1, indirect_symbol_index);
			lazy_import_entry_->include_option(roCreateNewBlock);
			lazy_import_entry_->include_option(roDataSegment);
			lazy_import_entry_->set_alignment(OperandSizeToValue(cpu_address_size()));
			lazy_import_size_ = static_cast<uint32_t>(jmp_import_list.size() * OperandSizeToValue(cpu_address_size()));

			address = 0;
			MacSegment *data_segment = file->segment_list()->GetSectionByName(SEG_DATA);
			if (data_segment) {
				MacSection *section = file->section_list()->GetSectionByName(data_segment, SECT_DYLD);
				if (section)
					address = section->address();
			}
			if (!address)
				throw std::runtime_error("Section \"__dyld\" not found");

			IntelCommand *dyld_entry = AddCommand(cmPush, IntelOperand(otRegistr, osQWord, regR11, 0));
			AddCommand(cmLea, IntelOperand(otRegistr, osQWord, regR11, 0), IntelOperand(otMemory | otValue, osQWord, 0, file->image_base(), LARGE_VALUE));
			AddCommand(cmPush, IntelOperand(otRegistr, osQWord, regR11, 0));
			AddCommand(cmJmp, IntelOperand(otMemory | otValue, osQWord, 0, address, LARGE_VALUE));

			index = old_count;
			old_count = count();
			for (i = 0; i < jmp_import_list.size(); i++) {
				command = AddCommand(cmLea, IntelOperand(otRegistr, osQWord, regR11, 0), IntelOperand(otMemory | otValue, osQWord, 0, 0, LARGE_VALUE));
				command->AddLink(1, ltOffset, item(index + i));
				item(index + i)->link()->set_to_command(command);
				command = AddCommand(cmJmp, IntelOperand(otValue, osQWord, 0, 0));
				command->AddLink(0, ltJmp, dyld_entry);
			}
		}
	}
	else {
		for (i = 0; i < file->import_list()->count(); i++) {
			import = file->import_list()->item(i);
			for (j = 0; j < import->count(); j++) {
				import_function = import->item(j);
				if ((import_function->options() & ioFromRuntime) && import_function->is_lazy())
					jmp_import_list.push_back(import_function);
			}
		}
		if (!jmp_import_list.empty()) {
			// move S_LAZY_SYMBOL_POINTERS to data segment
			std::vector<uint64_t> address_list;
			index = count();
			size_t indirect_symbol_index = file->indirect_symbol_list()->count();
			address = ctx.manager->Alloc(jmp_import_list.size() * (cpu_address_size() == osDWord ? 5 : 6), mtReadable);

			CommandBlock *block = AddBlock(count(), true);
			block->set_address(address);

			for (i = 0; i < jmp_import_list.size(); i++) {
				import_function = jmp_import_list[i];

				file->indirect_symbol_list()->Add(0, 0, import_function->symbol());

				if (cpu_address_size() == osDWord) {
					command = AddCommand(cmJmp, IntelOperand(otValue, osDWord));
					command->CompileToNative();
					command->AddLink(0, ltJmp);
				}
				else {
					command = AddCommand(cmJmp, IntelOperand(otMemory | otValue, cpu_address_size(), 0, 0, LARGE_VALUE));
					command->CompileToNative();
					command->AddLink(0, ltOffset);
				}

				command->set_address(address);
				command->set_block(block);

				file->AddressSeek(import_function->address());
				if (cpu_address_size() == osDWord) {
					address_list.push_back(file->ReadDWord());
					file->AddressSeek(import_function->address());
					file->WriteDWord(static_cast<uint32_t>(address));
				}
				else {
					address_list.push_back(file->ReadQWord());
					file->AddressSeek(import_function->address());
					file->WriteQWord(address);
				}
				
				address += command->dump_size();
			}
			block->set_end_index(count() - 1);

			if (cpu_address_size() == osDWord) {
				old_count = count();
				for (i = 0; i < jmp_import_list.size(); i++) {
					command = AddCommand(cmJmp, IntelOperand(otMemory | otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
					command->CompileToNative();
					command->AddLink(0, ltOffset);
					item(index + i)->link()->set_to_command(command);
				}
				index = old_count;
			}

			old_count = count();
			for (i = 0; i < jmp_import_list.size(); i++) {
				import_function = jmp_import_list[i];
				command = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, address_list[i], NEED_FIXUP));
				item(index + i)->link()->set_to_command(command);

				import_function->set_address(0);
				import_function_info_[import_function] = command;
			}

			lazy_import_entry_ = item(old_count);
			lazy_import_entry_->set_operand_value(1, indirect_symbol_index);
			lazy_import_entry_->include_option(roCreateNewBlock);
			lazy_import_entry_->include_option(roDataSegment);
			lazy_import_entry_->set_alignment(OperandSizeToValue(cpu_address_size()));
			lazy_import_size_ = static_cast<uint32_t>(jmp_import_list.size() * OperandSizeToValue(cpu_address_size()));
		}
	}

	// create init module function list
	index = count();
	AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
	for (i = 0; i < file->section_list()->count(); i++) {
		MacSection *section = file->section_list()->item(i);
		if (section->type() != S_MOD_INIT_FUNC_POINTERS)
			continue;

		file->AddressSeek(section->address());
		for (j = 0; j < section->size(); j += OperandSizeToValue(cpu_address_size())) {
			command = Add(section->address() + j);
			command->ReadValueFromFile(*file, cpu_address_size());
		}
	}
	init_entry_ = item(index);
	init_entry_->include_option(roCreateNewBlock);
	init_entry_->include_option(roDataSegment);
	init_entry_->set_alignment(OperandSizeToValue(cpu_address_size()));
	init_size_ = static_cast<uint32_t>((count() - index) * OperandSizeToValue(cpu_address_size()));

	// work around MacOSX >= 10.13 - init function must be point within __TEXT segment
	if (max_header_address) {
		max_header_address -= 5;
		CommandBlock *block = AddBlock(count(), true);
		block->set_address(max_header_address);
		command = AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size(), 0, 0));
		command->set_address(max_header_address);
		command->set_block(block);
		init_entry_->AddLink(0, ltOffset, command);
	}

	// create termination module function list
	index = count();
	AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
	for (i = 0; i < file->section_list()->count(); i++) {
		MacSection *section = file->section_list()->item(i);
		if (section->type() != S_MOD_TERM_FUNC_POINTERS)
			continue;

		file->AddressSeek(section->address());
		for (j = 0; j < section->size(); j += OperandSizeToValue(cpu_address_size())) {
			command = Add(section->address() + j);
			command->ReadValueFromFile(*file, cpu_address_size());
		}
	}
	term_entry_ = item(index);
	term_entry_->include_option(roCreateNewBlock);
	term_entry_->include_option(roDataSegment);
	term_entry_->set_alignment(OperandSizeToValue(cpu_address_size()));
	term_entry_->AddLink(0, ltGateOffset);
	term_size_ = (uint32_t)((count() - index) * OperandSizeToValue(cpu_address_size()));

	// create S_THREAD_LOCAL_VARIABLES section
	index = count();
	if (file->flags() & MH_HAS_TLV_DESCRIPTORS) {
		for (i = 0; i < file->section_list()->count(); i++) {
			MacSection *section = file->section_list()->item(i);
			if (section->type() != S_THREAD_LOCAL_VARIABLES)
				continue;

			if ((ctx.options.flags & cpPack) && !section->parent()->excluded_from_packing()) {
				file->AddressSeek(section->address());
				for (j = 0; j < section->size(); j += OperandSizeToValue(cpu_address_size())) {
					command = Add(section->address() + j);
					command->ReadValueFromFile(*file, cpu_address_size());
					if (j == 0)
						command->set_operand_value(1, section->size());
				}
			}
			else {
				for (j = 0; j < section->size(); j += OperandSizeToValue(cpu_address_size())) {
					import_function = file->import_list()->GetFunctionByAddress(section->address() + j);
					if (import_function) {
						std::map<MacImportFunction *, IntelCommand *>::const_iterator it = import_function_info_.find(import_function);
						if (it != import_function_info_.end())
							import_function_info_.erase(it);
					}
				}
			}
		}
	}
	thread_variables_entry_ = (count() == index) ? NULL : item(index);
	thread_variables_size_ = (uint32_t)((count() - index) * OperandSizeToValue(cpu_address_size()));
	if (thread_variables_entry_) {
		thread_variables_entry_->include_option(roCreateNewBlock);
		thread_variables_entry_->include_option(roDataSegment);
		thread_variables_entry_->set_alignment(OperandSizeToValue(cpu_address_size()));
	}

	// create S_THREAD_LOCAL_REGULAR section
	index = count();
	if (ctx.options.flags & cpPack) {
		address = 0;
		uint64_t end_address = 0;
		for (i = 0; i < file->section_list()->count(); i++) {
			MacSection *section = file->section_list()->item(i);
			if (section->type() == S_THREAD_LOCAL_REGULAR || section->type() == S_THREAD_LOCAL_ZEROFILL) {
				if (!address)
					address = section->address();
				end_address = section->address() + section->size();
			}
		}
		if (address) {
			segment = file->segment_list()->GetSectionByAddress(address);
			if (segment && !segment->excluded_from_packing()) {
				uint32_t size = static_cast<uint32_t>(end_address - address);
				uint32_t physical_size = std::min(static_cast<uint32_t>(segment->address() + segment->physical_size() - address), size);
				if (physical_size) {
					file->AddressSeek(address);
					Data data;
					data.resize(size);
					file->Read(&data[0], physical_size);
					AddCommand(data);
				}
			}
		}
	}
	thread_data_entry_ = (count() == index) ? NULL : item(index);
	thread_data_size_ = 0;
	if (thread_data_entry_) {
		for (i = index; i < count(); i++) {
			thread_data_size_ += static_cast<uint32_t>(item(i)->dump_size());
		}
		thread_data_entry_->include_option(roCreateNewBlock);
		thread_data_entry_->include_option(roDataSegment);
		thread_data_entry_->set_alignment(OperandSizeToValue(cpu_address_size()));
	}

	// create watermarks
	AddWatermark(ctx.options.watermark, 2);

	// create segment list for setting WRITABLE flag
	std::vector<MacSegment *> writable_segment_list;
	std::vector<PackerInfo> packer_info_list;
	MacFixupList loader_fixup_list;
	segment = file->segment_list()->GetSectionByAddress(loader_data_address);
	if (segment)
		writable_segment_list.push_back(segment);

	if ((file->runtime_functions_section() && file->runtime_functions_section()->name() == SECT_EH_FRAME) || file->unwind_info_section()) {
		segment = file->segment_list()->GetBaseSegment();
		if (segment)
			writable_segment_list.push_back(segment);
	}

	// parse objc load methods
	std::vector<IntelCommand *> load_command_list;
	if (!objc_segment_list.empty()) {
		size_t value_size = OperandSizeToValue(file->cpu_address_size());
		std::set<uint64_t> address_list;
		objc.GetLoadMethodReferences(address_list);
		for (std::set<uint64_t>::const_iterator it = address_list.begin(); it != address_list.end(); it++) {
			if (!file->AddressSeek(*it))
				continue;

			uint64_t pos = file->Tell();
			uint64_t value = 0;
			file->Read(&value, value_size);

			CommandBlock *block = AddBlock(count(), true);

			command = AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size(), 0, 0));
			command->AddLink(0, ltGateOffset);
			command->set_operand_value(1, value);
			command->set_block(block);
			command->CompileToNative();

			address = ctx.manager->Alloc(command->dump_size(), mtReadable);
			block->set_address(address);
			command->set_address(address);

			value = address;
			file->Seek(pos);
			file->Write(&value, value_size);

			load_command_list.push_back(command);
		}
	}

	IntelCommand *packer_props = NULL;
	if (ctx.options.flags & cpPack) {
		std::set<MacSegment *> skip_segment_list;
		for (i = 0; i < objc_segment_list.size(); i++) {
			skip_segment_list.insert(objc_segment_list[i]);
		}
		MacSegment *data_segment = file->segment_list()->GetSectionByName(SEG_DATA);
		if (data_segment) {
			// skip sections with vars
			if (file->section_list()->GetSectionByName(data_segment, SECT_DYLD) ||
				file->section_list()->GetSectionByName(data_segment, SECT_PROGRAM_VARS)) {
					skip_segment_list.insert(data_segment);
			}
		}

		PackerInfo packer_info;
		for (i = 0; i < file->segment_list()->count(); i++) {
			segment = file->segment_list()->item(i);
			if (segment->excluded_from_packing())
				continue;

			bool can_be_packed = true;
			if ((segment->memory_type() & (mtWritable | mtShared)) == (mtWritable | mtShared)) {
				can_be_packed = false;
			} else if (skip_segment_list.find(segment) != skip_segment_list.end()) {
				can_be_packed = false;
			}

			if (!can_be_packed) {
				//file->Notify(mtWarning, NULL, string_format(language[lsSegmentCanNotBePacked].c_str(), segment->name().c_str()));
				continue;
			}

			if (segment->physical_size()) {
				packer_info = PackerInfo(segment, segment->address(), static_cast<size_t>(segment->physical_size()));

				if (segment == data_segment) {
					ISection *section = file->section_list()->GetSectionByName(data_segment, SECT_DYLD);
					if (section && section->address() + section->size() >= packer_info.address) {
						size_t delta = static_cast<size_t>(section->address() + section->size() - packer_info.address);
						packer_info.address += delta;
						if (packer_info.size > delta) {
							packer_info.size -= delta;
						} else {
							packer_info.size = 0;
						}
					}
				} else if (segment == file->header_segment()) {
					size_t delta = file->max_header_size();
					packer_info.address += delta;
					if (packer_info.size > delta) {
						packer_info.size -= delta;
					} else {
						packer_info.size = 0;
					}
				}

				if (!packer_info.size)
					continue;

				packer_info_list.push_back(packer_info);
				packed_segment_list_.push_back(segment);

				// need add packed section into WRITABLE section list
				if (std::find(writable_segment_list.begin(), writable_segment_list.end(), segment) == writable_segment_list.end())
					writable_segment_list.push_back(segment);
			}
		}

		// parse objc structures
		if (!objc_segment_list.empty()) {
			size_t value_size = OperandSizeToValue(file->cpu_address_size());
			std::set<uint64_t> address_list;
			objc.GetStringReferences(address_list);
			for (i = 0; i < file->section_list()->count(); i++) {
				MacSection *section = file->section_list()->item(i);
				if (find(objc_segment_list.begin(), objc_segment_list.end(), section->parent()) != objc_segment_list.end()) {
					switch (section->type()) {
					case S_LITERAL_POINTERS:
						for (j = 0; j < section->size(); j += value_size) {
							address_list.insert(section->address() + j);
						}
						break;
					}
				}
			}

			index = count();
			for (std::set<uint64_t>::const_iterator it = address_list.begin(); it != address_list.end(); it++) {
				if (!file->AddressSeek(*it))
					continue;

				// move strings to loader segment
				uint64_t pos = file->Tell();
				uint64_t value = 0;
				file->Read(&value, value_size);
				segment = file->segment_list()->GetSectionByAddress(value);
				if (!segment || std::find(packer_info_list.begin(), packer_info_list.end(), segment) == packer_info_list.end())
					continue;

				command = NULL;
				for (i = index; i < count(); i++) {
					if (item(i)->operand(0).value == value) {
						command = item(i);
						break;
					}
				}
				if (!command) {
					file->AddressSeek(value);
					std::string str = file->ReadString();

					CommandBlock *block = AddBlock(count(), true);

					command = AddCommand(str);
					command->set_block(block);
					command->set_operand_value(0, value);

					address = ctx.manager->Alloc(command->dump_size(), mtReadable);
					block->set_address(address);
					command->set_address(address);
				}

				file->Seek(pos);
				value = command->address();
				file->Write(&value, value_size);
			}
		}

		// packing sections
		j = 0;
		for (i = 0; i < packer_info_list.size(); i++) {
			j += packer_info_list[i].size;
		}
		file->StartProgress(string_format("%s...", language[lsPacking].c_str()), j);

		Data data;
		Packer packer;

		if (!packer.WriteProps(&data))
			throw std::runtime_error("Packer error");
		packer_props = AddCommand(data);
		packer_props->include_option(roCreateNewBlock);

		for (i = 0; i < packer_info_list.size(); i++) {
			packer_info = packer_info_list[i];
			if (!file->AddressSeek(packer_info.address))
				return false;

			if (!packer.Code(file, packer_info.size, &data))
				throw std::runtime_error("Packer error");

			command = AddCommand(data);
			command->include_option(roCreateNewBlock);
			packer_info_list[i].data = command;
		}

		// remove packed sections from file
		uint32_t physical_offset = 0;
		for (i = 0; i < file->segment_list()->count(); i++) {
			segment = file->segment_list()->item(i);
			uint32_t physical_size = segment->physical_size();
			bool is_packed = false;
			std::vector<PackerInfo>::iterator it = std::find(packer_info_list.begin(), packer_info_list.end(), segment);
			if (it != packer_info_list.end()) {
				physical_size = static_cast<uint32_t>(it->address - segment->address());
				is_packed = true;
				if (segment == file->header_segment() && file->file_type() == MH_DYLIB) {
					file->Seek(physical_size);
					j = physical_size;
					physical_size = AlignValue(physical_size, file->segment_alignment());
					for (k = j; k < physical_size; k++) {
						file->WriteByte(0);
					}
				}
			}
			if (segment->physical_offset() != physical_offset) {
				size_t delta = static_cast<size_t>(physical_offset - segment->physical_offset());
				for (j = 0; j < file->section_list()->count(); j++) {
					MacSection *section = file->section_list()->item(j);
					if (section->parent() == segment && section->physical_offset())
						section->set_physical_offset(static_cast<uint32_t>(section->physical_offset() + delta));
				}
			}

			if (physical_size > 0 && segment->physical_offset() != physical_offset) {
				uint8_t *buff = new uint8_t[physical_size];
				file->Seek(segment->physical_offset());
				file->Read(buff, physical_size);
				file->Seek(physical_offset);
				file->Write(buff, physical_size);
				delete [] buff;
			}

			segment->set_physical_offset(physical_offset);
			segment->set_physical_size(physical_size);

			if (is_packed) {
				j = physical_offset + physical_size;
				file->Seek(j);
				physical_offset = (uint32_t)AlignValue(j, file->file_alignment());
				if (!physical_size && j == physical_offset)
					physical_offset += file->file_alignment();
				for (k = j; k < physical_offset; k++) {
					file->WriteByte(0);
				}
			} else {
				physical_offset += physical_size;
			}
		}
		file->Resize(physical_offset);
	}

	for (i = 0; i < file->fixup_list()->count(); i++) {
		MacFixup *fixup = file->fixup_list()->item(i);
		if (fixup->is_deleted())
			continue;

		segment = file->segment_list()->GetSectionByAddress(fixup->address());
		if (!segment)
			continue;

		if (std::find(packer_info_list.begin(), packer_info_list.end(), segment) == packer_info_list.end()) {
			if ((segment->memory_type() & (mtExecutable | mtWritable)) != mtExecutable || segment->name() == SEG_TEXT)
				continue;
		}

		if (fixup->symbol()) {
			// external relocation
			// FIXME
			continue;
			command = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size())); //-V779
			relocation_info_[fixup] = command;
		}
		else {
			// local relocation
			if (ctx.options.flags & cpStripFixups)
				continue;

			loader_fixup_list.AddObject(fixup->Clone(&loader_fixup_list));
			fixup->set_deleted(true);
		}

		// need add section into WRITABLE section list
		if (std::find(writable_segment_list.begin(), writable_segment_list.end(), segment) == writable_segment_list.end())
			writable_segment_list.push_back(segment);
	}

	// create packer info for loader
	std::vector<LoaderInfo> loader_info_list;
	index = count();
	if (packer_props) {
		command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
		link = command->AddLink(0, ltOffset, packer_props);
		link->set_sub_value(file->image_base());
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, packer_props->dump_size()));

		for (i = 0; i < packer_info_list.size(); i++) {
			command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
			link = command->AddLink(0, ltOffset, packer_info_list[i].data);
			link->set_sub_value(file->image_base());

			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, packer_info_list[i].address - file->image_base()));
		}
	}
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create file CRC info for loader
	index = count();
	if ((ctx.options.flags | ctx.options.sdk_flags) & cpMemoryProtection) {
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
		for (i = 0; i < 4; i++) {
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
		}
	}
	file_crc_entry_ = (count() == index) ? NULL : item(index);
	if (file_crc_entry_)
		file_crc_entry_->include_option(roCreateNewBlock);
	file_crc_size_ = static_cast<uint32_t>((count() - index) * OperandSizeToValue(osDWord));
	loader_info_list.push_back(LoaderInfo(file_crc_entry_, file_crc_size_));

	file_crc_size_entry_ = file_crc_entry_ ? AddCommand(cmDD, IntelOperand(otValue, osDWord)) : NULL;
	if (file_crc_size_entry_)
		file_crc_size_entry_->include_option(roCreateNewBlock);

	// create header and loader CRC info for loader
	index = count();
	if (((ctx.options.flags | ctx.options.sdk_flags) & cpMemoryProtection) || (ctx.options.flags & cpLoaderCRC)) {
		// calc CRC blocks count
		k = 30 + new_import_list.count();
		if ((ctx.options.flags & cpStripFixups) == 0) {
			std::vector<IFunction *> function_list = ctx.file->function_list()->processor_list();
			function_list.push_back(this);
			for (i = 0; i < runtime_function_list->count(); i++) {
				func = runtime_function_list->item(i);
				if (func->tag() != ftLoader)
					continue;

				if (func->compilation_type() == ctMutation)
					function_list.push_back(func);
			}

			for (i = 0; i < function_list.size(); i++) {
				func = reinterpret_cast<IntelFunction *>(function_list[i]);
				for (j = 0; j < func->count(); j++) {
					command = func->item(j);
					for (size_t c = 0; c < 3; c++) {
						IntelOperand operand = command->operand(c);
						if (operand.type == otNone)
							break;
						if (operand.fixup)
							k++;
					}
				}
			}
		}
		for (i = 0; i < k; i++) {
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
		}
	}
	loader_crc_entry_ = (count() == index) ? NULL : item(index);
	if (loader_crc_entry_)
		loader_crc_entry_->include_option(roCreateNewBlock);
	loader_crc_size_ = static_cast<uint32_t>((count() - index) * OperandSizeToValue(osDWord));
	loader_info_list.push_back(LoaderInfo(loader_crc_entry_, loader_crc_size_));

	loader_crc_size_entry_ = loader_crc_entry_ ? AddCommand(cmDD, IntelOperand(otValue, osDWord)) : NULL;
	if (loader_crc_size_entry_)
		loader_crc_size_entry_->include_option(roCreateNewBlock);
	loader_crc_hash_entry_ = loader_crc_entry_ ? AddCommand(cmDD, IntelOperand(otValue, osDWord)) : NULL;
	if (loader_crc_hash_entry_)
		loader_crc_hash_entry_->include_option(roCreateNewBlock);

	// create section info for loader
	index = count();
	for (i = 0; i < writable_segment_list.size(); i++) {
		segment = writable_segment_list[i];
		if ((segment->memory_type() & mtWritable) && ((segment->memory_type() & mtExecutable) == 0 || segment->physical_size()))
			continue;

		segment->include_maxprot(VM_PROT_WRITE);

		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, segment->address() - file->image_base()));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, segment->size()));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, segment->flags()));
	}
	// add runtime's WRITABLE sections
	for (i = 0; i < runtime->segment_list()->count(); i++) {
		segment = runtime->segment_list()->item(i);
		if (segment->memory_type() & mtWritable) {
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, segment->address() - file->image_base()));
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, segment->size()));
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, segment->flags()));
		}
	}
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create fixup info for loader
	if (loader_fixup_list.count() > 0) {
		Data data;
		loader_fixup_list.WriteToData(data, file->image_base());
		command = AddCommand(data);
	} else {
		command = NULL;
	}
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (command) ? command->dump_size() : 0));

	// create relocation info for loader
	loader_info_list.push_back(LoaderInfo(NULL, 0));
	
	// create IAT info for loader
	index = count();
	for (std::map<MacImportFunction *, IntelCommand *>::iterator it = import_function_info_.begin(); it != import_function_info_.end(); it++) {
		import_function = it->first;
		if (!import_function->address())
			continue;

		command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
		link = command->AddLink(0, ltOffset, it->second);
		link->set_sub_value(file->image_base());

		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, import_function->address() - file->image_base()));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, OperandSizeToValue(cpu_address_size())));
	}
	for (std::map<MacFixup *, IntelCommand *>::iterator it = relocation_info_.begin(); it != relocation_info_.end(); it++) {
		MacFixup *fixup = it->first;

		command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
		link = command->AddLink(0, ltOffset, it->second);
		link->set_sub_value(file->image_base());

		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, fixup->address() - file->image_base()));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, OperandSizeToValue(cpu_address_size())));
	}
	if (thread_variables_entry_) {
		size_t c = thread_variables_size_ / OperandSizeToValue(cpu_address_size());
		j = IndexOf(thread_variables_entry_);
		for (i = 0; i < c; i++) {
			src_command = item(j + i);
			if (!src_command->operand(1).value)
				continue;

			command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
			link = command->AddLink(0, ltOffset, src_command);
			link->set_sub_value(file->image_base());

			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, src_command->address() - file->image_base()));
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, src_command->operand(1).value));
		}
	}
	size_t patch_section_index = count();
	if (file->runtime_functions_section() && file->runtime_functions_section()->name() == SECT_EH_FRAME) {
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
	}
	if (file->unwind_info_section()) {
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
	}
	patch_section_entry_ = (count() == patch_section_index) ? NULL : item(patch_section_index);
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create import info for loader
	index = count();
	/*
	if (ctx.options.flags & cpImportProtection) {
		for (i = 0, import_index = 0; i < orig_dll_count; i++) {
			import = new_import_list.item(i);
			if (import->count() == 0)
				continue;

			// DLL name
			command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
			link = command->AddLink(0, ltOffset, import_info_list[i].loader_name);
			link->set_sub_value(file->image_base());

			for (j = 0; j < import->count(); j++, import_index++) {
				import_function = import->item(j);
				if (import_function->options() & ioNative)
					continue;

				if (ctx.options.flags & cpResourceProtection) {
					// internal API
					if ((import_function->options() & ioFromRuntime) == 0 && import_function->type() >= atLoadResource && import_function->type() <= atEnumResourceTypesW)
						continue;
				}

				iat_command = intel_import->GetIATCommand(import_function);

				// API name
				if (import_function->is_ordinal()) {
					AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, IMAGE_ORDINAL_FLAG32 | import_function->ordinal()));
				} else {
					command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
					link = command->AddLink(0, ltOffset, import_function_info_list[import_index].loader_name);
					link->set_sub_value(file->image_base());
				}

				// IAT
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, ((iat_command) ? iat_command->address() : import_function->address()) - file->image_base()));

				// decrypt value
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, (iat_command) ? iat_command->operand(1).value : 0));
			}

			// end of DLL
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
		}
	}
	*/
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create internal import info for loader
	index = count();
	/*
	if (ctx.options.flags & cpResourceProtection) {
		for (i = 0; i < orig_dll_count; i++) {
			import = new_import_list.item(i);
			for (j = 0; j < import->count(); j++) {
				import_function = import->item(j);

				if ((import_function->options() & ioFromRuntime) || import_function->type() < atLoadResource || import_function->type() > atEnumResourceTypesW)
					continue;

				iat_command = (intel_import) ? intel_import->GetIATCommand(import_function) : NULL;

				address = runtime->export_list()->GetAddressByType(import_function->type());
				func = reinterpret_cast<IntelFunction*>(file->function_list()->GetFunctionByAddress(address));
				if (func && func->entry())
					address = func->entry()->address();

				// address
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, address - file->image_base()));
				// IAT
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, ((iat_command) ? iat_command->address() : import_function->address()) - file->image_base()));
				// decrypt value
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, (iat_command) ? iat_command->operand(1).value : 0));
			}
		}
	}
	*/
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create memory CRC info for loader
	if (intel_crc) {
		command = intel_crc->table_entry();
		i = static_cast<size_t>(intel_crc->size_entry()->operand(0).value);
	} else {
		command = NULL;
		i = 0;
	}
	loader_info_list.push_back(LoaderInfo(command, i));

	// create delay import info for loader
	index = count();
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create strings for loader
	uint32_t string_key = rand32();
	std::map<uint32_t, IntelCommand *> loader_string_list;
	loader_string_list[FACE_FILE_CORRUPTED] = AddCommand(EncryptString((ctx.options.flags & cpMemoryProtection) ? ctx.options.messages[MESSAGE_FILE_CORRUPTED].c_str() : std::string().c_str(), string_key));
	loader_string_list[FACE_DEBUGGER_FOUND] = AddCommand(EncryptString(ctx.options.messages[MESSAGE_DEBUGGER_FOUND].c_str(), string_key));
	loader_string_list[FACE_VIRTUAL_MACHINE_FOUND] = AddCommand(EncryptString(ctx.options.messages[MESSAGE_VIRTUAL_MACHINE_FOUND].c_str(), string_key));
	loader_string_list[FACE_PROC_NOT_FOUND] = AddCommand(EncryptString("The procedure entry point %c could not be located in the module %c", string_key));
	loader_string_list[FACE_ORDINAL_NOT_FOUND] = AddCommand(EncryptString("The ordinal %d could not be located in the module %c", string_key));
	loader_string_list[FACE_INITIALIZATION_ERROR] = AddCommand(EncryptString("Initialization error %d", string_key));
	VMProtectBeginVirtualization("Loader Strings");
	loader_string_list[FACE_UNREGISTERED_VERSION] = AddCommand(EncryptString(
#ifdef DEMO
		true
#else
		(ctx.options.flags & cpUnregisteredVersion) 
#endif
		? VMProtectDecryptStringA("This application is protected with unregistered version of VMProtect.") : "", string_key));
	VMProtectEnd();
	loader_string_list[FACE_MACOSX_FORMAT_VALUE] = AddCommand("%s\n");
	loader_string_list[FACE_GNU_PTRACE] = AddCommand("ptrace");
	for (std::map<uint32_t, IntelCommand *>::const_iterator it = loader_string_list.begin(); it != loader_string_list.end(); it++) {
		it->second->include_option(roCreateNewBlock);
	}

	file_entry_ = NULL;
	if (file->entry_point() && max_header_address) {
		segment = file->segment_list()->GetSectionByAddress(file->entry_point());
		if (segment && std::find(packer_info_list.begin(), packer_info_list.end(), segment) != packer_info_list.end()) {
			// work around MacOSX >= 10.13 - entry point function must be point within __TEXT segment
			max_header_address -= 5;
			CommandBlock *block = AddBlock(count(), true);
			block->set_address(max_header_address);
			file_entry_ = AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size(), 0, file->entry_point()));
			file_entry_->set_address(max_header_address);
			file_entry_->set_block(block);
		}
	}

	// append loader
	old_count = count();
	std::vector<IntelCommand*> internal_entry_list;
	for (size_t n = 0; n < 2; n++) {
		for (i = 0; i < runtime_function_list->count(); i++) {
			func = runtime_function_list->item(i);
			if (func->tag() != ftLoader)
				continue;

			if (func->compilation_type() == ctMutation) {
				if (n != 0)
					continue;
			} else {
				if (n != 1)
					continue;
			}

			bool is_internal = (func->compilation_type() != ctMutation && func->entry_type() == etNone);
			for (j = 0; j < func->count(); j++) {
				src_command = func->item(j);

				dst_command = src_command->Clone(this);
				AddObject(dst_command);
				if (is_internal) {
					if (j == 0)
						internal_entry_list.push_back(dst_command);
					if (dst_command->type() == cmRet)
						dst_command->include_option(roInternal);
				}

				src_link = src_command->link();
				if (src_link) {
					dst_link = src_link->Clone(link_list());
					dst_link->set_from_command(dst_command);
					link_list()->AddObject(dst_link);
				
					if (src_link->parent_command())
						dst_link->set_parent_command(GetCommandByAddress(src_link->parent_command()->address()));
				}

				uint64_t ref_address = (dst_command->type() == cmCall && dst_command->operand(0).type == otValue && func->compilation_type() != ctMutation) ? dst_command->operand(0).value : dst_command->address();
				std::map<uint64_t, MacImportFunction *>::const_iterator it_import = runtime_info_list.find(ref_address);
				if (it_import != runtime_info_list.end()) {
					if (dst_command->type() == cmCall) {
						IntelOperand operand = dst_command->operand(0);
						if (operand.type == otValue) {
							command = GetCommandByAddress(dst_command->operand(0).value);
							operand = command->operand(0);
							delete dst_command->link();
							dst_command->AddLink(-1, ltCall);
						}
						dst_command->Init(cmMov, IntelOperand(otRegistr, operand.size, regEAX), operand);

						command = new IntelCommand(this, cpu_address_size(), cmCall, IntelOperand(otRegistr, operand.size, regEAX));
						if (dst_command->link())
							dst_command->link()->set_from_command(command);
						AddObject(command);
					}
					dst_link = dst_command->AddLink((dst_command->operand(1).type != otNone) ? 1 : 0, ltOffset);
					std::map<MacImportFunction *, IntelCommand *>::iterator it = import_function_info_.find(it_import->second);
					if (it != import_function_info_.end())
						dst_link->set_to_command(it->second);
				}

				if (!dst_command->is_data() && (dst_command->options() & roBreaked)) {
					// need add JMP after breaked commands
					IntelCommand *jmp_command = new IntelCommand(this, cpu_address_size(), cmJmp, IntelOperand(otValue, cpu_address_size(), 0, dst_command->next_address()));
					jmp_command->AddLink(0, ltJmp, dst_command->next_address());
					jmp_command->set_address_range(dst_command->address_range());
					jmp_command->CompileToNative();
					AddObject(jmp_command);
				}

				command = dst_command;
				for (k = 0; k < 3; k++) {
					IntelOperand operand = command->operand(k);
					if (operand.type == otNone)
						break;

					if ((operand.type & otValue) == 0)
						continue;

					if ((operand.value & 0xFFFF0000) == 0xFACE0000) {
						switch (static_cast<uint32_t>(operand.value)) {
						case FACE_LOADER_OPTIONS:
							operand.value = 0;
							if (ctx.options.flags & cpMemoryProtection)
								operand.value |= LOADER_OPTION_CHECK_PATCH;
							if (ctx.options.flags & cpCheckDebugger)
								operand.value |= LOADER_OPTION_CHECK_DEBUGGER;
							if (ctx.options.flags & cpCheckVirtualMachine)
								operand.value |= LOADER_OPTION_CHECK_VIRTUAL_MACHINE;
							command->set_operand_value(k, operand.value);
							command->CompileToNative();
							break;
						case FACE_LOADER_DATA:
							command->set_operand_value(k, loader_data_address - file->image_base());
							command->CompileToNative();
							break;
						case FACE_RUNTIME_ENTRY:
							if (runtime->segment_list()->count()) {
								uint64_t runtime_init_address = runtime->export_list()->GetAddressByType(atRuntimeInit);
								if (!runtime_init_address)
									return false;
								command->set_operand_value(k, runtime_init_address - file->image_base());
							} else {
								command->set_operand_value(k, 0);
							}
							command->CompileToNative();
							break;
						case FACE_STRING_DECRYPT_KEY:
							command->set_operand_value(k, string_key);
							command->CompileToNative();
							break;
						case FACE_PACKER_INFO:
						case FACE_FILE_CRC_INFO:
						case FACE_LOADER_CRC_INFO:
						case FACE_SECTION_INFO:
						case FACE_FIXUP_INFO:
						case FACE_RELOCATION_INFO:
						case FACE_IAT_INFO:
						case FACE_IMPORT_INFO:
						case FACE_INTERNAL_IMPORT_INFO:
						case FACE_MEMORY_CRC_INFO:
						case FACE_DELAY_IMPORT_INFO:
							dst_command = loader_info_list[(operand.value & 0xff) >> 1].data;
							if (dst_command) {
								link = command->AddLink((int)k, ltOffset, dst_command);
								link->set_sub_value(file->image_base());
							} else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_PACKER_INFO_SIZE:
						case FACE_SECTION_INFO_SIZE:
						case FACE_FIXUP_INFO_SIZE:
						case FACE_RELOCATION_INFO_SIZE:
						case FACE_IAT_INFO_SIZE:
						case FACE_IMPORT_INFO_SIZE:
						case FACE_INTERNAL_IMPORT_INFO_SIZE:
						case FACE_MEMORY_CRC_INFO_SIZE:
						case FACE_DELAY_IMPORT_INFO_SIZE:
							command->set_operand_value(k, loader_info_list[(operand.value & 0xff) >> 1].size);
							command->CompileToNative();
							break;
						case FACE_LOADER_CRC_INFO_SIZE:
							if (loader_crc_size_entry_) {
								link = command->AddLink((int)k, ltOffset, loader_crc_size_entry_);
								link->set_sub_value(file->image_base());
							} else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_LOADER_CRC_INFO_HASH:
							if (loader_crc_hash_entry_) {
								link = command->AddLink((int)k, ltOffset, loader_crc_hash_entry_);
								link->set_sub_value(file->image_base());
							} else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_FILE_CRC_INFO_SIZE:
							if (file_crc_size_entry_) {
								link = command->AddLink((int)k, ltOffset, file_crc_size_entry_);
								link->set_sub_value(file->image_base());
							} else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_MEMORY_CRC_INFO_HASH:
							command->set_operand_value(k, intel_crc ? intel_crc->hash_entry()->operand(0).value : 0);
							command->CompileToNative();
							break;
						case FACE_CRC_INFO_SALT:
							command->set_operand_value(k, file->function_list()->crc_cryptor()->item(0)->value());
							command->CompileToNative();
							break;
						case FACE_IMAGE_BASE:
							if (command->operand(0).size != cpu_address_size()) {
								IntelOperand first = command->operand(0);
								IntelOperand second = command->operand(1);
								first.size = cpu_address_size();
								second.size = cpu_address_size();
								command->Init(static_cast<IntelCommandType>(command->type()), first, second);
							}
							command->set_operand_value(k, file->image_base());
							command->set_operand_fixup(k, NEED_FIXUP);
							command->CompileToNative();
							break;
						case FACE_FILE_BASE:
							if (command->operand(0).size != cpu_address_size()) {
								IntelOperand first = command->operand(0);
								IntelOperand second = command->operand(1);
								first.size = cpu_address_size();
								second.size = cpu_address_size();
								command->Init(static_cast<IntelCommandType>(command->type()), first, second);
							}
							command->set_operand_value(k, file->image_base());
							command->CompileToNative();
							break;
						case FACE_VAR_IS_PATCH_DETECTED:
						case FACE_VAR_IS_DEBUGGER_DETECTED:
						case FACE_VAR_LOADER_CRC_INFO:
						case FACE_VAR_LOADER_CRC_INFO_SIZE:
						case FACE_VAR_LOADER_CRC_INFO_HASH:
						case FACE_VAR_CPU_HASH:
						case FACE_VAR_CPU_COUNT:
						case FACE_VAR_SESSION_KEY:
						case FACE_VAR_DRIVER_UNLOAD:
						case FACE_VAR_CRC_IMAGE_SIZE:
						case FACE_VAR_LOADER_STATUS:
						case FACE_VAR_SERVER_DATE:
							command->set_operand_value(k, ctx.runtime_var_index[(operand.value & 0xff) >> 4] * OperandSizeToValue(cpu_address_size()));
							command->CompileToNative();
							break;
						case FACE_VAR_IS_PATCH_DETECTED_SALT:
						case FACE_VAR_IS_DEBUGGER_DETECTED_SALT:
						case FACE_VAR_LOADER_CRC_INFO_SALT:
						case FACE_VAR_LOADER_CRC_INFO_SIZE_SALT:
						case FACE_VAR_LOADER_CRC_INFO_HASH_SALT:
						case FACE_VAR_CPU_HASH_SALT:
						case FACE_VAR_CPU_COUNT_SALT:
						case FACE_VAR_DRIVER_UNLOAD_SALT:
						case FACE_VAR_CRC_IMAGE_SIZE_SALT:
						case FACE_VAR_SERVER_DATE_SALT:
							command->set_operand_value(k, ctx.runtime_var_salt[operand.value & 0xff]);
							command->CompileToNative();
							break;
						case FACE_VAR_CPU_COUNT_SALT ^ 1:
							command->set_operand_value(k, ctx.runtime_var_salt[VAR_CPU_COUNT] ^ 1);
							command->CompileToNative();
							break;
						default:
							std::map<uint32_t, IntelCommand *>::const_iterator it = loader_string_list.find(static_cast<uint32_t>(operand.value));
							if (it != loader_string_list.end()) {
								if (command->type() == cmMov) {
									operand = command->operand(0);
									operand.size = cpu_address_size();
									if (operand.type == otRegistr) {
										command->Init(cmLea, operand, IntelOperand(otMemory | otValue, cpu_address_size(), 0, 0, (cpu_address_size() == osDWord) ? NEED_FIXUP : LARGE_VALUE));
									} else {
										command->Init(cmMov, operand, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
									}
								} else {
									command->Init(cmPush, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
								}
								command->AddLink((int)k, ltOffset, it->second); 
							} else {
								throw std::runtime_error(string_format("Unknown loader string: %X", static_cast<uint32_t>(operand.value)));
							}
						}
					}
				}
			}
		}
		if (n == 0) {
			// create native blocks
			for (j = 0; j < count(); j++) {
				item(j)->include_option(roNoProgress);
			}
			CompileToNative(ctx);
			for (j = 0; j < count(); j++) {
				item(j)->exclude_option(roNoProgress);
			}
		}
	}

	IntelOperand base_operand;
	uint64_t base_address = 0;
	for (i = old_count; i < count(); i++) {
		command = item(i);
		dst_link = command->link();

		// search references to LoaderAlloc/LoaderFree
		if (command->type() == cmRet) {
			base_operand.type = otNone;
		} else if (command->type() == cmCall && command->operand(0).type == otValue && command->operand(0).value == command->next_address()) {
			base_address = command->next_address();
			IntelCommand *next_command = item(i + 1);
			IntelCommand *next_command2 = item(i + 2);
			if (next_command->type() == cmPop && next_command->operand(0).type == otRegistr &&
				next_command2->type() == cmMov && next_command2->operand(1).type == otRegistr && next_command2->operand(1).registr == next_command->operand(0).registr) {
					base_operand = next_command2->operand(0);
			} else {
				base_operand.type = otNone;
			}

			if (command->block()) {
				command->Init(cmPush, IntelOperand(otValue, cpu_address_size(), 0, command->next_address(), NEED_FIXUP));
				command->CompileToNative();
				delete command->link();
				continue;
			}
		} else if (base_operand.type != otNone) {
			if (command->type() == cmMov && command->operand(1).type == base_operand.type && command->operand(1).value == base_operand.value) {
				uint8_t registr = command->operand(0).registr;
				for (j = i + 1; j < count(); j++) {
					IntelCommand *next_command = item(j);
					if (next_command->type() == cmLea && next_command->operand(1).type == (otMemory | otRegistr | otValue) && next_command->operand(1).registr == registr) {
						address = base_address + next_command->operand(1).value;
						ICommand *to_command = GetCommandByAddress(address);
						if (to_command) {
							CommandLink *link = next_command->AddLink(1, ltOffset, to_command);
							link->set_sub_value(base_address);
							if (next_command->operand(0).registr == registr)
								break;
						}
					}
				}
			}
		}
		if (!dst_link) {
			for (k = 0; k < 2; k++) {
				IntelOperand operand = command->operand(k);
				if (operand.type == otNone)
					break;

				if (cpu_address_size() == osDWord) {
					if (!operand.fixup)
						continue;
				} else {
					if (!operand.is_large_value)
						continue;
				}

				dst_command = reinterpret_cast<IntelCommand *>(GetCommandByAddress(operand.value));
				if (dst_command && !dst_command->is_data()) {
					dst_link = command->AddLink((int)k, ltOffset, dst_command);
					break;
				}
			}
		} else {
			if (dst_link->to_address())
				dst_link->set_to_command(GetCommandByAddress(dst_link->to_address()));
		}
	}
	setup_image_entry = GetCommandByAddress(runtime->export_list()->GetAddressByType(atSetupImage));
	if (!setup_image_entry)
		return false;

	free_image_entry = GetCommandByAddress(runtime->export_list()->GetAddressByType(atFreeImage));
	if (!free_image_entry)
		return false;

	// create entry commands
	load_command_list.push_back(NULL);
	for (i = 0; i < load_command_list.size(); i++) { 
		IntelCommand *load_command = load_command_list[i];

		old_count = count();
		size_t stack = 0x20;
		AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEBP));
		if (load_command && cpu_address_size() == osQWord) {
			AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEDI));
			AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regESI));
		}
		AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEBP), IntelOperand(otRegistr, cpu_address_size(), regESP));
		AddCommand(cmAnd, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, -0x10));
		AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, stack));

		// call SetupImage
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, setup_image_entry);

		// check loader error code
		AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, TRUE));
		IntelCommand *check_loader_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
		check_loader_command->set_flags(fl_Z);
		check_loader_command->AddLink(0, ltJmpWithFlag);

		// call FreeImage
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, free_image_entry);

		command = AddCommand(cmNop);
		check_loader_command->link()->set_to_command(command);

		AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otRegistr, cpu_address_size(), regEBP));
		if (load_command && cpu_address_size() == osQWord) {
			AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regESI));
			AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEDI));
		}
		AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEBP));

		if (load_command) {
			AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size(), 0, load_command->operand(1).value));
			load_command->link()->set_to_command(item(old_count));
		} else {
			AddCommand(cmRet);
			set_entry(item(old_count));
		}
	}

	// create term commands
	if (term_entry_) {
		old_count = count();

		AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEBP));
		AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEBP), IntelOperand(otRegistr, cpu_address_size(), regESP));
		AddCommand(cmAnd, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, -0x10));

		// call FreeImage
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, free_image_entry);

		AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otRegistr, cpu_address_size(), regEBP));
		AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEBP));
		AddCommand(cmRet);

		term_entry_->link()->set_to_command(item(old_count));
	}

	for (i = 0; i < count(); i++) {
		command = item(i);
		command->CompileToNative();
	}

	// search API calls
	for (i = 0; i < count(); i++) {
		command = item(i);
		if (command->block() || command->type() != cmCall || command->operand(0).type == otValue)
			continue;

		k = 0;
		for (j = i; j > 0; j--) {
			IntelCommand *param_command = item(j - 1);

			switch (param_command->type()) {
			case cmMov: case cmLea: case cmXor: case cmMovsxd:
				if (cpu_address_size() == osQWord) {
					if (param_command->operand(0).type == otRegistr) {
						switch (param_command->operand(0).registr) {
						case regEDI:
							k = std::max<size_t>(k, 1);
							break;
						case regESI:
							k = std::max<size_t>(k, 2);
							break;
						case regEDX:
							k = std::max<size_t>(k, 3);
							break;
						case regECX:
							k = std::max<size_t>(k, 4);
							break;
						case regR8:
							k = std::max<size_t>(k, 5);
							break;
						case regR9:
							k = std::max<size_t>(k, 6);
							break;
						}
					} else if ((param_command->operand(0).type & (otMemory | otBaseRegistr)) == (otMemory | otBaseRegistr) && param_command->operand(0).base_registr == regESP) {
						switch (param_command->operand(0).value) {
						case 0x00:
							k = std::max<size_t>(k, 7);
							break;
						case 0x04:
							k = std::max<size_t>(k, 8);
							break;
						case 0x08:
							k = std::max<size_t>(k, 9);
							break;
						case 0x0c:
							k = std::max<size_t>(k, 10);
							break;
						case 0x10:
							k = std::max<size_t>(k, 11);
							break;
						case 0x14:
							k = std::max<size_t>(k, 12);
							break;
						default:
							if (param_command->operand(0).value >= 0x18)
								k = NOT_ID;
							break;
						}
					}
				} else if ((param_command->operand(0).type & (otMemory | otBaseRegistr)) == (otMemory | otBaseRegistr) && param_command->operand(0).base_registr == regESP) {
					switch (param_command->operand(0).value) {
					case 0x00:
						k = std::max<size_t>(k, 1);
						break;
					case 0x04:
						k = std::max<size_t>(k, 2);
						break;
					case 0x08:
						k = std::max<size_t>(k, 3);
						break;
					case 0x0c:
						k = std::max<size_t>(k, 4);
						break;
					case 0x10:
						k = std::max<size_t>(k, 5);
						break;
					case 0x14:
						k = std::max<size_t>(k, 6);
						break;
					case 0x18:
						k = std::max<size_t>(k, 7);
						break;
					case 0x1c:
						k = std::max<size_t>(k, 8);
						break;
					case 0x20:
						k = std::max<size_t>(k, 9);
						break;
					case 0x24:
						k = std::max<size_t>(k, 10);
						break;
					case 0x28:
						k = std::max<size_t>(k, 11);
						break;
					case 0x2c:
						k = std::max<size_t>(k, 12);
						break;
					default:
						if (param_command->operand(0).value >= 0x30)
							k = NOT_ID;
						break;
					}
				}
				break;
			case cmCall: case cmJmp: case cmJmpWithFlag: case cmRet:
				param_command = NULL;
				break;
			}
			if (!param_command || link_list()->GetLinkByToAddress(ltNone, param_command->address()))
				break;
		}
		if (k == NOT_ID)
			continue;

		command->include_option(roInternal);
		command->set_operand_value(2, k);
	}


	for (i = 0; i < link_list()->count(); i++) {
		CommandLink *link = link_list()->item(i);
		if (link->from_command()->type() == cmCall && std::find(internal_entry_list.begin(), internal_entry_list.end(), link->to_command()) != internal_entry_list.end())
			reinterpret_cast<IntelCommand*>(link->from_command())->include_option(roInternal);
		link->from_command()->PrepareLink(ctx);
	}

	return BaseIntelLoader::Prepare(ctx);
}

bool MacIntelLoader::Compile(const CompileContext &ctx)
{
	if ((ctx.options.flags & cpStripFixups) == 0) {
		// convert fixups into PIC code
		size_t i, j, k;
		std::vector<IFunction *> function_list = ctx.file->function_list()->processor_list();
		function_list.push_back(this);
		for (i = 0; i < function_list.size(); i++) {
			IntelFunction *func = reinterpret_cast<IntelFunction *>(function_list[i]);
			OperandSize cpu_address_size = func->cpu_address_size();
			for (j = 0; j < func->count(); j++) {
				IntelCommand *src_command = func->item(j);
				CommandBlock *block = src_command->block();
				if (!block || (block->type() & mtExecutable) == 0 || (func->item(block->start_index())->options() & roDataSegment))
					continue;

				size_t fixup_index = NOT_ID;
				for (k = 0; k < 3; k++) {
					IntelOperand operand = src_command->operand(k);
					if (operand.type == otNone)
						break;

					if ((operand.type & otValue) && operand.fixup) {
						fixup_index = k;
						break;
					}
				}

				if (fixup_index != NOT_ID) {
					IntelCommand *command, *ref_command;

					bool is_case = src_command->link() && src_command->link()->type() == ltCase;
					if (is_case) {
						src_command->set_operand_fixup(0, NULL);
						command = reinterpret_cast<IntelCommand *>(src_command->link()->parent_command());
						if (command->link()->to_command() == src_command) {
							if (command->type() == cmJmp && (command->operand(0).type & otMemory))
								src_command = command;
							else {
								src_command = NULL;
								for (k = func->IndexOf(command); k < func->count(); k++) {
									command = func->item(k);
									if (command->type() == cmJmp && command->operand(0).type == otValue) {
										k = func->IndexOf(command->link()->to_command());
										if (k == NOT_ID)
											break;
										k--;
									} else if (command->link() && command->link()->type() == ltJmp && command->link()->operand_index() == -1) {
										src_command = command;
										break;
									} else if (command->type() == cmRet)
										break;
								}
								if (!src_command)
									throw std::runtime_error("Runtime error at MacIntelLoader::Compile");
							}
						}
						else
							continue;
					}

					block = func->AddBlock(func->count(), true);

					IntelRegistrList registr_list;
					registr_list.push_back(regEAX);
					registr_list.push_back(regECX);
					registr_list.push_back(regEDX);
					registr_list.push_back(regEBX);
					registr_list.push_back(regEBP);
					registr_list.push_back(regESI);
					registr_list.push_back(regEDI);

					IntelOperand new_operand[3];
					for (k = 0; k < 3; k++) {
						IntelOperand operand = src_command->operand(k);
						if (operand.type == otNone)
							break;

						if (operand.type & otRegistr)
							registr_list.remove(operand.registr);
						if (operand.type & otBaseRegistr)
							registr_list.remove(operand.base_registr);
						if (operand.fixup)
							operand.fixup = NULL;
						new_operand[k] = operand;
					}

					uint8_t reg1 = registr_list.GetRandom();
					uint8_t reg2 = registr_list.GetRandom();
					IntelCommand *link_command = NULL;
					CommandLink *src_link = src_command->link();

					func->AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, reg1));
					func->AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, reg2));
					if (cpu_address_size == osQWord) {
						ref_command = func->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otMemory | otValue, cpu_address_size, 0, 0, LARGE_VALUE));
						ref_command->AddLink(1, ltOffset, ref_command);
					}
					else {
						command = func->AddCommand(cmCall, IntelOperand(otValue, cpu_address_size));
						command->AddLink(0, ltCall);
						ref_command = func->AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size, reg1));
						command->link()->set_to_command(ref_command);
					}

					command = func->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg2), IntelOperand(otValue, cpu_address_size));
					command->AddLink(1, ltOffset, ref_command);
					command = func->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otRegistr, cpu_address_size, reg2));

					if (src_command->type() != cmLea && (new_operand[fixup_index].type & otMemory)) {
						IntelOperand mov_operand = new_operand[fixup_index];
						OperandSize mov_size = mov_operand.size;
						mov_operand.size = cpu_address_size;
						command = func->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, reg2), mov_operand);
						if (src_link) {
							link_command = command;
							if (src_link->operand_index() != -1)
								func->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, reg2), IntelOperand(otRegistr, cpu_address_size, reg1));
						}
						new_operand[fixup_index] = IntelOperand(otRegistr, mov_size, reg2);
						func->AddCommand(cmMov, new_operand[fixup_index], IntelOperand(otMemory | otRegistr, mov_size, reg2));
					}

					switch (src_command->type()) {
					case cmPush:
						command = func->AddCommand(link_command ? cmMov : cmAdd, IntelOperand(otRegistr, cpu_address_size, reg1), new_operand[0]);
						break;
					case cmJmp:
						command = func->AddCommand(link_command && !is_case ? cmMov : cmAdd, IntelOperand(otRegistr, cpu_address_size, reg1), new_operand[0]);
						break;
					default:
						command = func->AddCommand(static_cast<IntelCommandType>(src_command->type()), new_operand[0], new_operand[1]);
						if (!link_command)
							func->AddCommand(cmAdd, new_operand[0], IntelOperand(otRegistr, new_operand[0].size, reg1));
						break;
					}
					if (!link_command)
						link_command = command;

					if (src_link) {
						if (src_link->operand_index() == -1)
							src_link->set_from_command(link_command);
						else {
							link_command->AddLink(1, src_link->type(), src_link->to_command());
							delete src_link;
						}
					}

					func->AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size, reg2));

					switch (src_command->type()) {
					case cmPush:
						func->AddCommand(cmXchg, IntelOperand(otMemory | otRegistr, cpu_address_size, regESP), IntelOperand(otRegistr, cpu_address_size, reg1));
						break;
					case cmJmp:
						func->AddCommand(cmXchg, IntelOperand(otMemory | otRegistr, cpu_address_size, regESP), IntelOperand(otRegistr, cpu_address_size, reg1));
						func->AddCommand(cmRet);
						break;
					default:
						func->AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size, reg1));
						break;
					}

					if (src_command->type() != cmJmp) {
						command = func->AddCommand(cmJmp, IntelOperand(otValue, func->cpu_address_size()));
						command->AddLink(0, ltJmp, func->item(func->IndexOf(src_command) + 1));
					}
					src_command->Init(cmJmp, IntelOperand(otValue, cpu_address_size, 0));
					src_command->AddLink(0, ltJmp, func->item(block->start_index()));
					src_command->CompileToNative();
					for (k = block->start_index(); k < func->count(); k++) {
						command = func->item(k);
						command->set_block(block);
						command->CompileToNative();
						block->set_end_index(k);
					}
				}
			}
		}
	}

	if (!BaseIntelLoader::Compile(ctx))
		return false;

	IntelCommand *command = init_entry_->link() ? reinterpret_cast<IntelCommand *>(init_entry_->link()->to_command()) : init_entry_;
	command->set_operand_value(0, entry()->address());
	command->CompileToNative();

	for (std::map<MacImportFunction *, IntelCommand *>::iterator it = import_function_info_.begin(); it != import_function_info_.end(); it++) {
		MacImportFunction *import_function = it->first;
		IntelCommand *command = it->second;
		import_function->set_address(command->address());
	}

	for (std::map<MacFixup *, IntelCommand *>::iterator it = relocation_info_.begin(); it != relocation_info_.end(); it++) {
		MacFixup *fixup = it->first;
		IntelCommand *command = it->second;
		fixup->set_address(command->address());
	}

	return true;
}

/**
 * ELFIntelFunctionList
 */

ELFIntelFunctionList::ELFIntelFunctionList(IArchitecture *owner)
	: IntelFunctionList(owner)
{

}

ELFIntelFunctionList::ELFIntelFunctionList(IArchitecture *owner, const ELFIntelFunctionList &src)
	: IntelFunctionList(owner, src)
{

}

ELFIntelFunctionList *ELFIntelFunctionList::Clone(IArchitecture *owner) const
{
	ELFIntelFunctionList *list = new ELFIntelFunctionList(owner, *this);
	return list;
}

IntelSDK *ELFIntelFunctionList::AddSDK(OperandSize cpu_address_size)
{
	IntelSDK *func = new ELFIntelSDK(this, cpu_address_size);
	AddObject(func);
	return func;
}

void ELFIntelFunctionList::ReadFromBuffer(Buffer &buffer, IArchitecture &file)
{
	IntelFunctionList::ReadFromBuffer(buffer, file);

	std::vector<IntelCommand*> memory_ref_list;
	size_t i, j, k;
	IntelCommand *command, *mem_command;
	size_t c = count();
	OperandSize cpu_address_size = file.cpu_address_size();
	ELFDirectory *plt_got = reinterpret_cast<ELFArchitecture &>(file).command_list()->GetCommandByType(DT_PLTGOT);
	uint64_t plt_got_address = plt_got ? plt_got->value() : 0;
	for (i = 0; i < c; i++) {
		IntelFunction *func = item(i);
		if (func->tag() != ftLoader)
			continue;

		for (j = 0; j < func->count(); j++) {
			command = func->item(j);

			if (command->type() == cmMovaps) {
				for (k = 0; k < 3; k++) {
					IntelOperand operand = command->operand(k);
					if (operand.type == otNone)
						break;

					if ((operand.type & otValue) == 0)
						continue;

					if (operand.type == (otMemory | otValue)) {
						if (cpu_address_size == osQWord && operand.is_large_value) {
							memory_ref_list.push_back(command);
						}
					} else if (operand.type == (otMemory | otRegistr | otValue) && plt_got_address) {
						if (cpu_address_size == osDWord)
							memory_ref_list.push_back(command);
					}
				}
			}
		}
	}

	if (memory_ref_list.size()) {
		for (i = 0; i < memory_ref_list.size(); i++) {
			command = memory_ref_list[i];
			IntelFunction *func = reinterpret_cast<IntelFunction *>(command->owner());

			IntelOperand operand = command->operand(1);
			uint64_t address = operand.value;
			if (operand.type & otRegistr) {
				address += plt_got_address;
				if (cpu_address_size == osDWord)
					address = static_cast<uint32_t>(address);
			}
			if (!func->GetCommandByAddress(address)) {
				file.AddressSeek(address);
				mem_command = func->Add(address);
				mem_command->ReadArray(file, OperandSizeToValue(operand.size));
				mem_command->include_option(roCreateNewBlock);
				if (operand.size == osXMMWord)
					mem_command->set_alignment(0x10);
#ifdef CHECKED
				mem_command->update_hash();
#endif
			}
			CommandLink *link = command->AddLink(1, ltOffset, address);
			if (operand.type & otRegistr)
				link->set_sub_value(plt_got_address);
		}
	}
}

/**
 * ELFIntelSDK
 */

ELFIntelSDK::ELFIntelSDK(IFunctionList *parent, OperandSize cpu_address_size)
	: IntelSDK(parent, cpu_address_size)
{

}

/**
 * ELFIntelLoader
 */

ELFIntelLoader::ELFIntelLoader(IntelFunctionList *owner, OperandSize cpu_address_size)
	: BaseIntelLoader(owner, cpu_address_size), import_entry_(NULL), import_size_(0), file_crc_entry_(NULL),
	file_crc_size_(0), file_crc_size_entry_(NULL), loader_crc_entry_(NULL), loader_crc_size_(0), loader_crc_size_entry_(NULL),
	loader_crc_hash_entry_(NULL), term_entry_(NULL), preinit_entry_(NULL), preinit_size_(0), init_entry_(NULL), tls_entry_(NULL),
	relro_entry_(NULL)
{
	//set_compilation_type(ctMutation);
}

uint32_t ELFIntelLoader::GetPackedSize(ELFArchitecture *file) const
{
	size_t i;
	PackerInfo packer_info;
	ELFSegment *segment;
	std::vector<PackerInfo> packer_info_list;
	uint32_t physical_size;

	for (i = 0; i < file->segment_list()->count(); i++) {
		segment = file->segment_list()->item(i);
		if (segment->type() != PT_LOAD || segment->excluded_from_packing())
			continue;

		bool can_be_packed = true;
		if ((segment->memory_type() & (mtWritable | mtShared)) == (mtWritable | mtShared)) {
			can_be_packed = false;
		}

		if (!can_be_packed)
			continue;

		if (segment->physical_size()) {
			packer_info = PackerInfo(segment, segment->address(), static_cast<size_t>(segment->physical_size()));

			if (segment == file->header_segment()) {
				ELFSegment *interp = file->segment_list()->GetSectionByType(PT_INTERP);
				size_t delta = interp ? static_cast<uint32_t>(interp->address() + interp->size() - segment->address()) : file->max_header_size();
				packer_info.address += delta;
				if (packer_info.size > delta) {
					packer_info.size -= delta;
				}
				else {
					packer_info.size = 0;
				}
			}

			if (!packer_info.size)
				continue;

			packer_info_list.push_back(packer_info);
		}
	}

	uint32_t physical_offset = 0;
	for (i = 0; i < file->segment_list()->count(); i++) {
		segment = file->segment_list()->item(i);
		if (segment->type() != PT_LOAD)
			continue;

		std::vector<PackerInfo>::iterator it = std::find(packer_info_list.begin(), packer_info_list.end(), segment);
		if (it != packer_info_list.end()) {
			physical_size = static_cast<uint32_t>(it->address - segment->address());
			physical_offset = (uint32_t)AlignValue(physical_offset + physical_size, file->file_alignment());
		}
		else {
			physical_size = segment->physical_size();
			physical_offset += physical_size;
		}
	}
	return physical_offset;
}

bool ELFIntelLoader::Prepare(const CompileContext &ctx)
{
	ELFArchitecture *file, *runtime;
	size_t i, j, k, index, old_count, start_index;
	IntelCommand *command, *src_command, *dst_command, *setup_image_entry, *free_image_entry;
	CommandLink *link, *src_link, *dst_link;
	uint64_t loader_data_address;
	IntelFunctionList *runtime_function_list;
	IntelFunction *func;
	IntelCRCTable *intel_crc;
	ELFImport *import;
	ELFImportFunction *import_function;
	std::map<uint64_t, ELFImportFunction *> runtime_info_list;
	std::map<ELFImportFunction *, IntelCommand *> import_function_info;
	std::map<ELFRelocation *, IntelCommand *> iat_info;
	ELFRelocation *relocation;
	ELFSegment *segment;
	std::map<ELFRelocation *, IntelCommand *> relocation_info;

	file = reinterpret_cast<ELFArchitecture *>(ctx.file);
	runtime = reinterpret_cast<ELFArchitecture *>(ctx.runtime);
	intel_crc = reinterpret_cast<IntelFunctionList *>(file->function_list())->crc_table();
	IntelLoaderData *loader_data = reinterpret_cast<IntelFunctionList*>(file->function_list())->loader_data();
	loader_data_address = (loader_data) ? loader_data->entry()->address() : runtime->export_list()->GetAddressByType(atLoaderData);
	if (!loader_data_address)
		return false;

	// create AV signature buffer
	AddAVBuffer(ctx);
	start_index = count();

	ICommand *entry_point_command = NULL;
	if (file->entry_point()) {
		IFunction *entry_point_func = ctx.file->function_list()->GetFunctionByAddress(file->entry_point());
		if (entry_point_func)
			entry_point_command = entry_point_func->entry();
	}

	// add loader import
	std::map<uint64_t, ELFImportFunction *> import_map;
	ELFImportList &new_import_list = *file->import_list();
	runtime_function_list = reinterpret_cast<IntelFunctionList *>(runtime->function_list());
	IntelCommandType value_command_type = (cpu_address_size() == osDWord) ? cmDD : cmDQ;
	index = count();
	std::map<ELFRelocation *, ELFImportFunction *> relocation_map;
	ELFDirectory *plt_got = runtime->command_list()->GetCommandByType(DT_PLTGOT);
	uint64_t plt_got_address = plt_got ? plt_got->value() : 0;
	for (i = 0; i < runtime_function_list->count(); i++) {
		func = runtime_function_list->item(i);
		if (func->tag() != ftLoader)
			continue;

		for (j = 0; j < func->count(); j++) {
			command = func->item(j);
			import_function = NULL;
			switch (command->type()) {
			case cmCall:
			case cmJmp:
			case cmMov:
				k = (command->type() == cmMov) ? 1 : 0;
				if (command->operand(k).type == (otMemory | otValue))
					import_function = runtime->import_list()->GetFunctionByAddress(command->operand(k).value);
				else if (command->type() != cmMov && command->operand(k).type == (otMemory | otRegistr | otValue) && command->operand(k).registr == regEBX && plt_got_address)
					import_function = runtime->import_list()->GetFunctionByAddress(plt_got_address + command->operand(k).value);
				break;
			}
			if (!import_function)
				continue;

			std::map<uint64_t, ELFImportFunction *>::const_iterator it = import_map.find(import_function->address());
			ELFImportFunction *new_import_function = (it != import_map.end()) ? it->second : NULL;
			if (!new_import_function) {
				ELFImport *src_import = reinterpret_cast<ELFImport *>(import_function->owner());
				import = new_import_list.GetImportByName(src_import->name());
				if (!import) {
					import = new ELFImport(&new_import_list, src_import->name());
					new_import_list.AddObject(import);
				}

				ELFSymbol *symbol = import_function->symbol()->Clone(file->dynsymbol_list());
				symbol->set_version(0);
				file->dynsymbol_list()->AddObject(symbol);

				ELFRelocation *src_relocation = runtime->relocation_list()->GetRelocationByAddress(import_function->address());
				relocation = src_relocation->Clone(file->relocation_list());
				if (relocation->type() == R_386_JMP_SLOT)
					relocation->set_type(R_386_GLOB_DAT);
				relocation->set_address(0);
				relocation->set_symbol(symbol);
				file->relocation_list()->AddObject(relocation);

				new_import_function = import->Add(0, import_function->name(), symbol);
				import_map[import_function->address()] = new_import_function;
				relocation_map[relocation] = new_import_function;
			}
			runtime_info_list[command->address()] = new_import_function;
		}
	}

	// create IAT
	for (i = 0; i < new_import_list.count(); i++) {
		import = new_import_list.item(i);
		for (j = 0; j < import->count(); j++) {
			import_function = import->item(j);
			if (!import_function)
				continue;

			relocation = file->relocation_list()->GetRelocationByAddress(import_function->address());
			relocation_map[relocation] = import_function;
		}
	}
	AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size()));
	AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size()));
	AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size()));
	for (i = 0; i < file->relocation_list()->count(); i++) {
		relocation = file->relocation_list()->item(i);
		if (relocation->type() != R_386_JMP_SLOT)
			continue;

		command = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltOffset);
		command->set_operand_relocation(0, relocation);
		command->CompileToNative();

		import_function = relocation_map[relocation];
		if (import_function)
			import_function_info[import_function] = command;
	}
	import_entry_ = item(start_index);
	import_entry_->include_option(roCreateNewBlock);
	import_entry_->set_alignment(OperandSizeToValue(cpu_address_size()));
	import_size_ = static_cast<uint32_t>((count() - start_index) * OperandSizeToValue(cpu_address_size()));
	for (i = 0; i < file->relocation_list()->count(); i++) {
		relocation = file->relocation_list()->item(i);
		if (relocation->type() == R_386_JMP_SLOT)
			continue;

		if (relocation->address()) {
			if ((ctx.options.flags & cpPack) == 0)
				continue;
			if (cpu_address_size() == osDWord) {
				if (relocation->type() == R_386_IRELATIVE) {
					relocation_info[relocation] = NULL;
					continue;
				}
			}
			else {
				if (relocation->type() == R_X86_64_IRELATIVE) {
					relocation_info[relocation] = NULL;
					continue;
				}
			}
			segment = file->segment_list()->GetSectionByAddress(relocation->address());
			if (!segment || segment->excluded_from_packing() || segment->address() + segment->physical_size() <= relocation->address())
				continue;
		}

		command = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, (relocation->type() == R_386_PC32) ? 0 : relocation->value()));
		command->set_operand_relocation(0, relocation);
		command->CompileToNative();

		import_function = relocation_map[relocation];
		if (import_function)
			import_function_info[import_function] = command;

		if (relocation->address()) {
			if (relocation->type() == R_386_PC32)
				relocation_info[relocation] = command;
			else {
				iat_info[relocation] = command;
				if (relocation->type() == R_386_COPY && relocation->symbol()->size() > command->dump_size()) {
					Data data;
					data.resize(AlignValue(relocation->symbol()->size(), command->dump_size()) - command->dump_size());
					AddCommand(data);
				}
			}
		}
	}

	// create jump table
	IntelCommand *jmp_table_entry = AddCommand(cmPush, IntelOperand(otMemory | otValue, cpu_address_size(), 0, 0, (cpu_address_size() == osDWord) ? NEED_FIXUP : LARGE_VALUE));
	jmp_table_entry->AddLink(0, ltOffset, item(start_index + 1));
	command = AddCommand(cmJmp, IntelOperand(otMemory | otValue, cpu_address_size(), 0, 0, (cpu_address_size() == osDWord) ? NEED_FIXUP : LARGE_VALUE));
	command->AddLink(0, ltOffset, item(start_index + 2));
	k = 1;
	index = 0;
	for (i = 0; i < file->relocation_list()->count(); i++) {
		relocation = file->relocation_list()->item(i);
		if (relocation->type() != R_386_JMP_SLOT)
			continue;

		IntelCommand *iat_command = item(start_index + 3 + index);
		if (relocation->address()) {
			CommandBlock *block = AddBlock(count(), true);

			command = AddCommand(cmJmp, IntelOperand(otMemory | otValue, cpu_address_size(), 0, 0, (cpu_address_size() == osDWord) ? NEED_FIXUP : LARGE_VALUE));
			command->AddLink(0, ltOffset, iat_command);
			command->CompileToNative();
			command->set_block(block);

			uint64_t address = ctx.manager->Alloc(command->dump_size(), mtReadable);
			block->set_address(address);

			file->AddressSeek(relocation->address());
			if (cpu_address_size() == osDWord)
				file->WriteDWord(static_cast<uint32_t>(address));
			else
				file->WriteQWord(address);

			file->fixup_list()->Add(relocation->address(), cpu_address_size());
		}

		size_t offset = index * k;
		if (cpu_address_size() == osDWord)
			offset *= sizeof(Elf32_Rel);
		command = AddCommand(cmPush, IntelOperand(otValue, cpu_address_size(), 0, offset));
		iat_command->link()->set_to_command(command);

		command = AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltJmp, jmp_table_entry);

		index++;
	}

	ELFDirectory *dir = file->command_list()->GetCommandByType(DT_PREINIT_ARRAY);
	if (dir) {
		// create preinit module function list
		uint64_t address = dir->value();
		if (file->AddressSeek(address)) {
			dir = file->command_list()->GetCommandByType(DT_PREINIT_ARRAYSZ);
			if (dir) {
				index = count();
				AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
				for (j = 0; j < static_cast<size_t>(dir->value()); j += OperandSizeToValue(cpu_address_size())) {
					command = Add(address + j);
					command->ReadValueFromFile(*file, cpu_address_size());
				}
				preinit_entry_ = item(index);
				preinit_entry_->include_option(roCreateNewBlock);
				preinit_entry_->set_alignment(OperandSizeToValue(cpu_address_size()));
				preinit_entry_->AddLink(0, ltGateOffset);
				preinit_size_ = static_cast<uint32_t>((count() - index) * OperandSizeToValue(cpu_address_size()));
			}
		}
	}
	term_entry_ = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size()));
	term_entry_->include_option(roCreateNewBlock);
	term_entry_->AddLink(0, ltGateOffset);

	if (file->file_type() == ET_DYN) {
		init_entry_ = AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size()));
		init_entry_->AddLink(0, ltGateOffset);
	}

	// create watermarks
	AddWatermark(ctx.options.watermark, 2);

	// create segment list for setting WRITABLE flag
	std::vector<ELFSegment *> writable_segment_list;
	segment = file->segment_list()->GetSectionByAddress(loader_data_address);
	if (segment)
		writable_segment_list.push_back(segment);
	for (i = 0; i < file->relocation_list()->count(); i++) {
		ELFRelocation *relocation = file->relocation_list()->item(i);
		if (!relocation->address())
			continue;

		segment = file->segment_list()->GetSectionByAddress(relocation->address());
		if (!segment)
			continue;

		if (std::find(writable_segment_list.begin(), writable_segment_list.end(), segment) == writable_segment_list.end())
			writable_segment_list.push_back(segment);
	}

	std::vector<PackerInfo> packer_info_list;
	ELFFixupList loader_fixup_list;
	bool pack_resources = false;
	IntelCommand *packer_props = NULL;
	if (ctx.options.flags & cpPack) {
		ELFSegment *tls_segment = file->segment_list()->GetSectionByType(PT_TLS);
		if (tls_segment && tls_segment->physical_size()) {
			segment = file->segment_list()->GetSectionByAddress(tls_segment->address());
			if (segment && !segment->excluded_from_packing() && file->AddressSeek(tls_segment->address())) {
				Data data;
				for (i = 0; i < tls_segment->physical_size(); i++) {
					data.PushByte(file->ReadByte());
				}
				tls_entry_ = AddCommand(data);
				tls_entry_->include_option(roCreateNewBlock);
				tls_entry_->set_alignment(static_cast<uint32_t>(tls_segment->alignment()));
			}
		}

		PackerInfo packer_info;
		for (i = 0; i < file->segment_list()->count(); i++) {
			segment = file->segment_list()->item(i);
			if (segment->type() != PT_LOAD || segment->excluded_from_packing())
				continue;

			bool can_be_packed = true;
			if ((segment->memory_type() & (mtWritable | mtShared)) == (mtWritable | mtShared)) {
				can_be_packed = false;
			}

			if (!can_be_packed) {
				//file->Notify(mtWarning, NULL, string_format(language[lsSegmentCanNotBePacked].c_str(), section->name().c_str()));
				continue;
			}

			if (segment->physical_size()) {
				packer_info = PackerInfo(segment, segment->address(), static_cast<size_t>(segment->physical_size()));

				if (segment == file->header_segment()) {
					ELFSegment *interp = file->segment_list()->GetSectionByType(PT_INTERP);
					size_t delta = interp ? static_cast<uint32_t>(interp->address() + interp->size() - segment->address()) : file->max_header_size();
					packer_info.address += delta;
					if (packer_info.size > delta) {
						packer_info.size -= delta;
					} else {
						packer_info.size = 0;
					}
				}

				if (!packer_info.size)
					continue;

				packer_info_list.push_back(packer_info);

				// need add packed section into WRITABLE section list
				if (std::find(writable_segment_list.begin(), writable_segment_list.end(), segment) == writable_segment_list.end())
					writable_segment_list.push_back(segment);
			}
		}

		if ((ctx.options.flags & cpStripFixups) == 0) {
			for (i = 0; i < file->fixup_list()->count(); i++) {
				ELFFixup *fixup = file->fixup_list()->item(i);
				if (fixup->is_deleted())
					continue;

				segment = file->segment_list()->GetSectionByAddress(fixup->address());
				if (!segment || std::find(packer_info_list.begin(), packer_info_list.end(), segment) == packer_info_list.end())
					continue;

				loader_fixup_list.AddObject(fixup->Clone(&loader_fixup_list));
				fixup->set_deleted(true);

				// need add section into WRITABLE section list
				if (std::find(writable_segment_list.begin(), writable_segment_list.end(), segment) == writable_segment_list.end())
					writable_segment_list.push_back(segment);
			}
		}

		// packing sections
		j = 0;
		for (i = 0; i < packer_info_list.size(); i++) {
			j += packer_info_list[i].size;
		}
		file->StartProgress(string_format("%s...", language[lsPacking].c_str()), j);

		Data data;
		Packer packer;

		if (!packer.WriteProps(&data))
			throw std::runtime_error("Packer error");
		packer_props = AddCommand(data);
		packer_props->include_option(roCreateNewBlock);

		for (i = 0; i < packer_info_list.size(); i++) {
			packer_info = packer_info_list[i];
			if (!file->AddressSeek(packer_info.address))
				return false;

			if (!packer.Code(file, packer_info.size, &data))
				throw std::runtime_error("Packer error");

			command = AddCommand(data);
			command->include_option(roCreateNewBlock);
			packer_info_list[i].data = command;
		}

		// remove packed sections from file
		uint32_t physical_offset = 0;
		for (i = 0; i < file->segment_list()->count(); i++) {
			segment = file->segment_list()->item(i);
			if (segment->type() != PT_LOAD)
				continue;

			uint32_t physical_size = segment->physical_size();
			bool is_packed = false;
			std::vector<PackerInfo>::iterator it = std::find(packer_info_list.begin(), packer_info_list.end(), segment);
			if (it != packer_info_list.end()) {
				physical_size = static_cast<uint32_t>(it->address - segment->address());
				is_packed = true;
			}
			if (segment->physical_offset() != physical_offset) {
				size_t delta = static_cast<size_t>(physical_offset - segment->physical_offset());
				for (j = 0; j < file->section_list()->count(); j++) {
					ELFSection *section = file->section_list()->item(j);
					if (section->parent() == segment && section->physical_offset())
						section->set_physical_offset(static_cast<uint32_t>(section->physical_offset() + delta));
				}
			}

			if (physical_size > 0 && segment->physical_offset() != physical_offset) {
				uint8_t *buff = new uint8_t[physical_size];
				file->Seek(segment->physical_offset());
				file->Read(buff, physical_size);
				file->Seek(physical_offset);
				file->Write(buff, physical_size);
				delete [] buff;
			}

			if (segment->physical_offset() != physical_offset) {
				uint64_t delta = (static_cast<uint64_t>(physical_offset) & (segment->alignment() - 1)) - (segment->address() & (segment->alignment() - 1));
				segment->Rebase(delta);
				segment->set_size((static_cast<int64_t>(delta) > 0 && segment->size() < delta) ? 0 : segment->size() - delta);
			}
			segment->set_physical_offset(physical_offset);
			segment->set_physical_size(physical_size);

			if (is_packed) {
				j = physical_offset + physical_size;
				file->Seek(j);
				physical_offset = (uint32_t)AlignValue(j, file->file_alignment());
				for (k = j; k < physical_offset; k++) {
					file->WriteByte(0);
				}
			} else {
				physical_offset += physical_size;
			}
		}
		file->Resize(physical_offset);
	}

	// create packer info for loader
	std::vector<LoaderInfo> loader_info_list;
	index = count();
	if (packer_props) {
		command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
		link = command->AddLink(0, ltOffset, packer_props);
		link->set_sub_value(file->image_base());
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, packer_props->dump_size()));

		for (i = 0; i < packer_info_list.size(); i++) {
			command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
			link = command->AddLink(0, ltOffset, packer_info_list[i].data);
			link->set_sub_value(file->image_base());

			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, packer_info_list[i].address - file->image_base()));
		}
	}
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create file CRC info for loader
	index = count();
	if ((ctx.options.flags | ctx.options.sdk_flags) & cpMemoryProtection) {
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
		for (i = 0; i < 4; i++) {
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
		}
	}
	file_crc_entry_ = (count() == index) ? NULL : item(index);
	if (file_crc_entry_)
		file_crc_entry_->include_option(roCreateNewBlock);
	file_crc_size_ = static_cast<uint32_t>((count() - index) * OperandSizeToValue(osDWord));
	loader_info_list.push_back(LoaderInfo(file_crc_entry_, file_crc_size_));

	file_crc_size_entry_ = file_crc_entry_ ? AddCommand(cmDD, IntelOperand(otValue, osDWord)) : NULL;
	if (file_crc_size_entry_)
		file_crc_size_entry_->include_option(roCreateNewBlock);

	// create header and loader CRC info for loader
	index = count();
	if (((ctx.options.flags | ctx.options.sdk_flags) & cpMemoryProtection) || (ctx.options.flags & cpLoaderCRC)) {
		// calc CRC blocks count
		k = 30;
		if ((ctx.options.flags & cpStripFixups) == 0) {
			std::vector<IFunction *> function_list = ctx.file->function_list()->processor_list();
			function_list.push_back(this);
			for (i = 0; i < runtime_function_list->count(); i++) {
				func = runtime_function_list->item(i);
				if (func->tag() != ftLoader)
					continue;

				if (func->compilation_type() == ctMutation)
					function_list.push_back(func);
			}

			for (i = 0; i < function_list.size(); i++) {
				func = reinterpret_cast<IntelFunction *>(function_list[i]);
				for (j = 0; j < func->count(); j++) {
					command = func->item(j);
					for (size_t c = 0; c < 3; c++) {
						IntelOperand operand = command->operand(c);
						if (operand.type == otNone)
							break;
						if (operand.fixup)
							k++;
					}
				}
			}
		}
		for (i = 0; i < k; i++) {
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
		}
	}
	loader_crc_entry_ = (count() == index) ? NULL : item(index);
	if (loader_crc_entry_)
		loader_crc_entry_->include_option(roCreateNewBlock);
	loader_crc_size_ = static_cast<uint32_t>((count() - index) * OperandSizeToValue(osDWord));
	loader_info_list.push_back(LoaderInfo(loader_crc_entry_, loader_crc_size_));

	loader_crc_size_entry_ = loader_crc_entry_ ? AddCommand(cmDD, IntelOperand(otValue, osDWord)) : NULL;
	if (loader_crc_size_entry_)
		loader_crc_size_entry_->include_option(roCreateNewBlock);
	loader_crc_hash_entry_ = loader_crc_entry_ ? AddCommand(cmDD, IntelOperand(otValue, osDWord)) : NULL;
	if (loader_crc_hash_entry_)
		loader_crc_hash_entry_->include_option(roCreateNewBlock);

	// create section info for loader
	index = count();
	for (i = 0; i < writable_segment_list.size(); i++) {
		segment = writable_segment_list[i];
		if (segment->memory_type() & mtWritable)
			continue;

		size_t page_offset = static_cast<size_t>(segment->address() & (ELF_PAGE_SIZE - 1));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, segment->address() - page_offset - file->image_base()));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, segment->size() + page_offset));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, segment->prot()));
	}
	// add runtime's WRITABLE sections
	for (i = 0; i < runtime->segment_list()->count(); i++) {
		segment = runtime->segment_list()->item(i);
		if ((segment->memory_type() & mtWritable) == 0)
			continue;

		size_t page_offset = static_cast<size_t>(segment->address() & (ELF_PAGE_SIZE - 1));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, segment->address() - page_offset - file->image_base()));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, segment->size() + page_offset));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, segment->prot()));
	}
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create fixup info for loader
	if (loader_fixup_list.count() > 0) {
		Data data;
		loader_fixup_list.WriteToData(data, file->image_base());
		command = AddCommand(data);
	} else {
		command = NULL;
	}
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (command) ? command->dump_size() : 0));

	// create relocation info for loader
	index = count();
	for (std::map<ELFRelocation *, IntelCommand *>::const_iterator it = relocation_info.begin(); it != relocation_info.end(); it++) {
		relocation = it->first;
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, relocation->address() - file->image_base()));
		switch (relocation->type()) {
		case R_386_PC32:
			command = AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, 0));
			link = command->AddLink(0, ltOffset, it->second);
			link->set_sub_value(file->image_base());
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, 1));
			relocation->set_type(R_386_32);
			break;
		default:
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, relocation->addend() - file->image_base()));
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, 0));
			delete relocation;
			break;
		}
	}
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));
	
	// create IAT info for loader
	index = count();
	for (std::map<ELFRelocation *, IntelCommand *>::iterator it = iat_info.begin(); it != iat_info.end(); it++) {
		relocation = it->first;

		command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
		link = command->AddLink(0, ltOffset, it->second);
		link->set_sub_value(file->image_base());

		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, relocation->address() - file->image_base()));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, (relocation->type() == R_386_COPY) ? relocation->symbol()->size() : OperandSizeToValue(cpu_address_size())));
	}
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create import info for loader
	index = count();
	/*
	if (ctx.options.flags & cpImportProtection) {
		for (i = 0, import_index = 0; i < orig_dll_count; i++) {
			import = new_import_list.item(i);
			if (import->count() == 0)
				continue;

			// DLL name
			command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
			link = command->AddLink(0, ltOffset, import_info_list[i].loader_name);
			link->set_sub_value(file->image_base());

			for (j = 0; j < import->count(); j++, import_index++) {
				import_function = import->item(j);
				if (import_function->options() & ioNative)
					continue;

				if (ctx.options.flags & cpResourceProtection) {
					// internal API
					if ((import_function->options() & ioFromRuntime) == 0 && import_function->type() >= atLoadResource && import_function->type() <= atEnumResourceTypesW)
						continue;
				}

				iat_command = intel_import->GetIATCommand(import_function);

				// API name
				if (import_function->is_ordinal()) {
					AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, IMAGE_ORDINAL_FLAG32 | import_function->ordinal()));
				} else {
					command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
					link = command->AddLink(0, ltOffset, import_function_info_list[import_index].loader_name);
					link->set_sub_value(file->image_base());
				}

				// IAT
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, ((iat_command) ? iat_command->address() : import_function->address()) - file->image_base()));

				// decrypt value
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, (iat_command) ? iat_command->operand(1).value : 0));
			}

			// end of DLL
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
		}
	}
	*/
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create internal import info for loader
	index = count();
	/*
	if (ctx.options.flags & cpResourceProtection) {
		for (i = 0; i < orig_dll_count; i++) {
			import = new_import_list.item(i);
			for (j = 0; j < import->count(); j++) {
				import_function = import->item(j);

				if ((import_function->options() & ioFromRuntime) || import_function->type() < atLoadResource || import_function->type() > atEnumResourceTypesW)
					continue;

				iat_command = (intel_import) ? intel_import->GetIATCommand(import_function) : NULL;

				address = runtime->export_list()->GetAddressByType(import_function->type());
				func = reinterpret_cast<IntelFunction*>(file->function_list()->GetFunctionByAddress(address));
				if (func && func->entry())
					address = func->entry()->address();

				// address
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, address - file->image_base()));
				// IAT
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, ((iat_command) ? iat_command->address() : import_function->address()) - file->image_base()));
				// decrypt value
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, (iat_command) ? iat_command->operand(1).value : 0));
			}
		}
	}
	*/
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create memory CRC info for loader
	if (intel_crc) {
		command = intel_crc->table_entry();
		i = static_cast<size_t>(intel_crc->size_entry()->operand(0).value);
	} else {
		command = NULL;
		i = 0;
	}
	loader_info_list.push_back(LoaderInfo(command, i));

	// create delay import info for loader
	index = count();
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// process PT_GNU_RELRO segments
	for (i = file->segment_list()->count(); i > 0; i--) {
		ELFSegment *read_only_segment = file->segment_list()->item(i - 1);
		if (read_only_segment->type() != PT_GNU_RELRO)
			continue;

		for (j = 0; j < writable_segment_list.size(); j++) {
			segment = writable_segment_list[j];
			if (std::max<uint64_t>(segment->address(), read_only_segment->address()) < std::min<uint64_t>(segment->address() + segment->size(), read_only_segment->address() + read_only_segment->size())) {
				if (!relro_entry_) {
					index = count();
					size_t page_offset = static_cast<size_t>(read_only_segment->address() & (ELF_PAGE_SIZE - 1));
					AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, read_only_segment->address() - page_offset - file->image_base()));
					AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, read_only_segment->size() + page_offset));
					AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, PROT_READ));
					relro_entry_ = item(index);
					relro_entry_->include_option(roCreateNewBlock);
				}
				delete read_only_segment;
				break;
			}
		}
	}

	// create strings for loader
	uint32_t string_key = rand32();
	std::map<uint32_t, IntelCommand *> loader_string_list;
	loader_string_list[FACE_FILE_CORRUPTED] = AddCommand(EncryptString((ctx.options.flags & cpMemoryProtection) ? ctx.options.messages[MESSAGE_FILE_CORRUPTED].c_str() : std::string().c_str(), string_key));
	loader_string_list[FACE_DEBUGGER_FOUND] = AddCommand(EncryptString(ctx.options.messages[MESSAGE_DEBUGGER_FOUND].c_str(), string_key));
	loader_string_list[FACE_VIRTUAL_MACHINE_FOUND] = AddCommand(EncryptString(ctx.options.messages[MESSAGE_VIRTUAL_MACHINE_FOUND].c_str(), string_key));
	loader_string_list[FACE_PROC_NOT_FOUND] = AddCommand(EncryptString("The procedure entry point %c could not be located in the module %c", string_key));
	loader_string_list[FACE_ORDINAL_NOT_FOUND] = AddCommand(EncryptString("The ordinal %d could not be located in the module %c", string_key));
	loader_string_list[FACE_INITIALIZATION_ERROR] = AddCommand(EncryptString("Initialization error %d", string_key));
	VMProtectBeginVirtualization("Loader Strings");
	loader_string_list[FACE_UNREGISTERED_VERSION] = AddCommand(EncryptString(
#ifdef DEMO
		true
#else
		(ctx.options.flags & cpUnregisteredVersion) 
#endif
		? VMProtectDecryptStringA("This application is protected with unregistered version of VMProtect.") : "", string_key));
	VMProtectEnd();
	loader_string_list[FACE_MACOSX_FORMAT_VALUE] = AddCommand("%s\n");
	loader_string_list[FACE_GNU_PTRACE] = AddCommand("ptrace");
	for (std::map<uint32_t, IntelCommand *>::const_iterator it = loader_string_list.begin(); it != loader_string_list.end(); it++) {
		it->second->include_option(roCreateNewBlock);
	}

	// append loader
	old_count = count();
	std::vector<IntelCommand*> internal_entry_list;
	for (size_t n = 0; n < 2; n++) {
		for (i = 0; i < runtime_function_list->count(); i++) {
			func = runtime_function_list->item(i);
			if (func->tag() != ftLoader)
				continue;

			if (func->compilation_type() == ctMutation) {
				if (n != 0)
					continue;
			} else {
				if (n != 1)
					continue;
			}

			func->Init(ctx);

			bool is_internal = (func->compilation_type() != ctMutation && func->entry_type() == etNone);
			for (j = 0; j < func->link_list()->count(); j++) {
				src_link = func->link_list()->item(j);
				if (src_link->type() != ltMemSEHBlock)
					continue;

				src_link->from_command()->set_address(0);
			}

			for (j = 0; j < func->count(); j++) {
				src_command = func->item(j);

				dst_command = src_command->Clone(this);
				AddObject(dst_command);
				if (is_internal) {
					if (j == 0)
						internal_entry_list.push_back(dst_command);
					if (dst_command->type() == cmRet)
						dst_command->include_option(roInternal);
				}

				src_link = src_command->link();
				if (src_link) {
					dst_link = src_link->Clone(link_list());
					dst_link->set_from_command(dst_command);
					link_list()->AddObject(dst_link);
				
					if (src_link->parent_command())
						dst_link->set_parent_command(GetCommandByAddress(src_link->parent_command()->address()));
				}

				std::map<uint64_t, ELFImportFunction *>::const_iterator it_import = runtime_info_list.find(dst_command->address());
				if (it_import != runtime_info_list.end()) {
					if (dst_command->type() == cmCall) {
						IntelOperand operand = dst_command->operand(0);
						dst_command->Init(cmMov, IntelOperand(otRegistr, operand.size, regEAX), operand);

						command = new IntelCommand(this, cpu_address_size(), cmCall, IntelOperand(otRegistr, operand.size, regEAX));
						if (dst_command->link())
							dst_command->link()->set_from_command(command);
						AddObject(command);
					}
					k = (dst_command->operand(1).type != otNone) ? 1 : 0;
					dst_link = dst_command->AddLink((int)k, ltOffset);
					if (dst_command->operand(k).type & otRegistr)
						dst_link->set_sub_value(plt_got_address);
					std::map<ELFImportFunction *, IntelCommand *>::iterator it = import_function_info.find(it_import->second);
					if (it != import_function_info.end())
						dst_link->set_to_command(it->second);
				}

				if (dst_command->type() == cmCall && (dst_command->options() & roFar) == 0 && dst_command->operand(0).type == otValue) {
					uint64_t next_address = dst_command->address() + dst_command->original_dump_size();
					CompilerFunction *compiler_function = runtime->compiler_function_list()->GetFunctionByAddress(next_address);
					if (compiler_function && compiler_function->type() == cfBaseRegistr) {
						delete dst_command->link();
						IntelOperand operand;
						operand.decode(compiler_function->value(0));
						dst_command->Init(cmLea, operand, IntelOperand(otMemory | otValue, operand.size, 0, next_address, (cpu_address_size() == osDWord) ? NEED_FIXUP : LARGE_VALUE));
					}
				}
				if (!dst_command->is_data() && (dst_command->options() & roBreaked)) {
					// need add JMP after breaked commands
					IntelCommand *jmp_command = new IntelCommand(this, cpu_address_size(), cmJmp, IntelOperand(otValue, cpu_address_size(), 0, dst_command->next_address()));
					jmp_command->AddLink(0, ltJmp, dst_command->next_address());
					jmp_command->set_address_range(dst_command->address_range());
					jmp_command->CompileToNative();
					AddObject(jmp_command);
				}

				command = dst_command;
				for (k = 0; k < 3; k++) {
					IntelOperand operand = command->operand(k);
					if (operand.type == otNone)
						break;

					if ((operand.type & otValue) == 0)
						continue;

					if ((operand.value & 0xFFFF0000) == 0xFACE0000) {
						switch (static_cast<uint32_t>(operand.value)) {
						case FACE_LOADER_OPTIONS:
							operand.value = 0;
							if (ctx.options.flags & cpMemoryProtection)
								operand.value |= LOADER_OPTION_CHECK_PATCH;
							if (ctx.options.flags & cpCheckDebugger)
								operand.value |= LOADER_OPTION_CHECK_DEBUGGER;
							if (ctx.options.flags & cpCheckVirtualMachine)
								operand.value |= LOADER_OPTION_CHECK_VIRTUAL_MACHINE;
							command->set_operand_value(k, operand.value);
							command->CompileToNative();
							break;
						case FACE_LOADER_DATA:
							command->set_operand_value(k, loader_data_address - file->image_base());
							command->CompileToNative();
							break;
						case FACE_RUNTIME_ENTRY:
							if (runtime->segment_list()->count()) {
								uint64_t runtime_init_address = runtime->export_list()->GetAddressByType(atRuntimeInit);
								if (!runtime_init_address)
									return false;
								command->set_operand_value(k, runtime_init_address - file->image_base());
							} else {
								command->set_operand_value(k, 0);
							}
							command->CompileToNative();
							break;
						case FACE_STRING_DECRYPT_KEY:
							command->set_operand_value(k, string_key);
							command->CompileToNative();
							break;
						case FACE_PACKER_INFO:
						case FACE_FILE_CRC_INFO:
						case FACE_LOADER_CRC_INFO:
						case FACE_SECTION_INFO:
						case FACE_FIXUP_INFO:
						case FACE_RELOCATION_INFO:
						case FACE_IAT_INFO:
						case FACE_IMPORT_INFO:
						case FACE_INTERNAL_IMPORT_INFO:
						case FACE_MEMORY_CRC_INFO:
						case FACE_DELAY_IMPORT_INFO:
							dst_command = loader_info_list[(operand.value & 0xff) >> 1].data;
							if (dst_command) {
								link = command->AddLink((int)k, ltOffset, dst_command);
								link->set_sub_value(file->image_base());
							} else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_PACKER_INFO_SIZE:
						case FACE_SECTION_INFO_SIZE:
						case FACE_FIXUP_INFO_SIZE:
						case FACE_RELOCATION_INFO_SIZE:
						case FACE_IAT_INFO_SIZE:
						case FACE_IMPORT_INFO_SIZE:
						case FACE_INTERNAL_IMPORT_INFO_SIZE:
						case FACE_MEMORY_CRC_INFO_SIZE:
						case FACE_DELAY_IMPORT_INFO_SIZE:
							command->set_operand_value(k, loader_info_list[(operand.value & 0xff) >> 1].size);
							command->CompileToNative();
							break;
						case FACE_LOADER_CRC_INFO_SIZE:
							if (loader_crc_size_entry_) {
								link = command->AddLink((int)k, ltOffset, loader_crc_size_entry_);
								link->set_sub_value(file->image_base());
							} else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_LOADER_CRC_INFO_HASH:
							if (loader_crc_hash_entry_) {
								link = command->AddLink((int)k, ltOffset, loader_crc_hash_entry_);
								link->set_sub_value(file->image_base());
							} else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_FILE_CRC_INFO_SIZE:
							if (file_crc_size_entry_) {
								link = command->AddLink((int)k, ltOffset, file_crc_size_entry_);
								link->set_sub_value(file->image_base());
							} else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_MEMORY_CRC_INFO_HASH:
							command->set_operand_value(k, intel_crc ? intel_crc->hash_entry()->operand(0).value : 0);
							command->CompileToNative();
							break;
						case FACE_CRC_INFO_SALT:
							command->set_operand_value(k, file->function_list()->crc_cryptor()->item(0)->value());
							command->CompileToNative();
							break;
						case FACE_IMAGE_BASE:
							if (command->operand(0).size != cpu_address_size()) {
								IntelOperand first = command->operand(0);
								IntelOperand second = command->operand(1);
								first.size = cpu_address_size();
								second.size = cpu_address_size();
								command->Init(static_cast<IntelCommandType>(command->type()), first, second);
							}
							command->set_operand_value(k, file->image_base());
							command->set_operand_fixup(k, NEED_FIXUP);
							command->CompileToNative();
							break;
						case FACE_FILE_BASE:
							if (command->operand(0).size != cpu_address_size()) {
								IntelOperand first = command->operand(0);
								IntelOperand second = command->operand(1);
								first.size = cpu_address_size();
								second.size = cpu_address_size();
								command->Init(static_cast<IntelCommandType>(command->type()), first, second);
							}
							command->set_operand_value(k, file->image_base());
							command->CompileToNative();
							break;
						case FACE_GNU_RELRO_INFO:
							if (relro_entry_) {
								link = command->AddLink((int)k, ltOffset, relro_entry_);
								link->set_sub_value(file->image_base());
							}
							else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_VAR_IS_PATCH_DETECTED:
						case FACE_VAR_IS_DEBUGGER_DETECTED:
						case FACE_VAR_LOADER_CRC_INFO:
						case FACE_VAR_LOADER_CRC_INFO_SIZE:
						case FACE_VAR_LOADER_CRC_INFO_HASH:
						case FACE_VAR_CPU_HASH:
						case FACE_VAR_CPU_COUNT:
						case FACE_VAR_SESSION_KEY:
						case FACE_VAR_DRIVER_UNLOAD:
						case FACE_VAR_CRC_IMAGE_SIZE:
						case FACE_VAR_LOADER_STATUS:
						case FACE_VAR_SERVER_DATE:
							command->set_operand_value(k, ctx.runtime_var_index[(operand.value & 0xff) >> 4] * OperandSizeToValue(cpu_address_size()));
							command->CompileToNative();
							break;
						case FACE_VAR_IS_PATCH_DETECTED_SALT:
						case FACE_VAR_IS_DEBUGGER_DETECTED_SALT:
						case FACE_VAR_LOADER_CRC_INFO_SALT:
						case FACE_VAR_LOADER_CRC_INFO_SIZE_SALT:
						case FACE_VAR_LOADER_CRC_INFO_HASH_SALT:
						case FACE_VAR_CPU_HASH_SALT:
						case FACE_VAR_CPU_COUNT_SALT:
						case FACE_VAR_DRIVER_UNLOAD_SALT:
						case FACE_VAR_CRC_IMAGE_SIZE_SALT:
						case FACE_VAR_SERVER_DATE_SALT:
							command->set_operand_value(k, ctx.runtime_var_salt[operand.value & 0xff]);
							command->CompileToNative();
							break;
						case FACE_VAR_CPU_COUNT_SALT ^ 1:
							command->set_operand_value(k, ctx.runtime_var_salt[VAR_CPU_COUNT] ^ 1);
							command->CompileToNative();
							break;
						default:
							std::map<uint32_t, IntelCommand *>::const_iterator it = loader_string_list.find(static_cast<uint32_t>(operand.value));
							if (it != loader_string_list.end()) {
								if (command->type() == cmMov) {
									operand = command->operand(0);
									operand.size = cpu_address_size();
									if (operand.type == otRegistr) {
										command->Init(cmLea, operand, IntelOperand(otMemory | otValue, cpu_address_size(), 0, 0, (cpu_address_size() == osDWord) ? NEED_FIXUP : LARGE_VALUE));
									} else {
										command->Init(cmMov, operand, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
									}
								} else {
									command->Init(cmPush, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
								}
								command->AddLink((int)k, ltOffset, it->second); 
							} else {
								throw std::runtime_error(string_format("Unknown loader string: %X", static_cast<uint32_t>(operand.value)));
							}
						}
					}
				}
			}
		}
		if (n == 0) {
			// create native blocks
			for (j = 0; j < count(); j++) {
				item(j)->include_option(roNoProgress);
			}
			CompileToNative(ctx);
			for (j = 0; j < count(); j++) {
				item(j)->exclude_option(roNoProgress);
			}
		}
	}

	for (i = old_count; i < count(); i++) {
		command = item(i);
		dst_link = command->link();

		if (command->type() == cmCall && command->operand(0).type == otValue && command->operand(0).value == command->next_address()) {
			uint64_t base_address = command->next_address();
			IntelCommand *next_command = item(i + 1);
			IntelCommand *next_command2 = item(i + 2);
			if (next_command->type() == cmPop && next_command->operand(0).type == otRegistr &&
				next_command2->type() == cmAdd && next_command2->operand(0).type == otRegistr && next_command2->operand(0).registr == next_command->operand(0).registr) {
				base_address += next_command2->operand(1).value;
			}
			else {
				base_address = 0;
			}
			if (base_address) {
				for (j = i + 1; j < count(); j++) {
					IntelCommand *next_command = item(j);
					if (next_command->type() == cmLea && next_command->operand(1).type == (otMemory | otRegistr | otValue) && (next_command->operand(1).registr == regEBX || next_command->operand(1).registr == regESI)) {
						uint64_t address = base_address + next_command->operand(1).value;
						ICommand *to_command = GetCommandByAddress(address);
						if (to_command) {
							link = next_command->AddLink(1, ltOffset, to_command);
							link->set_sub_value(base_address);
						}
					} else if (next_command->type() == cmMov && next_command->operand(1).type == (otMemory | otRegistr | otValue) && next_command->operand(1).registr == regEDI) {
						uint64_t address = base_address + next_command->operand(1).value;
						for (std::map<ELFRelocation *, IntelCommand *>::const_iterator it = iat_info.begin(); it != iat_info.end(); it++) {
							if (it->first->address() == address) {
								if (it->first->symbol()->bind() == STB_LOCAL) {
									next_command->Init(cmLea, next_command->operand(0), next_command->operand(1));
									link = next_command->AddLink(1, ltGateOffset, it->first->symbol()->value());
									link->set_sub_value(base_address);
								}
								break;
							}
						}
					} else if (command->type() == cmRet) {
						break;
					}
				}
			}
		}

		if (!dst_link) {
			// search references to LoaderAlloc/LoaderFree/FreeImage
			for (k = 0; k < 2; k++) {
				IntelOperand operand = command->operand(k);
				if (operand.type == otNone)
					break;

				if (cpu_address_size() == osDWord) {
					if (!operand.fixup)
						continue;
				} else {
					if (!operand.is_large_value)
						continue;
				}
				if (command->address() + command->original_dump_size() == operand.value)
					continue;

				dst_command = reinterpret_cast<IntelCommand *>(GetCommandByAddress(operand.value));
				if (dst_command && !dst_command->is_data()) {
					dst_link = command->AddLink((int)k, dst_command->block() ? ltOffset : ltGateOffset, dst_command);
					break;
				}
			}
		} else {
			if (dst_link->to_address())
				dst_link->set_to_command(GetCommandByAddress(dst_link->to_address()));
		}
	}
	setup_image_entry = GetCommandByAddress(runtime->export_list()->GetAddressByType(atSetupImage));
	if (!setup_image_entry)
		return false;

	free_image_entry = GetCommandByAddress(runtime->export_list()->GetAddressByType(atFreeImage));
	if (!free_image_entry)
		return false;

	// create entry command
	for (i = 0; i < 2; i++) {
		uint64_t jmp_address;
		if (i == 0)
			jmp_address = file->entry_point();
		 else {
			if (file->file_type() == ET_EXEC)
				continue;

			ELFDirectory *dir = file->command_list()->GetCommandByType(DT_INIT);
			jmp_address = dir ? dir->value() : 0;
		}

		old_count = count();
		AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEBP));
		AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEDX));
		AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEBP), IntelOperand(otRegistr, cpu_address_size(), regESP));
		AddCommand(cmAnd, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, -0x10));

		// call SetupImage
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, setup_image_entry);

		// check loader error code
		AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, TRUE));
		IntelCommand *check_loader_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
		check_loader_command->set_flags(fl_Z);
		check_loader_command->AddLink(0, ltJmpWithFlag);

		// call FreeImage
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, free_image_entry);

		command = AddCommand(cmNop);
		check_loader_command->link()->set_to_command(command);

		AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otRegistr, cpu_address_size(), regEBP));
		AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEDX));
		AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEBP));

		if (jmp_address) {
			command = AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size(), 0, jmp_address));
			command->AddLink(0, ltJmp, jmp_address);
		} else {
			AddCommand(cmRet);
		}

		if (i == 0)
			set_entry(item(old_count));
		else
			init_entry_->link()->set_to_command(item(old_count));
	}

	// create preinit command
	if (preinit_entry_) {
		old_count = count();
		AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEBP));
		AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEBP), IntelOperand(otRegistr, cpu_address_size(), regESP));
		AddCommand(cmAnd, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, -0x10));

		// call SetupImage
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, setup_image_entry);

		// check loader error code
		AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, TRUE));
		IntelCommand *check_loader_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
		check_loader_command->set_flags(fl_Z);
		check_loader_command->AddLink(0, ltJmpWithFlag);

		// call FreeImage
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, free_image_entry);

		command = AddCommand(cmNop);
		check_loader_command->link()->set_to_command(command);

		AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otRegistr, cpu_address_size(), regEBP));
		AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEBP));
		AddCommand(cmRet);

		preinit_entry_->link()->set_to_command(item(old_count));
	}

	// create term command
	if (term_entry_) {
		old_count = count();
		AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEBP));
		AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEBP), IntelOperand(otRegistr, cpu_address_size(), regESP));
		AddCommand(cmAnd, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, -0x10));

		ELFDirectory *fini = file->command_list()->GetCommandByType(DT_FINI);
		if (fini) {
			command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size(), 0, fini->value()));
			command->AddLink(0, ltCall, fini->value());
		}

		// call FreeImage
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, free_image_entry);

		AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otRegistr, cpu_address_size(), regEBP));
		AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEBP));
		AddCommand(cmRet);

		term_entry_->link()->set_to_command(item(old_count));
	}

	for (i = 0; i < count(); i++) {
		command = item(i);
		command->CompileToNative();
	}

	for (i = 0; i < link_list()->count(); i++) {
		CommandLink *link = link_list()->item(i);
		if (link->from_command()->type() == cmCall && std::find(internal_entry_list.begin(), internal_entry_list.end(), link->to_command()) != internal_entry_list.end())
			reinterpret_cast<IntelCommand*>(link->from_command())->include_option(roInternal);
		link->from_command()->PrepareLink(ctx);
	}

	return BaseIntelLoader::Prepare(ctx);
}

bool ELFIntelLoader::Compile(const CompileContext &ctx)
{
	if (!BaseIntelLoader::Compile(ctx))
		return false;

	return true;
}

/**
 * IntelVirtualMachine
 */

IntelVirtualMachine::IntelVirtualMachine(IntelVirtualMachineList *owner, VirtualMachineType type, uint8_t id, IntelVirtualMachineProcessor *processor)
	: BaseVirtualMachine(owner, id), type_(type), processor_(processor), entry_command_(NULL), init_command_(NULL), ext_jmp_command_(NULL), command_cryptor_(NULL),
		stack_registr_(0), pcode_registr_(0), jmp_registr_(0), crypt_registr_(0)
{
	backward_direction_ = (rand() & 1) == 0;
}

IntelVirtualMachine::~IntelVirtualMachine()
{
	delete ext_jmp_command_;
	delete command_cryptor_;
	for (size_t i = 0; i < cryptor_list_.size(); i++) {
		delete cryptor_list_[i];
	}
}

void IntelVirtualMachine::Init(const CompileContext &ctx, const IntelOpcodeList &visible_opcode_list)
{
	InitCommands(ctx, visible_opcode_list);

	opcode_stack_.clear();
	for (size_t i = 0; i < opcode_list_.count(); i++) {
		IntelOpcodeInfo *item = opcode_list_.item(i);
		opcode_stack_[item->Key()].push_back(item);
	}
}

void IntelVirtualMachine::Prepare(const CompileContext &ctx)
{
	size_t i;
	std::vector<IntelVirtualMachine *> virtual_machine_list;
	OperandSize cpu_address_size = processor_->cpu_address_size();
	for (i = 0; i < ctx.file->virtual_machine_list()->count(); i++) {
		IntelVirtualMachine *virtual_machine = reinterpret_cast<IntelVirtualMachineList *>(ctx.file->virtual_machine_list())->item(i);
		if (virtual_machine->processor()->cpu_address_size() == cpu_address_size)
			virtual_machine_list.push_back(virtual_machine);
	}

	// setup VMs cross references
	for (i = 0; i < vm_links_.size(); i++) {
		IntelVirtualMachine *virtual_machine = virtual_machine_list[i];

		IntelCommand *command = vm_links_[i];
		command->link()->set_to_command(virtual_machine->init_command());

		size_t j = processor_->IndexOf(command);
		uint8_t stack_registr = stack_registr_;
		uint8_t pcode_registr = processor_->item(j - 2)->operand(0).registr;
		if (virtual_machine->pcode_registr_ != pcode_registr) {
			if (virtual_machine->pcode_registr_ == stack_registr_) {
				command = new IntelCommand(processor_, cpu_address_size, cmXchg, IntelOperand(otRegistr, cpu_address_size, virtual_machine->pcode_registr_), IntelOperand(otRegistr, cpu_address_size, pcode_registr));
				stack_registr = pcode_registr;
			} else 
				command = new IntelCommand(processor_, cpu_address_size, cmMov, IntelOperand(otRegistr, cpu_address_size, virtual_machine->pcode_registr_), IntelOperand(otRegistr, cpu_address_size, pcode_registr));
			command->CompileToNative();
			processor_->InsertObject(j++, command);
		}
		if (virtual_machine->stack_registr_ != stack_registr) {
			command = new IntelCommand(processor_, cpu_address_size, cmMov, IntelOperand(otRegistr, cpu_address_size, virtual_machine->stack_registr_), IntelOperand(otRegistr, cpu_address_size, stack_registr));
			command->CompileToNative();
			processor_->InsertObject(j, command);
		}
	}
}

IntelCommand *IntelVirtualMachine::AddReadCommand(OperandSize size, OpcodeCryptor *command_cryptor, uint8_t registr)
{
	size_t c = processor_->count();
	OperandSize mov_size = (size < osDWord) ? osDWord : size;
	if (backward_direction_) {
		processor_->AddCommand(cmSub, IntelOperand(otRegistr, processor_->cpu_address_size(), pcode_registr_), IntelOperand(otValue, processor_->cpu_address_size(), 0, OperandSizeToValue(size)));
		processor_->AddCommand((mov_size == size) ? cmMov : cmMovzx, IntelOperand(otRegistr, mov_size, registr), IntelOperand(otMemory | otRegistr, size, pcode_registr_));
	}
	else {
		processor_->AddCommand((mov_size == size) ? cmMov : cmMovzx, IntelOperand(otRegistr, mov_size, registr), IntelOperand(otMemory | otRegistr, size, pcode_registr_));
		processor_->AddCommand(cmAdd, IntelOperand(otRegistr, processor_->cpu_address_size(), pcode_registr_), IntelOperand(otValue, processor_->cpu_address_size(), 0, OperandSizeToValue(size)));
	}

	if (command_cryptor) {
		IntelCommandType command_type = CryptorCommandToIntel(command_cryptor->type());
		OperandSize size = command_cryptor->size();

		processor_->AddCommand(command_type, IntelOperand(otRegistr, size, registr), IntelOperand(otRegistr, size, crypt_registr_));
		for (size_t i = 0; i < command_cryptor->count(); i++) {
			AddValueCommand(*command_cryptor->item(i), false, registr);
		}
		if (processor_->cpu_address_size() == osQWord && size == osDWord) {
			processor_->AddCommand(cmPush, IntelOperand(otRegistr, osQWord, crypt_registr_));
			processor_->AddCommand(command_type, IntelOperand(otMemory | otRegistr, size, regESP), IntelOperand(otRegistr, size, registr));
			processor_->AddCommand(cmPop, IntelOperand(otRegistr, osQWord, crypt_registr_));
		}
		else {
			processor_->AddCommand(command_type, IntelOperand(otRegistr, size, crypt_registr_), IntelOperand(otRegistr, size, registr));
		}
	}

	return processor_->item(c);
}

void IntelVirtualMachine::AddValueCommand(ValueCommand &value_command, bool is_decrypt, uint8_t registr)
{
	IntelCommandType command_type = CryptorCommandToIntel(value_command.type(is_decrypt));
	IntelOperand second_operand;
	if (command_type == cmAdd || command_type == cmSub || command_type == cmXor || command_type == cmRol || command_type == cmRor)
		second_operand = IntelOperand(otValue, (command_type == cmRol || command_type == cmRor) ? osByte : value_command.size(), 0, value_command.value());
	processor_->AddCommand(command_type, IntelOperand(otRegistr, value_command.size(), registr), second_operand);
}

void IntelVirtualMachine::AddEndHandlerCommands(IntelCommand *to_command, OpcodeCryptor *command_cryptor)
{
	IntelCommand *command;
	if (type_ == vtAdvanced) {
		IntelRegistrList registr_list = free_registr_list_;
		uint8_t reg1 = registr_list.GetRandom();
		AddReadCommand(osDWord, command_cryptor, reg1);
		if (processor_->cpu_address_size() == osQWord)
			processor_->AddCommand(cmMovsxd, IntelOperand(otRegistr, processor_->cpu_address_size(), reg1), IntelOperand(otRegistr, osDWord, reg1));
		processor_->AddCommand(cmAdd, IntelOperand(otRegistr, processor_->cpu_address_size(), jmp_registr_), IntelOperand(otRegistr, processor_->cpu_address_size(), reg1));
		if (to_command) {
			command = processor_->AddCommand(cmJmp, IntelOperand(otValue, processor_->cpu_address_size()));
			command->AddLink(0, ltJmp, to_command);
		}
		else {
			command = processor_->AddCommand(cmJmp, IntelOperand(otRegistr, processor_->cpu_address_size(), jmp_registr_));
			command->AddLink(-1, ltJmp);
		}
	}
	else {
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, processor_->cpu_address_size()));
		command->AddLink(0, ltJmp, to_command);
	}
}

IntelCommand *IntelVirtualMachine::CloneHandler(IntelCommand *handler)
{
	size_t i, c, j;
	std::map<ICommand *, ICommand *> command_map;

	c = processor_->count();
	j = processor_->IndexOf(handler);
	for (i = j; i < c; i++) {
		IntelCommand *src_command = processor_->item(i);
		IntelCommand *dst_command = src_command->Clone(processor_);
		processor_->AddObject(dst_command);

		command_map[src_command] = dst_command;

		CommandLink *src_link = src_command->link();
		if (src_link) {
			CommandLink *dst_link = src_link->Clone(processor_->link_list());
			dst_link->set_from_command(dst_command);
			dst_link->set_to_command(src_link->to_command());
			processor_->link_list()->AddObject(dst_link);
		}

		if (src_command->type() == cmJmp && src_link && src_link->to_command()) {
			if (j > processor_->IndexOf(src_link->to_command()))
				break;
		}
		else if (src_command->is_end())
			break;
	}

	for (i = c; i < processor_->count(); i++) {
		IntelCommand *command = processor_->item(i);
		CommandLink *link = command->link();
		if (!link || !link->to_command())
			continue;

		std::map<ICommand *, ICommand *>::const_iterator it = command_map.find(link->to_command());
		if (it != command_map.end())
			link->set_to_command(it->second);
	}

	return processor_->item(c);
}

void IntelVirtualMachine::AddCallCommands(CallingConvention calling_convention, IntelCommand *call_entry, uint8_t registr)
{
	std::vector<uint8_t> registr_list;
	IntelCommand *command;
	size_t i;

	OperandSize cpu_address_size = processor_->cpu_address_size();
	OperandSize arg_address_size = (calling_convention == ccStdcallToMSx64) ? osDWord : processor_->cpu_address_size();

	switch (calling_convention) { //-V719
	case ccMSx64:
	case ccStdcallToMSx64:
		registr_list.push_back(regECX);
		registr_list.push_back(regEDX);
		registr_list.push_back(regR8);
		registr_list.push_back(regR9);
		break;
	case ccABIx64:
		registr_list.push_back(regEDI);
		registr_list.push_back(regESI);
		registr_list.push_back(regEDX);
		registr_list.push_back(regECX);
		registr_list.push_back(regR8);
		registr_list.push_back(regR9);
		break;
	}

	// push common registers
	processor_->AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, pcode_registr_));
	if (jmp_registr_)
		processor_->AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, jmp_registr_));
	if (crypt_registr_)
		processor_->AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, crypt_registr_));
	if (stack_registr_ != regEBP)
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regEBP), IntelOperand(otRegistr, cpu_address_size, stack_registr_));

	if (registr != regEBX)
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regEBX), IntelOperand(otRegistr, osDWord, registr));
	processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regEDX), IntelOperand(otRegistr, osDWord, regEBX));
	if (!registr_list.empty()) {
		processor_->AddCommand(cmXor, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regECX));
		processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regEBX), IntelOperand(otValue, osDWord, 0, registr_list.size()));
		IntelCommand *jmp_no_stack_args = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_no_stack_args->set_flags(fl_C | fl_Z);
		jmp_no_stack_args->AddLink(0, ltJmpWithFlag);
		if (calling_convention != ccStdcallToMSx64)
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regEDX), IntelOperand(otValue, osDWord, 0, registr_list.size()));
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otRegistr | otValue, osDWord, regEBX, 0 - registr_list.size()));
		command = processor_->AddCommand(cmShl, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otValue, osByte, 0, cpu_address_size == osDWord ? 2 : 3));
		jmp_no_stack_args->link()->set_to_command(command);
	}
	processor_->AddCommand(cmShl, IntelOperand(otRegistr, osDWord, regEDX), IntelOperand(otValue, osByte, 0, arg_address_size == osDWord ? 2 : 3));
	if (calling_convention != ccCdecl) {
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regEAX), IntelOperand(otRegistr, cpu_address_size, regEBP));
		processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, regEAX), IntelOperand(otRegistr, cpu_address_size, regEDX));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, cpu_address_size, regEAX));
	}
	if (calling_convention != ccStdcall) {
		// align stack
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 2), IntelOperand(otRegistr, cpu_address_size, regESP));
		processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otRegistr, cpu_address_size, registr_list.empty() ? regEDX : regECX));
		processor_->AddCommand(cmAnd, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otValue, cpu_address_size, 0, -16));
		processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otRegistr, cpu_address_size, registr_list.empty() ? regEDX : regECX));
	} else if (call_entry)
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 2), IntelOperand(otRegistr, cpu_address_size, regESP));

	processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regEBX), IntelOperand(otRegistr, osDWord, regEBX));
	IntelCommand *jmp_end_store = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
	jmp_end_store->set_flags(fl_Z);
	jmp_end_store->AddLink(0, ltJmpWithFlag);

	IntelCommand *load_arg = processor_->AddCommand(cmMov, IntelOperand(otRegistr, arg_address_size, regEAX), IntelOperand(otMemory | otBaseRegistr | otRegistr | otValue, arg_address_size, (regEBP << 4) | regEBX));
	load_arg->set_operand_scale(1, arg_address_size == osDWord ? 2 : 3);

	std::vector<IntelCommand *> jmp_loop_arg;
	IntelCommand *jmp_arg_command = NULL;
	if (!registr_list.empty()) {
		// store arg in register
		for (i = 0; i < registr_list.size(); i++) {
			command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regEBX), IntelOperand(otValue, osDWord, 0, i + 1));
			if (jmp_arg_command)
				jmp_arg_command->link()->set_to_command(command);

			jmp_arg_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
			jmp_arg_command->set_flags(fl_Z);
			jmp_arg_command->include_option(roInverseFlag);
			jmp_arg_command->AddLink(0, ltJmpWithFlag);

			processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, registr_list[i]), IntelOperand(otRegistr, cpu_address_size, regEAX));
			command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
			command->AddLink(0, ltJmp);
			jmp_loop_arg.push_back(command);
		}
	}

	// store arg in stack
	if (calling_convention == ccMSx64) {
		command = processor_->AddCommand(cmPush, IntelOperand(otMemory | otBaseRegistr | otRegistr | otValue, cpu_address_size, (regEBP << 4) | regEBX, 0x20));
		command->set_operand_scale(0, 3);
	} else
		command = processor_->AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, regEAX));
	if (jmp_arg_command)
		jmp_arg_command->link()->set_to_command(command);

	// loop arg
	command = processor_->AddCommand(cmSub, IntelOperand(otRegistr, osDWord, regEBX), IntelOperand(otValue, osDWord, 0, 1));
	for (i = 0; i < jmp_loop_arg.size(); i++) {
		jmp_loop_arg[i]->link()->set_to_command(command);
	}
	command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
	command->set_flags(fl_Z);
	command->include_option(roInverseFlag);
	command->AddLink(0, ltJmpWithFlag, load_arg);

	// end store
	command = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regEAX), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0));
	jmp_end_store->link()->set_to_command(command);

	if (calling_convention == ccStdcallToMSx64) {
		// convert input args
		std::vector<IntelCommand *> jmp_end_convert;
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otRegistr, osDWord, regEAX));
		processor_->AddCommand(cmShr, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otValue, osByte, 0, 24));
		IntelCommand *jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		jmp_end_convert.push_back(jmp_command);

		// NtProtectVirtualMemory
		processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 1));
		IntelCommand *cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otValue, osDWord, 0, (uint32_t)-1)); // NtCurrentProcess
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->include_option(roInverseFlag);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmMovsxd, IntelOperand(otRegistr, osQWord, regECX), IntelOperand(otRegistr, osDWord, regECX));

		command = processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regEDX), IntelOperand(otRegistr, osDWord, regEDX));
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 3));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regEDX), IntelOperand(otMemory | otRegistr, osDWord, regEDX));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, cpu_address_size, regR10), IntelOperand(otRegistr, cpu_address_size, regEDX));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regEDX), IntelOperand(otRegistr, cpu_address_size, regR10));

		command = processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regR8), IntelOperand(otRegistr, osDWord, regR8));
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 4));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR8), IntelOperand(otMemory | otRegistr, osDWord, regR8));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, cpu_address_size, regR10), IntelOperand(otRegistr, cpu_address_size, regR8));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regR8), IntelOperand(otRegistr, cpu_address_size, regR10));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		// NtSetInformationThread
		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 2));
		cmp_command->link()->set_to_command(command);
		cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otValue, osDWord, 0, (uint32_t)-2)); // NtCurrentThread
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->include_option(roInverseFlag);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmMovsxd, IntelOperand(otRegistr, osQWord, regECX), IntelOperand(otRegistr, osDWord, regECX));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		// NtQueryInformationProcess
		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 3));
		cmp_command->link()->set_to_command(command);
		cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otValue, osDWord, 0, (uint32_t)-1)); // NtCurrentProcess
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->include_option(roInverseFlag);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmMovsxd, IntelOperand(otRegistr, osQWord, regECX), IntelOperand(otRegistr, osDWord, regECX));

		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regEDX), IntelOperand(otValue, osDWord, 0, 0x7)); // ProcessDebugPort
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->include_option(roInverseFlag);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 3));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regR8), IntelOperand(otRegistr, cpu_address_size, regR10));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR9), IntelOperand(otValue, osDWord, 0, OperandSizeToValue(cpu_address_size)));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regEDX), IntelOperand(otValue, osDWord, 0, 0x1e)); // ProcessDebugObjectHandle
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->include_option(roInverseFlag);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 3));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regR8), IntelOperand(otRegistr, cpu_address_size, regR10));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR9), IntelOperand(otValue, osDWord, 0, OperandSizeToValue(cpu_address_size)));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		// NtMapViewOfSection
		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 4));
		cmp_command->link()->set_to_command(command);
		cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regEDX), IntelOperand(otValue, osDWord, 0, (uint32_t)-1)); // NtCurrentProcess
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->include_option(roInverseFlag);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmMovsxd, IntelOperand(otRegistr, osQWord, regEDX), IntelOperand(otRegistr, osDWord, regEDX));

		command = processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regR8), IntelOperand(otRegistr, osDWord, regR8));
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 3));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR8), IntelOperand(otMemory | otRegistr, osDWord, regR8));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, cpu_address_size, regR10), IntelOperand(otRegistr, cpu_address_size, regR8));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regR8), IntelOperand(otRegistr, cpu_address_size, regR10));

		command = processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, OperandSizeToValue(cpu_address_size) * 2));
		processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otRegistr, osDWord, regR11));
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 4));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otMemory | otRegistr, osDWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, cpu_address_size, regR10), IntelOperand(otRegistr, cpu_address_size, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, OperandSizeToValue(cpu_address_size) * 2), IntelOperand(otRegistr, cpu_address_size, regR10));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		// NtUnmapViewOfSection
		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 5));
		cmp_command->link()->set_to_command(command);
		cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otValue, osDWord, 0, (uint32_t)-1)); // NtCurrentProcess
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->include_option(roInverseFlag);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmMovsxd, IntelOperand(otRegistr, osQWord, regECX), IntelOperand(otRegistr, osDWord, regECX));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		// NtOpenFile
		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 6));
		cmp_command->link()->set_to_command(command);
		cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		command = processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regECX));
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 3));

		command = processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regR9), IntelOperand(otRegistr, osDWord, regR9));
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regR9), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 5));

		command = processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regR8), IntelOperand(otRegistr, osDWord, regR8));
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 10));
		processor_->AddCommand(cmAnd, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otValue, cpu_address_size, 0, (uint64_t)-16));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otValue, osDWord, 0, 0x30));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osQWord, regR10), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmXor, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otRegistr, osDWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR10, 0x08), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR10, 0x10), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR10, 0x20), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR10, 0x28), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otMemory | otRegistr | otValue, osDWord, regR8, 0x0c));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR10, 0x18), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otMemory | otRegistr | otValue, osDWord, regR8, 0x08));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regR8), IntelOperand(otRegistr, cpu_address_size, regR10));

		processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otRegistr, osDWord, regR11));
		IntelCommand *jmp_command2 = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command2->set_flags(fl_Z);
		jmp_command2->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otRegistr, osDWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR8, 0 - OperandSizeToValue(cpu_address_size) * 2), IntelOperand(otRegistr, osQWord, regR10));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otRegistr | otValue, osDWord, regR11, 4));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR8, 0 - OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, osQWord, regR10));
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regR8, 0 - OperandSizeToValue(cpu_address_size) * 2));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR8, 0x10), IntelOperand(otRegistr, osQWord, regR10));

		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		jmp_command2->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		// NtCreateSection
		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 7));
		cmp_command->link()->set_to_command(command);
		cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		command = processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regECX));
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 3));

		command = processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regR8), IntelOperand(otRegistr, osDWord, regR8));
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 8));
		processor_->AddCommand(cmAnd, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otValue, cpu_address_size, 0, (uint64_t)-16));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otValue, osDWord, 0, 0x30));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osQWord, regR10), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmXor, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otRegistr, osDWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR10, 0x08), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR10, 0x10), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR10, 0x20), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR10, 0x28), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otMemory | otRegistr | otValue, osDWord, regR8, 0x0c));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR10, 0x18), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otMemory | otRegistr | otValue, osDWord, regR8, 0x08));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regR8), IntelOperand(otRegistr, cpu_address_size, regR10));

		processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otRegistr, osDWord, regR11));
		jmp_command2 = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command2->set_flags(fl_Z);
		jmp_command2->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otRegistr, osDWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR8, 0 - OperandSizeToValue(cpu_address_size) * 2), IntelOperand(otRegistr, osQWord, regR10));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otRegistr | otValue, osDWord, regR11, 4));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR8, 0 - OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, osQWord, regR10));
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regR8, 0 - OperandSizeToValue(cpu_address_size) * 2));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR8, 0x10), IntelOperand(otRegistr, osQWord, regR10));

		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		jmp_command2->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		// NtQueryVirtualMemory
		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 8));
		cmp_command->link()->set_to_command(command);
		cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otValue, osDWord, 0, (uint32_t)-1)); // NtCurrentProcess
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->include_option(roInverseFlag);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmMovsxd, IntelOperand(otRegistr, osQWord, regECX), IntelOperand(otRegistr, osDWord, regECX));

		command = processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regR9), IntelOperand(otRegistr, osDWord, regR9));
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 8));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regR9), IntelOperand(otRegistr, cpu_address_size, regR10));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osDWord, regESP), IntelOperand(otValue, osDWord, 0, 0x30));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		command = processor_->AddCommand(cmAnd, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, WOW64_FLAG - 1));
		cmp_command->link()->set_to_command(command);
		for (i = 0; i < jmp_end_convert.size(); i++) {
			jmp_end_convert[i]->link()->set_to_command(command);
		}
	}

	if (calling_convention == ccMSx64 || calling_convention == ccStdcallToMSx64)
		processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otValue, cpu_address_size, 0, 0x20));
	if (call_entry) {
		command = processor_->AddCommand(cmCall, IntelOperand(otValue, cpu_address_size));
		command->AddLink(0, ltCall, call_entry);
	} else
		processor_->AddCommand(cmCall, IntelOperand(otRegistr, cpu_address_size, regEAX));

	if (calling_convention == ccStdcallToMSx64) {
		// convert output args
		std::vector<IntelCommand *> jmp_end_convert;
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, osDWord, regEBP << 4, 0));
		processor_->AddCommand(cmShr, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otValue, osByte, 0, 24));
		IntelCommand *jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		jmp_end_convert.push_back(jmp_command);

		// NtProtectVirtualMemory
		processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 1));
		IntelCommand *cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size) * 2));
		processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regECX));
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, osDWord, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 3));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regR10));

		command = processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size) * 3));
		jmp_command->link()->set_to_command(command);
		processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regECX));
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, osDWord, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 4));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regR10));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		// NtQueryInformationProcess
		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 3));
		cmp_command->link()->set_to_command(command);
		cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		command = processor_->AddCommand(cmCmp, IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size) * 2), IntelOperand(otValue, osDWord, 0, 0x7));  // ProcessDebugPort
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->include_option(roInverseFlag);
		jmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size) * 3));
		processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size) * 5));
		IntelCommand *jmp_command2 = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command2->set_flags(fl_Z);
		jmp_command2->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, osDWord, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 3));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regR10));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command2->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		command = processor_->AddCommand(cmCmp, IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size) * 2), IntelOperand(otValue, osDWord, 0, 0x1e));  // ProcessDebugObjectHandle
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->include_option(roInverseFlag);
		jmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size) * 3));
		processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size) * 5));
		jmp_command2 = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command2->set_flags(fl_Z);
		jmp_command2->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, osDWord, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 3));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regR10));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		jmp_command2->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		// NtMapViewOfSection
		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 4));
		cmp_command->link()->set_to_command(command);
		cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size) * 3));
		processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regECX));
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, osDWord, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 3));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regR10));

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size) * 7));
		jmp_command->link()->set_to_command(command);
		processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regECX));
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, osDWord, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 4));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regR10));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		// NtOpenFile
		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 6));
		cmp_command->link()->set_to_command(command);
		cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size)));
		processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regECX));
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, osDWord, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 3));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regR10));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		// NtCreateSection
		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 7));
		cmp_command->link()->set_to_command(command);
		cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size)));
		processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regECX));
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, osDWord, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 3));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regR10));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		// NtQueryVirtualMemory
		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 8));
		cmp_command->link()->set_to_command(command);
		cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size) * 4));
		processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regECX));
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, osDWord, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 8));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otMemory | otRegistr, osDWord, regR10));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otMemory | otRegistr | otValue, osDWord, regR10, OperandSizeToValue(cpu_address_size)));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osDWord, regECX, OperandSizeToValue(arg_address_size)), IntelOperand(otRegistr, osDWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otMemory | otRegistr | otValue, osDWord, regR10, OperandSizeToValue(cpu_address_size) * 2));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osDWord, regECX, OperandSizeToValue(arg_address_size) * 2), IntelOperand(otRegistr, osDWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otMemory | otRegistr | otValue, osDWord, regR10, OperandSizeToValue(cpu_address_size) * 3));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osDWord, regECX, OperandSizeToValue(arg_address_size) * 3), IntelOperand(otRegistr, osDWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osQWord, regR11), IntelOperand(otMemory | otRegistr | otValue, osQWord, regR10, OperandSizeToValue(cpu_address_size) * 4));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regECX, OperandSizeToValue(arg_address_size) * 4), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otMemory | otRegistr | otValue, osDWord, regR10, OperandSizeToValue(cpu_address_size) * 5));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osDWord, regECX, OperandSizeToValue(arg_address_size) * 6), IntelOperand(otRegistr, osDWord, regR11));

		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		command = processor_->AddCommand(cmNop);
		cmp_command->link()->set_to_command(command);
		for (i = 0; i < jmp_end_convert.size(); i++) {
			jmp_end_convert[i]->link()->set_to_command(command);
		}
	}

	// correct stack
	if (calling_convention != ccStdcall)
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 2));
	else if (call_entry)
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 2));
	if (calling_convention != ccCdecl)
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regEBP), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size)));

	// save result
	processor_->AddCommand(cmMov, IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, 0), IntelOperand(otRegistr, arg_address_size, regEAX));

	// pop common registers
	if (stack_registr_ != regEBP)
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otRegistr, cpu_address_size, regEBP));
	if (crypt_registr_)
		processor_->AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size, crypt_registr_));
	if (jmp_registr_)
		processor_->AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size, jmp_registr_));
	processor_->AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size, pcode_registr_));
}

bool IntelVirtualMachine::IsRegistrUsed(uint8_t registr)
{
	return (registr == stack_registr_ || registr == pcode_registr_ || (jmp_registr_ && registr == jmp_registr_) || (crypt_registr_ && registr == crypt_registr_));
}

void IntelVirtualMachine::InitCommands(const CompileContext &ctx, const IntelOpcodeList &visible_opcode_list)
{
	IntelCommand *command, *read_opcode, *check_stack, *opcode_entry, *switch_entry, *jmp_command;
	uint8_t seg, s, reg1, reg2, reg3, reg4;
	OperandSize size, mov_size;
	size_t i, operand_size, result_size, j, c;
	IntelCommandType command_type;
	OpcodeCryptor *value_cryptor, *registr_cryptor, *end_cryptor;
	IntelOpcodeInfo *opcode;
	OperandSize cpu_address_size = processor_->cpu_address_size();
	IntelFunctionList *function_list = reinterpret_cast<IntelFunctionList *>(processor_->owner());

	IntelRegistrList wrong_registr_list;
	switch (ctx.file->calling_convention()) {
	case ccMSx64:
	case ccABIx64:
		wrong_registr_list.push_back(regR12);
		wrong_registr_list.push_back(regR13);
		wrong_registr_list.push_back(regR14);
		wrong_registr_list.push_back(regR15);
		break;
	}

	// init registers
	if 
#ifdef DEMO
		(true)
#else
		(ctx.options.flags & cpUnregisteredVersion)
#endif	
	{
		crypt_registr_ = (ctx.options.flags & cpEncryptBytecode) ? regEBX : 0;
		pcode_registr_ = regESI;
		stack_registr_ = regEBP;
		if (type_ == vtAdvanced)
			jmp_registr_ = regEDI;
		else if (cpu_address_size == osQWord)
			jmp_registr_ = regR11;
		else
			jmp_registr_ = 0;
	}
	else {
		IntelRegistrList work_registr_list;
		work_registr_list.push_back(regEBX);
		work_registr_list.push_back(regEBP);
		work_registr_list.push_back(regESI);
		work_registr_list.push_back(regEDI);
		if (cpu_address_size == osQWord) {
			for (i = 8; i < 16; i++) {
				work_registr_list.push_back((uint8_t)i);
			}
		}
		work_registr_list.remove(wrong_registr_list);

		crypt_registr_ = 0;
		if (ctx.options.flags & cpEncryptBytecode) {
			if (cpu_address_size == osDWord) {
				crypt_registr_ = regEBX;
				work_registr_list.remove(crypt_registr_);
			}
			else
				crypt_registr_ = work_registr_list.GetRandom();
		}
		pcode_registr_ = work_registr_list.GetRandom();
		stack_registr_ = work_registr_list.GetRandom();
		jmp_registr_ = (type_ == vtAdvanced || cpu_address_size == osQWord) ? work_registr_list.GetRandom() : 0;
	}

	free_registr_list_.push_back(regEAX);
	free_registr_list_.push_back(regECX);
	free_registr_list_.push_back(regEDX);
	free_registr_list_.push_back(regEBX);
	free_registr_list_.push_back(regEBP);
	free_registr_list_.push_back(regESI);
	free_registr_list_.push_back(regEDI);
	if (cpu_address_size == osQWord) {
		for (i = 8; i < 16; i++) {
			free_registr_list_.push_back((uint8_t)i);
		}
	}
	free_registr_list_.remove(wrong_registr_list);
	free_registr_list_.remove(pcode_registr_);
	free_registr_list_.remove(stack_registr_);
	if (jmp_registr_)
		free_registr_list_.remove(jmp_registr_);
	if (crypt_registr_)
		free_registr_list_.remove(crypt_registr_);

	// init cryptors
	entry_cryptor_.Init(osDWord);
	if (ctx.options.flags & cpEncryptBytecode) {
		command_cryptor_ = new OpcodeCryptor();
		command_cryptor_->Init((type_ == vtAdvanced) ? osDWord : osByte);
	}
	value_cryptor = NULL;
	registr_cryptor = NULL;
	end_cryptor = NULL;

	// init registr list
	registr_order_.clear();
	registr_order_.push_back(regEFX);
	registr_order_.push_back(regEAX);
	registr_order_.push_back(regECX);
	registr_order_.push_back(regEDX);
	registr_order_.push_back(regEBX);
	registr_order_.push_back(regEBP);
	registr_order_.push_back(regESI);
	registr_order_.push_back(regEDI);
	if (cpu_address_size == osQWord) {
		for (i = 8; i < 16; i++) {
			registr_order_.push_back((uint8_t)i);
		}
	}
	for (i = 0; i < registr_order_.size(); i++) {
		std::swap(registr_order_[i], registr_order_[rand() % registr_order_.size()]);
	}

	// create commands
	c = processor_->count();
	for (i = 0; i < registr_order_.size(); i++) {
		uint8_t reg = registr_order_[i];
		if (reg == regEFX) {
			processor_->AddCommand(cmPushf);
		}
		else {
			processor_->AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, reg));
		}
	}
	entry_command_ = processor_->item(c);
	entry_command_->include_section_option(rtLinkedToInt);

	size_t context_registr_count = (cpu_address_size == osQWord) ? 24 : 16;
	if (ctx.file->runtime_function_list() && ctx.file->runtime_function_list()->count())
		context_registr_count += 8;
	{
		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom();
	}
	if (ctx.file->cpu_address_size() != cpu_address_size && cpu_address_size == osQWord)
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otMemory | otValue, cpu_address_size, 0, 0, LARGE_VALUE));
	else
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otValue, cpu_address_size, 0, 0, NEED_FIXUP));
	processor_->AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, reg1));
	processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, pcode_registr_), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, (registr_order_.size() + 2) * OperandSizeToValue(cpu_address_size)));
	for (i = entry_cryptor_.count(); i > 0; i--) {
		AddValueCommand(*entry_cryptor_.item(i - 1), true, pcode_registr_);
	}
	processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, pcode_registr_), IntelOperand(otRegistr, cpu_address_size, reg1));
	if (cpu_address_size == osQWord) {
		if (ctx.file->image_base() >> 32) {
			IntelRegistrList registr_list = free_registr_list_;
			reg1 = registr_list.GetRandom();
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otValue, cpu_address_size, 0, ctx.file->image_base() & 0xffffffff00000000ull));
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, pcode_registr_), IntelOperand(otRegistr, cpu_address_size, reg1));
		}
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otRegistr, cpu_address_size, regESP));
		processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otValue, cpu_address_size, 0, 128 + context_registr_count * OperandSizeToValue(cpu_address_size)));
		processor_->AddCommand(cmAnd, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otValue, cpu_address_size, 0, -16));
	}
	else {
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otRegistr, cpu_address_size, regESP));
		processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otValue, cpu_address_size, 0, 128 + context_registr_count * OperandSizeToValue(cpu_address_size)));
	}

	c = processor_->count();
	if (crypt_registr_) {
		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom();
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, crypt_registr_), IntelOperand(otRegistr, cpu_address_size, pcode_registr_));
		if (ctx.file->cpu_address_size() != cpu_address_size && cpu_address_size == osQWord)
			processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otMemory | otValue, cpu_address_size, 0, 0, LARGE_VALUE));
		else
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otValue, cpu_address_size, 0, 0, NEED_FIXUP));
		processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, crypt_registr_), IntelOperand(otRegistr, cpu_address_size, reg1));
	}
	if (type_ == vtAdvanced) {
		opcode_entry = processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, jmp_registr_), IntelOperand(otMemory | otValue, cpu_address_size, 0, 0, (cpu_address_size == osDWord) ? NEED_FIXUP : LARGE_VALUE));
		opcode_entry->AddLink(1, ltOffset, opcode_entry);
		AddEndHandlerCommands(NULL, command_cryptor_);
		opcode_list_.Add(cmNop, otNone, cpu_address_size, 0, opcode_entry, NULL, command_cryptor_);
	}
	else if (cpu_address_size == osQWord) {
		command = processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, jmp_registr_), IntelOperand(otMemory | otValue, cpu_address_size, 0, 0, LARGE_VALUE));
		command->AddLink(1, ltOffset);
		switch_entry = command;
	}
	else if (c == processor_->count())
		processor_->AddCommand(cmNop);
	init_command_ = processor_->item(c);

	read_opcode = NULL;
	if (type_ == vtAdvanced) {
		command = processor_->AddCommand(cmJmp, IntelOperand(otRegistr, cpu_address_size, jmp_registr_));
		command->AddLink(-1, ltJmp);
	}
	else {
		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom(cpu_address_size == osDWord);
		read_opcode = AddReadCommand(osByte, command_cryptor_, reg1);
		if (cpu_address_size == osQWord) {
			command = processor_->AddCommand(cmJmp, IntelOperand(otMemory | otBaseRegistr | otRegistr, cpu_address_size, (jmp_registr_ << 4) | reg1, 0));
			command->set_operand_scale(0, 3);
			command->AddLink(-1, ltJmp);
		}
		else {
			command = processor_->AddCommand(cmJmp, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, reg1, 0, NEED_FIXUP));
			command->set_operand_scale(0, 2);
			command->AddLink(0, ltSwitch);
			switch_entry = command;
		}
	}

	// check stack
	{
		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom();
		check_stack = processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, (context_registr_count + 8) * OperandSizeToValue(cpu_address_size)));
		processor_->AddCommand(cmCmp, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otRegistr, cpu_address_size, reg1));
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_C | fl_Z);
		jmp_command->include_option(roInverseFlag);
		jmp_command->AddLink(0, ltJmpWithFlag);

		registr_list = free_registr_list_;
		registr_list.remove(regESI);
		registr_list.remove(regEDI);
		registr_list.remove(regECX);
		reg1 = registr_list.GetRandom();
		reg2 = registr_list.GetRandom();
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg2), IntelOperand(otRegistr, cpu_address_size, regESP));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regECX), IntelOperand(otValue, cpu_address_size, 0, context_registr_count * OperandSizeToValue(cpu_address_size)));
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, stack_registr_ << 4, -128));
		processor_->AddCommand(cmAnd, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otValue, cpu_address_size, 0, (cpu_address_size == osQWord) ? -16 : -4));
		processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otRegistr, cpu_address_size, regECX));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otRegistr, cpu_address_size, reg1));
		if (IsRegistrUsed(regEDI))
			processor_->AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, regEDI));
		if (IsRegistrUsed(regESI))
			processor_->AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, regESI));
		processor_->AddCommand(cmPushf);
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regESI), IntelOperand(otRegistr, cpu_address_size, reg2));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regEDI), IntelOperand(otRegistr, cpu_address_size, reg1));
		processor_->AddCommand(cmCld);
		command = processor_->AddCommand(cmMovs, IntelOperand(otRegistr, osByte));
		command->set_preffix_command(cmRep);
		processor_->AddCommand(cmPopf);
		if (IsRegistrUsed(regESI))
			processor_->AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size, regESI));
		if (IsRegistrUsed(regEDI))
			processor_->AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size, regEDI));
		if (type_ == vtAdvanced) {
			command = processor_->AddCommand(cmJmp, IntelOperand(otRegistr, cpu_address_size, jmp_registr_));
			command->AddLink(-1, ltJmp);
			jmp_command->link()->set_to_command(command);
		}
		else {
			command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
			command->AddLink(0, ltJmp, read_opcode);
			jmp_command->link()->set_to_command(read_opcode);
		}
	}

	// push registr
	for (s = osByte; s <= cpu_address_size; s++) {
		size = static_cast<OperandSize>(s);
		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom(cpu_address_size == osDWord);
		reg2 = registr_list.GetRandom();
		mov_size = (size == osByte) ? osWord : size;
		if (ctx.options.flags & cpEncryptBytecode) {
			registr_cryptor = new OpcodeCryptor();
			cryptor_list_.push_back(registr_cryptor);
			registr_cryptor->Init(osByte);
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = AddReadCommand(osByte, registr_cryptor, reg1);
		processor_->AddCommand((mov_size == size) ? cmMov : cmMovzx, IntelOperand(otRegistr, mov_size, reg2), IntelOperand(otMemory | otBaseRegistr | otRegistr, size, (regESP << 4) | reg1));
		operand_size = 0;
		result_size = OperandSizeToValue(mov_size);
		if (result_size > operand_size)
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size) //-V547
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, mov_size, stack_registr_), IntelOperand(otRegistr, mov_size, reg2));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
		opcode_list_.Add(cmPush, otRegistr, size, 0, opcode_entry, registr_cryptor, end_cryptor);
	}

	// pop registr
	for (s = osByte; s <= cpu_address_size; s++) {
		size = static_cast<OperandSize>(s);
		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
		reg2 = registr_list.GetRandom(cpu_address_size == osDWord);
		mov_size = (size == osByte) ? osWord : size;
		if (ctx.options.flags & cpEncryptBytecode) {
			registr_cryptor = new OpcodeCryptor();
			cryptor_list_.push_back(registr_cryptor);
			registr_cryptor->Init(osByte);
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, mov_size, reg1), IntelOperand(otMemory | otRegistr, mov_size, stack_registr_));
		operand_size = OperandSizeToValue(mov_size);
		result_size = 0;
		if (result_size > operand_size) //-V547
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size)
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		AddReadCommand(osByte, registr_cryptor, reg2);
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otBaseRegistr | otRegistr, size, (regESP << 4) | reg2), IntelOperand(otRegistr, size, reg1));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor); //-V547
		opcode_list_.Add(cmPop, otRegistr, size, 0, opcode_entry, registr_cryptor, end_cryptor);
	}

	// push value
	for (s = osByte; s <= cpu_address_size; s++) {
		size = static_cast<OperandSize>(s);
		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
		if (ctx.options.flags & cpEncryptBytecode) {
			value_cryptor = new OpcodeCryptor();
			cryptor_list_.push_back(value_cryptor);
			value_cryptor->Init(size);
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = AddReadCommand(size, value_cryptor, reg1);
		mov_size = (size == osByte) ? osWord : size;
		operand_size = 0;
		result_size = OperandSizeToValue(mov_size);
		if (result_size > operand_size)
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size) //-V547
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, mov_size, stack_registr_), IntelOperand(otRegistr, mov_size, reg1));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
		opcode_list_.Add(cmPush, otValue, size, 0, opcode_entry, value_cryptor, end_cryptor);
	}

	// push [address]
	for (s = osByte; s <= cpu_address_size; s++) {
		size = static_cast<OperandSize>(s);
		mov_size = (size == osByte) ? osWord : size;
		for (seg = segES; seg <= segGS; seg++) {
			if (seg != segDS && seg != segSS && !visible_opcode_list.GetOpcodeInfo(cmPush, otMemory, size, seg))
				continue;

			IntelRegistrList registr_list = free_registr_list_;
			reg1 = registr_list.GetRandom();
			reg2 = registr_list.GetRandom();
			if (ctx.options.flags & cpEncryptBytecode) {
				if (type_ == vtAdvanced) {
					end_cryptor = new OpcodeCryptor();
					cryptor_list_.push_back(end_cryptor);
					end_cryptor->Init(osDWord);
				}
			}
			opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
			command = processor_->AddCommand((mov_size == size) ? cmMov : cmMovzx, IntelOperand(otRegistr, mov_size, reg2), IntelOperand(otMemory | otRegistr, size, reg1));
			if (seg != segDS)
				command->set_base_segment(static_cast<IntelSegment>(seg));
			operand_size = OperandSizeToValue(cpu_address_size);
			result_size = OperandSizeToValue(mov_size);
			if (result_size > operand_size)
				processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
			else if (result_size < operand_size)
				processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
			processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, mov_size, stack_registr_), IntelOperand(otRegistr, mov_size, reg2));
			AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
			opcode_list_.Add(cmPush, otMemory, size, seg, opcode_entry, NULL, end_cryptor);
		}
	}

	// pop [address]
	for (s = osByte; s <= cpu_address_size; s++) {
		size = static_cast<OperandSize>(s);
		mov_size = (size == osByte) ? osWord : size;
		for (seg = segES; seg <= segGS; seg++) {
			if (seg != segDS && seg != segSS && !visible_opcode_list.GetOpcodeInfo(cmPop, otMemory, size, seg))
				continue;

			IntelRegistrList registr_list = free_registr_list_;
			reg1 = registr_list.GetRandom();
			reg2 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
			if (ctx.options.flags & cpEncryptBytecode) {
				if (type_ == vtAdvanced) {
					end_cryptor = new OpcodeCryptor();
					cryptor_list_.push_back(end_cryptor);
					end_cryptor->Init(osDWord);
				}
			}
			opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, reg2), IntelOperand(otMemory | otRegistr | otValue, size, stack_registr_, OperandSizeToValue(cpu_address_size)));
			operand_size = OperandSizeToValue(cpu_address_size) + OperandSizeToValue(mov_size);
			result_size = 0;
			if (result_size > operand_size) //-V547
				processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
			else if (result_size < operand_size)
				processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
			command = processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, size, reg1), IntelOperand(otRegistr, size, reg2));
			if (seg != segDS)
				command->set_base_segment(static_cast<IntelSegment>(seg));
			AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor); //-V547
			opcode_list_.Add(cmPop, otMemory, size, seg, opcode_entry, NULL, end_cryptor);
		}
	}

	// push segment registr
	for (seg = segES; seg <= segGS; seg++) {
		if (!visible_opcode_list.GetOpcodeInfo(cmPush, otSegmentRegistr, osWord, seg))
			continue;

		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom();
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, osWord, reg1), IntelOperand(otSegmentRegistr, osWord, seg));
		operand_size = 0;
		result_size = OperandSizeToValue(osWord);
		if (result_size > operand_size)
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size) //-V547
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osWord, stack_registr_), IntelOperand(otRegistr, osWord, reg1));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
		opcode_list_.Add(cmPush, otSegmentRegistr, osWord, seg, opcode_entry, NULL, end_cryptor);
	}

	// pop segment registr
	for (seg = segES; seg <= segGS; seg++) {
		if (seg == segCS || !visible_opcode_list.GetOpcodeInfo(cmPop, otSegmentRegistr, osWord, seg))
			continue;

		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom();
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, osWord, reg1), IntelOperand(otMemory | otRegistr, osWord, stack_registr_));
		operand_size = OperandSizeToValue(osWord);
		result_size = 0;
		if (result_size > operand_size) //-V547
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size)
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmMov, IntelOperand(otSegmentRegistr, osWord, seg), IntelOperand(otRegistr, osWord, reg1));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor); //-V547
		opcode_list_.Add(cmPop, otSegmentRegistr, osWord, seg, opcode_entry, NULL, end_cryptor);
	}

	size_t debug_reg_count = 8;

	// push debug registr
	for (i = 0; i < debug_reg_count; i++) {
		if (!visible_opcode_list.GetOpcodeInfo(cmPush, otDebugRegistr, cpu_address_size, (uint8_t)i))
			continue;

		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom();
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otDebugRegistr, cpu_address_size, (uint8_t)i));
		operand_size = 0;
		result_size = OperandSizeToValue(cpu_address_size);
		if (result_size > operand_size)
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size) //-V547
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_), IntelOperand(otRegistr, cpu_address_size, reg1));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
		opcode_list_.Add(cmPush, otDebugRegistr, cpu_address_size, (uint8_t)i, opcode_entry, NULL, end_cryptor);
	}

	// pop debug registr
	for (i = 0; i < debug_reg_count; i++) {
		if (!visible_opcode_list.GetOpcodeInfo(cmPop, otDebugRegistr, cpu_address_size, (uint8_t)i))
			continue;

		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom();
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
		operand_size = OperandSizeToValue(cpu_address_size);
		result_size = 0;
		if (result_size > operand_size) //-V547
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size)
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		command = processor_->AddCommand(cmMov, IntelOperand(otDebugRegistr, cpu_address_size, (uint8_t)i), IntelOperand(otRegistr, cpu_address_size, reg1));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor); //-V547
		opcode_list_.Add(cmPop, otDebugRegistr, cpu_address_size, (uint8_t)i, opcode_entry, NULL, end_cryptor);
	}

	size_t control_reg_count = cpu_address_size == osDWord ? 8 : 9;

	// push control registr
	for (i = 0; i < control_reg_count; i++) {
		if (!visible_opcode_list.GetOpcodeInfo(cmPush, otControlRegistr, cpu_address_size, (uint8_t)i))
			continue;

		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom();
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otControlRegistr, cpu_address_size, (uint8_t)i));
		operand_size = 0;
		result_size = OperandSizeToValue(cpu_address_size);
		if (result_size > operand_size)
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size) //-V547
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_), IntelOperand(otRegistr, cpu_address_size, reg1));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
		opcode_list_.Add(cmPush, otControlRegistr, cpu_address_size, (uint8_t)i, opcode_entry, NULL, end_cryptor);
	}

	// pop control registr
	for (i = 0; i < control_reg_count; i++) {
		if (!visible_opcode_list.GetOpcodeInfo(cmPop, otControlRegistr, cpu_address_size, (uint8_t)i))
			continue;

		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom();
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
		operand_size = OperandSizeToValue(cpu_address_size);
		result_size = 0;
		if (result_size > operand_size) //-V547
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size)
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		command = processor_->AddCommand(cmMov, IntelOperand(otControlRegistr, cpu_address_size, (uint8_t)i), IntelOperand(otRegistr, cpu_address_size, reg1));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor); //-V547
		opcode_list_.Add(cmPop, otControlRegistr, cpu_address_size, (uint8_t)i, opcode_entry, NULL, end_cryptor);
	}

	// push ESP
	for (s = osWord; s <= cpu_address_size; s++) {
		size = static_cast<OperandSize>(s);
		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom();
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otRegistr, cpu_address_size, stack_registr_));
		operand_size = 0;
		result_size = OperandSizeToValue(size);
		if (result_size > operand_size)
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size) //-V547
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, size, stack_registr_), IntelOperand(otRegistr, size, reg1));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
		opcode_list_.Add(cmPush, otRegistr, size, 0xFF, opcode_entry, NULL, end_cryptor);
	}

	// pop ESP
	for (s = osWord; s <= cpu_address_size; s++) {
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		size = static_cast<OperandSize>(s);
		opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, stack_registr_), IntelOperand(otMemory | otRegistr, size, stack_registr_));
		AddEndHandlerCommands(check_stack, end_cryptor);
		opcode_list_.Add(cmPop, otRegistr, size, 0xFF, opcode_entry, NULL, end_cryptor);
	}

	// add
	for (s = osByte; s <= cpu_address_size; s++) {
		size = static_cast<OperandSize>(s);
		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
		reg2 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		mov_size = (size == osByte) ? osWord : size;
		opcode_entry = processor_->AddCommand((mov_size == size) ? cmMov : cmMovzx, IntelOperand(otRegistr, mov_size, reg1), IntelOperand(otMemory | otRegistr, size, stack_registr_));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, reg2), IntelOperand(otMemory | otRegistr | otValue, size, stack_registr_, OperandSizeToValue(mov_size)));
		operand_size = OperandSizeToValue(mov_size);
		result_size = OperandSizeToValue(cpu_address_size);
		if (result_size > operand_size)
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size)
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmAdd, IntelOperand(otRegistr, size, reg1), IntelOperand(otRegistr, size, reg2));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, mov_size, stack_registr_, OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, mov_size, reg1));
		processor_->AddCommand(cmPushf, IntelOperand(otNone, cpu_address_size));
		processor_->AddCommand(cmPop, IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
		opcode_list_.Add(cmAdd, otNone, size, true, opcode_entry, NULL, end_cryptor);
	}

	// nor
	for (s = osByte; s <= cpu_address_size; s++) {
		size = static_cast<OperandSize>(s);
		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
		reg2 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		mov_size = (size == osByte) ? osWord : size;
		opcode_entry = processor_->AddCommand((mov_size == size) ? cmMov : cmMovzx, IntelOperand(otRegistr, mov_size, reg1), IntelOperand(otMemory | otRegistr, size, stack_registr_));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, reg2), IntelOperand(otMemory | otRegistr | otValue, size, stack_registr_, OperandSizeToValue(mov_size)));
		operand_size = OperandSizeToValue(mov_size);
		result_size = OperandSizeToValue(cpu_address_size);
		if (result_size > operand_size)
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size)
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmNot, IntelOperand(otRegistr, size, reg1));
		processor_->AddCommand(cmNot, IntelOperand(otRegistr, size, reg2));
		processor_->AddCommand(cmAnd, IntelOperand(otRegistr, size, reg1), IntelOperand(otRegistr, size, reg2));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, mov_size, stack_registr_, OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, mov_size, reg1));
		processor_->AddCommand(cmPushf, IntelOperand(otNone, cpu_address_size));
		processor_->AddCommand(cmPop, IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
		opcode_list_.Add(cmNor, otNone, size, true, opcode_entry, NULL, end_cryptor);
	}

	// nand
	for (s = osByte; s <= cpu_address_size; s++) {
		size = static_cast<OperandSize>(s);
		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
		reg2 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		mov_size = (size == osByte) ? osWord : size;
		opcode_entry = processor_->AddCommand((mov_size == size) ? cmMov : cmMovzx, IntelOperand(otRegistr, mov_size, reg1), IntelOperand(otMemory | otRegistr, size, stack_registr_));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, reg2), IntelOperand(otMemory | otRegistr | otValue, size, stack_registr_, OperandSizeToValue(mov_size)));
		operand_size = OperandSizeToValue(mov_size);
		result_size = OperandSizeToValue(cpu_address_size);
		if (result_size > operand_size)
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size)
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmNot, IntelOperand(otRegistr, size, reg1));
		processor_->AddCommand(cmNot, IntelOperand(otRegistr, size, reg2));
		processor_->AddCommand(cmOr, IntelOperand(otRegistr, size, reg1), IntelOperand(otRegistr, size, reg2));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, mov_size, stack_registr_, OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, mov_size, reg1));
		processor_->AddCommand(cmPushf, IntelOperand(otNone, cpu_address_size));
		processor_->AddCommand(cmPop, IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
		opcode_list_.Add(cmNand, otNone, size, true, opcode_entry, NULL, end_cryptor);
	}

	// shl, shr
	for (i = 0; i < 2; i++) {
		command_type = (i == 0) ? cmShl : cmShr;
		for (s = osByte; s <= cpu_address_size; s++) {
			size = static_cast<OperandSize>(s);
			IntelRegistrList registr_list = free_registr_list_;
			registr_list.remove(regECX);
			reg1 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
			if (ctx.options.flags & cpEncryptBytecode) {
				if (type_ == vtAdvanced) {
					end_cryptor = new OpcodeCryptor();
					cryptor_list_.push_back(end_cryptor);
					end_cryptor->Init(osDWord);
				}
			}
			mov_size = (size == osByte) ? osWord : size;
			opcode_entry = processor_->AddCommand((mov_size == size) ? cmMov : cmMovzx, IntelOperand(otRegistr, mov_size, reg1), IntelOperand(otMemory | otRegistr, size, stack_registr_));
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, osByte, regECX), IntelOperand(otMemory | otRegistr | otValue, osByte, stack_registr_, OperandSizeToValue(mov_size)));
			operand_size = OperandSizeToValue(osWord);
			result_size = OperandSizeToValue(cpu_address_size);
			if (result_size > operand_size)
				processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
			else if (result_size < operand_size)
				processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
			processor_->AddCommand(command_type, IntelOperand(otRegistr, size, reg1), IntelOperand(otRegistr, osByte, regECX));
			processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, mov_size, stack_registr_, OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, mov_size, reg1));
			processor_->AddCommand(cmPushf, IntelOperand(otNone, cpu_address_size));
			processor_->AddCommand(cmPop, IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
			AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
			opcode_list_.Add(command_type, otNone, size, true, opcode_entry, NULL, end_cryptor);
		}
	}

	// rcl, rcr
	for (i = 0; i < 2; i++) {
		command_type = (i == 0) ? cmRcl : cmRcr;
		for (s = osByte; s <= cpu_address_size; s++) {
			size = static_cast<OperandSize>(s);
			if (!visible_opcode_list.GetOpcodeInfo(command_type, otNone, size, true))
				continue;

			IntelRegistrList registr_list = free_registr_list_;
			registr_list.remove(regECX);
			reg1 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
			if (ctx.options.flags & cpEncryptBytecode) {
				if (type_ == vtAdvanced) {
					end_cryptor = new OpcodeCryptor();
					cryptor_list_.push_back(end_cryptor);
					end_cryptor->Init(osDWord);
				}
			}
			mov_size = (size == osByte) ? osWord : size;
			opcode_entry = processor_->AddCommand((mov_size == size) ? cmMov : cmMovzx, IntelOperand(otRegistr, mov_size, reg1), IntelOperand(otMemory | otRegistr, size, stack_registr_));
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, osWord, regECX), IntelOperand(otMemory | otRegistr | otValue, osWord, stack_registr_, OperandSizeToValue(mov_size)));
			operand_size = OperandSizeToValue(osWord);
			result_size = OperandSizeToValue(cpu_address_size);
			if (result_size > operand_size)
				processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
			else if (result_size < operand_size)
				processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
			processor_->AddCommand(cmShr, IntelOperand(otHiPartRegistr, osByte, regECX), IntelOperand(otValue, osByte, 0, 1));
			processor_->AddCommand(command_type, IntelOperand(otRegistr, size, reg1), IntelOperand(otRegistr, osByte, regECX));
			processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, mov_size, stack_registr_, OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, mov_size, reg1));
			processor_->AddCommand(cmPushf, IntelOperand(otNone, cpu_address_size));
			processor_->AddCommand(cmPop, IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
			AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
			opcode_list_.Add(command_type, otNone, size, true, opcode_entry, NULL, end_cryptor);
		}
	}

	// shld, shrd
	for (i = 0; i < 2; i++) {
		command_type = (i == 0) ? cmShld : cmShrd;
		for (s = osDWord; s <= cpu_address_size; s++) {
			size = static_cast<OperandSize>(s);
			IntelRegistrList registr_list = free_registr_list_;
			registr_list.remove(regECX);
			reg1 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
			reg2 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
			if (ctx.options.flags & cpEncryptBytecode) {
				if (type_ == vtAdvanced) {
					end_cryptor = new OpcodeCryptor();
					cryptor_list_.push_back(end_cryptor);
					end_cryptor->Init(osDWord);
				}
			}
			opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, reg1), IntelOperand(otMemory | otRegistr, size, stack_registr_));
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, reg2), IntelOperand(otMemory | otRegistr | otValue, size, stack_registr_, OperandSizeToValue(size)));
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, osByte, regECX), IntelOperand(otMemory | otRegistr | otValue, osByte, stack_registr_, OperandSizeToValue(size) * 2));
			operand_size = OperandSizeToValue(size) + OperandSizeToValue(osWord);
			result_size = OperandSizeToValue(cpu_address_size);
			if (result_size > operand_size)
				processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
			else if (result_size < operand_size)
				processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
			processor_->AddCommand(command_type, IntelOperand(otRegistr, size, reg1), IntelOperand(otRegistr, size, reg2), IntelOperand(otRegistr, osByte, regECX));
			processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, size, stack_registr_, OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, size, reg1));
			processor_->AddCommand(cmPushf, IntelOperand(otNone, cpu_address_size));
			processor_->AddCommand(cmPop, IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
			AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
			opcode_list_.Add(command_type, otNone, size, true, opcode_entry, NULL, end_cryptor);
		}
	}

	// div, idiv
	for (i = 0; i < 2; i++) {
		command_type = (i == 0) ? cmDiv : cmIdiv;
		for (s = osByte; s <= cpu_address_size; s++) {
			size = static_cast<OperandSize>(s);
			if (!visible_opcode_list.GetOpcodeInfo(command_type, otNone, size, true))
				continue;

			if (ctx.options.flags & cpEncryptBytecode) {
				if (type_ == vtAdvanced) {
					end_cryptor = new OpcodeCryptor();
					cryptor_list_.push_back(end_cryptor);
					end_cryptor->Init(osDWord);
				}
			}
			mov_size = (size == osByte) ? osWord : size;
			if (size == osByte) {
				opcode_entry = processor_->AddCommand(cmMovzx, IntelOperand(otRegistr, mov_size, regEAX), IntelOperand(otMemory | otRegistr, size, stack_registr_));
				processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, regECX), IntelOperand(otMemory | otRegistr | otValue, size, stack_registr_, OperandSizeToValue(mov_size)));
			}
			else {
				opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, regEAX), IntelOperand(otMemory | otRegistr | otValue, size, stack_registr_, OperandSizeToValue(size)));
				processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, regEDX), IntelOperand(otMemory | otRegistr, size, stack_registr_));
				processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, regECX), IntelOperand(otMemory | otRegistr | otValue, size, stack_registr_, OperandSizeToValue(size) * 2));
			}
			operand_size = OperandSizeToValue(mov_size);
			result_size = OperandSizeToValue(cpu_address_size);
			if (result_size > operand_size)
				processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
			else if (result_size < operand_size)
				processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
			processor_->AddCommand(command_type, IntelOperand(otRegistr, size, regECX));
			if (size == osByte) {
				processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, mov_size, stack_registr_, OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, mov_size, regEAX));
			}
			else {
				processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, mov_size, stack_registr_, OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, size, regEDX));
				processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, mov_size, stack_registr_, OperandSizeToValue(cpu_address_size) + OperandSizeToValue(mov_size)), IntelOperand(otRegistr, size, regEAX));
			}
			processor_->AddCommand(cmPushf, IntelOperand(otNone, cpu_address_size));
			processor_->AddCommand(cmPop, IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
			AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
			opcode_list_.Add(command_type, otNone, size, true, opcode_entry, NULL, end_cryptor);
		}
	}

	// mul, imul
	for (i = 0; i < 2; i++) {
		command_type = (i == 0) ? cmMul : cmImul;
		for (s = osByte; s <= cpu_address_size; s++) {
			size = static_cast<OperandSize>(s);
			if (!visible_opcode_list.GetOpcodeInfo(command_type, otNone, size, true))
				continue;

			if (ctx.options.flags & cpEncryptBytecode) {
				if (type_ == vtAdvanced) {
					end_cryptor = new OpcodeCryptor();
					cryptor_list_.push_back(end_cryptor);
					end_cryptor->Init(osDWord);
				}
			}
			mov_size = (size == osByte) ? osWord : size;
			opcode_entry = processor_->AddCommand((mov_size == size) ? cmMov : cmMovzx, IntelOperand(otRegistr, mov_size, regEAX), IntelOperand(otMemory | otRegistr | otValue, size, stack_registr_, OperandSizeToValue(mov_size)));
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, regEDX), IntelOperand(otMemory | otRegistr, size, stack_registr_));
			operand_size = (size == osByte) ? OperandSizeToValue(mov_size) : 0;
			result_size = OperandSizeToValue(cpu_address_size);
			if (result_size > operand_size)
				processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
			else if (result_size < operand_size)
				processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
			processor_->AddCommand(command_type, IntelOperand(otRegistr, size, regEDX));
			if (size == osByte) {
				processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, mov_size, stack_registr_, OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, mov_size, regEAX));
			}
			else {
				processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, mov_size, stack_registr_, OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, mov_size, regEDX));
				processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, mov_size, stack_registr_, OperandSizeToValue(cpu_address_size) + OperandSizeToValue(mov_size)), IntelOperand(otRegistr, mov_size, regEAX));
			}
			processor_->AddCommand(cmPushf, IntelOperand(otNone, cpu_address_size));
			processor_->AddCommand(cmPop, IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
			AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
			opcode_list_.Add(command_type, otNone, size, true, opcode_entry, NULL, end_cryptor);
		}
	}

	// fild, fld, fadd, fsub, fsubr, fstp, fst, fist, fistp, fdiv, fmul, fcomp, fstcw, fldcw, fstsw
	for (i = 0; i < 33; i++) {
		switch (i) {
		case 0:
			command_type = cmFild;
			size = osWord;
			break;
		case 1:
			command_type = cmFild;
			size = osDWord;
			break;
		case 2:
			command_type = cmFild;
			size = osQWord;
			break;
		case 3:
			command_type = cmFld;
			size = osDWord;
			break;
		case 4:
			command_type = cmFld;
			size = osQWord;
			break;
		case 5:
			command_type = cmFld;
			size = osTByte;
			break;
		case 6:
			command_type = cmFadd;
			size = osDWord;
			break;
		case 7:
			command_type = cmFadd;
			size = osQWord;
			break;
		case 8:
			command_type = cmFsub;
			size = osDWord;
			break;
		case 9:
			command_type = cmFsub;
			size = osQWord;
			break;
		case 10:
			command_type = cmFsubr;
			size = osDWord;
			break;
		case 11:
			command_type = cmFsubr;
			size = osQWord;
			break;
		case 12:
			command_type = cmFstp;
			size = osDWord;
			break;
		case 13:
			command_type = cmFstp;
			size = osQWord;
			break;
		case 14:
			command_type = cmFstp;
			size = osTByte;
			break;
		case 15:
			command_type = cmFst;
			size = osDWord;
			break;
		case 16:
			command_type = cmFst;
			size = osQWord;
			break;
		case 17:
			command_type = cmFist;
			size = osWord;
			break;
		case 18:
			command_type = cmFist;
			size = osDWord;
			break;
		case 19:
			command_type = cmFistp;
			size = osWord;
			break;
		case 20:
			command_type = cmFistp;
			size = osDWord;
			break;
		case 21:
			command_type = cmFistp;
			size = osQWord;
			break;
		case 22:
			command_type = cmFisub;
			size = osWord;
			break;
		case 23:
			command_type = cmFisub;
			size = osDWord;
			break;
		case 24:
			command_type = cmFdiv;
			size = osDWord;
			break;
		case 25:
			command_type = cmFdiv;
			size = osQWord;
			break;
		case 26:
			command_type = cmFmul;
			size = osDWord;
			break;
		case 27:
			command_type = cmFmul;
			size = osQWord;
			break;
		case 28:
			command_type = cmFcomp;
			size = osDWord;
			break;
		case 29:
			command_type = cmFcomp;
			size = osQWord;
			break;
		case 30:
			command_type = cmFstcw;
			size = osWord;
			break;
		case 31:
			command_type = cmFldcw;
			size = osWord;
			break;
		case 32:
			command_type = cmFstsw;
			size = osWord;
			break;
		}
		if (!visible_opcode_list.GetOpcodeInfo(command_type, otNone, size, 0))
			continue;

		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(command_type, IntelOperand(otMemory | otRegistr, size, stack_registr_));
		AddEndHandlerCommands(read_opcode, end_cryptor);
		opcode_list_.Add(command_type, otNone, size, 0, opcode_entry, NULL, end_cryptor);
	}

	// wait, fchs, fsqrt, f2xm1, fabs, fclex, fcos, fdecstp, fincstp, finit, fldln2, fldz, fld1, fldpi, fpatan, fprem, fprem1, fptan, frndint, fsin, ftst, fyl2x, fldlg2
	for (i = 0; i < 24; i++) {
		switch (i) {
		case 0:
			command_type = cmWait;
			break;
		case 1:
			command_type = cmFchs;
			break;
		case 2:
			command_type = cmFsqrt;
			break;
		case 3:
			command_type = cmF2xm1;
			break;
		case 4:
			command_type = cmFabs;
			break;
		case 5:
			command_type = cmFclex;
			break;
		case 6:
			command_type = cmFcos;
			break;
		case 7:
			command_type = cmFdecstp;
			break;
		case 8:
			command_type = cmFincstp;
			break;
		case 9:
			command_type = cmFinit;
			break;
		case 10:
			command_type = cmFldln2;
			break;
		case 12:
			command_type = cmFldz;
			break;
		case 13:
			command_type = cmFld1;
			break;
		case 14:
			command_type = cmFldpi;
			break;
		case 15:
			command_type = cmFpatan;
			break;
		case 16:
			command_type = cmFprem;
			break;
		case 17:
			command_type = cmFprem1;
			break;
		case 18:
			command_type = cmFptan;
			break;
		case 19:
			command_type = cmFrndint;
			break;
		case 20:
			command_type = cmFsin;
			break;
		case 21:
			command_type = cmFtst;
			break;
		case 22:
			command_type = cmFyl2x;
			break;
		case 23:
			command_type = cmFldlg2;
			break;
		}
		if (!visible_opcode_list.GetOpcodeInfo(command_type, otNone, cpu_address_size, 0))
			continue;

		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(command_type);
		AddEndHandlerCommands(read_opcode, end_cryptor);
		opcode_list_.Add(command_type, otNone, cpu_address_size, 0, opcode_entry, NULL, end_cryptor);
	}

	// ret, iret
	for (j = 0; j < 3; j++) {
		command_type = (j == 1) ? cmIret : cmRet;
		if (j > 0 && !visible_opcode_list.GetOpcodeInfo(command_type, otNone, cpu_address_size, (j == 2) ? 1 : 0))
			continue;

		opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otRegistr, cpu_address_size, stack_registr_));

		for (i = registr_order_.size(); i > 0; i--) {
			uint8_t reg = registr_order_[i - 1];
			if (reg == regEFX) {
				processor_->AddCommand(cmPopf);
			}
			else {
				processor_->AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size, reg));
			}
		}

		command = processor_->AddCommand(command_type);
		if (j == 2)
			command->include_option(roFar);
		opcode_list_.Add(command_type, otNone, cpu_address_size, (command->options() & roFar) ? 1 : 0, opcode_entry);
	}

	// popf
	{
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(cmPush, IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
		operand_size = OperandSizeToValue(cpu_address_size);
		result_size = 0;
		if (result_size > operand_size) //-V547
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size)
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmPopf, IntelOperand(otNone, cpu_address_size));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor); //-V547
		opcode_list_.Add(cmPopf, otNone, cpu_address_size, 0, opcode_entry, NULL, end_cryptor);
	}

	// jmp
	for (i = 0; i < ctx.options.vm_count; i++) {
		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom();
		opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
		processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, OperandSizeToStack(cpu_address_size)));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		command->AddLink(0, ltJmp);
		vm_links_.push_back(command);

		opcode_list_.Add(cmJmp, otNone, cpu_address_size, (uint8_t)i + 1, opcode_entry);
	}

	// rdtsc
	if (visible_opcode_list.GetOpcodeInfo(cmRdtsc, otNone, cpu_address_size, 0)) {
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(cmRdtsc);
		operand_size = 0;
		result_size = OperandSizeToValue(osDWord) * 2;
		if (result_size > operand_size)
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size) //-V547
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osDWord, stack_registr_), IntelOperand(otRegistr, osDWord, regEDX));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osDWord, stack_registr_, OperandSizeToValue(osDWord)), IntelOperand(otRegistr, osDWord, regEAX));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
		opcode_list_.Add(cmRdtsc, otNone, cpu_address_size, 0, opcode_entry, NULL, end_cryptor);
	}

	// cpuid
	if (visible_opcode_list.GetOpcodeInfo(cmCpuid, otNone, cpu_address_size, 0)) {
		if (stack_registr_ == regEBX) {
			IntelRegistrList registr_list = free_registr_list_;
			registr_list.remove(regEAX);
			registr_list.remove(regEBX);
			registr_list.remove(regECX);
			registr_list.remove(regEDX);
			reg1 = registr_list.GetRandom();
		}
		else
			reg1 = stack_registr_;
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otMemory | otRegistr, osDWord, stack_registr_));
		if (reg1 != stack_registr_)
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otRegistr, cpu_address_size, stack_registr_));
		if (IsRegistrUsed(regEBX))
			processor_->AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, regEBX));
		processor_->AddCommand(cmCpuid);
		operand_size = OperandSizeToValue(osDWord);
		result_size = OperandSizeToValue(osDWord) * 4;
		if (result_size > operand_size)
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size)
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osDWord, reg1, OperandSizeToValue(osDWord) * 3), IntelOperand(otRegistr, osDWord, regEAX));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osDWord, reg1, OperandSizeToValue(osDWord) * 2), IntelOperand(otRegistr, osDWord, regEBX));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osDWord, reg1, OperandSizeToValue(osDWord)), IntelOperand(otRegistr, osDWord, regECX));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osDWord, reg1), IntelOperand(otRegistr, osDWord, regEDX));
		if (IsRegistrUsed(regEBX))
			processor_->AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size, regEBX));
		if (reg1 != stack_registr_)
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otRegistr, cpu_address_size, reg1));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
		opcode_list_.Add(cmCpuid, otNone, cpu_address_size, 0, opcode_entry, NULL, end_cryptor);
	}

	// call
	if (visible_opcode_list.GetOpcodeInfo(cmCall, otNone, cpu_address_size, 0)) {
		IntelRegistrList registr_list = free_registr_list_;
		registr_list.remove(regEBP);
		reg1 = registr_list.GetRandom(cpu_address_size == osDWord);
		if (ctx.options.flags & cpEncryptBytecode) {
			value_cryptor = new OpcodeCryptor();
			cryptor_list_.push_back(value_cryptor);
			value_cryptor->Init(osByte);
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = AddReadCommand(osByte, value_cryptor, reg1);
		AddCallCommands(ctx.file->calling_convention(), NULL, reg1);
		AddEndHandlerCommands(read_opcode, end_cryptor);
		opcode_list_.Add(cmCall, otNone, cpu_address_size, 0, opcode_entry, value_cryptor, end_cryptor);
	}

	// syscall
	if (visible_opcode_list.GetOpcodeInfo(cmSyscall, otNone, cpu_address_size, 0)) {
		IntelRegistrList registr_list = free_registr_list_;
		registr_list.remove(regEBP);
		reg1 = registr_list.GetRandom(cpu_address_size == osDWord);
		if (ctx.options.flags & cpEncryptBytecode) {
			value_cryptor = new OpcodeCryptor();
			cryptor_list_.push_back(value_cryptor);
			value_cryptor->Init(osByte);
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		c = processor_->count();
		if (cpu_address_size == osDWord) {
			// x32
			IntelVirtualMachineProcessor *new_processor = function_list->AddProcessor(osDWord);
			new_processor->set_compilation_type(ctVirtualization);

			command = new_processor->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regEDX), IntelOperand(otRegistr, cpu_address_size, regESP));
			new_processor->AddCommand(cmSysenter);
			new_processor->AddCommand(cmRet);

			IntelCommand *sysenter_entry = new_processor->AddCommand(cmCall, IntelOperand(otValue, cpu_address_size));
			sysenter_entry->AddLink(0, ltCall, command);
			new_processor->AddCommand(cmRet);

			IntelVirtualMachineProcessor *old_processor = processor_;
			processor_ = new_processor;

			opcode_entry = AddReadCommand(osByte, value_cryptor, reg1);
			processor_->AddCommand(cmTest, IntelOperand(otMemory | otRegistr, osDWord, stack_registr_), IntelOperand(otValue, osDWord, 0, WOW64_FLAG));
			IntelCommand *cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
			cmp_command->set_flags(fl_Z);
			cmp_command->include_option(roInverseFlag);
			cmp_command->AddLink(0, ltJmpWithFlag);
			AddCallCommands(ctx.file->calling_convention(), sysenter_entry, reg1);
			AddEndHandlerCommands(read_opcode, end_cryptor);

			jmp_command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
			jmp_command->AddLink(0, ltJmp);
			cmp_command->link()->set_to_command(jmp_command);

			size_t old_count = processor_->count();
			command = processor_->AddCommand(cmPush, IntelOperand(otSegmentRegistr, cpu_address_size, segCS, 0));
			jmp_command->link()->set_to_command(command);
			IntelCommand *ret_offset_command = processor_->AddCommand(cmPush, IntelOperand(otValue, cpu_address_size, 0, 0, NEED_FIXUP));
			ret_offset_command->AddLink(0, ltOffset);
			IntelCommand *far_call = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size, 0, 0, NEED_FIXUP), IntelOperand(otValue, osWord, 0, 0x33));
			far_call->AddLink(0, ltGateOffset);
			far_call->include_option(roFar);
			command = processor_->AddCommand(cmNop);
			ret_offset_command->link()->set_to_command(command);

			// AMD bug
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, osWord, regECX), IntelOperand(otSegmentRegistr, osWord, segSS));
			processor_->AddCommand(cmMov, IntelOperand(otSegmentRegistr, osWord, segSS), IntelOperand(otRegistr, osWord, regECX));
			jmp_command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
			jmp_command->AddLink(0, ltGateOffset);

			CommandBlock *block = NULL;
			for (i = old_count; i < processor_->count(); i++) {
				if (!block)
					block = processor_->AddBlock(i, true);
				command = processor_->item(i);
				command->set_block(block);
				block->set_end_index(i);
				if (command->is_end())
					block = NULL;
			}

			old_count = processor_->count();
			AddEndHandlerCommands(read_opcode, end_cryptor);
			jmp_command->link()->set_to_command(processor_->item(old_count));

			// x64
			new_processor = function_list->AddProcessor(osQWord);
			new_processor->set_compilation_type(ctVirtualization);

			IntelCommand *syscall_entry = new_processor->AddCommand(cmMov, IntelOperand(otRegistr, osQWord, regR10), IntelOperand(otRegistr, osQWord, regECX));
			new_processor->AddCommand(cmSyscall);
			new_processor->AddCommand(cmRet);

			processor_ = new_processor;

			old_count = new_processor->count();
			AddCallCommands(ccStdcallToMSx64, syscall_entry, reg1);
			command = processor_->AddCommand(cmRet);
			command->include_option(roFar);
			far_call->link()->set_to_command(processor_->item(old_count));

			processor_ = old_processor;

			jmp_command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
			jmp_command->AddLink(0, ltJmp, opcode_entry);
			opcode_entry = jmp_command;
		}
		else {
			IntelVirtualMachineProcessor *new_processor = function_list->AddProcessor(osQWord);
			new_processor->set_compilation_type(ctVirtualization);
			IntelVirtualMachineProcessor *old_processor = processor_;
			processor_ = new_processor;

			IntelCommand *call_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otRegistr, cpu_address_size, regECX));
			processor_->AddCommand(cmSyscall);
			processor_->AddCommand(cmRet);

			opcode_entry = AddReadCommand(osByte, value_cryptor, reg1);
			AddCallCommands(ctx.file->calling_convention(), call_entry, reg1);
			AddEndHandlerCommands(read_opcode, end_cryptor);

			processor_ = old_processor;

			jmp_command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
			jmp_command->AddLink(0, ltJmp, opcode_entry);
			opcode_entry = jmp_command;
		}
		opcode_list_.Add(cmSyscall, otNone, cpu_address_size, 0, opcode_entry, value_cryptor, end_cryptor);
	}

	// crc
	if (visible_opcode_list.GetOpcodeInfo(cmCrc, otNone, cpu_address_size, 0)) {
		c = (type_ == vtAdvanced) ? 10 : 1;
		for (size_t k = 0; k < c; k++) {
			j = processor_->count();
			uint32_t crc_table_salt = rand32();
			for (i = 0; i < _countof(crc32_table); i++) {
				command = processor_->AddCommand(osDWord, crc32_table[i] ^ crc_table_salt);
				command->include_option(roNeedCRC);
			}
			IntelCommand *crc_table_entry = processor_->item(j);
			crc_table_entry->include_option(roCreateNewBlock);
			crc_table_entry->set_alignment(OperandSizeToValue(cpu_address_size));

			IntelRegistrList registr_list = free_registr_list_;
			registr_list.remove(regESI);
			reg1 = registr_list.GetRandom();
			reg2 = registr_list.GetRandom();
			reg3 = registr_list.GetRandom();
			reg4 = 0;
			if (ctx.options.flags & cpEncryptBytecode) {
				if (type_ == vtAdvanced) {
					end_cryptor = new OpcodeCryptor();
					cryptor_list_.push_back(end_cryptor);
					end_cryptor->Init(osDWord);
				}
			}

			opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg2), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, stack_registr_, OperandSizeToValue(cpu_address_size)));
			operand_size = OperandSizeToValue(cpu_address_size) * 2;
			result_size = OperandSizeToValue(osDWord);
			if (result_size > operand_size)
				processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
			else if (result_size < operand_size)
				processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));

			//processor_->AddCommand(cmInt, IntelOperand(otValue, osWord, 0, 3));

			processor_->AddCommand(cmXor, IntelOperand(otRegistr, osDWord, reg3), IntelOperand(otRegistr, osDWord, reg3));
			processor_->AddCommand(cmTest, IntelOperand(otRegistr, cpu_address_size, reg2), IntelOperand(otRegistr, cpu_address_size, reg2));
			IntelCommand *jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size, 0, 0));
			jmp_command->set_flags(fl_Z);
			jmp_command->AddLink(0, ltJmpWithFlag);

			if (cpu_address_size == osQWord) {
				reg4 = registr_list.GetRandom();
				command = processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, reg4), IntelOperand(otMemory | otValue, cpu_address_size, 0, 0, LARGE_VALUE));
				command->AddLink(1, ltOffset, crc_table_entry);
			}
			if (IsRegistrUsed(regESI))
				processor_->AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, regESI));

			IntelCommand *loop_command = processor_->AddCommand(cmMovzx, IntelOperand(otRegistr, osDWord, regESI), IntelOperand(otMemory | otRegistr, osByte, reg1));
			processor_->AddCommand(cmXor, IntelOperand(otRegistr, osDWord, regESI), IntelOperand(otRegistr, osDWord, reg3));
			processor_->AddCommand(cmAnd, IntelOperand(otRegistr, osDWord, regESI), IntelOperand(otValue, osDWord, 0, 0xff));

			if (cpu_address_size == osQWord) {
				command = processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regESI), IntelOperand(otMemory | otBaseRegistr | otRegistr, osDWord, (reg4 << 4) | regESI, 0));
				command->set_operand_scale(1, 2);
			}
			else {
				command = processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regESI), IntelOperand(otMemory | otRegistr | otValue, osDWord, regESI, 0, NEED_FIXUP));
				command->set_operand_scale(1, 2);
				command->AddLink(1, ltOffset, crc_table_entry);
			}

			processor_->AddCommand(cmShr, IntelOperand(otRegistr, osDWord, reg3), IntelOperand(otValue, osByte, 0, 8));
			processor_->AddCommand(cmXor, IntelOperand(otRegistr, osDWord, reg3), IntelOperand(otRegistr, osDWord, regESI));
			processor_->AddCommand(cmInc, IntelOperand(otRegistr, cpu_address_size, reg1));
			processor_->AddCommand(cmXor, IntelOperand(otRegistr, osDWord, reg3), IntelOperand(otValue, osDWord, 0, crc_table_salt));
			processor_->AddCommand(cmDec, IntelOperand(otRegistr, cpu_address_size, reg2));

			command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size, 0, 0));
			command->set_flags(fl_Z);
			command->include_option(roInverseFlag);
			command->AddLink(0, ltJmpWithFlag, loop_command);

			if (IsRegistrUsed(regESI))
				processor_->AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size, regESI));

			command = processor_->AddCommand(cmNot, IntelOperand(otRegistr, osDWord, reg3));
			jmp_command->link()->set_to_command(command);

			processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osDWord, stack_registr_), IntelOperand(otRegistr, osDWord, reg3));

			AddEndHandlerCommands(read_opcode, end_cryptor);
			opcode_list_.Add(cmCrc, otNone, cpu_address_size, 0, opcode_entry, NULL, end_cryptor);
		}
	}

	if (ctx.options.flags & cpMemoryProtection) {
		for (i = 0; i < opcode_list_.count(); i++) {
			IntelOpcodeInfo *opcode = opcode_list_.item(i);
			if (opcode->command_type() == cmCpuid || opcode->command_type() == cmRdtsc || opcode->command_type() == cmCrc || opcode->command_type() == cmSyscall) {
				for (j = processor_->IndexOf(opcode->entry()); j < processor_->count(); j++) {
					command = processor_->item(j);
					bool need_crc = true;
					if ((ctx.options.flags & cpStripFixups) == 0) {
						for (c = 0; c < 3; c++) {
							IntelOperand operand = command->operand(c);
							if (operand.type == otNone)
								break;

							if ((operand.type & otValue) && operand.fixup) {
								need_crc = false;
								break;
							}
						}
					}

					if (need_crc)
						command->include_option(roNeedCRC);
					if (command->type() == cmJmp || command->type() == cmRet || command->type() == cmIret)
						break;
				}
			}
		}
	}

	// lock
	for (i = 0; i < 7; i++) {
		switch (i) {
		case 0:
			command_type = cmAdd;
			break;
		case 1:
			command_type = cmSub;
			break;
		case 2:
			command_type = cmAnd;
			break;
		case 3:
			command_type = cmXor;
			break;
		case 4:
			command_type = cmOr;
			break;
		case 5:
			command_type = cmXchg;
			break;
		case 6:
			command_type = cmXadd;
			break;
		}
		for (s = osByte; s <= cpu_address_size; s++) {
			size = static_cast<OperandSize>(s);
			mov_size = (size == osByte) ? osWord : size;
			for (seg = segES; seg <= segGS; seg++) {
				if (!visible_opcode_list.GetOpcodeInfo(command_type, otMemory, size, seg))
					continue;

				IntelRegistrList registr_list = free_registr_list_;
				reg1 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
				reg2 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
				if (ctx.options.flags & cpEncryptBytecode) {
					if (type_ == vtAdvanced) {
						end_cryptor = new OpcodeCryptor();
						cryptor_list_.push_back(end_cryptor);
						end_cryptor->Init(osDWord);
					}
				}

				opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
				processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, reg2), IntelOperand(otMemory | otRegistr | otValue, size, stack_registr_, OperandSizeToValue(cpu_address_size)));
				operand_size = OperandSizeToValue(cpu_address_size) + OperandSizeToValue(mov_size);
				result_size = (command_type == cmXchg) ? 0 : OperandSizeToValue(cpu_address_size);
				if (command_type == cmXchg || command_type == cmXadd)
					result_size += OperandSizeToValue(mov_size);
				if (result_size > operand_size)
					processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
				else if (result_size < operand_size)
					processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
				command = processor_->AddCommand(command_type, IntelOperand(otMemory | otRegistr, size, reg1), IntelOperand(otRegistr, size, reg2));
				command->include_option(roLockPrefix);
				if (seg != segDS)
					command->set_base_segment(static_cast<IntelSegment>(seg));
				if (command_type == cmXchg)
					processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, mov_size, stack_registr_), IntelOperand(otRegistr, mov_size, reg2));
				else {
					if (command_type == cmXadd)
						processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, mov_size, stack_registr_, OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, mov_size, reg2));
					processor_->AddCommand(cmPushf, IntelOperand(otNone, cpu_address_size));
					processor_->AddCommand(cmPop, IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
				}
				AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
				opcode_list_.Add(command_type, otMemory, size, seg, opcode_entry, NULL, end_cryptor);
			}
		}
	}

	// randomize opcodes
	if (type_ == vtAdvanced) {
		c = opcode_list_.count();
		for (i = 0; i < c; i++) {
			opcode = opcode_list_.item(i);
			if (opcode->command_type() == cmNop || opcode->command_type() == cmJmp || opcode->command_type() == cmCrc)
				continue;

			for (j = 0; j < 10; j++) {
				opcode_list_.Add(opcode->command_type(), opcode->operand_type(), opcode->size(), opcode->value(), CloneHandler(opcode->entry()), opcode->value_cryptor(), opcode->end_cryptor());
			}
		}
	}
	else {
		c = opcode_list_.count();
		for (i = 0; i < opcode_list_.count(); i++) {
			opcode_list_.SwapObjects(i, rand() % c);
		}
		for (i = opcode_list_.count(); i < 0x100; i++) {
			opcode = opcode_list_.item(rand() % i);
			opcode_list_.Add(opcode->command_type(), opcode->operand_type(), opcode->size(), opcode->value(), (opcode->command_type() == cmJmp) ? opcode->entry() : CloneHandler(opcode->entry()), opcode->value_cryptor(), opcode->end_cryptor());
		}

		// CASEs
		c = processor_->count();
		command_type = (cpu_address_size == osDWord) ? cmDD : cmDQ;
		for (i = 0; i < opcode_list_.count(); i++) {
			IntelOpcodeInfo *opcode = opcode_list_.item(i);
			opcode->set_opcode(static_cast<uint8_t>(i));
			command = processor_->AddCommand(command_type, IntelOperand(otValue, cpu_address_size, 0, 0, NEED_FIXUP));
			CommandLink *link = command->AddLink(0, ltCase, opcode->entry());
			link->set_parent_command(switch_entry);
		}
		command = processor_->item(c);
		command->set_alignment(OperandSizeToValue(cpu_address_size));
		switch_entry->link()->set_to_command(command);
	}
}

IntelOpcodeInfo *IntelVirtualMachine::GetOpcode(IntelCommandType command_type, OperandType operand_type, OperandSize size, uint8_t value)
{
	IntelOpcodeInfo *res = NULL;
	uint64_t key = IntelOpcodeInfo::Key(command_type, operand_type, size, value);
	auto it = opcode_stack_.find(key);
	if (it != opcode_stack_.end()) 
		res = it->second.Next();
	return res;
}

static void EncryptBuffer(uint32_t *buffer, uint64_t key)
{
	uint32_t key0 = static_cast<uint32_t>(key >> 32);
	uint32_t key1 = static_cast<uint32_t>(key);
	buffer[0] = _rotr32(buffer[0] - key0, 7) ^ key1;
	buffer[1] = _rotr32(buffer[1] - key0, 11) ^ key1;
	buffer[2] = _rotr32(buffer[2] - key0, 17) ^ key1;
	buffer[3] = _rotr32(buffer[3] - key0, 23) ^ key1;
}

void IntelVirtualMachine::CompileCommand(IntelVMCommand &vm_command)
{
	IntelCommandType command_type = vm_command.command_type();
	OperandType operand_type = vm_command.operand_type();
	uint8_t registr = vm_command.registr();
	OperandSize size = vm_command.size();
	uint64_t value = vm_command.value();
	CommandBlock *block = vm_command.owner()->block();
	Data dump;
	bool backward_direction = (vm_command.owner()->section_options() & rtBackwardDirection) != 0;
	IntelOpcodeInfo *opcode = NULL;

	switch (command_type) {
	case cmPush:
		switch (operand_type) {
		case otRegistr: 
			if (registr == regESP && (size == osWord || size == osDWord || size == osQWord)) {
				opcode = GetOpcode(cmPush, otRegistr, size, 0xFF);
			} else {
				opcode = GetOpcode(cmPush, otRegistr, size, 0);
				dump.PushByte(block->GetRegistr(size, registr, false));
			}
			break;
		case otHiPartRegistr:
			opcode = GetOpcode(cmPush, otRegistr, size, 0);
			dump.PushByte((uint8_t)(block->GetRegistr(size, registr, false) + OperandSizeToValue(size)));
			break;
   		case otMemory:
			opcode = GetOpcode(cmPush, otMemory, size, vm_command.base_segment());
			break;
   		case otSegmentRegistr:
			opcode = GetOpcode(cmPush, otSegmentRegistr, size, registr);
			break;
   		case otDebugRegistr:
			opcode = GetOpcode(cmPush, otDebugRegistr, size, registr);
			break;
		case otControlRegistr:
			opcode = GetOpcode(cmPush, otControlRegistr, size, registr);
			break;
		case otValue:
			opcode = GetOpcode(cmPush, otValue, size, 0);

			uint64_t new_value;
			if (vm_command.crypt_command() == cmXadd) {
				uint32_t crypted_value[4];
				size_t i;
				for (i = 0; i < _countof(crypted_value); i++) {
					crypted_value[i] = rand32();
				}
				switch (vm_command.crypt_size()) {
				case osDWord:
					crypted_value[3] = static_cast<uint32_t>(value);
					break;
				case osQWord:
					*reinterpret_cast<uint64_t*>(&crypted_value[2]) = value;
					break;
				}
				uint32_t dw = 0;
				for (i = 1; i < 4; i++) {
					dw += crypted_value[i];
				}
				crypted_value[0] = 0 - dw;
				EncryptBuffer(crypted_value, vm_command.crypt_key());
				IntelVMCommand *link_command = vm_command.link_command();
				for (i = 3; i > 0; i--) {
					link_command->set_value(crypted_value[i - 1]);
					link_command->Compile();
					link_command = link_command->link_command();
				}
				new_value = crypted_value[3];
			} else {
				new_value = value;
			}

			new_value -= vm_command.sub_value();
				
			switch (size) {
			case osByte:
				dump.PushByte(static_cast<uint8_t>(new_value));
				break;
			case osWord:
				dump.PushWord(backward_direction ? __builtin_bswap16(static_cast<uint16_t>(new_value)) : static_cast<uint16_t>(new_value));
				break;
			case osDWord:
				dump.PushDWord(backward_direction ? __builtin_bswap32(static_cast<uint32_t>(new_value)) : static_cast<uint32_t>(new_value));
				break;
			case osQWord:
				dump.PushQWord(backward_direction ? __builtin_bswap64(new_value) : new_value);
				break;
			}
			break;
		}
		break;

	case cmPop:
		switch (operand_type) {
		case otRegistr: 
			if (registr == regESP && (size == osWord || size == osDWord || size == osQWord)) {
				opcode = GetOpcode(cmPop, otRegistr, size, 0xFF);
			} else {
				opcode = GetOpcode(cmPop, otRegistr, size, 0);
				dump.PushByte(block->GetRegistr(size, registr, true));
			}
			break;
		case otHiPartRegistr:
			opcode = GetOpcode(cmPop, otRegistr, size, 0);
			dump.PushByte((uint8_t)(block->GetRegistr(size, registr, true) + OperandSizeToValue(size)));
			break;
   		case otMemory:
			opcode = GetOpcode(cmPop, otMemory, size, vm_command.base_segment());
			break;
   		case otSegmentRegistr:
			opcode = GetOpcode(cmPop, otSegmentRegistr, size, registr);
			break;
   		case otDebugRegistr:
			opcode = GetOpcode(cmPop, otDebugRegistr, size, registr);
			break;
		case otControlRegistr:
			opcode = GetOpcode(cmPop, otControlRegistr, size, registr);
			break;
		}
		break;

	case cmCall:
		opcode = GetOpcode(cmCall, otNone, size, 0);
		dump.PushByte(vm_command.subtype());
		break;

	case cmSyscall:
		opcode = GetOpcode(cmSyscall, otNone, size, 0);
		dump.PushByte(vm_command.subtype());
		break;

	case cmJmp:
		if (vm_command.subtype())
			opcode = GetOpcode(command_type, otNone, size, vm_command.subtype());
		else
			opcode = GetOpcode(command_type, otNone, size, (vm_command.value() == 0) ? id() : static_cast<uint8_t>(vm_command.value()));
		break;

	case cmAdd: case cmSub: case cmXor: case cmOr: case cmXchg: case cmAnd: case cmXadd:
		if (vm_command.operand_type() == otMemory)
			opcode = GetOpcode(command_type, otMemory, size, vm_command.base_segment());
		else
			opcode = GetOpcode(command_type, otNone, size, vm_command.subtype());
		break;

	case cmNor: case cmNand: case cmCrc: case cmShld: case cmShrd: case cmShl: case cmShr: case cmDiv: 
	case cmIdiv: case cmMul: case cmImul: case cmRcl: case cmRcr:
	case cmPopf: case cmIret: case cmRet:
	case cmFadd: case cmFsub: case cmFisub: case cmFsubr: case cmFdiv: case cmFmul: case cmFcomp:
	case cmFstp: case cmFst: case cmFild: case cmFld: case cmFstcw: case cmFldcw: case cmFistp: case cmFist:
	case cmWait: case cmFstsw: case cmFchs: case cmFsqrt: case cmRdtsc: case cmCpuid:
	case cmF2xm1: case cmFabs: case cmFclex: case cmFcos: case cmFdecstp: case cmFincstp:
	case cmFinit: case cmFldln2: case cmFldlg2: case cmFprem: case cmFprem1: case cmFptan:
	case cmFrndint: case cmFsin: case cmFtst: case cmFyl2x: case cmFpatan: case cmFldz: case cmFld1: case cmFldpi:
		opcode = GetOpcode(command_type, otNone, size, vm_command.subtype());
		break;

	case cmDD:
		dump.PushDWord(static_cast<uint32_t>(value));
		break;

	case cmDQ:
		dump.PushQWord(value);
		break;

	default:
		opcode = NULL;
		break;
	}

	if (opcode) {
		vm_command.set_opcode(opcode);
		if (type() == vtAdvanced) {
			size_t i = vm_command.owner()->IndexOf(&vm_command);
			bool need_begin_offset;
			if (i == 0) {
				need_begin_offset = (vm_command.owner()->section_options() & (rtLinkedToInt | rtLinkedToExt)) != 0;
			} else {
				IntelVMCommand *prev_command = reinterpret_cast<IntelVMCommand *>(vm_command.owner()->item(i - 1));
				need_begin_offset = prev_command->is_end() || (prev_command->options() & voInitOffset);
			}

			if (need_begin_offset) {
				vm_command.include_option(voBeginOffset);
				uint32_t value = 0;
				dump.InsertBuff(0, &value, sizeof(value));
			}

			if (!vm_command.is_end()) {
				vm_command.include_option(voEndOffset);
				dump.PushDWord(0);
			}
		} else {
			dump.InsertByte(0, opcode->opcode());
		}
	} else if (!vm_command.is_data()) {
		throw std::runtime_error("Runtime error at CompileToVM: " + std::string(intel_command_name[command_type]));
	}

	vm_command.set_dump(dump);
}

std::vector<OpcodeCryptor *> IntelVirtualMachine::GetOpcodeCryptorList(IntelVMCommand *command)
{
	std::vector<OpcodeCryptor *> res;
	if (type_ == vtAdvanced) {
		if (command->options() & voBeginOffset)
			res.push_back(command_cryptor_);
	}
	else {
		res.push_back(command_cryptor_);
	}
	if (command->opcode()->value_cryptor())
		res.push_back(command->opcode()->value_cryptor());
	if (command->opcode()->end_cryptor())
		res.push_back(command->opcode()->end_cryptor());
	return res;
}

void IntelVirtualMachine::CompileBlock(CommandBlock &block, bool need_encrypt)
{
	size_t i, j, k, d, c;
	IntelFunction *func = reinterpret_cast<IntelFunction *>(block.function());
	if (type() == vtAdvanced) {
		IntelVMCommand *prev_command = NULL;
		IntelOpcodeInfo *nop_opcode = GetOpcode(cmNop, otNone, processor_->cpu_address_size(), 0);
		if (nop_opcode == NULL)
			throw std::runtime_error("Runtime error at CompileBlock/nop_opcode");

		for (i = block.start_index(); i <= block.end_index(); i++) {
			IntelCommand *command = func->item(i);
			for (j = 0; j < command->count(); j++) {
				IntelVMCommand *vm_command = command->item(j);
				if (vm_command->is_data())
					continue;

				if (prev_command && (prev_command->options() & voEndOffset)) {
					IntelOpcodeInfo *opcode = (prev_command->options() & voInitOffset) ? nop_opcode : vm_command->opcode();
					prev_command->set_dump_value(osDWord, prev_command->dump_size() - 4, static_cast<uint32_t>(opcode->entry()->address() - prev_command->opcode()->entry()->address()));
				}
				if (vm_command->options() & voBeginOffset)
					vm_command->set_dump_value(osDWord, 0, static_cast<uint32_t>(vm_command->opcode()->entry()->address() - nop_opcode->entry()->address()));
				prev_command = vm_command;
			}
		}
	}

	if (!need_encrypt)
		return;

	struct CRC {
		uint64_t Value;
		CRC()
			: Value(0)
		{

		}
		uint64_t GetValue(OperandSize size) const 
		{
			uint64_t res = 0;
			memcpy(&res, &Value, OperandSizeToValue(size));
			return res;
		}
		void SetValue(OperandSize size, uint64_t value) 
		{
			memcpy(&Value, &value, OperandSizeToValue(size));
		}
	};

	CRC crc, crc2;
	OperandSize os;
	OpcodeCryptor *cryptor;
	std::vector<OpcodeCryptor *> cryptor_list;
	std::vector<IVMCommand *> correct_command_list = block.correct_command_list();
	for (i = 0; i < correct_command_list.size(); i++) {
		IntelVMCommand *vm_command = reinterpret_cast<IntelVMCommand *>(correct_command_list[i]);
		IntelCommand *command = reinterpret_cast<IntelCommand *>(vm_command->owner());
		IntelVMCommand *ext_vm_entry = command->ext_vm_entry();
		bool use_ext_entry = ext_vm_entry && command->IndexOf(vm_command) < command->IndexOf(ext_vm_entry);

		size_t n = func->IndexOf(command) + 1;
		for (size_t r = n; r > block.start_index(); r--) {
			IntelCommand *cur_command = func->item(r - 1);
			if ((cur_command->section_options() & rtBeginSection) == 0)
				continue;

			crc.Value = cur_command->vm_address();
			crc2.Value = use_ext_entry ? command->ext_vm_address() : func->item(n)->vm_address();

			for (j = r - 1; j < n ; j++) {
				IntelCommand *tmp_command = func->item(j);
				for (k = 0; k < tmp_command->count(); k++) {
					IntelVMCommand *cur_vm_command = tmp_command->item(k);

					cryptor_list = GetOpcodeCryptorList(cur_vm_command);
					d = 0;
					for (c = 0; c < cryptor_list.size(); c++) {
						cryptor = cryptor_list[c];
						os = cryptor->size();
						crc.SetValue(os, cryptor->EncryptOpcode(crc.GetValue(os), cur_vm_command->dump_value(os, d)));
						d += OperandSizeToValue(os);
					}

					if (vm_command == cur_vm_command)
						break;
				}
			}

			size_t e = use_ext_entry ? command->IndexOf(ext_vm_entry) : command->count();

			for (k = e; k > 0; k--) {
				IntelVMCommand *cur_vm_command = command->item(k - 1);
				if (vm_command == cur_vm_command)
					break;

				cryptor_list = GetOpcodeCryptorList(cur_vm_command);
				d = cur_vm_command->dump_size();
				for (c = cryptor_list.size(); c > 0; c--) {
					cryptor = cryptor_list[c - 1];
					os = cryptor->size();
					crc2.SetValue(os, cryptor->DecryptOpcode(crc2.GetValue(os), cur_vm_command->dump_value(os, d - OperandSizeToValue(os))));
					d -= OperandSizeToValue(os);
				}
			}

			break;
		}

		if (type() == vtAdvanced) {
			j = (vm_command->options() & voBeginOffset) ? 4 : 0;
		} else {
			j = 1;
		}
		cryptor = vm_command->opcode()->value_cryptor();
		vm_command->set_dump_value(vm_command->size(), j, cryptor->EncryptOpcode(cryptor->DecryptOpcode(vm_command->dump_value(vm_command->size(), j), crc.Value), crc2.Value));
	}

	for (i = block.start_index(); i <= block.end_index(); i++) {
		IntelCommand *command = func->item(i);
		uint64_t address = command->vm_address();
		if (command->section_options() & rtBeginSection)
			crc.Value = command->vm_address();
		for (j = 0; j < command->count(); j++) {
			IntelVMCommand *vm_command = command->item(j);
			if (vm_command->is_data())
				continue;

			cryptor_list = GetOpcodeCryptorList(vm_command);
			d = 0;
			for (c = 0; c < cryptor_list.size(); c++) {
				cryptor = cryptor_list[c];
				os = cryptor->size();
				uint64_t old_value = vm_command->dump_value(os, d);
				vm_command->set_dump_value(os, d, cryptor->DecryptOpcode(cryptor->Decrypt(old_value), crc.Value));
				crc.SetValue(os, cryptor->EncryptOpcode(crc.Value, old_value));
				d += OperandSizeToValue(os);
			}

			if (vm_command->is_end()) {
				if (command->section_options() & rtBackwardDirection) {
					crc.Value = address - vm_command->dump_size();
				} else {
					crc.Value = address + vm_command->dump_size();
				}
			}

			if (command->section_options() & rtBackwardDirection) {
				address -= vm_command->dump_size();
			} else {
				address += vm_command->dump_size();
			}
		}
	}
}

void IntelVirtualMachine::AddExtJmpCommand(uint8_t id)
{
	IntelOpcodeInfo *opcode = GetOpcode(cmJmp, otNone, processor_->cpu_address_size(), id);
	if (!opcode)
		throw std::runtime_error("Runtime error at AddExtJmpCommand");
	if (type_ == vtAdvanced) {
		ext_jmp_command_ = new IntelCommand(NULL, processor_->cpu_address_size());
		ext_jmp_command_->set_address(opcode->entry()->address());
	}
	IntelOpcodeInfo *ext_jmp_opcode = opcode_list_.Add(cmJmp, otNone, processor_->cpu_address_size(), 0xff, (type() == vtAdvanced) ? ext_jmp_command_ : opcode->entry());
	ext_jmp_opcode->set_opcode(opcode->opcode());
	opcode_stack_[ext_jmp_opcode->Key()].push_back(ext_jmp_opcode);
}

/**
 * IntelVirtualMachineList
 */

IntelVirtualMachineList::IntelVirtualMachineList()
	: IVirtualMachineList()
{
	crc_manager_ = new MemoryManager(NULL);
}

IntelVirtualMachineList::~IntelVirtualMachineList()
{
	delete crc_manager_;
}

IntelVirtualMachineList *IntelVirtualMachineList::Clone() const
{
	IntelVirtualMachineList *list = new IntelVirtualMachineList();
	return list;
}

void IntelVirtualMachineList::Prepare(const CompileContext &ctx)
{
	size_t i;
	IntelOpcodeList visible_opcode_list;
	OperandSize cpu_address_size = ctx.file->cpu_address_size();

	VirtualMachineType type =
#ifdef DEMO
		true
#else
		((ctx.options.flags & cpUnregisteredVersion) != 0 || ((ctx.options.vm_flags & 1) != 0))
#endif	
		? vtClassic : vtAdvanced;

	if (ctx.runtime) {
		visible_opcode_list.Add(cmCall, otNone, cpu_address_size, 0);
		visible_opcode_list.Add(cmCpuid, otNone, cpu_address_size, 0);
		visible_opcode_list.Add(cmCrc, otNone, cpu_address_size, 0);
	}

	if (ctx.options.flags & cpMemoryProtection) {
		visible_opcode_list.Add(cmRdtsc, otNone, cpu_address_size, 0);
		visible_opcode_list.Add(cmDiv, otNone, osDWord, true);
		visible_opcode_list.Add(cmMul, otNone, osDWord, true);
	}

	IntelCommandInfoList command_info_list(cpu_address_size);

	size_t n = ctx.runtime ? 2 : 1;
	for (size_t k = 0; k < n; k++) {
		IntelFunctionList *function_list = (k == 0) ? reinterpret_cast<IntelFunctionList *>(ctx.file->function_list()) : reinterpret_cast<IntelFunctionList *>(ctx.runtime->function_list());

		for (size_t i = 0; i < function_list->count(); i++) {
			IntelFunction *func = function_list->item(i);

			if (func->compilation_type() == ctMutation || (k == 1 && func->tag() != ftLoader))
				continue;

			if (func->compilation_options() & coLockToKey)
				visible_opcode_list.Add(cmCall, otNone, cpu_address_size, 0);

			for (size_t j = 0; j < func->count(); j++) {
				IntelCommand *command = func->item(j);
				if (command->link() && command->link()->type() == ltNative)
					continue;

				if ((command->options() & roLockPrefix) && command->type() != cmXchg) {
					if (type == vtAdvanced) { //-V547
						bool native_found = true;
						switch (command->type()) {
						case cmAdd: case cmSub: case cmAnd: case cmOr: case cmXor: case cmXadd:
							if (command->operand(0).type & otMemory)
								native_found = false;
							break;
						}
						if (!native_found) {
							command->include_option(roNoNative);
							size_t n = (command->operand(0).type & otMemory) ? 0 : 1;
							visible_opcode_list.Add(static_cast<IntelCommandType>(command->type()), otMemory, command->operand(0).size, command->operand(n).effective_base_segment(command->base_segment()));
						}
					}
					continue;
				}
				else
					switch (command->type()) {
					case cmWait: case cmFchs: case cmFsqrt: case cmF2xm1:
					case cmFabs: case cmFclex: case cmFcos: case cmFdecstp:
					case cmFincstp: case cmFinit: case cmFldln2: case cmFldz:
					case cmFld1: case cmFldpi: case cmFpatan: case cmFprem:
					case cmFprem1: case cmFptan: case cmFrndint: case cmFsin:
					case cmFtst: case cmFyl2x: case cmFldlg2:
					case cmRdtsc: case cmPopf: case cmIret:
						visible_opcode_list.Add(static_cast<IntelCommandType>(command->type()), otNone, cpu_address_size, 0);
						break;

					case cmFild: case cmFld: case cmFadd: case cmFsub: case cmFsubr:
					case cmFstp: case cmFst: case cmFdiv: case cmFmul: case cmFcomp:
					case cmFistp: case cmFist: case cmFisub:
					case cmFstsw: case cmFldcw: case cmFstcw:
						visible_opcode_list.Add(static_cast<IntelCommandType>(command->type()), otNone, command->operand(0).size, 0);
						break;

					case cmDiv: case cmIdiv: case cmMul: case cmImul: case cmRcl: case cmRcr:
						visible_opcode_list.Add(static_cast<IntelCommandType>(command->type()), otNone, command->operand(0).size, true);
						break;

					case cmRet:
						if (command->options() & roFar)
							visible_opcode_list.Add(static_cast<IntelCommandType>(command->type()), otNone, cpu_address_size, 1);
						break;

					case cmCpuid:
						if (k == 1)
							visible_opcode_list.Add(static_cast<IntelCommandType>(command->type()), otNone, cpu_address_size, 0);
						break;

					case cmSyscall:
						if (k == 1)
							visible_opcode_list.Add(static_cast<IntelCommandType>(command->type()), otNone, cpu_address_size, 0);
						break;

					case cmXchg:
						if (((command->operand(0).type | command->operand(1).type) & otMemory) && type == vtAdvanced) {
							command->include_option(roNoNative);
							size_t n = (command->operand(0).type & otMemory) ? 0 : 1;
							visible_opcode_list.Add(static_cast<IntelCommandType>(command->type()), otMemory, command->operand(0).size, command->operand(n).effective_base_segment(command->base_segment()));
						}
						break;
					}

				if (command->GetCommandInfo(command_info_list)) {
					for (size_t n = 0; n < command_info_list.count(); n++) {
						CommandInfo *command_info = command_info_list.item(n);
						IntelCommandType command_type = (command_info->type() == atRead) ? cmPush : cmPop;

						switch (command_info->operand_type()) {
						case otSegmentRegistr:
							visible_opcode_list.Add(command_type, command_info->operand_type(), osWord, command_info->value());
							break;
						case otControlRegistr:
						case otDebugRegistr:
							visible_opcode_list.Add(command_type, command_info->operand_type(), cpu_address_size, command_info->value());
							break;
						case otMemory:
							if (command_info->size() > cpu_address_size) {
								visible_opcode_list.Add(command_type, command_info->operand_type(), cpu_address_size, command_info->value());
								if (command_info->size() == osTByte)
									visible_opcode_list.Add(command_type, command_info->operand_type(), osWord, command_info->value());
							}
							else {
								visible_opcode_list.Add(command_type, command_info->operand_type(), command_info->size(), command_info->value());
							}
							break;
						}
					}
				}
			}
		}
	}

	IntelFunctionList *function_list = reinterpret_cast<IntelFunctionList *>(ctx.file->function_list());
	IntelVirtualMachineProcessor *processor = function_list->AddProcessor(cpu_address_size);
	for (i = 0; i < ctx.options.vm_count; i++) {
		IntelVirtualMachine *virtual_machine = new IntelVirtualMachine(this, type, (uint8_t)i + 1, processor);
		AddObject(virtual_machine);
		virtual_machine->Init(ctx, visible_opcode_list);
	}

	std::vector<IFunction *> processor_list = function_list->processor_list();
	for (i = 0; i < processor_list.size(); i++) {
		IFunction *func = processor_list[i];
		if (func->compilation_type() != ctMutation && func->cpu_address_size() != cpu_address_size) {
			IntelVirtualMachineProcessor *new_processor = function_list->AddProcessor(func->cpu_address_size());
			IntelVirtualMachine *virtual_machine = new IntelVirtualMachine(this, type, 1, new_processor);
			AddObject(virtual_machine);
			CompileContext new_ctx;
			new_ctx.options.vm_count = 1;
#ifndef DEMO
			new_ctx.options.flags = ctx.options.flags & (cpUnregisteredVersion | cpEncryptBytecode);
#endif
			new_ctx.file = ctx.file;
			visible_opcode_list.clear();
			visible_opcode_list.Add(cmRet, otNone, osQWord, 1);
			if (ctx.options.flags & cpMemoryProtection) {
				visible_opcode_list.Add(cmRdtsc, otNone, osQWord, 0);
				visible_opcode_list.Add(cmDiv, otNone, osDWord, true);
				visible_opcode_list.Add(cmMul, otNone, osDWord, true);
				visible_opcode_list.Add(cmCrc, otNone, osQWord, 0);
			}
			virtual_machine->Init(new_ctx, visible_opcode_list);
			break;
		}
	}
	
	for (i = 0; i < count(); i++) {
		item(i)->Prepare(ctx);
	}
}

uint64_t IntelVirtualMachineList::GetCRCValue(uint64_t &crc_address, size_t size)
{
	size_t i, j;

	if (map_.empty()) {
		std::set<IntelFunction *> processor_list;
		for (i = 0; i < count(); i++) {
			IntelFunction *processor = item(i)->processor();
			if (processor_list.find(processor) != processor_list.end())
				continue;

			processor_list.insert(processor);
			for (j = 0; j < processor->count(); j++) {
				IntelCommand *command = processor->item(j);
				if (command->options() & roNeedCRC)
					map_[command->address()] = command;
			}
		}
	}

	crc_address = crc_manager_->Alloc(size, mtReadable);
	if (!crc_address) {
		crc_manager_->clear();
		for (std::map<uint64_t, ICommand *>::const_iterator it = map_.begin(); it != map_.end(); it++) {
			ICommand *command = it->second;
			crc_manager_->Add(command->address(), command->dump_size(), mtReadable);
		}
		crc_manager_->Pack();
		crc_address = crc_manager_->Alloc(size, mtReadable);
	}

	if (crc_address) {
		std::map<uint64_t, ICommand *>::const_iterator it = map_.upper_bound(crc_address);
		if (it != map_.begin())
			it--;

		uint64_t address = crc_address;
		uint64_t value = 0;
		uint8_t *ptr = reinterpret_cast<uint8_t *>(&value);
		uint8_t *ptr_end = ptr + size;
		while (it != map_.end()) {
			ICommand *command = it->second;
			if (command->address() <= address && command->next_address() > address) {
				for (j = static_cast<size_t>(address - command->address()); j < command->dump_size(); j++) {
					*ptr = command->dump(j);
					ptr++;
					address++;
					if (ptr == ptr_end)
						return value;
				}
			}
			it++;
		}
	}

	throw std::runtime_error("Runtime error at GetCRCValue");
}

void IntelVirtualMachineList::ClearCRCMap()
{
	map_.clear();
	crc_manager_->clear();
}

/**
 * IntelOpcodeInfo
 */

IntelOpcodeInfo::IntelOpcodeInfo(IntelOpcodeList *owner, IntelCommandType command_type, OperandType operand_type, OperandSize size, uint8_t value, 
	IntelCommand *entry, OpcodeCryptor *value_cryptor, OpcodeCryptor *end_cryptor)
	: IObject(), owner_(owner), command_type_(command_type), operand_type_(operand_type), size_(size), value_(value), entry_(entry), 
	value_cryptor_(value_cryptor), end_cryptor_(end_cryptor), opcode_(0)
{

}

IntelOpcodeInfo::~IntelOpcodeInfo()
{
	if (owner_)
		owner_->RemoveObject(this);
}

uint64_t IntelOpcodeInfo::Key()
{
	return Key(command_type(), operand_type(), size(), value_);
}

uint64_t IntelOpcodeInfo::Key(IntelCommandType command_type, OperandType operand_type, OperandSize size, uint8_t value)
{
	union
	{
		uint64_t result;
		struct  
		{
			uint32_t
				command_type:	10,
				operand_type:	14,
				value:			 8;
			uint32_t
				size:	 3,
				unused:	29;
		};
	} key;

	key.result = 0;

	assert(command_type < (1 << 10));
	key.command_type = command_type;
	assert(operand_type < (1 << 14));
	key.operand_type = operand_type;
	key.value = value;
	
	assert(size < (1 << 3));
	key.size = size;

	return key.result;
}

IntelOpcodeInfo *IntelOpcodeInfo::circular_queue::Next()
{
	IntelOpcodeInfo *res = NULL;
	if (size())
		res = this->operator[](position_++ % size());
	return res;
}

/**
 * IntelOpcodeInfoList
 */

IntelOpcodeList::IntelOpcodeList()
	: ObjectList<IntelOpcodeInfo>()
{

}

IntelOpcodeInfo *IntelOpcodeList::Add(IntelCommandType command_type, OperandType operand_type, OperandSize size, uint8_t value, IntelCommand *entry, OpcodeCryptor *value_cryptor, OpcodeCryptor *end_cryptor)
{
	if (!entry && GetOpcodeInfo(command_type, operand_type, size, value))
		return NULL;

	IntelOpcodeInfo *opcode = new IntelOpcodeInfo(this, command_type, operand_type, size, value, entry, value_cryptor, end_cryptor);
	AddObject(opcode);
	return opcode;
}

IntelOpcodeInfo *IntelOpcodeList::GetOpcodeInfo(IntelCommandType command_type, OperandType operand_type, OperandSize size, uint8_t value) const
{
	for (size_t i = 0; i < count(); i++) {
		IntelOpcodeInfo *opcode = item(i);
		if (opcode->command_type() == command_type && opcode->operand_type() == operand_type && opcode->size() == size && opcode->value() == value)
			return opcode;
	}
	return NULL;
}

/**
 * IntelVirtualMachineProcessor
 */

IntelVirtualMachineProcessor::IntelVirtualMachineProcessor(IntelFunctionList *owner, OperandSize cpu_address_size)
	: IntelFunction(owner, cpu_address_size)
{
	set_compilation_type(ctMutation);
	set_tag(ftProcessor);
}

bool IntelVirtualMachineProcessor::Prepare(const CompileContext &ctx)
{
	if (cpu_address_size() == ctx.file->cpu_address_size() && ctx.file->runtime_function_list())
		AddExceptionHandler(ctx);

	for (size_t i = 0; i < count(); i++) {
		IntelCommand *command = item(i);
		command->CompileToNative();
	}

	return IntelFunction::Prepare(ctx);
}

void IntelVirtualMachineProcessor::AddExceptionHandler(const CompileContext &ctx)
{
	size_t c = count();
	if (c == 0)
		return;

	switch (ctx.file->calling_convention()) {
	case ccMSx64:
		{
			// RCX: ExceptionRecord
			// RDX: EstablisherFrame
			// R8: ContextRecord
			// R9: DispatcherContext

			IntelCommand *command;
			size_t i, k;
			size_t context_registr_count = ((cpu_address_size() == osQWord) ? 24 : 16) + 8;

			IntelCommand *empty_unwind_command = AddCommand(cmRet);
			empty_unwind_command->include_option(roCreateNewBlock);

			IntelCommand *handler_entry = AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEAX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEDX, (context_registr_count - 8 + 0) * OperandSizeToValue(cpu_address_size())));
			AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regECX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEDX, (context_registr_count - 8 + 1) * OperandSizeToValue(cpu_address_size())));

			AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size(), regECX), IntelOperand(otValue, cpu_address_size(), 0, 8));
			AddCommand(cmMov, IntelOperand(otMemory | otRegistr, cpu_address_size(), regECX), IntelOperand(otRegistr, cpu_address_size(), regEAX));

			command = AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size(), regEDX), IntelOperand(otValue, cpu_address_size(), 0, (context_registr_count - 8 + 6) * OperandSizeToValue(cpu_address_size())));
			command = AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size(), regEAX), IntelOperand(otMemory | otValue, cpu_address_size(), 0, 0, LARGE_VALUE));
			command->AddLink(1, ltOffset, empty_unwind_command);
			IntelCommand *cmp_command = AddCommand(cmCmp, IntelOperand(otRegistr, cpu_address_size(), regECX), IntelOperand(otRegistr, cpu_address_size(), regEDX));
			IntelCommand *jmp_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
			jmp_command->set_flags(fl_C | fl_Z);
			jmp_command->AddLink(0, ltJmpWithFlag);
			AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size(), regECX), IntelOperand(otValue, cpu_address_size(), 0, 8));
			AddCommand(cmMov, IntelOperand(otMemory | otRegistr, cpu_address_size(), regECX), IntelOperand(otRegistr, cpu_address_size(), regEAX));
			command = AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size()));
			command->AddLink(0, ltJmp, cmp_command);

			command = AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regECX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regR9, 0x28)); // DISPATCHER_CONTEXT.ContextRecord
			jmp_command->link()->set_to_command(command);
			AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEAX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regECX, offsetof(CONTEXT64, Rsp)));
			AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEAX), IntelOperand(otMemory | otRegistr, cpu_address_size(), regEAX));
			AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regECX, offsetof(CONTEXT64, Rip)), IntelOperand(otRegistr, cpu_address_size(), regEAX));

			command = AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, ExceptionContinueSearch));
			AddCommand(cmRet);

			k = count();

			UNWIND_CODE unwind_code;
			std::vector<UNWIND_CODE> unwind_code_list;

			unwind_code.CodeOffset = 5;
			unwind_code.UnwindOp = UWOP_ALLOC_LARGE;
			unwind_code.OpInfo = 0;
			unwind_code_list.push_back(unwind_code);

			unwind_code.FrameOffset = (USHORT)(context_registr_count - 8 + 2);
			unwind_code_list.push_back(unwind_code);

			unwind_code.CodeOffset = 4;
			unwind_code.UnwindOp = UWOP_PUSH_NONVOL;
			unwind_code.OpInfo = regEBP;
			unwind_code_list.push_back(unwind_code);

			unwind_code.CodeOffset = 3;
			unwind_code.UnwindOp = UWOP_PUSH_NONVOL;
			unwind_code.OpInfo = regESI;
			unwind_code_list.push_back(unwind_code);

			unwind_code.CodeOffset = 2;
			unwind_code.UnwindOp = UWOP_PUSH_NONVOL;
			unwind_code.OpInfo = regEDI;
			unwind_code_list.push_back(unwind_code);

			unwind_code.CodeOffset = 1;
			unwind_code.UnwindOp = UWOP_PUSH_NONVOL;
			unwind_code.OpInfo = regEBX;
			unwind_code_list.push_back(unwind_code);

			UNWIND_INFO unwind_info = UNWIND_INFO();
			unwind_info.Version = 1;
			unwind_info.Flags = UNW_FLAG_EHANDLER;
			unwind_info.CountOfCodes = static_cast<uint8_t>(unwind_code_list.size());

			union UNWIND_INFO_HELPER {
				UNWIND_INFO info;
				uint32_t value;
			};

			UNWIND_INFO_HELPER unwind_info_helper;
			unwind_info_helper.info = unwind_info;

			// unwind data
			IntelCommand *unwind_data_command = AddCommand(osDWord, unwind_info_helper.value);
			unwind_data_command->include_option(roCreateNewBlock);
			unwind_data_command->set_alignment(OperandSizeToValue(osDWord));
			for (i = 0; i < unwind_code_list.size(); i++) {
				AddCommand(osWord, unwind_code_list[i].FrameOffset);
			}
			if (unwind_code_list.size() & 1)
				AddCommand(osWord, 0);

			// handler
			command = AddCommand(osDWord, 0);
			CommandLink *link = command->AddLink(0, ltOffset, handler_entry);
			link->set_sub_value(ctx.file->image_base());
			// handler data
			AddCommand(osDWord, 0);

			uint64_t info_address = owner()->IndexOf(this) * 10;
			FunctionInfo *info = function_info_list()->Add(info_address, info_address, btImageBase, 0, 0, unwind_info.FrameRegister, 0, unwind_data_command);
			AddressRange *address_range = info->Add(0, 0, NULL, NULL, NULL);
			for (i = 0; i < c; i++) {
				item(i)->set_address_range(address_range);
			}

			unwind_info = UNWIND_INFO();
			unwind_info.Version = 1;
			unwind_info.Flags = UNW_FLAG_NHANDLER;

			unwind_info_helper.info = unwind_info;
			unwind_data_command = AddCommand(osDWord, unwind_info_helper.value);
			unwind_data_command->include_option(roCreateNewBlock);
			unwind_data_command->set_alignment(OperandSizeToValue(osDWord));

			info = function_info_list()->Add(info_address + 1, info_address + 1, btImageBase, 0, 0, 0, 0, unwind_data_command);
			address_range = info->Add(0, 0, NULL, NULL, NULL);
			empty_unwind_command->set_address_range(address_range);

			unwind_info = UNWIND_INFO();
			unwind_info.Version = 1;
			unwind_info.Flags = UNW_FLAG_NHANDLER;

			unwind_info_helper.info = unwind_info;
			unwind_data_command = AddCommand(osDWord, unwind_info_helper.value);
			unwind_data_command->include_option(roCreateNewBlock);
			unwind_data_command->set_alignment(OperandSizeToValue(osDWord));

			info = function_info_list()->Add(info_address + 2, info_address + 2, btImageBase, 0, 0, 0, 0, unwind_data_command);
			address_range = info->Add(0, 0, NULL, NULL, NULL);
			for (i = IndexOf(handler_entry); i < k; i++) {
				item(i)->set_address_range(address_range);
			}
		}
		break;
	}
}

/**
 * IntelVMCommand
 */

IntelVMCommand::IntelVMCommand(IntelCommand *owner, IntelCommandType command_type, OperandType operand_type, OperandSize size, uint64_t value, uint32_t options)
	: BaseVMCommand(owner), address_(0), command_type_(command_type), operand_type_(operand_type), size_(size), value_(0), registr_(0), subtype_(0), base_segment_(segDefault), options_(options),
	crypt_command_(cmUnknown), crypt_size_(osDefault), crypt_key_(0), link_command_(NULL), opcode_(NULL), sub_value_(0), fixup_(NULL)
{
	switch (operand_type_) { //-V719
	case otBaseRegistr:
	case otRegistr:
	case otHiPartRegistr:
	case otSegmentRegistr:
	case otDebugRegistr:
	case otControlRegistr:
		registr_ = static_cast<uint8_t>(value);
		break;
	case otValue:
		value_ = value;
		break;
	case otMemory:
		base_segment_ = static_cast<IntelSegment>(value);
		break;
	case otNone:
		subtype_ = static_cast<uint8_t>(value);
		break;
	}
};

IntelVMCommand::IntelVMCommand(IntelCommand *owner, const IntelVMCommand &src)
	: BaseVMCommand(owner), address_(0), link_command_(NULL)
{
	command_type_ = src.command_type_;
	operand_type_ = src.operand_type_;
	size_ = src.size_;
	value_ = src.value_;
	registr_ = src.registr_;
	subtype_ = src.subtype_;
	base_segment_ = src.base_segment_;
	options_ = src.options_;
	crypt_command_ = src.crypt_command_;
	crypt_size_ = src.crypt_size_;
	crypt_key_ = src.crypt_key_;
	dump_ = src.dump_;
	opcode_ = src.opcode_;
	sub_value_ = src.sub_value_;
	fixup_ = src.fixup_;
}

IntelVMCommand *IntelVMCommand::Clone(IntelCommand *owner)
{
	IntelVMCommand *vm_command = new IntelVMCommand(owner, *this);
	return vm_command;
}

void IntelVMCommand::WriteToFile(IArchitecture &file)
{
	if (!dump_.size())
		return;

	if (fixup_) {
		if (fixup_ == NEED_FIXUP) {
			ISection *segment = file.segment_list()->GetSectionByAddress(address_);
			fixup_ = file.fixup_list()->AddDefault(file.cpu_address_size(), segment && (segment->memory_type() & mtExecutable) != 0);
		}
		fixup_->set_address(address_);
	}

	if (owner()->section_options() & rtBackwardDirection) {
		for (size_t i = dump_.size(); i > 0; i--) {
			file.WriteByte(dump_[i - 1]);
		}
	} else {
		file.Write(dump_.data(), dump_.size());
	}
}

int IntelVMCommand::GetStackLevel() const
{
	int res = 0;
	OperandSize cpu_address_size = reinterpret_cast<IntelCommand *>(owner())->size();

	switch (command_type_) {
	case cmPush:
		if (operand_type_ == otMemory)
			res -= OperandSizeToStack(cpu_address_size);
		res += OperandSizeToStack(size_);
		break;
	case cmPop:
		if (operand_type_ == otMemory)
			res -= OperandSizeToStack(cpu_address_size);
		res -= OperandSizeToStack(size_);
		break;
	case cmJmp:
		res -= OperandSizeToStack(size_);
		break;
	case cmNor: case cmNand:
		res -= OperandSizeToStack(size_);
		res += OperandSizeToStack(cpu_address_size);
		break;
	case cmShl: case cmShr: case cmRcl: case cmRcr:
		res -= OperandSizeToStack(osWord);
		res += OperandSizeToStack(cpu_address_size);
		break;
	case cmPopf:
		res -= OperandSizeToStack(cpu_address_size);
		break;
	case cmShld: case cmShrd:
		res -= OperandSizeToStack(size_);
		res -= OperandSizeToStack(osWord);
		res += OperandSizeToStack(cpu_address_size);
		break;
	case cmDiv: case cmIdiv: case cmMul: case cmImul:
		if (size_ == osByte)
			res -= OperandSizeToStack(size_);
		res += OperandSizeToStack(cpu_address_size);
		break;
	case cmRdtsc:
		res -= OperandSizeToStack(osDWord) * 2;
		break;
	case cmCpuid:
		res -= OperandSizeToStack(osDWord);
		res += OperandSizeToStack(osDWord) * 4;
		break;
	case cmCall: case cmSyscall:
		res -= OperandSizeToStack(cpu_address_size) * subtype_;
		break;
	case cmCrc:
		res -= OperandSizeToStack(cpu_address_size) * 2;
		res += OperandSizeToStack(osDWord);
		break;
	case cmAnd: case cmSub: case cmAdd: case cmOr: case cmXor: case cmXchg: case cmXadd:
		if (operand_type_ == otMemory) {
			res -= OperandSizeToStack(size_);
			res -= OperandSizeToStack(cpu_address_size);
			if (command_type_ == cmXchg)
				res += OperandSizeToStack(size_);
			else {
				res += OperandSizeToStack(cpu_address_size);
				if (command_type_ == cmXadd)
					res += OperandSizeToStack(size_);
			}
		} else {
			res -= OperandSizeToStack(size_);
			res += OperandSizeToStack(cpu_address_size);
		}
		break;
	}

	return res;
}

void IntelVMCommand::Compile()
{
	reinterpret_cast<IntelVirtualMachine *>(owner()->block()->virtual_machine())->CompileCommand(*this);
}

uint64_t IntelVMCommand::CorrectDumpValue(OperandSize size, uint64_t value) const
{
	if (owner()->section_options() & rtBackwardDirection) {
		switch (size) {
		case osWord:
			value = __builtin_bswap16(static_cast<uint16_t>(value));
			break;
		case osDWord:
			value = __builtin_bswap32(static_cast<uint32_t>(value));
			break;
		case osQWord:
			value = __builtin_bswap64(value);
			break;
		}
	}

	return value;
}

uint64_t IntelVMCommand::dump_value(OperandSize size, size_t pos) const
{
	if (pos + OperandSizeToValue(size) > dump_.size())
		throw std::runtime_error("Index out of bounds");
	uint64_t res = 0;
	memcpy(&res, &dump_[pos], OperandSizeToValue(size));
	return CorrectDumpValue(size, res);
}

void IntelVMCommand::set_dump_value(OperandSize size, size_t pos, uint64_t value)
{
	if (pos + OperandSizeToValue(size) > dump_.size())
		throw std::runtime_error("Index out of bounds");
	value = CorrectDumpValue(size, value);
	memcpy(&dump_[pos], &value, OperandSizeToValue(size));
}

bool IntelVMCommand::can_merge(CommandInfoList &command_info_list) const
{
	CommandInfo *command_info;
	switch (command_type_) {
	case cmPush:
		switch (operand_type_) {
		case otRegistr:
			if (registr_ != regEmpty) {
				if (command_info_list.GetInfo(atWrite, otRegistr, registr_))
					return false;

				command_info = command_info_list.GetInfo(atWrite, otHiPartRegistr, registr_);
				if (command_info && size_ > command_info->size())
					return false;
			}
			break;

		case otHiPartRegistr:
			if (registr_ != regEmpty) {
				command_info = command_info_list.GetInfo(atWrite, otRegistr, registr_);
				if (command_info && size_ < command_info->size())
					return false;

				command_info = command_info_list.GetInfo(atWrite, otHiPartRegistr, registr_);
				if (command_info && size_ == command_info->size())
					return false;
			}
			break;

		case otSegmentRegistr: case otControlRegistr: case otDebugRegistr:
			if (command_info_list.GetInfo(atWrite, operand_type_, registr_))
				return false;
			break;

		case otMemory:
			if (base_segment_ == segFS || base_segment_ == segGS)
				return false;

			if (command_info_list.GetInfo(atWrite, otMemory))
				return false;

			break;
		}
		break;

	case cmPop:
		switch (operand_type_) {
		case otRegistr:
			if (registr_ == regESP || (registr_ & regExtended))
				return false;
			if (registr_ != regEmpty) {
				for (size_t i = 0; i < command_info_list.count(); i++) {
					command_info = command_info_list.item(i);
					if (command_info->operand_type() == otRegistr && command_info->value() == registr_) {
						return false;
					} else  if (command_info->operand_type() == otHiPartRegistr && command_info->value() == registr_) {
						if (size_ > command_info->size())
							return false;
					}
				}
			}
			break;

		case otHiPartRegistr:
			if (registr_ == regESP)
				return false;
			if (registr_ != regEmpty) {
				for (size_t i = 0; i < command_info_list.count(); i++) {
					command_info = command_info_list.item(i);
					if (command_info->operand_type() == otRegistr && command_info->value() == registr_) {
						if (size_ < command_info->size())
							return false;
					} else if (command_info->operand_type() == otHiPartRegistr && command_info->value() == registr_) {
						if (size_ == command_info->size())
							return false;
					}
				}
			}
			break;

		case otSegmentRegistr: case otControlRegistr: case otDebugRegistr:
			return false;
			break;

		case otMemory:
			if (base_segment_ == segFS || base_segment_ == segGS)
				return false;

			if (command_info_list.GetInfo(otMemory))
				return false;

			break;
		}

		break;

	case cmPopf:
		if (command_info_list.GetInfo(atWrite, otRegistr, regEFX))
			return false;
		break;

	case cmF2xm1: case cmFabs: case cmFclex: case cmFcos: case cmFdecstp: case cmFincstp:
	case cmFinit: case cmFldln2: case cmFldlg2: case cmFprem: case cmFprem1: case cmFptan:
	case cmFrndint: case cmFsin: case cmFtst: case cmFyl2x: case cmFpatan: case cmFldz: case cmFld1: case cmFldpi:
	case cmWait: case cmFchs: case cmFsqrt: case cmFstsw: 
	case cmFistp: case cmFstp: case cmFst: case cmFist: case cmFadd: case cmFsub: case cmFisub: case cmFsubr: case cmFdiv: case cmFmul: case cmFcomp:
	case cmFild: case cmFld:
		if (command_info_list.GetInfo(otFPURegistr))
			return false;
		break;

	case cmAdd: case cmSub: case cmAnd: case cmXor: case cmOr: case cmXchg: case cmXadd:
		if (operand_type_ == otMemory) {
			if (base_segment_ == segFS || base_segment_ == segGS)
				return false;

			if (command_info_list.GetInfo(otMemory))
				return false;
		}
		break;
	}

	return true;
}

bool IntelVMCommand::is_end() const
{
	return (command_type_ == cmJmp || command_type_ == cmRet || command_type_ == cmIret);
}

IntelOperand::IntelOperand(uint32_t type_, OperandSize size_, uint8_t registr_ /*= 0*/, uint64_t value_ /*= 0*/, IFixup *fixup_ /*= NULL*/)
{
	Clear();

	if (type_ == (otMemory | otRegistr) && registr_ == regEBP) {
		type_ = otMemory | otBaseRegistr |otValue;
		registr_ <<= 4;
	}

	type = type_;
	size = size_;
	registr = registr_ & 0x0f;
	base_registr = (registr_ & 0xf0) >> 4;
	value = value_;
	if (fixup_ == LARGE_VALUE) {
		is_large_value = true;
		value_size = osDWord;
	} else if (fixup_) {
		fixup = fixup_;
		value_size = (fixup == NEED_FIXUP) ? size_ : fixup->size();
	} else if ((type & (otMemory | otValue)) == (otMemory | otValue) && (type & (otRegistr | otBaseRegistr))) {
		value_size = (ByteToInt64(static_cast<uint8_t>(value)) == value) ? osByte : osDWord;
	} else {
		value_size = size_;
	}
}// SPDX-License-Identifier: GPL-2.0+
/*
 * Module-based torture test facility for locking
 *
 * Copyright (C) IBM Corporation, 2014
 *
 * Authors: Paul E. McKenney <paulmck@linux.ibm.com>
 *          Davidlohr Bueso <dave@stgolabs.net>
 *	Based on kernel/rcu/torture.c.
 */

#define pr_fmt(fmt) fmt

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/kthread.h>
#include <linux/sched/rt.h>
#include <linux/spinlock.h>
#include <linux/mutex.h>
#include <linux/rwsem.h>
#include <linux/smp.h>
#include <linux/interrupt.h>
#include <linux/sched.h>
#include <uapi/linux/sched/types.h>
#include <linux/rtmutex.h>
#include <linux/atomic.h>
#include <linux/moduleparam.h>
#include <linux/delay.h>
#include <linux/slab.h>
#include <linux/torture.h>
#include <linux/reboot.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Paul E. McKenney <paulmck@linux.ibm.com>");

torture_param(int, acq_writer_lim, 0, "Write_acquisition time limit (jiffies).");
torture_param(int, call_rcu_chains, 0, "Self-propagate call_rcu() chains during test (0=disable).");
torture_param(int, long_hold, 100, "Do occasional long hold of lock (ms), 0=disable");
torture_param(int, nested_locks, 0, "Number of nested locks (max = 8)");
torture_param(int, nreaders_stress, -1, "Number of read-locking stress-test threads");
torture_param(int, nwriters_stress, -1, "Number of write-locking stress-test threads");
torture_param(int, onoff_holdoff, 0, "Time after boot before CPU hotplugs (s)");
torture_param(int, onoff_interval, 0, "Time between CPU hotplugs (s), 0=disable");
torture_param(int, rt_boost, 2,
		   "Do periodic rt-boost. 0=Disable, 1=Only for rt_mutex, 2=For all lock types.");
torture_param(int, rt_boost_factor, 50, "A factor determining how often rt-boost happens.");
torture_param(int, shuffle_interval, 3, "Number of jiffies between shuffles, 0=disable");
torture_param(int, shutdown_secs, 0, "Shutdown time (j), <= zero to disable.");
torture_param(int, stat_interval, 60, "Number of seconds between stats printk()s");
torture_param(int, stutter, 5, "Number of jiffies to run/halt test, 0=disable");
torture_param(int, verbose, 1, "Enable verbose debugging printk()s");
torture_param(int, writer_fifo, 0, "Run writers at sched_set_fifo() priority");
/* Going much higher trips "BUG: MAX_LOCKDEP_CHAIN_HLOCKS too low!" errors */
#define MAX_NESTED_LOCKS 8

static char *torture_type = IS_ENABLED(CONFIG_PREEMPT_RT) ? "raw_spin_lock" : "spin_lock";
module_param(torture_type, charp, 0444);
MODULE_PARM_DESC(torture_type,
		 "Type of lock to torture (spin_lock, spin_lock_irq, mutex_lock, ...)");

static cpumask_var_t bind_readers; // Bind the readers to the specified set of CPUs.
static cpumask_var_t bind_writers; // Bind the writers to the specified set of CPUs.

// Parse a cpumask kernel parameter.  If there are more users later on,
// this might need to got to a more central location.
static int param_set_cpumask(const char *val, const struct kernel_param *kp)
{
	cpumask_var_t *cm_bind = kp->arg;
	int ret;
	char *s;

	if (!alloc_cpumask_var(cm_bind, GFP_KERNEL)) {
		s = "Out of memory";
		ret = -ENOMEM;
		goto out_err;
	}
	ret = cpulist_parse(val, *cm_bind);
	if (!ret)
		return ret;
	s = "Bad CPU range";
out_err:
	pr_warn("%s: %s, all CPUs set\n", kp->name, s);
	cpumask_setall(*cm_bind);
	return ret;
}

// Output a cpumask kernel parameter.
static int param_get_cpumask(char *buffer, const struct kernel_param *kp)
{
	cpumask_var_t *cm_bind = kp->arg;

	return sprintf(buffer, "%*pbl", cpumask_pr_args(*cm_bind));
}

static bool cpumask_nonempty(cpumask_var_t mask)
{
	return cpumask_available(mask) && !cpumask_empty(mask);
}

static const struct kernel_param_ops lt_bind_ops = {
	.set = param_set_cpumask,
	.get = param_get_cpumask,
};

module_param_cb(bind_readers, &lt_bind_ops, &bind_readers, 0644);
module_param_cb(bind_writers, &lt_bind_ops, &bind_writers, 0644);

long torture_sched_setaffinity(pid_t pid, const struct cpumask *in_mask);

static struct task_struct *stats_task;
static struct task_struct **writer_tasks;
static struct task_struct **reader_tasks;

static bool lock_is_write_held;
static atomic_t lock_is_read_held;
static unsigned long last_lock_release;

struct lock_stress_stats {
	long n_lock_fail;
	long n_lock_acquired;
};

struct call_rcu_chain {
	struct rcu_head crc_rh;
	bool crc_stop;
};
struct call_rcu_chain *call_rcu_chain;

/* Forward reference. */
static void lock_torture_cleanup(void);

/*
 * Operations vector for selecting different types of tests.
 */
struct lock_torture_ops {
	void (*init)(void);
	void (*exit)(void);
	int (*nested_lock)(int tid, u32 lockset);
	int (*writelock)(int tid);
	void (*write_delay)(struct torture_random_state *trsp);
	void (*task_boost)(struct torture_random_state *trsp);
	void (*writeunlock)(int tid);
	void (*nested_unlock)(int tid, u32 lockset);
	int (*readlock)(int tid);
	void (*read_delay)(struct torture_random_state *trsp);
	void (*readunlock)(int tid);

	unsigned long flags; /* for irq spinlocks */
	const char *name;
};

struct lock_torture_cxt {
	int nrealwriters_stress;
	int nrealreaders_stress;
	bool debug_lock;
	bool init_called;
	atomic_t n_lock_torture_errors;
	struct lock_torture_ops *cur_ops;
	struct lock_stress_stats *lwsa; /* writer statistics */
	struct lock_stress_stats *lrsa; /* reader statistics */
};
static struct lock_torture_cxt cxt = { 0, 0, false, false,
				       ATOMIC_INIT(0),
				       NULL, NULL};
/*
 * Definitions for lock torture testing.
 */

static int torture_lock_busted_write_lock(int tid __maybe_unused)
{
	return 0;  /* BUGGY, do not use in real life!!! */
}

static void torture_lock_busted_write_delay(struct torture_random_state *trsp)
{
	/* We want a long delay occasionally to force massive contention.  */
	if (long_hold && !(torture_random(trsp) % (cxt.nrealwriters_stress * 2000 * long_hold)))
		mdelay(long_hold);
	if (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))
		torture_preempt_schedule();  /* Allow test to be preempted. */
}

static void torture_lock_busted_write_unlock(int tid __maybe_unused)
{
	  /* BUGGY, do not use in real life!!! */
}

static void __torture_rt_boost(struct torture_random_state *trsp)
{
	const unsigned int factor = rt_boost_factor;

	if (!rt_task(current)) {
		/*
		 * Boost priority once every rt_boost_factor operations. When
		 * the task tries to take the lock, the rtmutex it will account
		 * for the new priority, and do any corresponding pi-dance.
		 */
		if (trsp && !(torture_random(trsp) %
			      (cxt.nrealwriters_stress * factor))) {
			sched_set_fifo(current);
		} else /* common case, do nothing */
			return;
	} else {
		/*
		 * The task will remain boosted for another 10 * rt_boost_factor
		 * operations, then restored back to its original prio, and so
		 * forth.
		 *
		 * When @trsp is nil, we want to force-reset the task for
		 * stopping the kthread.
		 */
		if (!trsp || !(torture_random(trsp) %
			       (cxt.nrealwriters_stress * factor * 2))) {
			sched_set_normal(current, 0);
		} else /* common case, do nothing */
			return;
	}
}

static void torture_rt_boost(struct torture_random_state *trsp)
{
	if (rt_boost != 2)
		return;

	__torture_rt_boost(trsp);
}

static struct lock_torture_ops lock_busted_ops = {
	.writelock	= torture_lock_busted_write_lock,
	.write_delay	= torture_lock_busted_write_delay,
	.task_boost     = torture_rt_boost,
	.writeunlock	= torture_lock_busted_write_unlock,
	.readlock       = NULL,
	.read_delay     = NULL,
	.readunlock     = NULL,
	.name		= "lock_busted"
};

static DEFINE_SPINLOCK(torture_spinlock);

static int torture_spin_lock_write_lock(int tid __maybe_unused)
__acquires(torture_spinlock)
{
	spin_lock(&torture_spinlock);
	return 0;
}

static void torture_spin_lock_write_delay(struct torture_random_state *trsp)
{
	const unsigned long shortdelay_us = 2;
	unsigned long j;

	/* We want a short delay mostly to emulate likely code, and
	 * we want a long delay occasionally to force massive contention.
	 */
	if (long_hold && !(torture_random(trsp) % (cxt.nrealwriters_stress * 2000 * long_hold))) {
		j = jiffies;
		mdelay(long_hold);
		pr_alert("%s: delay = %lu jiffies.\n", __func__, jiffies - j);
	}
	if (!(torture_random(trsp) % (cxt.nrealwriters_stress * 200 * shortdelay_us)))
		udelay(shortdelay_us);
	if (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))
		torture_preempt_schedule();  /* Allow test to be preempted. */
}

static void torture_spin_lock_write_unlock(int tid __maybe_unused)
__releases(torture_spinlock)
{
	spin_unlock(&torture_spinlock);
}

static struct lock_torture_ops spin_lock_ops = {
	.writelock	= torture_spin_lock_write_lock,
	.write_delay	= torture_spin_lock_write_delay,
	.task_boost     = torture_rt_boost,
	.writeunlock	= torture_spin_lock_write_unlock,
	.readlock       = NULL,
	.read_delay     = NULL,
	.readunlock     = NULL,
	.name		= "spin_lock"
};

static int torture_spin_lock_write_lock_irq(int tid __maybe_unused)
__acquires(torture_spinlock)
{
	unsigned long flags;

	spin_lock_irqsave(&torture_spinlock, flags);
	cxt.cur_ops->flags = flags;
	return 0;
}

static void torture_lock_spin_write_unlock_irq(int tid __maybe_unused)
__releases(torture_spinlock)
{
	spin_unlock_irqrestore(&torture_spinlock, cxt.cur_ops->flags);
}

static struct lock_torture_ops spin_lock_irq_ops = {
	.writelock	= torture_spin_lock_write_lock_irq,
	.write_delay	= torture_spin_lock_write_delay,
	.task_boost     = torture_rt_boost,
	.writeunlock	= torture_lock_spin_write_unlock_irq,
	.readlock       = NULL,
	.read_delay     = NULL,
	.readunlock     = NULL,
	.name		= "spin_lock_irq"
};

static DEFINE_RAW_SPINLOCK(torture_raw_spinlock);

static int torture_raw_spin_lock_write_lock(int tid __maybe_unused)
__acquires(torture_raw_spinlock)
{
	raw_spin_lock(&torture_raw_spinlock);
	return 0;
}

static void torture_raw_spin_lock_write_unlock(int tid __maybe_unused)
__releases(torture_raw_spinlock)
{
	raw_spin_unlock(&torture_raw_spinlock);
}

static struct lock_torture_ops raw_spin_lock_ops = {
	.writelock	= torture_raw_spin_lock_write_lock,
	.write_delay	= torture_spin_lock_write_delay,
	.task_boost	= torture_rt_boost,
	.writeunlock	= torture_raw_spin_lock_write_unlock,
	.readlock	= NULL,
	.read_delay	= NULL,
	.readunlock	= NULL,
	.name		= "raw_spin_lock"
};

static int torture_raw_spin_lock_write_lock_irq(int tid __maybe_unused)
__acquires(torture_raw_spinlock)
{
	unsigned long flags;

	raw_spin_lock_irqsave(&torture_raw_spinlock, flags);
	cxt.cur_ops->flags = flags;
	return 0;
}

static void torture_raw_spin_lock_write_unlock_irq(int tid __maybe_unused)
__releases(torture_raw_spinlock)
{
	raw_spin_unlock_irqrestore(&torture_raw_spinlock, cxt.cur_ops->flags);
}

static struct lock_torture_ops raw_spin_lock_irq_ops = {
	.writelock	= torture_raw_spin_lock_write_lock_irq,
	.write_delay	= torture_spin_lock_write_delay,
	.task_boost	= torture_rt_boost,
	.writeunlock	= torture_raw_spin_lock_write_unlock_irq,
	.readlock	= NULL,
	.read_delay	= NULL,
	.readunlock	= NULL,
	.name		= "raw_spin_lock_irq"
};

static DEFINE_RWLOCK(torture_rwlock);

static int torture_rwlock_write_lock(int tid __maybe_unused)
__acquires(torture_rwlock)
{
	write_lock(&torture_rwlock);
	return 0;
}

static void torture_rwlock_write_delay(struct torture_random_state *trsp)
{
	const unsigned long shortdelay_us = 2;

	/* We want a short delay mostly to emulate likely code, and
	 * we want a long delay occasionally to force massive contention.
	 */
	if (long_hold && !(torture_random(trsp) % (cxt.nrealwriters_stress * 2000 * long_hold)))
		mdelay(long_hold);
	else
		udelay(shortdelay_us);
}

static void torture_rwlock_write_unlock(int tid __maybe_unused)
__releases(torture_rwlock)
{
	write_unlock(&torture_rwlock);
}

static int torture_rwlock_read_lock(int tid __maybe_unused)
__acquires(torture_rwlock)
{
	read_lock(&torture_rwlock);
	return 0;
}

static void torture_rwlock_read_delay(struct torture_random_state *trsp)
{
	const unsigned long shortdelay_us = 10;

	/* We want a short delay mostly to emulate likely code, and
	 * we want a long delay occasionally to force massive contention.
	 */
	if (long_hold && !(torture_random(trsp) % (cxt.nrealreaders_stress * 2000 * long_hold)))
		mdelay(long_hold);
	else
		udelay(shortdelay_us);
}

static void torture_rwlock_read_unlock(int tid __maybe_unused)
__releases(torture_rwlock)
{
	read_unlock(&torture_rwlock);
}

static struct lock_torture_ops rw_lock_ops = {
	.writelock	= torture_rwlock_write_lock,
	.write_delay	= torture_rwlock_write_delay,
	.task_boost     = torture_rt_boost,
	.writeunlock	= torture_rwlock_write_unlock,
	.readlock       = torture_rwlock_read_lock,
	.read_delay     = torture_rwlock_read_delay,
	.readunlock     = torture_rwlock_read_unlock,
	.name		= "rw_lock"
};

static int torture_rwlock_write_lock_irq(int tid __maybe_unused)
__acquires(torture_rwlock)
{
	unsigned long flags;

	write_lock_irqsave(&torture_rwlock, flags);
	cxt.cur_ops->flags = flags;
	return 0;
}

static void torture_rwlock_write_unlock_irq(int tid __maybe_unused)
__releases(torture_rwlock)
{
	write_unlock_irqrestore(&torture_rwlock, cxt.cur_ops->flags);
}

static int torture_rwlock_read_lock_irq(int tid __maybe_unused)
__acquires(torture_rwlock)
{
	unsigned long flags;

	read_lock_irqsave(&torture_rwlock, flags);
	cxt.cur_ops->flags = flags;
	return 0;
}

static void torture_rwlock_read_unlock_irq(int tid __maybe_unused)
__releases(torture_rwlock)
{
	read_unlock_irqrestore(&torture_rwlock, cxt.cur_ops->flags);
}

static struct lock_torture_ops rw_lock_irq_ops = {
	.writelock	= torture_rwlock_write_lock_irq,
	.write_delay	= torture_rwlock_write_delay,
	.task_boost     = torture_rt_boost,
	.writeunlock	= torture_rwlock_write_unlock_irq,
	.readlock       = torture_rwlock_read_lock_irq,
	.read_delay     = torture_rwlock_read_delay,
	.readunlock     = torture_rwlock_read_unlock_irq,
	.name		= "rw_lock_irq"
};

static DEFINE_MUTEX(torture_mutex);
static struct mutex torture_nested_mutexes[MAX_NESTED_LOCKS];
static struct lock_class_key nested_mutex_keys[MAX_NESTED_LOCKS];

static void torture_mutex_init(void)
{
	int i;

	for (i = 0; i < MAX_NESTED_LOCKS; i++)
		__mutex_init(&torture_nested_mutexes[i], __func__,
			     &nested_mutex_keys[i]);
}

static int torture_mutex_nested_lock(int tid __maybe_unused,
				     u32 lockset)
{
	int i;

	for (i = 0; i < nested_locks; i++)
		if (lockset & (1 << i))
			mutex_lock(&torture_nested_mutexes[i]);
	return 0;
}

static int torture_mutex_lock(int tid __maybe_unused)
__acquires(torture_mutex)
{
	mutex_lock(&torture_mutex);
	return 0;
}

static void torture_mutex_delay(struct torture_random_state *trsp)
{
	/* We want a long delay occasionally to force massive contention.  */
	if (long_hold && !(torture_random(trsp) % (cxt.nrealwriters_stress * 2000 * long_hold)))
		mdelay(long_hold * 5);
	if (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))
		torture_preempt_schedule();  /* Allow test to be preempted. */
}

static void torture_mutex_unlock(int tid __maybe_unused)
__releases(torture_mutex)
{
	mutex_unlock(&torture_mutex);
}

static void torture_mutex_nested_unlock(int tid __maybe_unused,
					u32 lockset)
{
	int i;

	for (i = nested_locks - 1; i >= 0; i--)
		if (lockset & (1 << i))
			mutex_unlock(&torture_nested_mutexes[i]);
}

static struct lock_torture_ops mutex_lock_ops = {
	.init		= torture_mutex_init,
	.nested_lock	= torture_mutex_nested_lock,
	.writelock	= torture_mutex_lock,
	.write_delay	= torture_mutex_delay,
	.task_boost     = torture_rt_boost,
	.writeunlock	= torture_mutex_unlock,
	.nested_unlock	= torture_mutex_nested_unlock,
	.readlock       = NULL,
	.read_delay     = NULL,
	.readunlock     = NULL,
	.name		= "mutex_lock"
};

#include <linux/ww_mutex.h>
/*
 * The torture ww_mutexes should belong to the same lock class as
 * torture_ww_class to avoid lockdep problem. The ww_mutex_init()
 * function is called for initialization to ensure that.
 */
static DEFINE_WD_CLASS(torture_ww_class);
static struct ww_mutex torture_ww_mutex_0, torture_ww_mutex_1, torture_ww_mutex_2;
static struct ww_acquire_ctx *ww_acquire_ctxs;

static void torture_ww_mutex_init(void)
{
	ww_mutex_init(&torture_ww_mutex_0, &torture_ww_class);
	ww_mutex_init(&torture_ww_mutex_1, &torture_ww_class);
	ww_mutex_init(&torture_ww_mutex_2, &torture_ww_class);

	ww_acquire_ctxs = kmalloc_array(cxt.nrealwriters_stress,
					sizeof(*ww_acquire_ctxs),
					GFP_KERNEL);
	if (!ww_acquire_ctxs)
		VERBOSE_TOROUT_STRING("ww_acquire_ctx: Out of memory");
}

static void torture_ww_mutex_exit(void)
{
	kfree(ww_acquire_ctxs);
}

static int torture_ww_mutex_lock(int tid)
__acquires(torture_ww_mutex_0)
__acquires(torture_ww_mutex_1)
__acquires(torture_ww_mutex_2)
{
	LIST_HEAD(list);
	struct reorder_lock {
		struct list_head link;
		struct ww_mutex *lock;
	} locks[3], *ll, *ln;
	struct ww_acquire_ctx *ctx = &ww_acquire_ctxs[tid];

	locks[0].lock = &torture_ww_mutex_0;
	list_add(&locks[0].link, &list);

	locks[1].lock = &torture_ww_mutex_1;
	list_add(&locks[1].link, &list);

	locks[2].lock = &torture_ww_mutex_2;
	list_add(&locks[2].link, &list);

	ww_acquire_init(ctx, &torture_ww_class);

	list_for_each_entry(ll, &list, link) {
		int err;

		err = ww_mutex_lock(ll->lock, ctx);
		if (!err)
			continue;

		ln = ll;
		list_for_each_entry_continue_reverse(ln, &list, link)
			ww_mutex_unlock(ln->lock);

		if (err != -EDEADLK)
			return err;

		ww_mutex_lock_slow(ll->lock, ctx);
		list_move(&ll->link, &list);
	}

	return 0;
}

static void torture_ww_mutex_unlock(int tid)
__releases(torture_ww_mutex_0)
__releases(torture_ww_mutex_1)
__releases(torture_ww_mutex_2)
{
	struct ww_acquire_ctx *ctx = &ww_acquire_ctxs[tid];

	ww_mutex_unlock(&torture_ww_mutex_0);
	ww_mutex_unlock(&torture_ww_mutex_1);
	ww_mutex_unlock(&torture_ww_mutex_2);
	ww_acquire_fini(ctx);
}

static struct lock_torture_ops ww_mutex_lock_ops = {
	.init		= torture_ww_mutex_init,
	.exit		= torture_ww_mutex_exit,
	.writelock	= torture_ww_mutex_lock,
	.write_delay	= torture_mutex_delay,
	.task_boost     = torture_rt_boost,
	.writeunlock	= torture_ww_mutex_unlock,
	.readlock       = NULL,
	.read_delay     = NULL,
	.readunlock     = NULL,
	.name		= "ww_mutex_lock"
};

#ifdef CONFIG_RT_MUTEXES
static DEFINE_RT_MUTEX(torture_rtmutex);
static struct rt_mutex torture_nested_rtmutexes[MAX_NESTED_LOCKS];
static struct lock_class_key nested_rtmutex_keys[MAX_NESTED_LOCKS];

static void torture_rtmutex_init(void)
{
	int i;

	for (i = 0; i < MAX_NESTED_LOCKS; i++)
		__rt_mutex_init(&torture_nested_rtmutexes[i], __func__,
				&nested_rtmutex_keys[i]);
}

static int torture_rtmutex_nested_lock(int tid __maybe_unused,
				       u32 lockset)
{
	int i;

	for (i = 0; i < nested_locks; i++)
		if (lockset & (1 << i))
			rt_mutex_lock(&torture_nested_rtmutexes[i]);
	return 0;
}

static int torture_rtmutex_lock(int tid __maybe_unused)
__acquires(torture_rtmutex)
{
	rt_mutex_lock(&torture_rtmutex);
	return 0;
}

static void torture_rtmutex_delay(struct torture_random_state *trsp)
{
	const unsigned long shortdelay_us = 2;

	/*
	 * We want a short delay mostly to emulate likely code, and
	 * we want a long delay occasionally to force massive contention.
	 */
	if (long_hold && !(torture_random(trsp) % (cxt.nrealwriters_stress * 2000 * long_hold)))
		mdelay(long_hold);
	if (!(torture_random(trsp) %
	      (cxt.nrealwriters_stress * 200 * shortdelay_us)))
		udelay(shortdelay_us);
	if (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))
		torture_preempt_schedule();  /* Allow test to be preempted. */
}

static void torture_rtmutex_unlock(int tid __maybe_unused)
__releases(torture_rtmutex)
{
	rt_mutex_unlock(&torture_rtmutex);
}

static void torture_rt_boost_rtmutex(struct torture_random_state *trsp)
{
	if (!rt_boost)
		return;

	__torture_rt_boost(trsp);
}

static void torture_rtmutex_nested_unlock(int tid __maybe_unused,
					  u32 lockset)
{
	int i;

	for (i = nested_locks - 1; i >= 0; i--)
		if (lockset & (1 << i))
			rt_mutex_unlock(&torture_nested_rtmutexes[i]);
}

static struct lock_torture_ops rtmutex_lock_ops = {
	.init		= torture_rtmutex_init,
	.nested_lock	= torture_rtmutex_nested_lock,
	.writelock	= torture_rtmutex_lock,
	.write_delay	= torture_rtmutex_delay,
	.task_boost     = torture_rt_boost_rtmutex,
	.writeunlock	= torture_rtmutex_unlock,
	.nested_unlock	= torture_rtmutex_nested_unlock,
	.readlock       = NULL,
	.read_delay     = NULL,
	.readunlock     = NULL,
	.name		= "rtmutex_lock"
};
#endif

static DECLARE_RWSEM(torture_rwsem);
static int torture_rwsem_down_write(int tid __maybe_unused)
__acquires(torture_rwsem)
{
	down_write(&torture_rwsem);
	return 0;
}

static void torture_rwsem_write_delay(struct torture_random_state *trsp)
{
	/* We want a long delay occasionally to force massive contention.  */
	if (long_hold && !(torture_random(trsp) % (cxt.nrealwriters_stress * 2000 * long_hold)))
		mdelay(long_hold * 10);
	if (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))
		torture_preempt_schedule();  /* Allow test to be preempted. */
}

static void torture_rwsem_up_write(int tid __maybe_unused)
__releases(torture_rwsem)
{
	up_write(&torture_rwsem);
}

static int torture_rwsem_down_read(int tid __maybe_unused)
__acquires(torture_rwsem)
{
	down_read(&torture_rwsem);
	return 0;
}

static void torture_rwsem_read_delay(struct torture_random_state *trsp)
{
	/* We want a long delay occasionally to force massive contention.  */
	if (long_hold && !(torture_random(trsp) % (cxt.nrealreaders_stress * 2000 * long_hold)))
		mdelay(long_hold * 2);
	else
		mdelay(long_hold / 2);
	if (!(torture_random(trsp) % (cxt.nrealreaders_stress * 20000)))
		torture_preempt_schedule();  /* Allow test to be preempted. */
}

static void torture_rwsem_up_read(int tid __maybe_unused)
__releases(torture_rwsem)
{
	up_read(&torture_rwsem);
}

static struct lock_torture_ops rwsem_lock_ops = {
	.writelock	= torture_rwsem_down_write,
	.write_delay	= torture_rwsem_write_delay,
	.task_boost     = torture_rt_boost,
	.writeunlock	= torture_rwsem_up_write,
	.readlock       = torture_rwsem_down_read,
	.read_delay     = torture_rwsem_read_delay,
	.readunlock     = torture_rwsem_up_read,
	.name		= "rwsem_lock"
};

#include <linux/percpu-rwsem.h>
static struct percpu_rw_semaphore pcpu_rwsem;

static void torture_percpu_rwsem_init(void)
{
	BUG_ON(percpu_init_rwsem(&pcpu_rwsem));
}

static void torture_percpu_rwsem_exit(void)
{
	percpu_free_rwsem(&pcpu_rwsem);
}

static int torture_percpu_rwsem_down_write(int tid __maybe_unused)
__acquires(pcpu_rwsem)
{
	percpu_down_write(&pcpu_rwsem);
	return 0;
}

static void torture_percpu_rwsem_up_write(int tid __maybe_unused)
__releases(pcpu_rwsem)
{
	percpu_up_write(&pcpu_rwsem);
}

static int torture_percpu_rwsem_down_read(int tid __maybe_unused)
__acquires(pcpu_rwsem)
{
	percpu_down_read(&pcpu_rwsem);
	return 0;
}

static void torture_percpu_rwsem_up_read(int tid __maybe_unused)
__releases(pcpu_rwsem)
{
	percpu_up_read(&pcpu_rwsem);
}

static struct lock_torture_ops percpu_rwsem_lock_ops = {
	.init		= torture_percpu_rwsem_init,
	.exit		= torture_percpu_rwsem_exit,
	.writelock	= torture_percpu_rwsem_down_write,
	.write_delay	= torture_rwsem_write_delay,
	.task_boost     = torture_rt_boost,
	.writeunlock	= torture_percpu_rwsem_up_write,
	.readlock       = torture_percpu_rwsem_down_read,
	.read_delay     = torture_rwsem_read_delay,
	.readunlock     = torture_percpu_rwsem_up_read,
	.name		= "percpu_rwsem_lock"
};

/*
 * Lock torture writer kthread.  Repeatedly acquires and releases
 * the lock, checking for duplicate acquisitions.
 */
static int lock_torture_writer(void *arg)
{
	unsigned long j;
	unsigned long j1;
	u32 lockset_mask;
	struct lock_stress_stats *lwsp = arg;
	DEFINE_TORTURE_RANDOM(rand);
	bool skip_main_lock;
	int tid = lwsp - cxt.lwsa;

	VERBOSE_TOROUT_STRING("lock_torture_writer task started");
	if (!rt_task(current))
		set_user_nice(current, MAX_NICE);

	do {
		if ((torture_random(&rand) & 0xfffff) == 0)
			schedule_timeout_uninterruptible(1);

		lockset_mask = torture_random(&rand);
		/*
		 * When using nested_locks, we want to occasionally
		 * skip the main lock so we can avoid always serializing
		 * the lock chains on that central lock. By skipping the
		 * main lock occasionally, we can create different
		 * contention patterns (allowing for multiple disjoint
		 * blocked trees)
		 */
		skip_main_lock = (nested_locks &&
				 !(torture_random(&rand) % 100));

		cxt.cur_ops->task_boost(&rand);
		if (cxt.cur_ops->nested_lock)
			cxt.cur_ops->nested_lock(tid, lockset_mask);

		if (!skip_main_lock) {
			if (acq_writer_lim > 0)
				j = jiffies;
			cxt.cur_ops->writelock(tid);
			if (WARN_ON_ONCE(lock_is_write_held))
				lwsp->n_lock_fail++;
			lock_is_write_held = true;
			if (WARN_ON_ONCE(atomic_read(&lock_is_read_held)))
				lwsp->n_lock_fail++; /* rare, but... */
			if (acq_writer_lim > 0) {
				j1 = jiffies;
				WARN_ONCE(time_after(j1, j + acq_writer_lim),
					  "%s: Lock acquisition took %lu jiffies.\n",
					  __func__, j1 - j);
			}
			lwsp->n_lock_acquired++;

			cxt.cur_ops->write_delay(&rand);

			lock_is_write_held = false;
			WRITE_ONCE(last_lock_release, jiffies);
			cxt.cur_ops->writeunlock(tid);
		}
		if (cxt.cur_ops->nested_unlock)
			cxt.cur_ops->nested_unlock(tid, lockset_mask);

		stutter_wait("lock_torture_writer");
	} while (!torture_must_stop());

	cxt.cur_ops->task_boost(NULL); /* reset prio */
	torture_kthread_stopping("lock_torture_writer");
	return 0;
}

/*
 * Lock torture reader kthread.  Repeatedly acquires and releases
 * the reader lock.
 */
static int lock_torture_reader(void *arg)
{
	struct lock_stress_stats *lrsp = arg;
	int tid = lrsp - cxt.lrsa;
	DEFINE_TORTURE_RANDOM(rand);

	VERBOSE_TOROUT_STRING("lock_torture_reader task started");
	set_user_nice(current, MAX_NICE);

	do {
		if ((torture_random(&rand) & 0xfffff) == 0)
			schedule_timeout_uninterruptible(1);

		cxt.cur_ops->readlock(tid);
		atomic_inc(&lock_is_read_held);
		if (WARN_ON_ONCE(lock_is_write_held))
			lrsp->n_lock_fail++; /* rare, but... */

		lrsp->n_lock_acquired++;
		cxt.cur_ops->read_delay(&rand);
		atomic_dec(&lock_is_read_held);
		cxt.cur_ops->readunlock(tid);

		stutter_wait("lock_torture_reader");
	} while (!torture_must_stop());
	torture_kthread_stopping("lock_torture_reader");
	return 0;
}

/*
 * Create an lock-torture-statistics message in the specified buffer.
 */
static void __torture_print_stats(char *page,
				  struct lock_stress_stats *statp, bool write)
{
	long cur;
	bool fail = false;
	int i, n_stress;
	long max = 0, min = statp ? data_race(statp[0].n_lock_acquired) : 0;
	long long sum = 0;

	n_stress = write ? cxt.nrealwriters_stress : cxt.nrealreaders_stress;
	for (i = 0; i < n_stress; i++) {
		if (data_race(statp[i].n_lock_fail))
			fail = true;
		cur = data_race(statp[i].n_lock_acquired);
		sum += cur;
		if (max < cur)
			max = cur;
		if (min > cur)
			min = cur;
	}
	page += sprintf(page,
			"%s:  Total: %lld  Max/Min: %ld/%ld %s  Fail: %d %s\n",
			write ? "Writes" : "Reads ",
			sum, max, min,
			!onoff_interval && max / 2 > min ? "???" : "",
			fail, fail ? "!!!" : "");
	if (fail)
		atomic_inc(&cxt.n_lock_torture_errors);
}

/*
 * Print torture statistics.  Caller must ensure that there is only one
 * call to this function at a given time!!!  This is normally accomplished
 * by relying on the module system to only have one copy of the module
 * loaded, and then by giving the lock_torture_stats kthread full control
 * (or the init/cleanup functions when lock_torture_stats thread is not
 * running).
 */
static void lock_torture_stats_print(void)
{
	int size = cxt.nrealwriters_stress * 200 + 8192;
	char *buf;

	if (cxt.cur_ops->readlock)
		size += cxt.nrealreaders_stress * 200 + 8192;

	buf = kmalloc(size, GFP_KERNEL);
	if (!buf) {
		pr_err("lock_torture_stats_print: Out of memory, need: %d",
		       size);
		return;
	}

	__torture_print_stats(buf, cxt.lwsa, true);
	pr_alert("%s", buf);
	kfree(buf);

	if (cxt.cur_ops->readlock) {
		buf = kmalloc(size, GFP_KERNEL);
		if (!buf) {
			pr_err("lock_torture_stats_print: Out of memory, need: %d",
			       size);
			return;
		}

		__torture_print_stats(buf, cxt.lrsa, false);
		pr_alert("%s", buf);
		kfree(buf);
	}
}

/*
 * Periodically prints torture statistics, if periodic statistics printing
 * was specified via the stat_interval module parameter.
 *
 * No need to worry about fullstop here, since this one doesn't reference
 * volatile state or register callbacks.
 */
static int lock_torture_stats(void *arg)
{
	VERBOSE_TOROUT_STRING("lock_torture_stats task started");
	do {
		schedule_timeout_interruptible(stat_interval * HZ);
		lock_torture_stats_print();
		torture_shutdown_absorb("lock_torture_stats");
	} while (!torture_must_stop());
	torture_kthread_stopping("lock_torture_stats");
	return 0;
}


static inline void
lock_torture_print_module_parms(struct lock_torture_ops *cur_ops,
				const char *tag)
{
	static cpumask_t cpumask_all;
	cpumask_t *rcmp = cpumask_nonempty(bind_readers) ? bind_readers : &cpumask_all;
	cpumask_t *wcmp = cpumask_nonempty(bind_writers) ? bind_writers : &cpumask_all;

	cpumask_setall(&cpumask_all);
	pr_alert("%s" TORTURE_FLAG
		 "--- %s%s: acq_writer_lim=%d bind_readers=%*pbl bind_writers=%*pbl call_rcu_chains=%d long_hold=%d nested_locks=%d nreaders_stress=%d nwriters_stress=%d onoff_holdoff=%d onoff_interval=%d rt_boost=%d rt_boost_factor=%d shuffle_interval=%d shutdown_secs=%d stat_interval=%d stutter=%d verbose=%d writer_fifo=%d\n",
		 torture_type, tag, cxt.debug_lock ? " [debug]": "",
		 acq_writer_lim, cpumask_pr_args(rcmp), cpumask_pr_args(wcmp),
		 call_rcu_chains, long_hold, nested_locks, cxt.nrealreaders_stress,
		 cxt.nrealwriters_stress, onoff_holdoff, onoff_interval, rt_boost,
		 rt_boost_factor, shuffle_interval, shutdown_secs, stat_interval, stutter,
		 verbose, writer_fifo);
}

// If requested, maintain call_rcu() chains to keep a grace period always
// in flight.  These increase the probability of getting an RCU CPU stall
// warning and associated diagnostics when a locking primitive stalls.

static void call_rcu_chain_cb(struct rcu_head *rhp)
{
	struct call_rcu_chain *crcp = container_of(rhp, struct call_rcu_chain, crc_rh);

	if (!smp_load_acquire(&crcp->crc_stop)) {
		(void)start_poll_synchronize_rcu(); // Start one grace period...
		call_rcu(&crcp->crc_rh, call_rcu_chain_cb); // ... and later start another.
	}
}

// Start the requested number of call_rcu() chains.
static int call_rcu_chain_init(void)
{
	int i;

	if (call_rcu_chains <= 0)
		return 0;
	call_rcu_chain = kcalloc(call_rcu_chains, sizeof(*call_rcu_chain), GFP_KERNEL);
	if (!call_rcu_chain)
		return -ENOMEM;
	for (i = 0; i < call_rcu_chains; i++) {
		call_rcu_chain[i].crc_stop = false;
		call_rcu(&call_rcu_chain[i].crc_rh, call_rcu_chain_cb);
	}
	return 0;
}

// Stop all of the call_rcu() chains.
static void call_rcu_chain_cleanup(void)
{
	int i;

	if (!call_rcu_chain)
		return;
	for (i = 0; i < call_rcu_chains; i++)
		smp_store_release(&call_rcu_chain[i].crc_stop, true);
	rcu_barrier();
	kfree(call_rcu_chain);
	call_rcu_chain = NULL;
}

static void lock_torture_cleanup(void)
{
	int i;

	if (torture_cleanup_begin())
		return;

	/*
	 * Indicates early cleanup, meaning that the test has not run,
	 * such as when passing bogus args when loading the module.
	 * However cxt->cur_ops.init() may have been invoked, so beside
	 * perform the underlying torture-specific cleanups, cur_ops.exit()
	 * will be invoked if needed.
	 */
	if (!cxt.lwsa && !cxt.lrsa)
		goto end;

	if (writer_tasks) {
		for (i = 0; i < cxt.nrealwriters_stress; i++)
			torture_stop_kthread(lock_torture_writer, writer_tasks[i]);
		kfree(writer_tasks);
		writer_tasks = NULL;
	}

	if (reader_tasks) {
		for (i = 0; i < cxt.nrealreaders_stress; i++)
			torture_stop_kthread(lock_torture_reader,
					     reader_tasks[i]);
		kfree(reader_tasks);
		reader_tasks = NULL;
	}

	torture_stop_kthread(lock_torture_stats, stats_task);
	lock_torture_stats_print();  /* -After- the stats thread is stopped! */

	if (atomic_read(&cxt.n_lock_torture_errors))
		lock_torture_print_module_parms(cxt.cur_ops,
						"End of test: FAILURE");
	else if (torture_onoff_failures())
		lock_torture_print_module_parms(cxt.cur_ops,
						"End of test: LOCK_HOTPLUG");
	else
		lock_torture_print_module_parms(cxt.cur_ops,
						"End of test: SUCCESS");

	kfree(cxt.lwsa);
	cxt.lwsa = NULL;
	kfree(cxt.lrsa);
	cxt.lrsa = NULL;

	call_rcu_chain_cleanup();

end:
	if (cxt.init_called) {
		if (cxt.cur_ops->exit)
			cxt.cur_ops->exit();
		cxt.init_called = false;
	}
	torture_cleanup_end();
}

static int __init lock_torture_init(void)
{
	int i, j;
	int firsterr = 0;
	static struct lock_torture_ops *torture_ops[] = {
		&lock_busted_ops,
		&spin_lock_ops, &spin_lock_irq_ops,
		&raw_spin_lock_ops, &raw_spin_lock_irq_ops,
		&rw_lock_ops, &rw_lock_irq_ops,
		&mutex_lock_ops,
		&ww_mutex_lock_ops,
#ifdef CONFIG_RT_MUTEXES
		&rtmutex_lock_ops,
#endif
		&rwsem_lock_ops,
		&percpu_rwsem_lock_ops,
	};

	if (!torture_init_begin(torture_type, verbose))
		return -EBUSY;

	/* Process args and tell the world that the torturer is on the job. */
	for (i = 0; i < ARRAY_SIZE(torture_ops); i++) {
		cxt.cur_ops = torture_ops[i];
		if (strcmp(torture_type, cxt.cur_ops->name) == 0)
			break;
	}
	if (i == ARRAY_SIZE(torture_ops)) {
		pr_alert("lock-torture: invalid torture type: \"%s\"\n",
			 torture_type);
		pr_alert("lock-torture types:");
		for (i = 0; i < ARRAY_SIZE(torture_ops); i++)
			pr_alert(" %s", torture_ops[i]->name);
		pr_alert("\n");
		firsterr = -EINVAL;
		goto unwind;
	}

	if (nwriters_stress == 0 &&
	    (!cxt.cur_ops->readlock || nreaders_stress == 0)) {
		pr_alert("lock-torture: must run at least one locking thread\n");
		firsterr = -EINVAL;
		goto unwind;
	}

	if (nwriters_stress >= 0)
		cxt.nrealwriters_stress = nwriters_stress;
	else
		cxt.nrealwriters_stress = 2 * num_online_cpus();

	if (cxt.cur_ops->init) {
		cxt.cur_ops->init();
		cxt.init_called = true;
	}

#ifdef CONFIG_DEBUG_MUTEXES
	if (str_has_prefix(torture_type, "mutex"))
		cxt.debug_lock = true;
#endif
#ifdef CONFIG_DEBUG_RT_MUTEXES
	if (str_has_prefix(torture_type, "rtmutex"))
		cxt.debug_lock = true;
#endif
#ifdef CONFIG_DEBUG_SPINLOCK
	if ((str_has_prefix(torture_type, "spin")) ||
	    (str_has_prefix(torture_type, "rw_lock")))
		cxt.debug_lock = true;
#endif

	/* Initialize the statistics so that each run gets its own numbers. */
	if (nwriters_stress) {
		lock_is_write_held = false;
		cxt.lwsa = kmalloc_array(cxt.nrealwriters_stress,
					 sizeof(*cxt.lwsa),
					 GFP_KERNEL);
		if (cxt.lwsa == NULL) {
			VERBOSE_TOROUT_STRING("cxt.lwsa: Out of memory");
			firsterr = -ENOMEM;
			goto unwind;
		}

		for (i = 0; i < cxt.nrealwriters_stress; i++) {
			cxt.lwsa[i].n_lock_fail = 0;
			cxt.lwsa[i].n_lock_acquired = 0;
		}
	}

	if (cxt.cur_ops->readlock) {
		if (nreaders_stress >= 0)
			cxt.nrealreaders_stress = nreaders_stress;
		else {
			/*
			 * By default distribute evenly the number of
			 * readers and writers. We still run the same number
			 * of threads as the writer-only locks default.
			 */
			if (nwriters_stress < 0) /* user doesn't care */
				cxt.nrealwriters_stress = num_online_cpus();
			cxt.nrealreaders_stress = cxt.nrealwriters_stress;
		}

		if (nreaders_stress) {
			cxt.lrsa = kmalloc_array(cxt.nrealreaders_stress,
						 sizeof(*cxt.lrsa),
						 GFP_KERNEL);
			if (cxt.lrsa == NULL) {
				VERBOSE_TOROUT_STRING("cxt.lrsa: Out of memory");
				firsterr = -ENOMEM;
				kfree(cxt.lwsa);
				cxt.lwsa = NULL;
				goto unwind;
			}

			for (i = 0; i < cxt.nrealreaders_stress; i++) {
				cxt.lrsa[i].n_lock_fail = 0;
				cxt.lrsa[i].n_lock_acquired = 0;
			}
		}
	}

	firsterr = call_rcu_chain_init();
	if (torture_init_error(firsterr))
		goto unwind;

	lock_torture_print_module_parms(cxt.cur_ops, "Start of test");

	/* Prepare torture context. */
	if (onoff_interval > 0) {
		firsterr = torture_onoff_init(onoff_holdoff * HZ,
					      onoff_interval * HZ, NULL);
		if (torture_init_error(firsterr))
			goto unwind;
	}
	if (shuffle_interval > 0) {
		firsterr = torture_shuffle_init(shuffle_interval);
		if (torture_init_error(firsterr))
			goto unwind;
	}
	if (shutdown_secs > 0) {
		firsterr = torture_shutdown_init(shutdown_secs,
						 lock_torture_cleanup);
		if (torture_init_error(firsterr))
			goto unwind;
	}
	if (stutter > 0) {
		firsterr = torture_stutter_init(stutter, stutter);
		if (torture_init_error(firsterr))
			goto unwind;
	}

	if (nwriters_stress) {
		writer_tasks = kcalloc(cxt.nrealwriters_stress,
				       sizeof(writer_tasks[0]),
				       GFP_KERNEL);
		if (writer_tasks == NULL) {
			TOROUT_ERRSTRING("writer_tasks: Out of memory");
			firsterr = -ENOMEM;
			goto unwind;
		}
	}

	/* cap nested_locks to MAX_NESTED_LOCKS */
	if (nested_locks > MAX_NESTED_LOCKS)
		nested_locks = MAX_NESTED_LOCKS;

	if (cxt.cur_ops->readlock) {
		reader_tasks = kcalloc(cxt.nrealreaders_stress,
				       sizeof(reader_tasks[0]),
				       GFP_KERNEL);
		if (reader_tasks == NULL) {
			TOROUT_ERRSTRING("reader_tasks: Out of memory");
			kfree(writer_tasks);
			writer_tasks = NULL;
			firsterr = -ENOMEM;
			goto unwind;
		}
	}

	/*
	 * Create the kthreads and start torturing (oh, those poor little locks).
	 *
	 * TODO: Note that we interleave writers with readers, giving writers a
	 * slight advantage, by creating its kthread first. This can be modified
	 * for very specific needs, or even let the user choose the policy, if
	 * ever wanted.
	 */
	for (i = 0, j = 0; i < cxt.nrealwriters_stress ||
		    j < cxt.nrealreaders_stress; i++, j++) {
		if (i >= cxt.nrealwriters_stress)
			goto create_reader;

		/* Create writer. */
		firsterr = torture_create_kthread_cb(lock_torture_writer, &cxt.lwsa[i],
						     writer_tasks[i],
						     writer_fifo ? sched_set_fifo : NULL);
		if (torture_init_error(firsterr))
			goto unwind;
		if (cpumask_nonempty(bind_writers))
			torture_sched_setaffinity(writer_tasks[i]->pid, bind_writers);

	create_reader:
		if (cxt.cur_ops->readlock == NULL || (j >= cxt.nrealreaders_stress))
			continue;
		/* Create reader. */
		firsterr = torture_create_kthread(lock_torture_reader, &cxt.lrsa[j],
						  reader_tasks[j]);
		if (torture_init_error(firsterr))
			goto unwind;
		if (cpumask_nonempty(bind_readers))
			torture_sched_setaffinity(reader_tasks[j]->pid, bind_readers);
	}
	if (stat_interval > 0) {
		firsterr = torture_create_kthread(lock_torture_stats, NULL,
						  stats_task);
		if (torture_init_error(firsterr))
			goto unwind;
	}
	torture_init_end();
	return 0;

unwind:
	torture_init_end();
	lock_torture_cleanup();
	if (shutdown_secs) {
		WARN_ON(!IS_MODULE(CONFIG_LOCK_TORTURE_TEST));
		kernel_power_off();
	}
	return firsterr;
}

module_init(lock_torture_init);
module_exit(lock_torture_cleanup);
/* SPDX-License-Identifier: GPL-2.0 */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * Authors: Waiman Long <waiman.long@hpe.com>
 */

/*
 * Collect locking event counts
 */
#include <linux/debugfs.h>
#include <linux/sched.h>
#include <linux/sched/clock.h>
#include <linux/fs.h>

#include "lock_events.h"

#undef  LOCK_EVENT
#define LOCK_EVENT(name)	[LOCKEVENT_ ## name] = #name,

#define LOCK_EVENTS_DIR		"lock_event_counts"

/*
 * When CONFIG_LOCK_EVENT_COUNTS is enabled, event counts of different
 * types of locks will be reported under the <debugfs>/lock_event_counts/
 * directory. See lock_events_list.h for the list of available locking
 * events.
 *
 * Writing to the special ".reset_counts" file will reset all the above
 * locking event counts. This is a very slow operation and so should not
 * be done frequently.
 *
 * These event counts are implemented as per-cpu variables which are
 * summed and computed whenever the corresponding debugfs files are read. This
 * minimizes added overhead making the counts usable even in a production
 * environment.
 */
static const char * const lockevent_names[lockevent_num + 1] = {

#include "lock_events_list.h"

	[LOCKEVENT_reset_cnts] = ".reset_counts",
};

/*
 * Per-cpu counts
 */
DEFINE_PER_CPU(unsigned long, lockevents[lockevent_num]);

/*
 * The lockevent_read() function can be overridden.
 */
ssize_t __weak lockevent_read(struct file *file, char __user *user_buf,
			      size_t count, loff_t *ppos)
{
	char buf[64];
	int cpu, id, len;
	u64 sum = 0;

	/*
	 * Get the counter ID stored in file->f_inode->i_private
	 */
	id = (long)file_inode(file)->i_private;

	if (id >= lockevent_num)
		return -EBADF;

	for_each_possible_cpu(cpu)
		sum += per_cpu(lockevents[id], cpu);
	len = snprintf(buf, sizeof(buf) - 1, "%llu\n", sum);

	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
}

/*
 * Function to handle write request
 *
 * When idx = reset_cnts, reset all the counts.
 */
static ssize_t lockevent_write(struct file *file, const char __user *user_buf,
			   size_t count, loff_t *ppos)
{
	int cpu;

	/*
	 * Get the counter ID stored in file->f_inode->i_private
	 */
	if ((long)file_inode(file)->i_private != LOCKEVENT_reset_cnts)
		return count;

	for_each_possible_cpu(cpu) {
		int i;
		unsigned long *ptr = per_cpu_ptr(lockevents, cpu);

		for (i = 0 ; i < lockevent_num; i++)
			WRITE_ONCE(ptr[i], 0);
	}
	return count;
}

/*
 * Debugfs data structures
 */
static const struct file_operations fops_lockevent = {
	.read = lockevent_read,
	.write = lockevent_write,
	.llseek = default_llseek,
};

#ifdef CONFIG_PARAVIRT_SPINLOCKS
#include <asm/paravirt.h>

static bool __init skip_lockevent(const char *name)
{
	static int pv_on __initdata = -1;

	if (pv_on < 0)
		pv_on = !pv_is_native_spin_unlock();
	/*
	 * Skip PV qspinlock events on bare metal.
	 */
	if (!pv_on && !memcmp(name, "pv_", 3))
		return true;
	return false;
}
#else
static inline bool skip_lockevent(const char *name)
{
	return false;
}
#endif

/*
 * Initialize debugfs for the locking event counts.
 */
static int __init init_lockevent_counts(void)
{
	struct dentry *d_counts = debugfs_create_dir(LOCK_EVENTS_DIR, NULL);
	int i;

	if (IS_ERR(d_counts))
		goto out;

	/*
	 * Create the debugfs files
	 *
	 * As reading from and writing to the stat files can be slow, only
	 * root is allowed to do the read/write to limit impact to system
	 * performance.
	 */
	for (i = 0; i < lockevent_num; i++) {
		if (skip_lockevent(lockevent_names[i]))
			continue;
		if (IS_ERR(debugfs_create_file(lockevent_names[i], 0400, d_counts,
					 (void *)(long)i, &fops_lockevent)))
			goto fail_undo;
	}

	if (IS_ERR(debugfs_create_file(lockevent_names[LOCKEVENT_reset_cnts], 0200,
				 d_counts, (void *)(long)LOCKEVENT_reset_cnts,
				 &fops_lockevent)))
		goto fail_undo;

	return 0;
fail_undo:
	debugfs_remove_recursive(d_counts);
out:
	pr_warn("Could not create '%s' debugfs entries\n", LOCK_EVENTS_DIR);
	return -ENOMEM;
}
fs_initcall(init_lockevent_counts);
/* SPDX-License-Identifier: GPL-2.0 */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * Authors: Waiman Long <longman@redhat.com>
 */

#ifndef __LOCKING_LOCK_EVENTS_H
#define __LOCKING_LOCK_EVENTS_H

enum lock_events {

#include "lock_events_list.h"

	lockevent_num,	/* Total number of lock event counts */
	LOCKEVENT_reset_cnts = lockevent_num,
};

#ifdef CONFIG_LOCK_EVENT_COUNTS
/*
 * Per-cpu counters
 */
DECLARE_PER_CPU(unsigned long, lockevents[lockevent_num]);

/*
 * Increment the statistical counters. use raw_cpu_inc() because of lower
 * overhead and we don't care if we loose the occasional update.
 */
static inline void __lockevent_inc(enum lock_events event, bool cond)
{
	if (cond)
		raw_cpu_inc(lockevents[event]);
}

#define lockevent_inc(ev)	  __lockevent_inc(LOCKEVENT_ ##ev, true)
#define lockevent_cond_inc(ev, c) __lockevent_inc(LOCKEVENT_ ##ev, c)

static inline void __lockevent_add(enum lock_events event, int inc)
{
	raw_cpu_add(lockevents[event], inc);
}

#define lockevent_add(ev, c)	__lockevent_add(LOCKEVENT_ ##ev, c)

#else  /* CONFIG_LOCK_EVENT_COUNTS */

#define lockevent_inc(ev)
#define lockevent_add(ev, c)
#define lockevent_cond_inc(ev, c)

#endif /* CONFIG_LOCK_EVENT_COUNTS */

ssize_t lockevent_read(struct file *file, char __user *user_buf,
		       size_t count, loff_t *ppos);

#endif /* __LOCKING_LOCK_EVENTS_H */
/* SPDX-License-Identifier: GPL-2.0 */
/*
 * MCS lock defines
 *
 * This file contains the main data structure and API definitions of MCS lock.
 *
 * The MCS lock (proposed by Mellor-Crummey and Scott) is a simple spin-lock
 * with the desirable properties of being fair, and with each cpu trying
 * to acquire the lock spinning on a local variable.
 * It avoids expensive cache bounces that common test-and-set spin-lock
 * implementations incur.
 */
#ifndef __LINUX_MCS_SPINLOCK_H
#define __LINUX_MCS_SPINLOCK_H

#include <asm/mcs_spinlock.h>

struct mcs_spinlock {
	struct mcs_spinlock *next;
	int locked; /* 1 if lock acquired */
	int count;  /* nesting count, see qspinlock.c */
};

#ifndef arch_mcs_spin_lock_contended
/*
 * Using smp_cond_load_acquire() provides the acquire semantics
 * required so that subsequent operations happen after the
 * lock is acquired. Additionally, some architectures such as
 * ARM64 would like to do spin-waiting instead of purely
 * spinning, and smp_cond_load_acquire() provides that behavior.
 */
#define arch_mcs_spin_lock_contended(l)					\
do {									\
	smp_cond_load_acquire(l, VAL);					\
} while (0)
#endif

#ifndef arch_mcs_spin_unlock_contended
/*
 * smp_store_release() provides a memory barrier to ensure all
 * operations in the critical section has been completed before
 * unlocking.
 */
#define arch_mcs_spin_unlock_contended(l)				\
	smp_store_release((l), 1)
#endif

/*
 * Note: the smp_load_acquire/smp_store_release pair is not
 * sufficient to form a full memory barrier across
 * cpus for many architectures (except x86) for mcs_unlock and mcs_lock.
 * For applications that need a full barrier across multiple cpus
 * with mcs_unlock and mcs_lock pair, smp_mb__after_unlock_lock() should be
 * used after mcs_lock.
 */

/*
 * In order to acquire the lock, the caller should declare a local node and
 * pass a reference of the node to this function in addition to the lock.
 * If the lock has already been acquired, then this will proceed to spin
 * on this node->locked until the previous lock holder sets the node->locked
 * in mcs_spin_unlock().
 */
static inline
void mcs_spin_lock(struct mcs_spinlock **lock, struct mcs_spinlock *node)
{
	struct mcs_spinlock *prev;

	/* Init node */
	node->locked = 0;
	node->next   = NULL;

	/*
	 * We rely on the full barrier with global transitivity implied by the
	 * below xchg() to order the initialization stores above against any
	 * observation of @node. And to provide the ACQUIRE ordering associated
	 * with a LOCK primitive.
	 */
	prev = xchg(lock, node);
	if (likely(prev == NULL)) {
		/*
		 * Lock acquired, don't need to set node->locked to 1. Threads
		 * only spin on its own node->locked value for lock acquisition.
		 * However, since this thread can immediately acquire the lock
		 * and does not proceed to spin on its own node->locked, this
		 * value won't be used. If a debug mode is needed to
		 * audit lock status, then set node->locked value here.
		 */
		return;
	}
	WRITE_ONCE(prev->next, node);

	/* Wait until the lock holder passes the lock down. */
	arch_mcs_spin_lock_contended(&node->locked);
}

/*
 * Releases the lock. The caller should pass in the corresponding node that
 * was used to acquire the lock.
 */
static inline
void mcs_spin_unlock(struct mcs_spinlock **lock, struct mcs_spinlock *node)
{
	struct mcs_spinlock *next = READ_ONCE(node->next);

	if (likely(!next)) {
		/*
		 * Release the lock by setting it to NULL
		 */
		if (likely(cmpxchg_release(lock, node, NULL) == node))
			return;
		/* Wait until the next pointer is set */
		while (!(next = READ_ONCE(node->next)))
			cpu_relax();
	}

	/* Pass lock to next waiter. */
	arch_mcs_spin_unlock_contended(&next->locked);
}

#endif /* __LINUX_MCS_SPINLOCK_H */
#include "AES.h"

AES::AES(const AESKeyLength keyLength) {
  switch (keyLength) {
    case AESKeyLength::AES_128:
      this->Nk = 4;
      this->Nr = 10;
      break;
    case AESKeyLength::AES_192:
      this->Nk = 6;
      this->Nr = 12;
      break;
    case AESKeyLength::AES_256:
      this->Nk = 8;
      this->Nr = 14;
      break;
  }
}

unsigned char *AES::EncryptECB(const unsigned char in[], unsigned int inLen,
                               const unsigned char key[]) {
  CheckLength(inLen);
  unsigned char *out = new unsigned char[inLen];
  unsigned char *roundKeys = new unsigned char[4 * Nb * (Nr + 1)];
  KeyExpansion(key, roundKeys);
  for (unsigned int i = 0; i < inLen; i += blockBytesLen) {
    EncryptBlock(in + i, out + i, roundKeys);
  }

  delete[] roundKeys;

  return out;
}

unsigned char *AES::DecryptECB(const unsigned char in[], unsigned int inLen,
                               const unsigned char key[]) {
  CheckLength(inLen);
  unsigned char *out = new unsigned char[inLen];
  unsigned char *roundKeys = new unsigned char[4 * Nb * (Nr + 1)];
  KeyExpansion(key, roundKeys);
  for (unsigned int i = 0; i < inLen; i += blockBytesLen) {
    DecryptBlock(in + i, out + i, roundKeys);
  }

  delete[] roundKeys;

  return out;
}

unsigned char *AES::EncryptCBC(const unsigned char in[], unsigned int inLen,
                               const unsigned char key[],
                               const unsigned char *iv) {
  CheckLength(inLen);
  unsigned char *out = new unsigned char[inLen];
  unsigned char block[blockBytesLen];
  unsigned char *roundKeys = new unsigned char[4 * Nb * (Nr + 1)];
  KeyExpansion(key, roundKeys);
  memcpy(block, iv, blockBytesLen);
  for (unsigned int i = 0; i < inLen; i += blockBytesLen) {
    XorBlocks(block, in + i, block, blockBytesLen);
    EncryptBlock(block, out + i, roundKeys);
    memcpy(block, out + i, blockBytesLen);
  }

  delete[] roundKeys;

  return out;
}

unsigned char *AES::DecryptCBC(const unsigned char in[], unsigned int inLen,
                               const unsigned char key[],
                               const unsigned char *iv) {
  CheckLength(inLen);
  unsigned char *out = new unsigned char[inLen];
  unsigned char block[blockBytesLen];
  unsigned char *roundKeys = new unsigned char[4 * Nb * (Nr + 1)];
  KeyExpansion(key, roundKeys);
  memcpy(block, iv, blockBytesLen);
  for (unsigned int i = 0; i < inLen; i += blockBytesLen) {
    DecryptBlock(in + i, out + i, roundKeys);
    XorBlocks(block, out + i, out + i, blockBytesLen);
    memcpy(block, in + i, blockBytesLen);
  }

  delete[] roundKeys;

  return out;
}

unsigned char *AES::EncryptCFB(const unsigned char in[], unsigned int inLen,
                               const unsigned char key[],
                               const unsigned char *iv) {
  CheckLength(inLen);
  unsigned char *out = new unsigned char[inLen];
  unsigned char block[blockBytesLen];
  unsigned char encryptedBlock[blockBytesLen];
  unsigned char *roundKeys = new unsigned char[4 * Nb * (Nr + 1)];
  KeyExpansion(key, roundKeys);
  memcpy(block, iv, blockBytesLen);
  for (unsigned int i = 0; i < inLen; i += blockBytesLen) {
    EncryptBlock(block, encryptedBlock, roundKeys);
    XorBlocks(in + i, encryptedBlock, out + i, blockBytesLen);
    memcpy(block, out + i, blockBytesLen);
  }

  delete[] roundKeys;

  return out;
}

unsigned char *AES::DecryptCFB(const unsigned char in[], unsigned int inLen,
                               const unsigned char key[],
                               const unsigned char *iv) {
  CheckLength(inLen);
  unsigned char *out = new unsigned char[inLen];
  unsigned char block[blockBytesLen];
  unsigned char encryptedBlock[blockBytesLen];
  unsigned char *roundKeys = new unsigned char[4 * Nb * (Nr + 1)];
  KeyExpansion(key, roundKeys);
  memcpy(block, iv, blockBytesLen);
  for (unsigned int i = 0; i < inLen; i += blockBytesLen) {
    EncryptBlock(block, encryptedBlock, roundKeys);
    XorBlocks(in + i, encryptedBlock, out + i, blockBytesLen);
    memcpy(block, in + i, blockBytesLen);
  }

  delete[] roundKeys;

  return out;
}

void AES::CheckLength(unsigned int len) {
  if (len % blockBytesLen != 0) {
    throw std::length_error("Plaintext length must be divisible by " +
                            std::to_string(blockBytesLen));
  }
}

void AES::EncryptBlock(const unsigned char in[], unsigned char out[],
                       unsigned char *roundKeys) {
  unsigned char state[4][Nb];
  unsigned int i, j, round;

  for (i = 0; i < 4; i++) {
    for (j = 0; j < Nb; j++) {
      state[i][j] = in[i + 4 * j];
    }
  }

  AddRoundKey(state, roundKeys);

  for (round = 1; round <= Nr - 1; round++) {
    SubBytes(state);
    ShiftRows(state);
    MixColumns(state);
    AddRoundKey(state, roundKeys + round * 4 * Nb);
  }

  SubBytes(state);
  ShiftRows(state);
  AddRoundKey(state, roundKeys + Nr * 4 * Nb);

  for (i = 0; i < 4; i++) {
    for (j = 0; j < Nb; j++) {
      out[i + 4 * j] = state[i][j];
    }
  }
}

void AES::DecryptBlock(const unsigned char in[], unsigned char out[],
                       unsigned char *roundKeys) {
  unsigned char state[4][Nb];
  unsigned int i, j, round;

  for (i = 0; i < 4; i++) {
    for (j = 0; j < Nb; j++) {
      state[i][j] = in[i + 4 * j];
    }
  }

  AddRoundKey(state, roundKeys + Nr * 4 * Nb);

  for (round = Nr - 1; round >= 1; round--) {
    InvSubBytes(state);
    InvShiftRows(state);
    AddRoundKey(state, roundKeys + round * 4 * Nb);
    InvMixColumns(state);
  }

  InvSubBytes(state);
  InvShiftRows(state);
  AddRoundKey(state, roundKeys);

  for (i = 0; i < 4; i++) {
    for (j = 0; j < Nb; j++) {
      out[i + 4 * j] = state[i][j];
    }
  }
}

void AES::SubBytes(unsigned char state[4][Nb]) {
  unsigned int i, j;
  unsigned char t;
  for (i = 0; i < 4; i++) {
    for (j = 0; j < Nb; j++) {
      t = state[i][j];
      state[i][j] = sbox[t / 16][t % 16];
    }
  }
}

void AES::ShiftRow(unsigned char state[4][Nb], unsigned int i,
                   unsigned int n)  // shift row i on n positions
{
  unsigned char tmp[Nb];
  for (unsigned int j = 0; j < Nb; j++) {
    tmp[j] = state[i][(j + n) % Nb];
  }
  memcpy(state[i], tmp, Nb * sizeof(unsigned char));
}

void AES::ShiftRows(unsigned char state[4][Nb]) {
  ShiftRow(state, 1, 1);
  ShiftRow(state, 2, 2);
  ShiftRow(state, 3, 3);
}

unsigned char AES::xtime(unsigned char b)  // multiply on x
{
  return (b << 1) ^ (((b >> 7) & 1) * 0x1b);
}

void AES::MixColumns(unsigned char state[4][Nb]) {
  unsigned char temp_state[4][Nb];

  for (size_t i = 0; i < 4; ++i) {
    memset(temp_state[i], 0, 4);
  }

  for (size_t i = 0; i < 4; ++i) {
    for (size_t k = 0; k < 4; ++k) {
      for (size_t j = 0; j < 4; ++j) {
        if (CMDS[i][k] == 1)
          temp_state[i][j] ^= state[k][j];
        else
          temp_state[i][j] ^= GF_MUL_TABLE[CMDS[i][k]][state[k][j]];
      }
    }
  }

  for (size_t i = 0; i < 4; ++i) {
    memcpy(state[i], temp_state[i], 4);
  }
}

void AES::AddRoundKey(unsigned char state[4][Nb], unsigned char *key) {
  unsigned int i, j;
  for (i = 0; i < 4; i++) {
    for (j = 0; j < Nb; j++) {
      state[i][j] = state[i][j] ^ key[i + 4 * j];
    }
  }
}

void AES::SubWord(unsigned char *a) {
  int i;
  for (i = 0; i < 4; i++) {
    a[i] = sbox[a[i] / 16][a[i] % 16];
  }
}

void AES::RotWord(unsigned char *a) {
  unsigned char c = a[0];
  a[0] = a[1];
  a[1] = a[2];
  a[2] = a[3];
  a[3] = c;
}

void AES::XorWords(unsigned char *a, unsigned char *b, unsigned char *c) {
  int i;
  for (i = 0; i < 4; i++) {
    c[i] = a[i] ^ b[i];
  }
}

void AES::Rcon(unsigned char *a, unsigned int n) {
  unsigned int i;
  unsigned char c = 1;
  for (i = 0; i < n - 1; i++) {
    c = xtime(c);
  }

  a[0] = c;
  a[1] = a[2] = a[3] = 0;
}

void AES::KeyExpansion(const unsigned char key[], unsigned char w[]) {
  unsigned char temp[4];
  unsigned char rcon[4];

  unsigned int i = 0;
  while (i < 4 * Nk) {
    w[i] = key[i];
    i++;
  }

  i = 4 * Nk;
  while (i < 4 * Nb * (Nr + 1)) {
    temp[0] = w[i - 4 + 0];
    temp[1] = w[i - 4 + 1];
    temp[2] = w[i - 4 + 2];
    temp[3] = w[i - 4 + 3];

    if (i / 4 % Nk == 0) {
      RotWord(temp);
      SubWord(temp);
      Rcon(rcon, i / (Nk * 4));
      XorWords(temp, rcon, temp);
    } else if (Nk > 6 && i / 4 % Nk == 4) {
      SubWord(temp);
    }

    w[i + 0] = w[i - 4 * Nk] ^ temp[0];
    w[i + 1] = w[i + 1 - 4 * Nk] ^ temp[1];
    w[i + 2] = w[i + 2 - 4 * Nk] ^ temp[2];
    w[i + 3] = w[i + 3 - 4 * Nk] ^ temp[3];
    i += 4;
  }
}

void AES::InvSubBytes(unsigned char state[4][Nb]) {
  unsigned int i, j;
  unsigned char t;
  for (i = 0; i < 4; i++) {
    for (j = 0; j < Nb; j++) {
      t = state[i][j];
      state[i][j] = inv_sbox[t / 16][t % 16];
    }
  }
}

void AES::InvMixColumns(unsigned char state[4][Nb]) {
  unsigned char temp_state[4][Nb];

  for (size_t i = 0; i < 4; ++i) {
    memset(temp_state[i], 0, 4);
  }

  for (size_t i = 0; i < 4; ++i) {
    for (size_t k = 0; k < 4; ++k) {
      for (size_t j = 0; j < 4; ++j) {
        temp_state[i][j] ^= GF_MUL_TABLE[INV_CMDS[i][k]][state[k][j]];
      }
    }
  }

  for (size_t i = 0; i < 4; ++i) {
    memcpy(state[i], temp_state[i], 4);
  }
}

void AES::InvShiftRows(unsigned char state[4][Nb]) {
  ShiftRow(state, 1, Nb - 1);
  ShiftRow(state, 2, Nb - 2);
  ShiftRow(state, 3, Nb - 3);
}

void AES::XorBlocks(const unsigned char *a, const unsigned char *b,
                    unsigned char *c, unsigned int len) {
  for (unsigned int i = 0; i < len; i++) {
    c[i] = a[i] ^ b[i];
  }
}

void AES::printHexArray(unsigned char a[], unsigned int n) {
  for (unsigned int i = 0; i < n; i++) {
    printf("%02x ", a[i]);
  }
}

void AES::printHexVector(std::vector<unsigned char> a) {
  for (unsigned int i = 0; i < a.size(); i++) {
    printf("%02x ", a[i]);
  }
}

std::vector<unsigned char> AES::ArrayToVector(unsigned char *a,
                                              unsigned int len) {
  std::vector<unsigned char> v(a, a + len * sizeof(unsigned char));
  return v;
}

unsigned char *AES::VectorToArray(std::vector<unsigned char> &a) {
  return a.data();
}

std::vector<unsigned char> AES::EncryptECB(std::vector<unsigned char> in,
                                           std::vector<unsigned char> key) {
  unsigned char *out = EncryptECB(VectorToArray(in), (unsigned int)in.size(),
                                  VectorToArray(key));
  std::vector<unsigned char> v = ArrayToVector(out, in.size());
  delete[] out;
  return v;
}

std::vector<unsigned char> AES::DecryptECB(std::vector<unsigned char> in,
                                           std::vector<unsigned char> key) {
  unsigned char *out = DecryptECB(VectorToArray(in), (unsigned int)in.size(),
                                  VectorToArray(key));
  std::vector<unsigned char> v = ArrayToVector(out, (unsigned int)in.size());
  delete[] out;
  return v;
}

std::vector<unsigned char> AES::EncryptCBC(std::vector<unsigned char> in,
                                           std::vector<unsigned char> key,
                                           std::vector<unsigned char> iv) {
  unsigned char *out = EncryptCBC(VectorToArray(in), (unsigned int)in.size(),
                                  VectorToArray(key), VectorToArray(iv));
  std::vector<unsigned char> v = ArrayToVector(out, in.size());
  delete[] out;
  return v;
}

std::vector<unsigned char> AES::DecryptCBC(std::vector<unsigned char> in,
                                           std::vector<unsigned char> key,
                                           std::vector<unsigned char> iv) {
  unsigned char *out = DecryptCBC(VectorToArray(in), (unsigned int)in.size(),
                                  VectorToArray(key), VectorToArray(iv));
  std::vector<unsigned char> v = ArrayToVector(out, (unsigned int)in.size());
  delete[] out;
  return v;
}

std::vector<unsigned char> AES::EncryptCFB(std::vector<unsigned char> in,
                                           std::vector<unsigned char> key,
                                           std::vector<unsigned char> iv) {
  unsigned char *out = EncryptCFB(VectorToArray(in), (unsigned int)in.size(),
                                  VectorToArray(key), VectorToArray(iv));
  std::vector<unsigned char> v = ArrayToVector(out, in.size());
  delete[] out;
  return v;
}

std::vector<unsigned char> AES::DecryptCFB(std::vector<unsigned char> in,
                                           std::vector<unsigned char> key,
                                           std::vector<unsigned char> iv) {
  unsigned char *out = DecryptCFB(VectorToArray(in), (unsigned int)in.size(),
                                  VectorToArray(key), VectorToArray(iv));
  std::vector<unsigned char> v = ArrayToVector(out, (unsigned int)in.size());
  delete[] out;
  return v;
}
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_HPP
#define ELFIO_HPP

#include <string>
#include <iostream>
#include <fstream>
#include <functional>
#include <algorithm>
#include <array>
#include <vector>
#include <deque>
#include <memory>

#include <elfio/elf_types.hpp>
#include <elfio/elfio_version.hpp>
#include <elfio/elfio_utils.hpp>
#include <elfio/elfio_header.hpp>
#include <elfio/elfio_section.hpp>
#include <elfio/elfio_segment.hpp>
#include <elfio/elfio_strings.hpp>

#define ELFIO_HEADER_ACCESS_GET( TYPE, FNAME ) \
    TYPE get_##FNAME() const { return header ? ( header->get_##FNAME() ) : 0; }

#define ELFIO_HEADER_ACCESS_GET_SET( TYPE, FNAME )     \
    TYPE get_##FNAME() const                           \
    {                                                  \
        return header ? ( header->get_##FNAME() ) : 0; \
    }                                                  \
    void set_##FNAME( TYPE val )                       \
    {                                                  \
        if ( header ) {                                \
            header->set_##FNAME( val );                \
        }                                              \
    }

namespace ELFIO {

//------------------------------------------------------------------------------
class elfio
{
  public:
    //------------------------------------------------------------------------------
    elfio() noexcept : sections( this ), segments( this )
    {
        create( ELFCLASS32, ELFDATA2LSB );
    }

    explicit elfio( compression_interface* compression ) noexcept
        : sections( this ), segments( this ),
          compression( std::shared_ptr<compression_interface>( compression ) )
    {
        elfio();
    }

    elfio( elfio&& other ) noexcept
        : sections( this ), segments( this ),
          current_file_pos( other.current_file_pos )
    {
        header          = std::move( other.header );
        sections_       = std::move( other.sections_ );
        segments_       = std::move( other.segments_ );
        convertor       = std::move( other.convertor );
        addr_translator = std::move( other.addr_translator );
        compression     = std::move( other.compression );

        other.header = nullptr;
        other.sections_.clear();
        other.segments_.clear();
        other.compression = nullptr;
    }

    elfio& operator=( elfio&& other ) noexcept
    {
        if ( this != &other ) {
            header           = std::move( other.header );
            sections_        = std::move( other.sections_ );
            segments_        = std::move( other.segments_ );
            convertor        = std::move( other.convertor );
            addr_translator  = std::move( other.addr_translator );
            current_file_pos = other.current_file_pos;
            compression      = std::move( other.compression );

            other.current_file_pos = 0;
            other.header           = nullptr;
            other.compression      = nullptr;
            other.sections_.clear();
            other.segments_.clear();
        }
        return *this;
    }

    //------------------------------------------------------------------------------
    // clang-format off
    elfio( const elfio& )            = delete;
    elfio& operator=( const elfio& ) = delete;
    ~elfio()                         = default;
    // clang-format on

    //------------------------------------------------------------------------------
    void create( unsigned char file_class, unsigned char encoding )
    {
        sections_.clear();
        segments_.clear();
        convertor.setup( encoding );
        header = create_header( file_class, encoding );
        create_mandatory_sections();
    }

    void set_address_translation( std::vector<address_translation>& addr_trans )
    {
        addr_translator.set_address_translation( addr_trans );
    }

    //------------------------------------------------------------------------------
    bool load( const std::string& file_name, bool is_lazy = false )
    {
        pstream = std::make_unique<std::ifstream>();
        pstream->open( file_name.c_str(), std::ios::in | std::ios::binary );
        if ( pstream == nullptr || !*pstream ) {
            return false;
        }

        bool ret = load( *pstream, is_lazy );

        if ( !is_lazy ) {
            pstream.reset();
        }

        return ret;
    }

    //------------------------------------------------------------------------------
    bool load( std::istream& stream, bool is_lazy = false )
    {
        sections_.clear();
        segments_.clear();

        std::array<char, EI_NIDENT> e_ident = { 0 };
        // Read ELF file signature
        stream.seekg( addr_translator[0] );
        stream.read( e_ident.data(), sizeof( e_ident ) );

        // Is it ELF file?
        if ( stream.gcount() != sizeof( e_ident ) ||
             e_ident[EI_MAG0] != ELFMAG0 || e_ident[EI_MAG1] != ELFMAG1 ||
             e_ident[EI_MAG2] != ELFMAG2 || e_ident[EI_MAG3] != ELFMAG3 ) {
            return false;
        }

        if ( ( e_ident[EI_CLASS] != ELFCLASS64 ) &&
             ( e_ident[EI_CLASS] != ELFCLASS32 ) ) {
            return false;
        }

        if ( ( e_ident[EI_DATA] != ELFDATA2LSB ) &&
             ( e_ident[EI_DATA] != ELFDATA2MSB ) ) {
            return false;
        }

        convertor.setup( e_ident[EI_DATA] );
        header = create_header( e_ident[EI_CLASS], e_ident[EI_DATA] );
        if ( nullptr == header ) {
            return false;
        }
        if ( !header->load( stream ) ) {
            return false;
        }

        load_sections( stream, is_lazy );
        bool is_still_good = load_segments( stream, is_lazy );
        return is_still_good;
    }

    //------------------------------------------------------------------------------
    bool save( const std::string& file_name )
    {
        std::ofstream stream;
        stream.open( file_name.c_str(), std::ios::out | std::ios::binary );
        if ( !stream ) {
            return false;
        }

        return save( stream );
    }

    //------------------------------------------------------------------------------
    bool save( std::ostream& stream )
    {
        if ( !stream || header == nullptr ) {
            return false;
        }

        // Define layout specific header fields
        // The position of the segment table is fixed after the header.
        // The position of the section table is variable and needs to be fixed
        // before saving.
        header->set_segments_num( segments.size() );
        header->set_segments_offset(
            segments.size() > 0 ? header->get_header_size() : 0 );
        header->set_sections_num( sections.size() );
        header->set_sections_offset( 0 );

        // Layout the first section right after the segment table
        current_file_pos =
            header->get_header_size() +
            header->get_segment_entry_size() *
                static_cast<Elf_Xword>( header->get_segments_num() );

        calc_segment_alignment();

        bool is_still_good = layout_segments_and_their_sections();
        is_still_good = is_still_good && layout_sections_without_segments();
        is_still_good = is_still_good && layout_section_table();

        is_still_good = is_still_good && save_header( stream );
        is_still_good = is_still_good && save_sections( stream );
        is_still_good = is_still_good && save_segments( stream );

        return is_still_good;
    }

    //------------------------------------------------------------------------------
    // ELF header access functions
    ELFIO_HEADER_ACCESS_GET( unsigned char, class );
    ELFIO_HEADER_ACCESS_GET( unsigned char, elf_version );
    ELFIO_HEADER_ACCESS_GET( unsigned char, encoding );
    ELFIO_HEADER_ACCESS_GET( Elf_Word, version );
    ELFIO_HEADER_ACCESS_GET( Elf_Half, header_size );
    ELFIO_HEADER_ACCESS_GET( Elf_Half, section_entry_size );
    ELFIO_HEADER_ACCESS_GET( Elf_Half, segment_entry_size );

    ELFIO_HEADER_ACCESS_GET_SET( unsigned char, os_abi );
    ELFIO_HEADER_ACCESS_GET_SET( unsigned char, abi_version );
    ELFIO_HEADER_ACCESS_GET_SET( Elf_Half, type );
    ELFIO_HEADER_ACCESS_GET_SET( Elf_Half, machine );
    ELFIO_HEADER_ACCESS_GET_SET( Elf_Word, flags );
    ELFIO_HEADER_ACCESS_GET_SET( Elf64_Addr, entry );
    ELFIO_HEADER_ACCESS_GET_SET( Elf64_Off, sections_offset );
    ELFIO_HEADER_ACCESS_GET_SET( Elf64_Off, segments_offset );
    ELFIO_HEADER_ACCESS_GET_SET( Elf_Half, section_name_str_index );

    //------------------------------------------------------------------------------
    const endianess_convertor& get_convertor() const { return convertor; }

    //------------------------------------------------------------------------------
    Elf_Xword get_default_entry_size( Elf_Word section_type ) const
    {
        switch ( section_type ) {
        case SHT_RELA:
            if ( header->get_class() == ELFCLASS64 ) {
                return sizeof( Elf64_Rela );
            }
            else {
                return sizeof( Elf32_Rela );
            }
        case SHT_REL:
            if ( header->get_class() == ELFCLASS64 ) {
                return sizeof( Elf64_Rel );
            }
            else {
                return sizeof( Elf32_Rel );
            }
        case SHT_SYMTAB:
            if ( header->get_class() == ELFCLASS64 ) {
                return sizeof( Elf64_Sym );
            }
            else {
                return sizeof( Elf32_Sym );
            }
        case SHT_DYNAMIC:
            if ( header->get_class() == ELFCLASS64 ) {
                return sizeof( Elf64_Dyn );
            }
            else {
                return sizeof( Elf32_Dyn );
            }
        default:
            return 0;
        }
    }

    //------------------------------------------------------------------------------
    //! returns an empty string if no problems are detected,
    //! or a string containing an error message if problems are found,
    //! with one error per line.
    std::string validate() const
    {
        // clang-format off

        std::string errors;
        // Check for overlapping sections in the file
        // This is explicitly forbidden by ELF specification
        for ( int i = 0; i < sections.size(); ++i) {
            for ( int j = i+1; j < sections.size(); ++j ) {
                const section* a = sections[i];
                const section* b = sections[j];
                if (   ( ( a->get_type() & SHT_NOBITS) == 0 )
                    && ( ( b->get_type() & SHT_NOBITS) == 0 )
                    && ( a->get_size() > 0 )
                    && ( b->get_size() > 0 )
                    && ( a->get_offset() > 0 )
                    && ( b->get_offset() > 0 )
                    && ( is_offset_in_section( a->get_offset(), b )
                      || is_offset_in_section( a->get_offset()+a->get_size()-1, b )
                      || is_offset_in_section( b->get_offset(), a )
                      || is_offset_in_section( b->get_offset()+b->get_size()-1, a ) ) ) {
                        errors += "Sections " + a->get_name() + " and " + b->get_name() + " overlap in file\n";
                }
            }
        }
        // clang-format on

        // Check for conflicting section / program header tables, where
        // the same offset has different vaddresses in section table and
        // program header table.
        // This doesn't seem to be  explicitly forbidden by ELF specification,
        // but:
        // - it doesn't make any sense
        // - ELFIO relies on this being consistent when writing ELF files,
        //   since offsets are re-calculated from vaddress
        for ( int h = 0; h < segments.size(); ++h ) {
            const segment* seg = segments[h];
            const section* sec =
                find_prog_section_for_offset( seg->get_offset() );
            if ( seg->get_type() == PT_LOAD && seg->get_file_size() > 0 &&
                 sec != nullptr ) {
                Elf64_Addr sec_addr =
                    get_virtual_addr( seg->get_offset(), sec );
                if ( sec_addr != seg->get_virtual_address() ) {
                    errors += "Virtual address of segment " +
                              std::to_string( h ) + " (" +
                              to_hex_string( seg->get_virtual_address() ) +
                              ")" + " conflicts with address of section " +
                              sec->get_name() + " (" +
                              to_hex_string( sec_addr ) + ")" + " at offset " +
                              to_hex_string( seg->get_offset() ) + "\n";
                }
            }
        }

        // more checks to be added here...

        return errors;
    }

  private:
    //------------------------------------------------------------------------------
    static bool is_offset_in_section( Elf64_Off offset, const section* sec )
    {
        return ( offset >= sec->get_offset() ) &&
               ( offset < ( sec->get_offset() + sec->get_size() ) );
    }

    //------------------------------------------------------------------------------
    static Elf64_Addr get_virtual_addr( Elf64_Off offset, const section* sec )
    {
        return sec->get_address() + offset - sec->get_offset();
    }

    //------------------------------------------------------------------------------
    const section* find_prog_section_for_offset( Elf64_Off offset ) const
    {
        for ( const auto& sec : sections ) {
            if ( sec->get_type() == SHT_PROGBITS &&
                 is_offset_in_section( offset, sec.get() ) ) {
                return sec.get();
            }
        }
        return nullptr;
    }

    //------------------------------------------------------------------------------
    std::unique_ptr<elf_header> create_header( unsigned char file_class,
                                               unsigned char encoding )
    {
        std::unique_ptr<elf_header> new_header;

        if ( file_class == ELFCLASS64 ) {
            new_header = std::unique_ptr<elf_header>(
                new ( std::nothrow ) elf_header_impl<Elf64_Ehdr>(
                    &convertor, encoding, &addr_translator ) );
        }
        else if ( file_class == ELFCLASS32 ) {
            new_header = std::unique_ptr<elf_header>(
                new ( std::nothrow ) elf_header_impl<Elf32_Ehdr>(
                    &convertor, encoding, &addr_translator ) );
        }
        else {
            return nullptr;
        }

        return new_header;
    }

    //------------------------------------------------------------------------------
    section* create_section()
    {
        if ( auto file_class = get_class(); file_class == ELFCLASS64 ) {
            sections_.emplace_back(
                new ( std::nothrow ) section_impl<Elf64_Shdr>(
                    &convertor, &addr_translator, compression ) );
        }
        else if ( file_class == ELFCLASS32 ) {
            sections_.emplace_back(
                new ( std::nothrow ) section_impl<Elf32_Shdr>(
                    &convertor, &addr_translator, compression ) );
        }
        else {
            sections_.pop_back();
            return nullptr;
        }

        section* new_section = sections_.back().get();
        new_section->set_index( static_cast<Elf_Half>( sections_.size() - 1 ) );

        return new_section;
    }

    //------------------------------------------------------------------------------
    segment* create_segment()
    {
        if ( auto file_class = header->get_class(); file_class == ELFCLASS64 ) {
            segments_.emplace_back(
                new ( std::nothrow )
                    segment_impl<Elf64_Phdr>( &convertor, &addr_translator ) );
        }
        else if ( file_class == ELFCLASS32 ) {
            segments_.emplace_back(
                new ( std::nothrow )
                    segment_impl<Elf32_Phdr>( &convertor, &addr_translator ) );
        }
        else {
            segments_.pop_back();
            return nullptr;
        }

        segment* new_segment = segments_.back().get();
        new_segment->set_index( static_cast<Elf_Half>( segments_.size() - 1 ) );

        return new_segment;
    }

    //------------------------------------------------------------------------------
    void create_mandatory_sections()
    {
        // Create null section without calling to 'add_section' as no string
        // section containing section names exists yet
        section* sec0 = create_section();
        sec0->set_index( 0 );
        sec0->set_name( "" );
        sec0->set_name_string_offset( 0 );

        set_section_name_str_index( 1 );
        section* shstrtab = sections.add( ".shstrtab" );
        shstrtab->set_type( SHT_STRTAB );
        shstrtab->set_addr_align( 1 );
    }

    //------------------------------------------------------------------------------
    bool load_sections( std::istream& stream, bool is_lazy )
    {
        unsigned char file_class = header->get_class();
        Elf_Half      entry_size = header->get_section_entry_size();
        Elf_Half      num        = header->get_sections_num();
        Elf64_Off     offset     = header->get_sections_offset();

        if ( ( num != 0 && file_class == ELFCLASS64 &&
               entry_size < sizeof( Elf64_Shdr ) ) ||
             ( num != 0 && file_class == ELFCLASS32 &&
               entry_size < sizeof( Elf32_Shdr ) ) ) {
            return false;
        }

        for ( Elf_Half i = 0; i < num; ++i ) {
            section* sec = create_section();
            sec->load( stream,
                       static_cast<std::streamoff>( offset ) +
                           static_cast<std::streampos>( i ) * entry_size,
                       is_lazy );
            // To mark that the section is not permitted to reassign address
            // during layout calculation
            sec->set_address( sec->get_address() );
        }

        if ( Elf_Half shstrndx = get_section_name_str_index();
             SHN_UNDEF != shstrndx ) {
            string_section_accessor str_reader( sections[shstrndx] );
            for ( Elf_Half i = 0; i < num; ++i ) {
                Elf_Word section_offset = sections[i]->get_name_string_offset();
                const char* p = str_reader.get_string( section_offset );
                if ( p != nullptr ) {
                    sections[i]->set_name( p );
                }
            }
        }

        return true;
    }

    //------------------------------------------------------------------------------
    //! Checks whether the addresses of the section entirely fall within the given segment.
    //! It doesn't matter if the addresses are memory addresses, or file offsets,
    //!  they just need to be in the same address space
    static bool is_sect_in_seg( Elf64_Off sect_begin,
                                Elf_Xword sect_size,
                                Elf64_Off seg_begin,
                                Elf64_Off seg_end )
    {
        return ( seg_begin <= sect_begin ) &&
               ( sect_begin + sect_size <= seg_end ) &&
               ( sect_begin <
                 seg_end ); // this is important criteria when sect_size == 0
        // Example:  seg_begin=10, seg_end=12 (-> covering the bytes 10 and 11)
        //           sect_begin=12, sect_size=0  -> shall return false!
    }

    //------------------------------------------------------------------------------
    bool load_segments( std::istream& stream, bool is_lazy )
    {
        unsigned char file_class = header->get_class();
        Elf_Half      entry_size = header->get_segment_entry_size();
        Elf_Half      num        = header->get_segments_num();
        Elf64_Off     offset     = header->get_segments_offset();

        if ( ( num != 0 && file_class == ELFCLASS64 &&
               entry_size < sizeof( Elf64_Phdr ) ) ||
             ( num != 0 && file_class == ELFCLASS32 &&
               entry_size < sizeof( Elf32_Phdr ) ) ) {
            return false;
        }

        for ( Elf_Half i = 0; i < num; ++i ) {
            if ( file_class == ELFCLASS64 ) {
                segments_.emplace_back(
                    new ( std::nothrow ) segment_impl<Elf64_Phdr>(
                        &convertor, &addr_translator ) );
            }
            else if ( file_class == ELFCLASS32 ) {
                segments_.emplace_back(
                    new ( std::nothrow ) segment_impl<Elf32_Phdr>(
                        &convertor, &addr_translator ) );
            }
            else {
                segments_.pop_back();
                return false;
            }

            segment* seg = segments_.back().get();

            if ( !seg->load( stream,
                             static_cast<std::streamoff>( offset ) +
                                 static_cast<std::streampos>( i ) * entry_size,
                             is_lazy ) ||
                 stream.fail() ) {
                segments_.pop_back();
                return false;
            }

            seg->set_index( i );

            // Add sections to the segments (similar to readelfs algorithm)
            Elf64_Off segBaseOffset = seg->get_offset();
            Elf64_Off segEndOffset  = segBaseOffset + seg->get_file_size();
            Elf64_Off segVBaseAddr  = seg->get_virtual_address();
            Elf64_Off segVEndAddr   = segVBaseAddr + seg->get_memory_size();
            for ( const auto& psec : sections ) {
                // SHF_ALLOC sections are matched based on the virtual address
                // otherwise the file offset is matched
                if ( ( ( psec->get_flags() & SHF_ALLOC ) == SHF_ALLOC )
                         ? is_sect_in_seg( psec->get_address(),
                                           psec->get_size(), segVBaseAddr,
                                           segVEndAddr )
                         : is_sect_in_seg( psec->get_offset(), psec->get_size(),
                                           segBaseOffset, segEndOffset ) ) {
                    // Alignment of segment shall not be updated, to preserve original value
                    // It will be re-calculated on saving.
                    seg->add_section_index( psec->get_index(), 0 );
                }
            }
        }

        return true;
    }

    //------------------------------------------------------------------------------
    bool save_header( std::ostream& stream ) const
    {
        return header->save( stream );
    }

    //------------------------------------------------------------------------------
    bool save_sections( std::ostream& stream ) const
    {
        for ( const auto& sec : sections_ ) {
            std::streampos headerPosition =
                static_cast<std::streamoff>( header->get_sections_offset() ) +
                static_cast<std::streampos>(
                    header->get_section_entry_size() ) *
                    sec->get_index();

            sec->save( stream, headerPosition, sec->get_offset() );
        }
        return true;
    }

    //------------------------------------------------------------------------------
    bool save_segments( std::ostream& stream ) const
    {
        for ( const auto& seg : segments_ ) {
            std::streampos headerPosition =
                static_cast<std::streamoff>( header->get_segments_offset() ) +
                static_cast<std::streampos>(
                    header->get_segment_entry_size() ) *
                    seg->get_index();

            seg->save( stream, headerPosition, seg->get_offset() );
        }
        return true;
    }

    //------------------------------------------------------------------------------
    bool is_section_without_segment( unsigned int section_index ) const
    {
        bool found = false;

        for ( unsigned int j = 0; !found && ( j < segments.size() ); ++j ) {
            for ( Elf_Half k = 0;
                  !found && ( k < segments[j]->get_sections_num() ); ++k ) {
                found = segments[j]->get_section_index_at( k ) == section_index;
            }
        }

        return !found;
    }

    //------------------------------------------------------------------------------
    static bool is_subsequence_of( const segment* seg1, const segment* seg2 )
    {
        // Return 'true' if sections of seg1 are a subset of sections in seg2
        const std::vector<Elf_Half>& sections1 = seg1->get_sections();
        const std::vector<Elf_Half>& sections2 = seg2->get_sections();

        bool found = false;
        if ( sections1.size() < sections2.size() ) {
            found = std::includes( sections2.begin(), sections2.end(),
                                   sections1.begin(), sections1.end() );
        }

        return found;
    }

    //------------------------------------------------------------------------------
    std::vector<segment*> get_ordered_segments() const
    {
        std::vector<segment*> res;
        std::deque<segment*>  worklist;

        res.reserve( segments.size() );
        for ( const auto& seg : segments ) {
            worklist.emplace_back( seg.get() );
        }

        // Bring the segments which start at address 0 to the front
        size_t nextSlot = 0;
        for ( size_t i = 0; i < worklist.size(); ++i ) {
            if ( i != nextSlot && worklist[i]->is_offset_initialized() &&
                 worklist[i]->get_offset() == 0 ) {
                if ( worklist[nextSlot]->get_offset() == 0 ) {
                    ++nextSlot;
                }
                std::swap( worklist[i], worklist[nextSlot] );
                ++nextSlot;
            }
        }

        while ( !worklist.empty() ) {
            segment* seg = worklist.front();
            worklist.pop_front();

            size_t i = 0;
            for ( ; i < worklist.size(); ++i ) {
                if ( is_subsequence_of( seg, worklist[i] ) ) {
                    break;
                }
            }

            if ( i < worklist.size() ) {
                worklist.emplace_back( seg );
            }
            else {
                res.emplace_back( seg );
            }
        }

        return res;
    }

    //------------------------------------------------------------------------------
    bool layout_sections_without_segments()
    {
        for ( unsigned int i = 0; i < sections_.size(); ++i ) {
            if ( is_section_without_segment( i ) ) {
                const auto& sec = sections_[i];

                if ( Elf_Xword section_align = sec->get_addr_align();
                     section_align > 1 &&
                     current_file_pos % section_align != 0 ) {
                    current_file_pos +=
                        section_align - current_file_pos % section_align;
                }

                if ( 0 != sec->get_index() ) {
                    sec->set_offset( current_file_pos );
                }

                if ( SHT_NOBITS != sec->get_type() &&
                     SHT_NULL != sec->get_type() ) {
                    current_file_pos += sec->get_size();
                }
            }
        }

        return true;
    }

    //------------------------------------------------------------------------------
    void calc_segment_alignment() const
    {
        for ( const auto& seg : segments_ ) {
            for ( Elf_Half i = 0; i < seg->get_sections_num(); ++i ) {
                const auto& sect = sections_[seg->get_section_index_at( i )];
                if ( sect->get_addr_align() > seg->get_align() ) {
                    seg->set_align( sect->get_addr_align() );
                }
            }
        }
    }

    //------------------------------------------------------------------------------
    bool layout_segments_and_their_sections()
    {
        std::vector<segment*> worklist;
        std::vector<bool>     section_generated( sections.size(), false );

        // Get segments in a order in where segments which contain a
        // sub sequence of other segments are located at the end
        worklist = get_ordered_segments();

        for ( auto* seg : worklist ) {
            Elf_Xword segment_memory   = 0;
            Elf_Xword segment_filesize = 0;
            Elf_Xword seg_start_pos    = current_file_pos;
            // Special case: PHDR segment
            // This segment contains the program headers but no sections
            if ( seg->get_type() == PT_PHDR && seg->get_sections_num() == 0 ) {
                seg_start_pos  = header->get_segments_offset();
                segment_memory = segment_filesize =
                    header->get_segment_entry_size() *
                    static_cast<Elf_Xword>( header->get_segments_num() );
            }
            // Special case:
            else if ( seg->is_offset_initialized() && seg->get_offset() == 0 ) {
                seg_start_pos = 0;
                if ( seg->get_sections_num() > 0 ) {
                    segment_memory = segment_filesize = current_file_pos;
                }
            }
            // New segments with not generated sections
            // have to be aligned
            else if ( seg->get_sections_num() > 0 &&
                      !section_generated[seg->get_section_index_at( 0 )] ) {
                Elf_Xword align = seg->get_align() > 0 ? seg->get_align() : 1;
                Elf64_Off cur_page_alignment = current_file_pos % align;
                Elf64_Off req_page_alignment =
                    seg->get_virtual_address() % align;
                Elf64_Off error = req_page_alignment - cur_page_alignment;

                current_file_pos += ( seg->get_align() + error ) % align;
                seg_start_pos = current_file_pos;
            }
            else if ( seg->get_sections_num() > 0 ) {
                seg_start_pos =
                    sections[seg->get_section_index_at( 0 )]->get_offset();
            }

            // Write segment's data
            if ( !write_segment_data( seg, section_generated, segment_memory,
                                      segment_filesize, seg_start_pos ) ) {
                return false;
            }

            seg->set_file_size( segment_filesize );

            // If we already have a memory size from loading an elf file (value > 0),
            // it must not shrink!
            // Memory size may be bigger than file size and it is the loader's job to do something
            // with the surplus bytes in memory, like initializing them with a defined value.
            if ( seg->get_memory_size() < segment_memory ) {
                seg->set_memory_size( segment_memory );
            }

            seg->set_offset( seg_start_pos );
        }

        return true;
    }

    //------------------------------------------------------------------------------
    bool layout_section_table()
    {
        // Simply place the section table at the end for now
        Elf64_Off alignmentError = current_file_pos % 16;
        current_file_pos += 16 - alignmentError;
        header->set_sections_offset( current_file_pos );
        return true;
    }

    //------------------------------------------------------------------------------
    bool write_segment_data( const segment*     seg,
                             std::vector<bool>& section_generated,
                             Elf_Xword&         segment_memory,
                             Elf_Xword&         segment_filesize,
                             const Elf_Xword&   seg_start_pos )
    {
        for ( Elf_Half j = 0; j < seg->get_sections_num(); ++j ) {
            Elf_Half index = seg->get_section_index_at( j );

            section* sec = sections[index];

            // The NULL section is always generated
            if ( SHT_NULL == sec->get_type() ) {
                section_generated[index] = true;
                continue;
            }

            Elf_Xword section_align = 0;
            // Fix up the alignment
            if ( !section_generated[index] && sec->is_address_initialized() &&
                 SHT_NOBITS != sec->get_type() && SHT_NULL != sec->get_type() &&
                 0 != sec->get_size() ) {
                // Align the sections based on the virtual addresses
                // when possible (this is what matters for execution)
                Elf64_Off req_offset =
                    sec->get_address() - seg->get_virtual_address();
                Elf64_Off cur_offset = current_file_pos - seg_start_pos;
                if ( req_offset < cur_offset ) {
                    // something has gone awfully wrong, abort!
                    // section_align would turn out negative, seeking backwards and overwriting previous data
                    return false;
                }
                section_align = req_offset - cur_offset;
            }
            else if ( !section_generated[index] &&
                      !sec->is_address_initialized() ) {
                // If no address has been specified then only the section
                // alignment constraint has to be matched
                Elf_Xword align = sec->get_addr_align();
                if ( align == 0 ) {
                    align = 1;
                }
                Elf64_Off error = current_file_pos % align;
                section_align   = ( align - error ) % align;
            }
            else if ( section_generated[index] ) {
                // Alignment for already generated sections
                section_align =
                    sec->get_offset() - seg_start_pos - segment_filesize;
            }

            // Determine the segment file and memory sizes
            // Special case .tbss section (NOBITS) in non TLS segment
            if ( ( ( sec->get_flags() & SHF_ALLOC ) == SHF_ALLOC ) &&
                 !( ( ( sec->get_flags() & SHF_TLS ) == SHF_TLS ) &&
                    ( seg->get_type() != PT_TLS ) &&
                    ( SHT_NOBITS == sec->get_type() ) ) ) {
                segment_memory += sec->get_size() + section_align;
            }

            if ( SHT_NOBITS != sec->get_type() ) {
                segment_filesize += sec->get_size() + section_align;
            }

            // Nothing to be done when generating nested segments
            if ( section_generated[index] ) {
                continue;
            }

            current_file_pos += section_align;

            // Set the section addresses when missing
            if ( !sec->is_address_initialized() ) {
                sec->set_address( seg->get_virtual_address() +
                                  current_file_pos - seg_start_pos );
            }

            if ( 0 != sec->get_index() ) {
                sec->set_offset( current_file_pos );
            }

            if ( SHT_NOBITS != sec->get_type() ) {
                current_file_pos += sec->get_size();
            }

            section_generated[index] = true;
        }

        return true;
    }

    //------------------------------------------------------------------------------
  public:
    friend class Sections;
    class Sections
    {
      public:
        //------------------------------------------------------------------------------
        explicit Sections( elfio* parent ) : parent( parent ) {}

        //------------------------------------------------------------------------------
        Elf_Half size() const
        {
            return static_cast<Elf_Half>( parent->sections_.size() );
        }

        //------------------------------------------------------------------------------
        section* operator[]( unsigned int index ) const
        {
            section* sec = nullptr;

            if ( index < parent->sections_.size() ) {
                sec = parent->sections_[index].get();
            }

            return sec;
        }

        //------------------------------------------------------------------------------
        section* operator[]( const std::string_view& name ) const
        {
            section* sec = nullptr;

            for ( const auto& it : parent->sections_ ) {
                if ( it->get_name() == name ) {
                    sec = it.get();
                    break;
                }
            }

            return sec;
        }

        //------------------------------------------------------------------------------
        section* add( const std::string& name ) const
        {
            section* new_section = parent->create_section();
            new_section->set_name( name );

            Elf_Half str_index = parent->get_section_name_str_index();
            section* string_table( parent->sections_[str_index].get() );
            string_section_accessor str_writer( string_table );
            Elf_Word                pos = str_writer.add_string( name );
            new_section->set_name_string_offset( pos );

            return new_section;
        }

        //------------------------------------------------------------------------------
        std::vector<std::unique_ptr<section>>::iterator begin()
        {
            return parent->sections_.begin();
        }

        //------------------------------------------------------------------------------
        std::vector<std::unique_ptr<section>>::iterator end()
        {
            return parent->sections_.end();
        }

        //------------------------------------------------------------------------------
        std::vector<std::unique_ptr<section>>::const_iterator begin() const
        {
            return parent->sections_.cbegin();
        }

        //------------------------------------------------------------------------------
        std::vector<std::unique_ptr<section>>::const_iterator end() const
        {
            return parent->sections_.cend();
        }

        //------------------------------------------------------------------------------
      private:
        elfio* parent;
    };
    Sections sections;

    //------------------------------------------------------------------------------
    friend class Segments;
    class Segments
    {
      public:
        //------------------------------------------------------------------------------
        explicit Segments( elfio* parent ) : parent( parent ) {}

        //------------------------------------------------------------------------------
        Elf_Half size() const
        {
            return static_cast<Elf_Half>( parent->segments_.size() );
        }

        //------------------------------------------------------------------------------
        segment* operator[]( unsigned int index ) const
        {
            return parent->segments_[index].get();
        }

        //------------------------------------------------------------------------------
        segment* add() { return parent->create_segment(); }

        //------------------------------------------------------------------------------
        std::vector<std::unique_ptr<segment>>::iterator begin()
        {
            return parent->segments_.begin();
        }

        //------------------------------------------------------------------------------
        std::vector<std::unique_ptr<segment>>::iterator end()
        {
            return parent->segments_.end();
        }

        //------------------------------------------------------------------------------
        std::vector<std::unique_ptr<segment>>::const_iterator begin() const
        {
            return parent->segments_.cbegin();
        }

        //------------------------------------------------------------------------------
        std::vector<std::unique_ptr<segment>>::const_iterator end() const
        {
            return parent->segments_.cend();
        }

        //------------------------------------------------------------------------------
      private:
        elfio* parent;
    };
    Segments segments;

    //------------------------------------------------------------------------------
  private:
    std::unique_ptr<std::ifstream>         pstream = nullptr;
    std::unique_ptr<elf_header>            header  = nullptr;
    std::vector<std::unique_ptr<section>>  sections_;
    std::vector<std::unique_ptr<segment>>  segments_;
    endianess_convertor                    convertor;
    address_translator                     addr_translator;
    std::shared_ptr<compression_interface> compression = nullptr;

    Elf_Xword current_file_pos = 0;
};

} // namespace ELFIO

#include <elfio/elfio_symbols.hpp>
#include <elfio/elfio_note.hpp>
#include <elfio/elfio_relocation.hpp>
#include <elfio/elfio_dynamic.hpp>
#include <elfio/elfio_array.hpp>
#include <elfio/elfio_modinfo.hpp>
#include <elfio/elfio_versym.hpp>

#endif // ELFIO_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_ARRAY_HPP
#define ELFIO_ARRAY_HPP

#include <algorithm>

namespace ELFIO {

//------------------------------------------------------------------------------
template <class S, typename T> class array_section_accessor_template
{
  public:
    //------------------------------------------------------------------------------
    explicit array_section_accessor_template( const elfio& elf_file,
                                              S*           section )
        : elf_file( elf_file ), array_section( section )
    {
    }

    //------------------------------------------------------------------------------
    Elf_Xword get_entries_num() const
    {
        Elf_Xword entry_size = sizeof( T );
        return array_section->get_size() / entry_size;
    }

    //------------------------------------------------------------------------------
    bool get_entry( Elf_Xword index, Elf64_Addr& address ) const
    {
        if ( index >= get_entries_num() ) { // Is index valid
            return false;
        }

        const endianess_convertor& convertor = elf_file.get_convertor();

        const T temp = *reinterpret_cast<const T*>( array_section->get_data() +
                                                    index * sizeof( T ) );
        address      = convertor( temp );

        return true;
    }

    //------------------------------------------------------------------------------
    void add_entry( Elf64_Addr address )
    {
        const endianess_convertor& convertor = elf_file.get_convertor();

        T temp = convertor( (T)address );
        array_section->append_data( reinterpret_cast<char*>( &temp ),
                                    sizeof( temp ) );
    }

  private:
    //------------------------------------------------------------------------------
    const elfio& elf_file;
    S*           array_section;
};

template <typename T = Elf32_Word>
using array_section_accessor = array_section_accessor_template<section, T>;
template <typename T = Elf32_Word>
using const_array_section_accessor =
    array_section_accessor_template<const section, T>;

} // namespace ELFIO

#endif // ELFIO_ARRAY_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_DUMP_HPP
#define ELFIO_DUMP_HPP

#include <algorithm>
#include <string>
#include <ostream>
#include <sstream>
#include <iomanip>
#include <elfio/elfio.hpp>

namespace ELFIO {

static const struct class_table_t
{
    const char  key;
    const char* str;
} class_table[] = {
    { ELFCLASS32, "ELF32" },
    { ELFCLASS64, "ELF64" },
};

static const struct endian_table_t
{
    const char  key;
    const char* str;
} endian_table[] = {
    { ELFDATANONE, "None" },
    { ELFDATA2LSB, "Little endian" },
    { ELFDATA2MSB, "Big endian" },
};

static const struct os_abi_table_t
{
    const unsigned char key;
    const char*         str;
} os_abi_table[] = {
    { ELFOSABI_NONE, "UNIX System V" },
    { ELFOSABI_HPUX, "Hewlett-Packard HP-UX" },
    { ELFOSABI_NETBSD, "NetBSD" },
    { ELFOSABI_LINUX, "Linux" },
    { ELFOSABI_HURD, "GNU Hurd" },
    { ELFOSABI_SOLARIS, "Sun Solaris" },
    { ELFOSABI_AIX, "AIX" },
    { ELFOSABI_IRIX, "IRIX" },
    { ELFOSABI_FREEBSD, "FreeBSD" },
    { ELFOSABI_TRU64, "Compaq TRU64 UNIX" },
    { ELFOSABI_MODESTO, "Novell Modesto" },
    { ELFOSABI_OPENBSD, "Open BSD" },
    { ELFOSABI_OPENVMS, "Open VMS" },
    { ELFOSABI_NSK, "Hewlett-Packard Non-Stop Kernel" },
    { ELFOSABI_AROS, "Amiga Research OS" },
    { ELFOSABI_FENIXOS, "FenixOS" },
    { ELFOSABI_NUXI, "Nuxi CloudABI" },
    { ELFOSABI_OPENVOS, "OpenVOS" },
    { ELFOSABI_ARM, "ARM" },
    { ELFOSABI_STANDALONE, "Standalone (embedded)" },
};

static const struct version_table_t
{
    const Elf64_Word key;
    const char*      str;
} version_table[] = {
    { EV_NONE, "None" },
    { EV_CURRENT, "Current" },
};

static const struct type_table_t
{
    const Elf32_Half key;
    const char*      str;
} type_table[] = {
    { ET_NONE, "No file type" },    { ET_REL, "Relocatable file" },
    { ET_EXEC, "Executable file" }, { ET_DYN, "Shared object file" },
    { ET_CORE, "Core file" },
};

static const struct machine_table_t
{
    const Elf64_Half key;
    const char*      str;
} machine_table[] = {
    { EM_NONE, "No machine" },
    { EM_M32, "AT&T WE 32100" },
    { EM_SPARC, "SUN SPARC" },
    { EM_386, "Intel 80386" },
    { EM_68K, "Motorola m68k family" },
    { EM_88K, "Motorola m88k family" },
    { EM_486, "Intel 80486// Reserved for future use" },
    { EM_860, "Intel 80860" },
    { EM_MIPS, "MIPS R3000 (officially, big-endian only)" },
    { EM_S370, "IBM System/370" },
    { EM_MIPS_RS3_LE,
      "MIPS R3000 little-endian (Oct 4 1999 Draft) Deprecated" },
    { EM_res011, "Reserved" },
    { EM_res012, "Reserved" },
    { EM_res013, "Reserved" },
    { EM_res014, "Reserved" },
    { EM_PARISC, "HPPA" },
    { EM_res016, "Reserved" },
    { EM_VPP550, "Fujitsu VPP500" },
    { EM_SPARC32PLUS, "Sun's v8plus" },
    { EM_960, "Intel 80960" },
    { EM_PPC, "PowerPC" },
    { EM_PPC64, "64-bit PowerPC" },
    { EM_S390, "IBM S/390" },
    { EM_SPU, "Sony/Toshiba/IBM SPU" },
    { EM_res024, "Reserved" },
    { EM_res025, "Reserved" },
    { EM_res026, "Reserved" },
    { EM_res027, "Reserved" },
    { EM_res028, "Reserved" },
    { EM_res029, "Reserved" },
    { EM_res030, "Reserved" },
    { EM_res031, "Reserved" },
    { EM_res032, "Reserved" },
    { EM_res033, "Reserved" },
    { EM_res034, "Reserved" },
    { EM_res035, "Reserved" },
    { EM_V800, "NEC V800 series" },
    { EM_FR20, "Fujitsu FR20" },
    { EM_RH32, "TRW RH32" },
    { EM_MCORE, "Motorola M*Core // May also be taken by Fujitsu MMA" },
    { EM_RCE, "Old name for MCore" },
    { EM_ARM, "ARM" },
    { EM_OLD_ALPHA, "Digital Alpha" },
    { EM_SH, "Renesas (formerly Hitachi) / SuperH SH" },
    { EM_SPARCV9, "SPARC v9 64-bit" },
    { EM_TRICORE, "Siemens Tricore embedded processor" },
    { EM_ARC, "ARC Cores" },
    { EM_H8_300, "Renesas (formerly Hitachi) H8/300" },
    { EM_H8_300H, "Renesas (formerly Hitachi) H8/300H" },
    { EM_H8S, "Renesas (formerly Hitachi) H8S" },
    { EM_H8_500, "Renesas (formerly Hitachi) H8/500" },
    { EM_IA_64, "Intel IA-64 Processor" },
    { EM_MIPS_X, "Stanford MIPS-X" },
    { EM_COLDFIRE, "Motorola Coldfire" },
    { EM_68HC12, "Motorola M68HC12" },
    { EM_MMA, "Fujitsu Multimedia Accelerator" },
    { EM_PCP, "Siemens PCP" },
    { EM_NCPU, "Sony nCPU embedded RISC processor" },
    { EM_NDR1, "Denso NDR1 microprocesspr" },
    { EM_STARCORE, "Motorola Star*Core processor" },
    { EM_ME16, "Toyota ME16 processor" },
    { EM_ST100, "STMicroelectronics ST100 processor" },
    { EM_TINYJ, "Advanced Logic Corp. TinyJ embedded processor" },
    { EM_X86_64, "Advanced Micro Devices X86-64 processor" },
    { EM_PDSP, "Sony DSP Processor" },
    { EM_PDP10, "Digital Equipment Corp. PDP-10" },
    { EM_PDP11, "Digital Equipment Corp. PDP-11" },
    { EM_FX66, "Siemens FX66 microcontroller" },
    { EM_ST9PLUS, "STMicroelectronics ST9+ 8/16 bit microcontroller" },
    { EM_ST7, "STMicroelectronics ST7 8-bit microcontroller" },
    { EM_68HC16, "Motorola MC68HC16 Microcontroller" },
    { EM_68HC11, "Motorola MC68HC11 Microcontroller" },
    { EM_68HC08, "Motorola MC68HC08 Microcontroller" },
    { EM_68HC05, "Motorola MC68HC05 Microcontroller" },
    { EM_SVX, "Silicon Graphics SVx" },
    { EM_ST19, "STMicroelectronics ST19 8-bit cpu" },
    { EM_VAX, "Digital VAX" },
    { EM_CRIS, "Axis Communications 32-bit embedded processor" },
    { EM_JAVELIN, "Infineon Technologies 32-bit embedded cpu" },
    { EM_FIREPATH, "Element 14 64-bit DSP processor" },
    { EM_ZSP, "LSI Logic's 16-bit DSP processor" },
    { EM_MMIX, "Donald Knuth's educational 64-bit processor" },
    { EM_HUANY, "Harvard's machine-independent format" },
    { EM_PRISM, "SiTera Prism" },
    { EM_AVR, "Atmel AVR 8-bit microcontroller" },
    { EM_FR30, "Fujitsu FR30" },
    { EM_D10V, "Mitsubishi D10V" },
    { EM_D30V, "Mitsubishi D30V" },
    { EM_V850, "NEC v850" },
    { EM_M32R, "Renesas M32R (formerly Mitsubishi M32R)" },
    { EM_MN10300, "Matsushita MN10300" },
    { EM_MN10200, "Matsushita MN10200" },
    { EM_PJ, "picoJava" },
    { EM_OPENRISC, "OpenRISC 32-bit embedded processor" },
    { EM_ARC_A5, "ARC Cores Tangent-A5" },
    { EM_XTENSA, "Tensilica Xtensa Architecture" },
    { EM_VIDEOCORE, "Alphamosaic VideoCore processor" },
    { EM_TMM_GPP, "Thompson Multimedia General Purpose Processor" },
    { EM_NS32K, "National Semiconductor 32000 series" },
    { EM_TPC, "Tenor Network TPC processor" },
    { EM_SNP1K, "Trebia SNP 1000 processor" },
    { EM_ST200, "STMicroelectronics ST200 microcontroller" },
    { EM_IP2K, "Ubicom IP2022 micro controller" },
    { EM_MAX, "MAX Processor" },
    { EM_CR, "National Semiconductor CompactRISC" },
    { EM_F2MC16, "Fujitsu F2MC16" },
    { EM_MSP430, "TI msp430 micro controller" },
    { EM_BLACKFIN, "ADI Blackfin" },
    { EM_SE_C33, "S1C33 Family of Seiko Epson processors" },
    { EM_SEP, "Sharp embedded microprocessor" },
    { EM_ARCA, "Arca RISC Microprocessor" },
    { EM_UNICORE, "Microprocessor series from PKU-Unity Ltd. and MPRC of "
                  "Peking University" },
    { EM_EXCESS, "eXcess: 16/32/64-bit configurable embedded CPU" },
    { EM_DXP, "Icera Semiconductor Inc. Deep Execution Processor" },
    { EM_ALTERA_NIOS2, "Altera Nios II soft-core processor" },
    { EM_CRX, "National Semiconductor CRX" },
    { EM_XGATE, "Motorola XGATE embedded processor" },
    { EM_C166, "Infineon C16x/XC16x processor" },
    { EM_M16C, "Renesas M16C series microprocessors" },
    { EM_DSPIC30F, "Microchip Technology dsPIC30F Digital Signal Controller" },
    { EM_CE, "Freescale Communication Engine RISC core" },
    { EM_M32C, "Renesas M32C series microprocessors" },
    { EM_res121, "Reserved" },
    { EM_res122, "Reserved" },
    { EM_res123, "Reserved" },
    { EM_res124, "Reserved" },
    { EM_res125, "Reserved" },
    { EM_res126, "Reserved" },
    { EM_res127, "Reserved" },
    { EM_res128, "Reserved" },
    { EM_res129, "Reserved" },
    { EM_res130, "Reserved" },
    { EM_TSK3000, "Altium TSK3000 core" },
    { EM_RS08, "Freescale RS08 embedded processor" },
    { EM_res133, "Reserved" },
    { EM_ECOG2, "Cyan Technology eCOG2 microprocessor" },
    { EM_SCORE, "Sunplus Score" },
    { EM_SCORE7, "Sunplus S+core7 RISC processor" },
    { EM_DSP24, "New Japan Radio (NJR) 24-bit DSP Processor" },
    { EM_VIDEOCORE3, "Broadcom VideoCore III processor" },
    { EM_LATTICEMICO32, "RISC processor for Lattice FPGA architecture" },
    { EM_SE_C17, "Seiko Epson C17 family" },
    { EM_TI_C6000, "Texas Instruments TMS320C6000 DSP family" },
    { EM_TI_C2000, "Texas Instruments TMS320C2000 DSP family" },
    { EM_TI_C5500, "Texas Instruments TMS320C55x DSP family" },
    { EM_res143, "Reserved" },
    { EM_res144, "Reserved" },
    { EM_res145, "Reserved" },
    { EM_res146, "Reserved" },
    { EM_res147, "Reserved" },
    { EM_res148, "Reserved" },
    { EM_res149, "Reserved" },
    { EM_res150, "Reserved" },
    { EM_res151, "Reserved" },
    { EM_res152, "Reserved" },
    { EM_res153, "Reserved" },
    { EM_res154, "Reserved" },
    { EM_res155, "Reserved" },
    { EM_res156, "Reserved" },
    { EM_res157, "Reserved" },
    { EM_res158, "Reserved" },
    { EM_res159, "Reserved" },
    { EM_MMDSP_PLUS, "STMicroelectronics 64bit VLIW Data Signal Processor" },
    { EM_CYPRESS_M8C, "Cypress M8C microprocessor" },
    { EM_R32C, "Renesas R32C series microprocessors" },
    { EM_TRIMEDIA, "NXP Semiconductors TriMedia architecture family" },
    { EM_QDSP6, "QUALCOMM DSP6 Processor" },
    { EM_8051, "Intel 8051 and variants" },
    { EM_STXP7X, "STMicroelectronics STxP7x family" },
    { EM_NDS32,
      "Andes Technology compact code size embedded RISC processor family" },
    { EM_ECOG1, "Cyan Technology eCOG1X family" },
    { EM_ECOG1X, "Cyan Technology eCOG1X family" },
    { EM_MAXQ30, "Dallas Semiconductor MAXQ30 Core Micro-controllers" },
    { EM_XIMO16, "New Japan Radio (NJR) 16-bit DSP Processor" },
    { EM_MANIK, "M2000 Reconfigurable RISC Microprocessor" },
    { EM_CRAYNV2, "Cray Inc. NV2 vector architecture" },
    { EM_RX, "Renesas RX family" },
    { EM_METAG, "Imagination Technologies META processor architecture" },
    { EM_MCST_ELBRUS, "MCST Elbrus general purpose hardware architecture" },
    { EM_ECOG16, "Cyan Technology eCOG16 family" },
    { EM_CR16, "National Semiconductor CompactRISC 16-bit processor" },
    { EM_ETPU, "Freescale Extended Time Processing Unit" },
    { EM_SLE9X, "Infineon Technologies SLE9X core" },
    { EM_L1OM, "Intel L1OM" },
    { EM_INTEL181, "Reserved by Intel" },
    { EM_INTEL182, "Reserved by Intel" },
    { EM_AARCH64, "ARM AArch64" },
    { EM_res184, "Reserved by ARM" },
    { EM_AVR32, "Atmel Corporation 32-bit microprocessor family" },
    { EM_STM8, "STMicroeletronics STM8 8-bit microcontroller" },
    { EM_TILE64, "Tilera TILE64 multicore architecture family" },
    { EM_TILEPRO, "Tilera TILEPro multicore architecture family" },
    { EM_MICROBLAZE, "Xilinx MicroBlaze 32-bit RISC soft processor core" },
    { EM_CUDA, "NVIDIA CUDA architecture " },
    { EM_TILEGX, "Tilera TILE-Gx multicore architecture family" },
    { EM_CLOUDSHIELD, "CloudShield architecture family" },
    { EM_COREA_1ST, "KIPO-KAIST Core-A 1st generation processor family" },
    { EM_COREA_2ND, "KIPO-KAIST Core-A 2nd generation processor family" },
    { EM_ARC_COMPACT2, "Synopsys ARCompact V2" },
    { EM_OPEN8, "Open8 8-bit RISC soft processor core" },
    { EM_RL78, "Renesas RL78 family" },
    { EM_VIDEOCORE5, "Broadcom VideoCore V processor" },
    { EM_78KOR, "Renesas 78KOR family" },
    { EM_56800EX, "Freescale 56800EX Digital Signal Controller (DSC)" },
    { EM_BA1, "Beyond BA1 CPU architecture" },
    { EM_BA2, "Beyond BA2 CPU architecture" },
    { EM_XCORE, "XMOS xCORE processor family" },
    { EM_MCHP_PIC, "Microchip 8-bit PIC(r) family" },
    { EM_INTEL205, "Reserved by Intel" },
    { EM_INTEL206, "Reserved by Intel" },
    { EM_INTEL207, "Reserved by Intel" },
    { EM_INTEL208, "Reserved by Intel" },
    { EM_INTEL209, "Reserved by Intel" },
    { EM_KM32, "KM211 KM32 32-bit processor" },
    { EM_KMX32, "KM211 KMX32 32-bit processor" },
    { EM_KMX16, "KM211 KMX16 16-bit processor" },
    { EM_KMX8, "KM211 KMX8 8-bit processor" },
    { EM_KVARC, "KM211 KVARC processor" },
    { EM_CDP, "Paneve CDP architecture family" },
    { EM_COGE, "Cognitive Smart Memory Processor" },
    { EM_COOL, "iCelero CoolEngine" },
    { EM_NORC, "Nanoradio Optimized RISC" },
    { EM_CSR_KALIMBA, "CSR Kalimba architecture family" },
    { EM_Z80, "Zilog Z80" },
    { EM_VISIUM, "Controls and Data Services VISIUMcore processor" },
    { EM_FT32, "FTDI Chip FT32 high performance 32-bit RISC architecture" },
    { EM_MOXIE, "Moxie processor family" },
    { EM_AMDGPU, "AMD GPU architecture" },
    { EM_RISCV, "RISC-V" },
    { EM_LANAI, "Lanai processor" },
    { EM_CEVA, "CEVA Processor Architecture Family" },
    { EM_CEVA_X2, "CEVA X2 Processor Family" },
    { EM_BPF, "Linux BPF  in-kernel virtual machine" },
    { EM_GRAPHCORE_IPU, "Graphcore Intelligent Processing Unit" },
    { EM_IMG1, "Imagination Technologies" },
    { EM_NFP, "Netronome Flow Processor (P)" },
    { EM_CSKY, "C-SKY processor family" },
    { EM_ARC_COMPACT3_64, "Synopsys ARCv2.3 64-bit" },
    { EM_MCS6502, "MOS Technology MCS 6502 processor" },
    { EM_ARC_COMPACT3, "Synopsys ARCv2.3 32-bit" },
    { EM_KVX, "Kalray VLIW core of the MPPA processor family" },
    { EM_65816, "WDC 65816/65C816" },
    { EM_LOONGARCH, "Loongson Loongarch" },
    { EM_KF32, "ChipON KungFu32" },
    { EM_MT, "Morpho Techologies MT processor" },
    { EM_ALPHA, "Alpha" },
    { EM_WEBASSEMBLY, "Web Assembly" },
    { EM_DLX, "OpenDLX" },
    { EM_XSTORMY16, "Sanyo XStormy16 CPU core" },
    { EM_IQ2000, "Vitesse IQ2000" },
    { EM_M32C_OLD, "M32C_OLD" },
    { EM_NIOS32, "Altera Nios" },
    { EM_CYGNUS_MEP, "Toshiba MeP Media Engine" },
    { EM_ADAPTEVA_EPIPHANY, "Adapteva EPIPHANY" },
    { EM_CYGNUS_FRV, "Fujitsu FR-V" },
    { EM_S12Z, "Freescale S12Z" },
};

static const struct section_type_table_t
{
    const Elf64_Word key;
    const char*      str;
} section_type_table[] = {
    { SHT_NULL, "NULL" },
    { SHT_PROGBITS, "PROGBITS" },
    { SHT_SYMTAB, "SYMTAB" },
    { SHT_STRTAB, "STRTAB" },
    { SHT_RELA, "RELA" },
    { SHT_HASH, "HASH" },
    { SHT_DYNAMIC, "DYNAMIC" },
    { SHT_NOTE, "NOTE" },
    { SHT_NOBITS, "NOBITS" },
    { SHT_REL, "REL" },
    { SHT_SHLIB, "SHLIB" },
    { SHT_DYNSYM, "DYNSYM" },
    { SHT_INIT_ARRAY, "INIT_ARRAY" },
    { SHT_FINI_ARRAY, "FINI_ARRAY" },
    { SHT_PREINIT_ARRAY, "PREINIT_ARRAY" },
    { SHT_GROUP, "GROUP" },
    { SHT_SYMTAB_SHNDX, "SYMTAB_SHNDX" },
    { SHT_GNU_ATTRIBUTES, "GNU_ATTRIBUTES" },
    { SHT_GNU_HASH, "GNU_HASH" },
    { SHT_GNU_LIBLIST, "GNU_LIBLIST" },
    { SHT_CHECKSUM, "CHECKSUM" },
    { SHT_LOSUNW, "LOSUNW" },
    { SHT_SUNW_move, "SUNW_move" },
    { SHT_SUNW_COMDAT, "SUNW_COMDAT" },
    { SHT_SUNW_syminfo, "SUNW_syminfo" },
    { SHT_GNU_verdef, "GNU_verdef" },
    { SHT_GNU_verneed, "GNU_verneed" },
    { SHT_GNU_versym, "GNU_versym" },
    { SHT_ARM_EXIDX, "ARM_EXIDX" },
    { SHT_ARM_PREEMPTMAP, "ARM_PREEMPTMAP" },
    { SHT_ARM_ATTRIBUTES, "ARM_ATTRIBUTES" },
    { SHT_ARM_DEBUGOVERLAY, "ARM_DEBUGOVERLAY" },
    { SHT_ARM_OVERLAYSECTION, "ARM_OVERLAYSECTION" },

};

static const struct segment_type_table_t
{
    const Elf_Word key;
    const char*    str;
} segment_type_table[] = {
    { PT_NULL, "NULL" },
    { PT_LOAD, "LOAD" },
    { PT_DYNAMIC, "DYNAMIC" },
    { PT_INTERP, "INTERP" },
    { PT_NOTE, "NOTE" },
    { PT_SHLIB, "SHLIB" },
    { PT_PHDR, "PHDR" },
    { PT_TLS, "TLS" },
    { PT_GNU_EH_FRAME, "GNU_EH_FRAME" },
    { PT_GNU_STACK, "GNU_STACK" },
    { PT_GNU_RELRO, "GNU_RELRO" },
    { PT_GNU_PROPERTY, "GNU_PROPERTY" },
    { PT_GNU_MBIND_LO, "GNU_MBIND_LO" },
    { PT_GNU_MBIND_HI, "GNU_MBIND_HI" },
    { PT_PAX_FLAGS, "PAX_FLAGS" },
    { PT_OPENBSD_RANDOMIZE, "OPENBSD_RANDOMIZE" },
    { PT_OPENBSD_WXNEEDED, "OPENBSD_WXNEEDED " },
    { PT_OPENBSD_BOOTDATA, "OPENBSD_BOOTDATA " },
    { PT_SUNWBSS, "PT_SUNWBSS" },
    { PT_SUNWSTACK, "SUNWSTACK" },
};

static const struct segment_flag_table_t
{
    const Elf_Word key;
    const char*    str;
} segment_flag_table[] = {
    { 0, "   " }, { 1, "  E" }, { 2, " W " }, { 3, " WE" },
    { 4, "R  " }, { 5, "R E" }, { 6, "RW " }, { 7, "RWE" },
};

static const struct symbol_bind_t
{
    const Elf_Word key;
    const char*    str;
} symbol_bind_table[] = {
    { STB_LOCAL, "LOCAL" },   { STB_GLOBAL, "GLOBAL" },
    { STB_WEAK, "WEAK" },     { STB_LOOS, "LOOS" },
    { STB_HIOS, "HIOS" },     { STB_MULTIDEF, "MULTIDEF" },
    { STB_LOPROC, "LOPROC" }, { STB_HIPROC, "HIPROC" },
};

static const struct symbol_type_t
{
    const Elf_Word key;
    const char*    str;
} symbol_type_table[] = {
    { STT_NOTYPE, "NOTYPE" }, { STT_OBJECT, "OBJECT" },
    { STT_FUNC, "FUNC" },     { STT_SECTION, "SECTION" },
    { STT_FILE, "FILE" },     { STT_COMMON, "COMMON" },
    { STT_TLS, "TLS" },       { STT_LOOS, "LOOS" },
    { STT_HIOS, "HIOS" },     { STT_LOPROC, "LOPROC" },
    { STT_HIPROC, "HIPROC" },
};

static const struct dynamic_tag_t
{
    const Elf_Word key;
    const char*    str;
} dynamic_tag_table[] = {
    { DT_NULL, "NULL" },
    { DT_NEEDED, "NEEDED" },
    { DT_PLTRELSZ, "PLTRELSZ" },
    { DT_PLTGOT, "PLTGOT" },
    { DT_HASH, "HASH" },
    { DT_STRTAB, "STRTAB" },
    { DT_SYMTAB, "SYMTAB" },
    { DT_RELA, "RELA" },
    { DT_RELASZ, "RELASZ" },
    { DT_RELAENT, "RELAENT" },
    { DT_STRSZ, "STRSZ" },
    { DT_SYMENT, "SYMENT" },
    { DT_INIT, "INIT" },
    { DT_FINI, "FINI" },
    { DT_SONAME, "SONAME" },
    { DT_RPATH, "RPATH" },
    { DT_SYMBOLIC, "SYMBOLIC" },
    { DT_REL, "REL" },
    { DT_RELSZ, "RELSZ" },
    { DT_RELENT, "RELENT" },
    { DT_PLTREL, "PLTREL" },
    { DT_DEBUG, "DEBUG" },
    { DT_TEXTREL, "TEXTREL" },
    { DT_JMPREL, "JMPREL" },
    { DT_BIND_NOW, "BIND_NOW" },
    { DT_INIT_ARRAY, "INIT_ARRAY" },
    { DT_FINI_ARRAY, "FINI_ARRAY" },
    { DT_INIT_ARRAYSZ, "INIT_ARRAYSZ" },
    { DT_FINI_ARRAYSZ, "FINI_ARRAYSZ" },
    { DT_RUNPATH, "RUNPATH" },
    { DT_FLAGS, "FLAGS" },
    { DT_ENCODING, "ENCODING" },
    { DT_PREINIT_ARRAY, "PREINIT_ARRAY" },
    { DT_PREINIT_ARRAYSZ, "PREINIT_ARRAYSZ" },
    { DT_MAXPOSTAGS, "MAXPOSTAGS" },
    { DT_GNU_HASH, "GNU_HASH" },
    { DT_TLSDESC_PLT, "TLSDESC_PLT" },
    { DT_TLSDESC_GOT, "TLSDESC_GOT" },
    { DT_GNU_CONFLICT, "GNU_CONFLICT" },
    { DT_GNU_LIBLIST, "GNU_LIBLIST" },
    { DT_CONFIG, "CONFIG" },
    { DT_DEPAUDIT, "DEPAUDIT" },
    { DT_AUDIT, "AUDIT" },
    { DT_PLTPAD, "PLTPAD" },
    { DT_MOVETAB, "MOVETAB" },
    { DT_SYMINFO, "SYMINFO" },
    { DT_ADDRRNGHI, "ADDRRNGHI" },
    { DT_VERSYM, "VERSYM" },
    { DT_RELACOUNT, "RELACOUNT" },
    { DT_RELCOUNT, "RELCOUNT" },
    { DT_FLAGS_1, "FLAGS_1" },
    { DT_VERDEF, "VERDEF" },
    { DT_VERDEFNUM, "VERDEFNUM" },
    { DT_VERNEED, "VERNEED" },
    { DT_VERNEEDNUM, "VERNEEDNUM" },
};

// clang-format off
static const struct note_tag_t
{
    struct note_values_t
    {
        Elf64_Word  type;
        std::string type_str;
        std::string description;
    };
    std::string                name;
    std::vector<note_values_t> values;
} note_tag_table[] = {
    { "",
      { { NT_PRSTATUS,     "NT_PRSTATUS",     "prstatus struct" },
        { NT_FPREGSET,     "NT_FPREGSET",     "fpregset struct" },
        { NT_PRPSINFO,     "NT_PRPSINFO",     "prpsinfo struct" },
        { NT_TASKSTRUCT,   "NT_TASKSTRUCT",   "task struct" },
        { NT_AUXV,         "NT_AUXV",         "Elfxx_auxv_t" },
        { NT_PSTATUS,      "NT_PSTATUS",      "pstatus struct" },
        { NT_FPREGS,       "NT_FPREGS",       "fpregset struct" },
        { NT_PSINFO,       "NT_PSINFO",       "psinfo struct" },
        { NT_LWPSTATUS,    "NT_LWPSTATUS",    "lwpstatus_t struct" },
        { NT_LWPSINFO,     "NT_LWPSINFO",     "lwpsinfo_t struct" },
        { NT_WIN32PSTATUS, "NT_WIN32PSTATUS", "win32_pstatus struct" },
      } },
    { "LINUX",
      { { NT_PRXFPREG,             "NT_PRXFPREG", "Contains a user_xfpregs_struct;" },
        { NT_PPC_VMX,              "NT_PPC_VMX", "PowerPC Altivec/VMX registers" },
        { NT_PPC_VSX,              "NT_PPC_VSX", "PowerPC VSX registers" },
        { NT_PPC_TAR,              "NT_PPC_TAR", "PowerPC Target Address Register" },
        { NT_PPC_PPR,              "NT_PPC_PPR", "PowerPC Program Priority Register" },
        { NT_PPC_DSCR,             "NT_PPC_DSCR", "PowerPC Data Stream Control Register" },
        { NT_PPC_EBB,              "NT_PPC_EBB", "PowerPC Event Based Branch Registers" },
        { NT_PPC_PMU,              "NT_PPC_PMU", "PowerPC Performance Monitor Registers" },
        { NT_PPC_TM_CGPR,          "NT_PPC_TM_CGPR", "PowerPC TM checkpointed GPR Registers" },
        { NT_PPC_TM_CFPR,          "NT_PPC_TM_CFPR", "PowerPC TM checkpointed FPR Registers" },
        { NT_PPC_TM_CVMX,          "NT_PPC_TM_CVMX", "PowerPC TM checkpointed VMX Registers" },
        { NT_PPC_TM_CVSX,          "NT_PPC_TM_CVSX", "PowerPC TM checkpointed VSX Registers" },
        { NT_PPC_TM_SPR,           "NT_PPC_TM_SPR",   "PowerPC TM Special Purpose Registers" },
        { NT_PPC_TM_CTAR,          "NT_PPC_TM_CTAR", "PowerPC TM checkpointed TAR" },
        { NT_PPC_TM_CPPR,          "NT_PPC_TM_CPPR", "PowerPC TM checkpointed PPR" },
        { NT_PPC_TM_CDSCR,         "NT_PPC_TM_CDSCR", "PowerPC TM checkpointed Data SCR" },
        { NT_386_TLS,              "NT_386_TLS", "x86 TLS information" },
        { NT_386_IOPERM,           "NT_386_IOPERM", "x86 io permissions" },
        { NT_X86_XSTATE,           "NT_X86_XSTATE", "x86 XSAVE extended state" },
        { NT_X86_CET,              "NT_X86_CET", "x86 CET state" },
        { NT_S390_HIGH_GPRS,       "NT_S390_HIGH_GPRS", "S/390 upper halves of GPRs " },
        { NT_S390_TIMER,           "NT_S390_TIMER", "S390 timer" },
        { NT_S390_TODCMP,          "NT_S390_TODCMP", "S390 TOD clock comparator" },
        { NT_S390_TODPREG,         "NT_S390_TODPREG", "S390 TOD programmable register" },
        { NT_S390_CTRS,            "NT_S390_CTRS", "S390 control registers" },
        { NT_S390_PREFIX,          "NT_S390_PREFIX", "S390 prefix register" },
        { NT_S390_LAST_BREAK,      "NT_S390_LAST_BREAK", "S390 breaking event address" },
        { NT_S390_SYSTEM_CALL,     "NT_S390_SYSTEM_CALL", "S390 system call restart data" },
        { NT_S390_TDB,             "NT_S390_TDB", "S390 transaction diagnostic block" },
        { NT_S390_VXRS_LOW,        "NT_S390_VXRS_LOW", "S390 vector registers 0-15 upper half" },
        { NT_S390_VXRS_HIGH,       "NT_S390_VXRS_HIGH", "S390 vector registers 16-31" },
        { NT_S390_GS_CB,           "NT_S390_GS_CB", "s390 guarded storage registers" },
        { NT_S390_GS_BC,           "NT_S390_GS_BC", "s390 guarded storage broadcast control block" },
        { NT_ARM_VFP,              "NT_ARM_VFP", "ARM VFP registers" },
        { NT_ARM_TLS,              "NT_ARM_TLS", "AArch TLS registers" },
        { NT_ARM_HW_BREAK,         "NT_ARM_HW_BREAK", "AArch hardware breakpoint registers" },
        { NT_ARM_HW_WATCH,         "NT_ARM_HW_WATCH", "AArch hardware watchpoint registers" },
        { NT_ARM_SVE,              "NT_ARM_SVE", "AArch SVE registers. " },
        { NT_ARM_PAC_MASK,         "NT_ARM_PAC_MASK", "AArch pointer authentication code masks" },
        { NT_ARM_PACA_KEYS,        "NT_ARM_PACA_KEYS", "ARM pointer authentication address keys" },
        { NT_ARM_PACG_KEYS,        "NT_ARM_PACG_KEYS", "ARM pointer authentication generic keys" },
        { NT_ARM_TAGGED_ADDR_CTRL, "NT_ARM_TAGGED_ADDR_CTRL", "AArch64 tagged address control (prctl())" },
        { NT_ARM_PAC_ENABLED_KEYS, "NT_ARM_PAC_ENABLED_KEYS", "AArch64 pointer authentication enabled keys (prctl())" },
        { NT_ARC_V2,               "NT_ARC_V2", "ARC HS accumulator/extra registers. " },
        { NT_LARCH_CPUCFG,         "NT_LARCH_CPUCFG", "LoongArch CPU config registers" },
        { NT_LARCH_CSR,            "NT_LARCH_CSR", "LoongArch Control State Registers" },
        { NT_LARCH_LSX,            "NT_LARCH_LSX", "LoongArch SIMD eXtension registers" },
        { NT_LARCH_LASX,           "NT_LARCH_LASX", "LoongArch Advanced SIMD eXtension registers" },
        { NT_RISCV_CSR,            "NT_RISCV_CSR", "RISC-V Control and Status Registers" },
      } },
    { "CORE",
      { { NT_LARCH_LBT, "NT_LARCH_LBT", "LoongArch Binary Translation registers" }
      } },
    { "FreeBSD",
      { { NT_FREEBSD_THRMISC,            "NT_FREEBSD_THRMISC",            "Thread miscellaneous info." },
        { NT_FREEBSD_PROCSTAT_PROC,      "NT_FREEBSD_PROCSTAT_PROC",      "Procstat proc data." },
        { NT_FREEBSD_PROCSTAT_FILES,     "NT_FREEBSD_PROCSTAT_FILES",     "Procstat files data." },
        { NT_FREEBSD_PROCSTAT_VMMAP,     "NT_FREEBSD_PROCSTAT_VMMAP",     "Procstat vmmap data." },
        { NT_FREEBSD_PROCSTAT_GROUPS,    "NT_FREEBSD_PROCSTAT_GROUPS",    "Procstat groups data." },
        { NT_FREEBSD_PROCSTAT_UMASK,     "NT_FREEBSD_PROCSTAT_UMASK",     "Procstat umask data." },
        { NT_FREEBSD_PROCSTAT_RLIMIT,    "NT_FREEBSD_PROCSTAT_RLIMIT",    "Procstat rlimit data." },
        { NT_FREEBSD_PROCSTAT_OSREL,     "NT_FREEBSD_PROCSTAT_OSREL",     "Procstat osreldate data." },
        { NT_FREEBSD_PROCSTAT_PSSTRINGS, "NT_FREEBSD_PROCSTAT_PSSTRINGS", "Procstat ps_strings data." },
        { NT_FREEBSD_PROCSTAT_AUXV,      "NT_FREEBSD_PROCSTAT_AUXV",      "Procstat auxv data." },
        { NT_FREEBSD_PTLWPINFO,          "NT_FREEBSD_PTLWPINFO",          "Thread ptrace miscellaneous info." },
      } },
    { "NetBSD-CORE",
      { { NT_NETBSDCORE_PROCINFO,  "NT_NETBSDCORE_PROCINFO",  "Has a struct procinfo" },
        { NT_NETBSDCORE_AUXV,      "NT_NETBSDCORE_AUXV",      "Has auxv data" },
        { NT_NETBSDCORE_LWPSTATUS, "NT_NETBSDCORE_LWPSTATUS", "Has LWPSTATUS data" },
        { NT_NETBSDCORE_FIRSTMACH, "NT_NETBSDCORE_FIRSTMACH", "start of machdep note types" },
      } },
    { "OpenBSD",
      { { NT_OPENBSD_PROCINFO, "NT_OPENBSD_PROCINFO", "" },
        { NT_OPENBSD_AUXV,     "NT_OPENBSD_AUXV",     "" },
        { NT_OPENBSD_REGS,     "NT_OPENBSD_REGS",     "" },
        { NT_OPENBSD_FPREGS,   "NT_OPENBSD_FPREGS",   "" },
        { NT_OPENBSD_XFPREGS,  "NT_OPENBSD_XFPREGS",  "" },
        { NT_OPENBSD_WCOOKIE,  "NT_OPENBSD_WCOOKIE",  "" },
      } },
    { "SPU",
      { { NT_SPU, "NT_SPU", "" }
      } },
    { "GNU",
      { 
        { NT_GNU_ABI_TAG,          "NT_GNU_ABI_TAG",         "GNU ABI tag" },
        { NT_GNU_HWCAP,            "NT_GNU_HWCAP",           "Used by ld.so and kernel vDSO" },
        { NT_GNU_BUILD_ID,         "NT_GNU_BUILD_ID",        "Build ID of the binary" },
        { NT_GNU_GOLD_VERSION,     "NT_GNU_GOLD_VERSION",    "Version of GNU gold used to link the binary" },
        { NT_GNU_PROPERTY_TYPE_0,  "NT_GNU_PROPERTY_TYPE_0", "Property type 0" },
        // { NT_GNU_PROPERTY_TYPE_1,  "NT_GNU_PROPERTY_TYPE_1",  "Property type 1" },
        // { NT_GNU_PROPERTY_TYPE_2,  "NT_GNU_PROPERTY_TYPE_2",  "Property type 2" },
        // { NT_GNU_PROPERTY_TYPE_3,  "NT_GNU_PROPERTY_TYPE_3",  "Property type 3" },
        // { NT_GNU_PROPERTY_TYPE_4,  "NT_GNU_PROPERTY_TYPE_4",  "Property type 4" },
        // { NT_GNU_PROPERTY_TYPE_5,  "NT_GNU_PROPERTY_TYPE_5",  "Property type 5" },
        // { NT_GNU_PROPERTY_TYPE_6,  "NT_GNU_PROPERTY_TYPE_6",  "Property type 6" },
        // { NT_GNU_PROPERTY_TYPE_7,  "NT_GNU_PROPERTY_TYPE_7",  "Property type 7" },
        // { NT_GNU_PROPERTY_TYPE_8,  "NT_GNU_PROPERTY_TYPE_8",  "Property type 8" },
        // { NT_GNU_PROPERTY_TYPE_9,  "NT_GNU_PROPERTY_TYPE_9",  "Property type 9" },
        // { NT_GNU_PROPERTY_TYPE_10, "NT_GNU_PROPERTY_TYPE_10", "Property type 10" },
        // { NT_GNU_PROPERTY_TYPE_11, "NT_GNU_PROPERTY_TYPE_11", "Property type 11" },
        // { NT_GNU_PROPERTY_TYPE_12, "NT_GNU_PROPERTY_TYPE_12", "Property type 12" },
        // { NT_GNU_PROPERTY_TYPE_13, "NT_GNU_PROPERTY_TYPE_13", "Property type 13" },
        // { NT_GNU_PROPERTY_TYPE_14, "NT_GNU_PROPERTY_TYPE_14", "Property type 14" },
      } },
    // { "SOLARIS",
    //   { { NT_SOLARIS_AUXV, "NT_SOLARIS_AUXV", "" }
    //   } },
    // { "AIX",
    //   { { NT_AIX_AUXV, "NT_AIX_AUXV", "" }
    //   } },
    // { "IRIX",
    //   { { NT_IRIX_FPREGS, "NT_IRIX_FPREGS", "" }
    //   } },
};
// clang-format on

static const ELFIO::Elf_Xword MAX_DATA_ENTRIES = 64;

//------------------------------------------------------------------------------
class dump
{
#define DUMP_DEC_FORMAT( width ) \
    std::setw( width ) << std::setfill( ' ' ) << std::dec << std::right
#define DUMP_HEX0x_FORMAT( width ) \
    "0x" << std::setw( width ) << std::setfill( '0' ) << std::hex << std::right
#define DUMP_HEX_FORMAT( width ) \
    std::setw( width ) << std::setfill( '0' ) << std::hex << std::right
#define DUMP_STR_FORMAT( width ) \
    std::setw( width ) << std::setfill( ' ' ) << std::hex << std::left

  public:
    //------------------------------------------------------------------------------
    static void header( std::ostream& out, const elfio& reader )
    {
        if ( !reader.get_header_size() ) {
            return;
        }
        out << "ELF Header" << std::endl
            << std::endl
            << "  Class:      " << str_class( reader.get_class() ) << std::endl
            << "  Encoding:   " << str_endian( reader.get_encoding() )
            << std::endl
            << "  ELFVersion: " << str_version( reader.get_elf_version() )
            << std::endl
            << "  OS/ABI:     " << str_os_abi( reader.get_os_abi() )
            << std::endl
            << "  ABI Version:" << (int)reader.get_abi_version() << std::endl
            << "  Type:       " << str_type( reader.get_type() ) << std::endl
            << "  Machine:    " << str_machine( reader.get_machine() )
            << std::endl
            << "  Version:    " << str_version( reader.get_version() )
            << std::endl
            << "  Entry:      "
            << "0x" << std::hex << reader.get_entry() << std::endl
            << "  Flags:      "
            << "0x" << std::hex << reader.get_flags() << std::endl
            << std::endl;
    }

    //------------------------------------------------------------------------------
    static void section_headers( std::ostream& out, const elfio& reader )
    {
        Elf_Half n = reader.sections.size();

        if ( n == 0 ) {
            return;
        }

        out << "Section Headers:" << std::endl;
        if ( reader.get_class() == ELFCLASS32 ) { // Output for 32-bit
            out << "[  Nr ] Type              Addr       Size       ES   Flg "
                   "Lk   Inf   Al   Name"
                << std::endl;
        }
        else { // Output for 64-bit
            out << "[  Nr ] Type              Addr               Size          "
                   "     Offset     Flg"
                << std::endl
                << "        ES     Lk     Inf    Al       Name" << std::endl;
        }

        for ( Elf_Half i = 0; i < n; ++i ) { // For all sections
            const section* sec = reader.sections[i];
            section_header( out, i, sec, reader.get_class() );
        }

        out << "Key to Flags: W (write), A (alloc), X (execute), " << std::endl;
        out << "              M (merge), S (strings), I (info)," << std::endl;
        out << "              L (link order), O (extra OS processing required),"
            << std::endl;
        out << "              G (group), T (TLS), C (compressed), E (exclude)"
            << std::endl;
    }

    //------------------------------------------------------------------------------
    static void section_header( std::ostream&  out,
                                Elf_Half       no,
                                const section* sec,
                                unsigned char  elf_class )
    {
        std::ios_base::fmtflags original_flags = out.flags();

        // clang-format off
        if ( elf_class == ELFCLASS32 ) { // Output for 32-bit
            out << "[" << DUMP_DEC_FORMAT( 5 ) << no << "] "
                << DUMP_STR_FORMAT( 17 ) << str_section_type( sec->get_type() )
                << " " << DUMP_HEX0x_FORMAT( 8 ) << sec->get_address() << " "
                << DUMP_HEX0x_FORMAT( 8 ) << sec->get_size() << " "
                << DUMP_HEX0x_FORMAT( 2 ) << sec->get_entry_size() << " "
                << DUMP_STR_FORMAT( 3 ) << section_flags( sec->get_flags() )
                << " " << DUMP_HEX0x_FORMAT( 2 ) << sec->get_link() << " "
                << DUMP_HEX0x_FORMAT( 3 ) << sec->get_info() << " "
                << DUMP_HEX0x_FORMAT( 2 ) << sec->get_addr_align() << " "
                << DUMP_STR_FORMAT( 17 ) << sec->get_name() << " " << std::endl;
        }
        else { // Output for 64-bit
            out << "[" << DUMP_DEC_FORMAT( 5 ) << no << "] "
                << DUMP_STR_FORMAT( 17 ) << str_section_type( sec->get_type() ) << " "
                << DUMP_HEX0x_FORMAT( 16 ) << sec->get_address()                  << " "
                << DUMP_HEX0x_FORMAT( 16 ) << sec->get_size()                     << " "
                << DUMP_HEX0x_FORMAT(  8 ) << sec->get_offset()                   << " "
                << DUMP_STR_FORMAT(  3) << section_flags( sec->get_flags() )
                << std::endl
                << DUMP_STR_FORMAT( 8 ) << " "
                << DUMP_HEX0x_FORMAT( 4 ) << sec->get_entry_size() << " "
                << DUMP_HEX0x_FORMAT( 4 ) << sec->get_link()       << " "
                << DUMP_HEX0x_FORMAT( 4 ) << sec->get_info()       << " "
                << DUMP_HEX0x_FORMAT( 4 ) << sec->get_addr_align() << "   "
                << DUMP_STR_FORMAT( 17 ) << sec->get_name()
                << std::endl;
        }
        // clang-format on

        out.flags( original_flags );

        return;
    }

    //------------------------------------------------------------------------------
    static void segment_headers( std::ostream& out, const elfio& reader )
    {
        Elf_Half n = reader.segments.size();
        if ( n == 0 ) {
            return;
        }

        out << "Program Headers:" << std::endl;
        if ( reader.get_class() == ELFCLASS32 ) { // Output for 32-bit
            out << "[  Nr ] Type           VirtAddr   PhysAddr   FileSize   "
                   "Mem.Size   Flags    Align"
                << std::endl;
        }
        else { // Output for 64-bit
            out << "[  Nr ] Type           Offset             VirtAddr         "
                   "  PhysAddr"

                << std::endl
                << "                       FileSize           MemSize          "
                   "   Flags  Align"
                << std::endl;
        }

        for ( Elf_Half i = 0; i < n; ++i ) {
            const segment* seg = reader.segments[i];
            segment_header( out, i, seg, reader.get_class() );
        }

        out << std::endl;
    }

    //------------------------------------------------------------------------------
    static void segment_header( std::ostream&  out,
                                Elf_Half       no,
                                const segment* seg,
                                unsigned int   elf_class )
    {
        std::ios_base::fmtflags original_flags = out.flags();
        // clang-format off
        if ( elf_class == ELFCLASS32 ) { // Output for 32-bit
            out << "[" << DUMP_DEC_FORMAT( 5 ) << no << "] "
                << DUMP_STR_FORMAT( 14 ) << str_segment_type( seg->get_type() )
                << " " << DUMP_HEX0x_FORMAT( 8 ) << seg->get_virtual_address()
                << " " << DUMP_HEX0x_FORMAT( 8 ) << seg->get_physical_address()
                << " " << DUMP_HEX0x_FORMAT( 8 ) << seg->get_file_size() << " "
                << DUMP_HEX0x_FORMAT( 8 ) << seg->get_memory_size() << " "
                << DUMP_STR_FORMAT( 8 ) << str_segment_flag( seg->get_flags() )
                << " " << DUMP_HEX0x_FORMAT( 8 ) << seg->get_align() << " "
                << std::endl;
        }
        else { // Output for 64-bit
            out << "[" << DUMP_DEC_FORMAT( 5 ) << no << "] "
                << DUMP_STR_FORMAT( 14 ) << str_segment_type( seg->get_type() ) << " " 
                << DUMP_HEX0x_FORMAT( 16 ) << seg->get_offset()           << " "
                << DUMP_HEX0x_FORMAT( 16 ) << seg->get_virtual_address()  << " "
                << DUMP_HEX0x_FORMAT( 16 ) << seg->get_physical_address()
                << std::endl
                << DUMP_STR_FORMAT( 23 ) << " "
                << DUMP_HEX0x_FORMAT( 16 ) << seg->get_file_size()         << " "
                << DUMP_HEX0x_FORMAT( 16 ) << seg->get_memory_size()       << "  "
                << DUMP_STR_FORMAT(  3 ) << str_segment_flag( seg->get_flags() ) << "    "
                << DUMP_HEX0x_FORMAT(  1 ) << seg->get_align() 
                << std::endl;
        }
        // clang-format on

        out.flags( original_flags );
    }

    //------------------------------------------------------------------------------
    static void symbol_tables( std::ostream& out, const elfio& reader )
    {
        for ( const auto& sec : reader.sections ) { // For all sections
            if ( SHT_SYMTAB == sec->get_type() ||
                 SHT_DYNSYM == sec->get_type() ) {
                const_symbol_section_accessor symbols( reader, sec.get() );

                Elf_Xword sym_no = symbols.get_symbols_num();
                if ( sym_no == 0 ) {
                    continue;
                }

                out << "Symbol table (" << sec->get_name() << ")" << std::endl;
                if ( reader.get_class() == ELFCLASS32 ) { // Output for 32-bit
                    out << "[  Nr ] Value      Size       Type    Bind     "
                           " Sect Name"
                        << std::endl;
                }
                else { // Output for 64-bit
                    out << "[  Nr ] Value              Size               "
                           "Type    Bind      Sect"
                        << std::endl
                        << "        Name" << std::endl;
                }
                for ( Elf_Xword i = 0; i < sym_no; ++i ) {
                    std::string   name;
                    Elf64_Addr    value   = 0;
                    Elf_Xword     size    = 0;
                    unsigned char bind    = 0;
                    unsigned char type    = 0;
                    Elf_Half      section = 0;
                    unsigned char other   = 0;
                    symbols.get_symbol( i, name, value, size, bind, type,
                                        section, other );
                    symbol_table( out, i, name, value, size, bind, type,
                                  section, reader.get_class() );
                }

                out << std::endl;
            }
        }
    }

    //------------------------------------------------------------------------------
    static void symbol_table( std::ostream&      out,
                              Elf_Xword          no,
                              const std::string& name,
                              Elf64_Addr         value,
                              Elf_Xword          size,
                              unsigned char      bind,
                              unsigned char      type,
                              Elf_Half           section,
                              unsigned int       elf_class )
    {
        std::ios_base::fmtflags original_flags = out.flags();

        if ( elf_class == ELFCLASS32 ) { // Output for 32-bit
            out << "[" << DUMP_DEC_FORMAT( 5 ) << no << "] "
                << DUMP_HEX0x_FORMAT( 8 ) << value << " "
                << DUMP_HEX0x_FORMAT( 8 ) << size << " " << DUMP_STR_FORMAT( 7 )
                << str_symbol_type( type ) << " " << DUMP_STR_FORMAT( 8 )
                << str_symbol_bind( bind ) << " " << DUMP_DEC_FORMAT( 5 )
                << section << " " << DUMP_STR_FORMAT( 1 ) << name << " "
                << std::endl;
        }
        else { // Output for 64-bit
            out << "[" << DUMP_DEC_FORMAT( 5 ) << no << "] "
                << DUMP_HEX0x_FORMAT( 16 ) << value << " "
                << DUMP_HEX0x_FORMAT( 16 ) << size << " "
                << DUMP_STR_FORMAT( 7 ) << str_symbol_type( type ) << " "
                << DUMP_STR_FORMAT( 8 ) << str_symbol_bind( bind ) << " "
                << DUMP_DEC_FORMAT( 5 ) << section << " " << std::endl
                << "        " << DUMP_STR_FORMAT( 1 ) << name << " "
                << std::endl;
        }

        out.flags( original_flags );
    }

    //------------------------------------------------------------------------------
    static void notes( std::ostream& out, const elfio& reader )
    {
        for ( const auto& sec : reader.sections ) { // For all sections
            if ( SHT_NOTE == sec->get_type() ) {    // Look at notes
                note_section_accessor notes( reader, sec.get() );
                Elf_Word              no_notes = notes.get_notes_num();

                if ( no_notes == 0 )
                    continue;

                out << "Note section (" << sec->get_name() << ")" << std::endl
                    << "    No Name         Data size  Description"
                    << std::endl;
                for ( Elf_Word j = 0; j < no_notes; ++j ) { // For all notes
                    Elf_Word    type;
                    std::string name;
                    char*       desc;
                    Elf_Word    descsz;

                    if ( notes.get_note( j, type, name, desc, descsz ) ) {
                        // 'name' usually contains \0 at the end. Remove it
                        name = name.c_str();
                        note( out, j, type, name, desc, descsz );
                        out << std::endl;
                    }
                }

                out << std::endl;
            }
        }

        Elf_Half no = reader.segments.size();
        for ( Elf_Half i = 0; i < no; ++i ) { // For all segments
            segment* seg = reader.segments[i];
            if ( PT_NOTE == seg->get_type() ) { // Look at notes
                note_segment_accessor notes( reader, seg );
                Elf_Word              no_notes = notes.get_notes_num();

                if ( no_notes == 0 )
                    continue;

                out << "Note segment (" << i << ")" << std::endl
                    << "    No Name         Data size  Description"
                    << std::endl;
                for ( Elf_Word j = 0; j < no_notes; ++j ) { // For all notes
                    Elf_Word    type;
                    std::string name;
                    char*       desc;
                    Elf_Word    descsz;

                    if ( notes.get_note( j, type, name, desc, descsz ) ) {
                        // 'name' usually contains \0 at the end. Remove it
                        name = name.c_str();
                        note( out, j, type, name, desc, descsz );
                        out << std::endl;
                    }
                }

                out << std::endl;
            }
        }
    }

    //------------------------------------------------------------------------------
    static void note( std::ostream&      out,
                      int                no,
                      Elf_Word           type,
                      const std::string& name,
                      void*              desc,
                      Elf_Word           descsz )
    {
        out << "  [" << DUMP_DEC_FORMAT( 2 ) << no << "] ";

        const auto name_group = std::find_if(
            std::begin( note_tag_table ), std::end( note_tag_table ),
            [&name]( const note_tag_t& entry ) { return entry.name == name; } );

        std::vector<note_tag_t::note_values_t>::const_iterator type_value;
        if ( name_group != std::end( note_tag_table ) ) {
            type_value = std::find_if(
                name_group->values.begin(), name_group->values.end(),
                [&type]( const note_tag_t::note_values_t& e ) {
                    return e.type == type;
                } );
        }

        if ( name_group != std::end( note_tag_table ) &&
             type_value != name_group->values.end() ) {
            out << DUMP_STR_FORMAT( 12 ) << name_group->name << " "
                << DUMP_HEX0x_FORMAT( 8 ) << descsz << " "
                << type_value->type_str << " (" << type_value->description
                << ")";
        }
        else {
            out << DUMP_STR_FORMAT( 12 ) << name << " "
                << DUMP_HEX0x_FORMAT( 8 ) << descsz << " "
                << DUMP_HEX0x_FORMAT( 8 ) << type;
        }

        if ( descsz != 0 ) {
            for ( Elf_Word i = 0; i < descsz; ++i ) {
                if ( i % 16 == 0 ) {
                    out << std::endl << "         ";
                }
                out << DUMP_HEX_FORMAT( 2 )
                    << (uint32_t)( (uint8_t*)( desc ) )[i];
            }
        }
    }

    //------------------------------------------------------------------------------
    static void modinfo( std::ostream& out, const elfio& reader )
    {
        for ( const auto& sec : reader.sections ) { // For all sections
            if ( ".modinfo" == sec->get_name() ) {  // Look for the section
                out << "Section .modinfo" << std::endl;

                const_modinfo_section_accessor modinfo( sec.get() );
                for ( Elf_Word i = 0; i < modinfo.get_attribute_num(); i++ ) {
                    std::string field;
                    std::string value;
                    if ( modinfo.get_attribute( i, field, value ) ) {
                        out << "  " << std::setw( 20 ) << field
                            << std::setw( 0 ) << " = " << value << std::endl;
                    }
                }

                out << std::endl;
                break;
            }
        }
    }

    //------------------------------------------------------------------------------
    static void dynamic_tags( std::ostream& out, const elfio& reader )
    {
        for ( const auto& sec : reader.sections ) { // For all sections
            if ( SHT_DYNAMIC == sec->get_type() ) {
                dynamic_section_accessor dynamic( reader, sec.get() );

                Elf_Xword dyn_no = dynamic.get_entries_num();
                if ( dyn_no == 0 )
                    continue;

                out << "Dynamic section (" << sec->get_name() << ")"
                    << std::endl;
                out << "[  Nr ] Tag              Name/Value" << std::endl;
                for ( Elf_Xword i = 0; i < dyn_no; ++i ) {
                    Elf_Xword   tag   = 0;
                    Elf_Xword   value = 0;
                    std::string str;
                    dynamic.get_entry( i, tag, value, str );
                    dynamic_tag( out, i, tag, value, str, reader.get_class() );
                    if ( DT_NULL == tag ) {
                        break;
                    }
                }

                out << std::endl;
            }
        }
    }

    //------------------------------------------------------------------------------
    static void dynamic_tag( std::ostream&      out,
                             Elf_Xword          no,
                             Elf_Xword          tag,
                             Elf_Xword          value,
                             const std::string& str,
                             unsigned int /*elf_class*/ )
    {
        out << "[" << DUMP_DEC_FORMAT( 5 ) << no << "] "
            << DUMP_STR_FORMAT( 16 ) << str_dynamic_tag( tag ) << " ";
        if ( str.empty() ) {
            out << DUMP_HEX0x_FORMAT( 16 ) << value << " ";
        }
        else {
            out << DUMP_STR_FORMAT( 32 ) << str << " ";
        }
        out << std::endl;
    }

    //------------------------------------------------------------------------------
    static void section_data( std::ostream& out, const section* sec )
    {
        std::ios_base::fmtflags original_flags = out.flags();

        out << sec->get_name() << std::endl;
        const char* pdata = sec->get_data();
        if ( pdata ) {
            ELFIO::Elf_Xword i;
            for ( i = 0; i < std::min( sec->get_size(), MAX_DATA_ENTRIES );
                  ++i ) {
                if ( i % 16 == 0 ) {
                    out << "[" << DUMP_HEX0x_FORMAT( 8 ) << i << "]";
                }

                out << " " << DUMP_HEX0x_FORMAT( 2 )
                    << ( pdata[i] & 0x000000FF );

                if ( i % 16 == 15 ) {
                    out << std::endl;
                }
            }
            if ( i % 16 != 0 ) {
                out << std::endl;
            }

            out.flags( original_flags );
        }

        return;
    }

    //------------------------------------------------------------------------------
    static void section_datas( std::ostream& out, const elfio& reader )
    {
        Elf_Half n = reader.sections.size();

        if ( n == 0 ) {
            return;
        }

        out << "Section Data:" << std::endl;

        for ( Elf_Half i = 1; i < n; ++i ) { // For all sections
            const section* sec = reader.sections[i];
            if ( sec->get_type() == SHT_NOBITS ) {
                continue;
            }
            section_data( out, sec );
        }

        out << std::endl;
    }

    //------------------------------------------------------------------------------
    static void
    segment_data( std::ostream& out, Elf_Half no, const segment* seg )
    {
        std::ios_base::fmtflags original_flags = out.flags();

        out << "Segment # " << no << std::endl;
        const char* pdata = seg->get_data();
        if ( pdata ) {
            ELFIO::Elf_Xword i;
            for ( i = 0; i < std::min( seg->get_file_size(), MAX_DATA_ENTRIES );
                  ++i ) {
                if ( i % 16 == 0 ) {
                    out << "[" << DUMP_HEX0x_FORMAT( 8 ) << i << "]";
                }

                out << " " << DUMP_HEX0x_FORMAT( 2 )
                    << ( pdata[i] & 0x000000FF );

                if ( i % 16 == 15 ) {
                    out << std::endl;
                }
            }
            if ( i % 16 != 0 ) {
                out << std::endl;
            }

            out.flags( original_flags );
        }

        return;
    }

    //------------------------------------------------------------------------------
    static void segment_datas( std::ostream& out, const elfio& reader )
    {
        Elf_Half n = reader.segments.size();

        if ( n == 0 ) {
            return;
        }

        out << "Segment Data:" << std::endl;

        for ( Elf_Half i = 0; i < n; ++i ) { // For all sections
            const segment* seg = reader.segments[i];
            segment_data( out, i, seg );
        }

        out << std::endl;
    }

//------------------------------------------------------------------------------
#define STR_FUNC_TABLE( name )                                         \
    template <typename T> static std::string str_##name( const T key ) \
    {                                                                  \
        return format_assoc( name##_table, key );                      \
    }

    STR_FUNC_TABLE( class )
    STR_FUNC_TABLE( endian )
    STR_FUNC_TABLE( version )
    STR_FUNC_TABLE( os_abi )
    STR_FUNC_TABLE( type )
    STR_FUNC_TABLE( machine )
    STR_FUNC_TABLE( section_type )
    STR_FUNC_TABLE( segment_type )
    STR_FUNC_TABLE( segment_flag )
    STR_FUNC_TABLE( symbol_bind )
    STR_FUNC_TABLE( symbol_type )
    STR_FUNC_TABLE( dynamic_tag )

#undef STR_FUNC_TABLE

  private:
    //------------------------------------------------------------------------------
    template <typename T, typename K>
    std::string static find_value_in_table( const T& table, const K& key )
    {
        std::string res = "?";
        for ( unsigned int i = 0; i < sizeof( table ) / sizeof( table[0] );
              ++i ) {
            if ( table[i].key == key ) {
                res = table[i].str;
                break;
            }
        }

        return res;
    }

    //------------------------------------------------------------------------------
    template <typename T, typename K>
    static std::string format_assoc( const T& table, const K& key )
    {
        std::string str = find_value_in_table( table, key );
        if ( str == "?" ) {
            std::ostringstream oss;
            oss << str << " (0x" << std::hex << key << ")";
            str = oss.str();
        }

        return str;
    }

    //------------------------------------------------------------------------------
    template <typename T>
    static std::string format_assoc( const T& table, const char key )
    {
        return format_assoc( table, (const int)key );
    }

    //------------------------------------------------------------------------------
    static std::string section_flags( Elf_Xword flags )
    {
        std::string ret = "";
        if ( flags & SHF_WRITE ) {
            ret += "W";
        }
        if ( flags & SHF_ALLOC ) {
            ret += "A";
        }
        if ( flags & SHF_EXECINSTR ) {
            ret += "X";
        }
        if ( flags & SHF_MERGE ) {
            ret += "M";
        }
        if ( flags & SHF_STRINGS ) {
            ret += "S";
        }
        if ( flags & SHF_INFO_LINK ) {
            ret += "I";
        }
        if ( flags & SHF_LINK_ORDER ) {
            ret += "L";
        }
        if ( flags & SHF_OS_NONCONFORMING ) {
            ret += "O";
        }
        if ( flags & SHF_GROUP ) {
            ret += "G";
        }
        if ( flags & SHF_TLS ) {
            ret += "T";
        }
        if ( flags & SHF_COMPRESSED ) {
            ret += "C";
        }
        if ( flags & SHF_EXCLUDE ) {
            ret += "E";
        }
        if ( flags & SHF_GNU_MBIND ) {
            ret += "D";
        }

        return ret;
    }

#undef DUMP_DEC_FORMAT
#undef DUMP_HEX0x_FORMAT
#undef DUMP_STR_FORMAT
}; // class dump
} // namespace ELFIO

#endif // ELFIO_DUMP_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_DYNAMIC_HPP
#define ELFIO_DYNAMIC_HPP

#include <algorithm>

namespace ELFIO {

//------------------------------------------------------------------------------
template <class S> class dynamic_section_accessor_template
{
  public:
    //------------------------------------------------------------------------------
    explicit dynamic_section_accessor_template( const elfio& elf_file,
                                                S*           section )
        : elf_file( elf_file ), dynamic_section( section ), entries_num( 0 )
    {
    }

    //------------------------------------------------------------------------------
    Elf_Xword get_entries_num() const
    {
        size_t needed_entry_size = -1;
        if ( elf_file.get_class() == ELFCLASS32 ) {
            needed_entry_size = sizeof( Elf32_Dyn );
        }
        else {
            needed_entry_size = sizeof( Elf64_Dyn );
        }

        if ( ( 0 == entries_num ) &&
             ( 0 != dynamic_section->get_entry_size() &&
               dynamic_section->get_entry_size() >= needed_entry_size ) ) {
            entries_num =
                dynamic_section->get_size() / dynamic_section->get_entry_size();
            Elf_Xword   i;
            Elf_Xword   tag   = DT_NULL;
            Elf_Xword   value = 0;
            std::string str;
            for ( i = 0; i < entries_num; i++ ) {
                get_entry( i, tag, value, str );
                if ( tag == DT_NULL )
                    break;
            }
            entries_num = std::min<Elf_Xword>( entries_num, i + 1 );
        }

        return entries_num;
    }

    //------------------------------------------------------------------------------
    bool get_entry( Elf_Xword    index,
                    Elf_Xword&   tag,
                    Elf_Xword&   value,
                    std::string& str ) const
    {
        if ( index >= get_entries_num() ) { // Is index valid
            return false;
        }

        if ( elf_file.get_class() == ELFCLASS32 ) {
            generic_get_entry_dyn<Elf32_Dyn>( index, tag, value );
        }
        else {
            generic_get_entry_dyn<Elf64_Dyn>( index, tag, value );
        }

        // If the tag has a string table reference - prepare the string
        if ( tag == DT_NEEDED || tag == DT_SONAME || tag == DT_RPATH ||
             tag == DT_RUNPATH ) {
            string_section_accessor strsec(
                elf_file.sections[get_string_table_index()] );
            const char* result = strsec.get_string( (Elf_Word)value );
            if ( nullptr == result ) {
                str.clear();
                return false;
            }
            str = result;
        }
        else {
            str.clear();
        }

        return true;
    }

    //------------------------------------------------------------------------------
    void add_entry( Elf_Xword tag, Elf_Xword value )
    {
        if ( elf_file.get_class() == ELFCLASS32 ) {
            generic_add_entry_dyn<Elf32_Dyn>( tag, value );
        }
        else {
            generic_add_entry_dyn<Elf64_Dyn>( tag, value );
        }
    }

    //------------------------------------------------------------------------------
    void add_entry( Elf_Xword tag, const std::string& str )
    {
        string_section_accessor strsec(
            elf_file.sections[get_string_table_index()] );
        Elf_Xword value = strsec.add_string( str );
        add_entry( tag, value );
    }

    //------------------------------------------------------------------------------
  private:
    //------------------------------------------------------------------------------
    Elf_Half get_string_table_index() const
    {
        return (Elf_Half)dynamic_section->get_link();
    }

    //------------------------------------------------------------------------------
    template <class T>
    void generic_get_entry_dyn( Elf_Xword  index,
                                Elf_Xword& tag,
                                Elf_Xword& value ) const
    {
        const endianess_convertor& convertor = elf_file.get_convertor();

        // Check unusual case when dynamic section has no data
        if ( dynamic_section->get_data() == nullptr ||
             ( index + 1 ) * dynamic_section->get_entry_size() >
                 dynamic_section->get_size() ||
             dynamic_section->get_entry_size() < sizeof( T ) ) {
            tag   = DT_NULL;
            value = 0;
            return;
        }

        const T* pEntry = reinterpret_cast<const T*>(
            dynamic_section->get_data() +
            index * dynamic_section->get_entry_size() );
        tag = convertor( pEntry->d_tag );
        switch ( tag ) {
        case DT_NULL:
        case DT_SYMBOLIC:
        case DT_TEXTREL:
        case DT_BIND_NOW:
            value = 0;
            break;
        case DT_NEEDED:
        case DT_PLTRELSZ:
        case DT_RELASZ:
        case DT_RELAENT:
        case DT_STRSZ:
        case DT_SYMENT:
        case DT_SONAME:
        case DT_RPATH:
        case DT_RELSZ:
        case DT_RELENT:
        case DT_PLTREL:
        case DT_INIT_ARRAYSZ:
        case DT_FINI_ARRAYSZ:
        case DT_RUNPATH:
        case DT_FLAGS:
        case DT_PREINIT_ARRAYSZ:
            value = convertor( pEntry->d_un.d_val );
            break;
        case DT_PLTGOT:
        case DT_HASH:
        case DT_STRTAB:
        case DT_SYMTAB:
        case DT_RELA:
        case DT_INIT:
        case DT_FINI:
        case DT_REL:
        case DT_DEBUG:
        case DT_JMPREL:
        case DT_INIT_ARRAY:
        case DT_FINI_ARRAY:
        case DT_PREINIT_ARRAY:
        default:
            value = convertor( pEntry->d_un.d_ptr );
            break;
        }
    }

    //------------------------------------------------------------------------------
    template <class T>
    void generic_add_entry_dyn( Elf_Xword tag, Elf_Xword value )
    {
        const endianess_convertor& convertor = elf_file.get_convertor();

        T entry;

        switch ( tag ) {
        case DT_NULL:
        case DT_SYMBOLIC:
        case DT_TEXTREL:
        case DT_BIND_NOW:
            entry.d_un.d_val = convertor( decltype( entry.d_un.d_val )( 0 ) );
            break;
        case DT_NEEDED:
        case DT_PLTRELSZ:
        case DT_RELASZ:
        case DT_RELAENT:
        case DT_STRSZ:
        case DT_SYMENT:
        case DT_SONAME:
        case DT_RPATH:
        case DT_RELSZ:
        case DT_RELENT:
        case DT_PLTREL:
        case DT_INIT_ARRAYSZ:
        case DT_FINI_ARRAYSZ:
        case DT_RUNPATH:
        case DT_FLAGS:
        case DT_PREINIT_ARRAYSZ:
            entry.d_un.d_val =
                convertor( decltype( entry.d_un.d_val )( value ) );
            break;
        case DT_PLTGOT:
        case DT_HASH:
        case DT_STRTAB:
        case DT_SYMTAB:
        case DT_RELA:
        case DT_INIT:
        case DT_FINI:
        case DT_REL:
        case DT_DEBUG:
        case DT_JMPREL:
        case DT_INIT_ARRAY:
        case DT_FINI_ARRAY:
        case DT_PREINIT_ARRAY:
        default:
            entry.d_un.d_ptr =
                convertor( decltype( entry.d_un.d_val )( value ) );
            break;
        }

        entry.d_tag = convertor( decltype( entry.d_tag )( tag ) );

        dynamic_section->append_data( reinterpret_cast<char*>( &entry ),
                                      sizeof( entry ) );
    }

    //------------------------------------------------------------------------------
  private:
    const elfio&      elf_file;
    S*                dynamic_section;
    mutable Elf_Xword entries_num;
};

using dynamic_section_accessor = dynamic_section_accessor_template<section>;
using const_dynamic_section_accessor =
    dynamic_section_accessor_template<const section>;

} // namespace ELFIO

#endif // ELFIO_DYNAMIC_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELF_HEADER_HPP
#define ELF_HEADER_HPP

#include <iostream>

namespace ELFIO {

class elf_header
{
  public:
    virtual ~elf_header() = default;

    virtual bool load( std::istream& stream )       = 0;
    virtual bool save( std::ostream& stream ) const = 0;

    // ELF header functions
    ELFIO_GET_ACCESS_DECL( unsigned char, class );
    ELFIO_GET_ACCESS_DECL( unsigned char, elf_version );
    ELFIO_GET_ACCESS_DECL( unsigned char, encoding );
    ELFIO_GET_ACCESS_DECL( Elf_Half, header_size );
    ELFIO_GET_ACCESS_DECL( Elf_Half, section_entry_size );
    ELFIO_GET_ACCESS_DECL( Elf_Half, segment_entry_size );

    ELFIO_GET_SET_ACCESS_DECL( Elf_Word, version );
    ELFIO_GET_SET_ACCESS_DECL( unsigned char, os_abi );
    ELFIO_GET_SET_ACCESS_DECL( unsigned char, abi_version );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Half, type );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Half, machine );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Word, flags );
    ELFIO_GET_SET_ACCESS_DECL( Elf64_Addr, entry );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Half, sections_num );
    ELFIO_GET_SET_ACCESS_DECL( Elf64_Off, sections_offset );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Half, segments_num );
    ELFIO_GET_SET_ACCESS_DECL( Elf64_Off, segments_offset );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Half, section_name_str_index );
};

template <class T> struct elf_header_impl_types;
template <> struct elf_header_impl_types<Elf32_Ehdr>
{
    using Phdr_type                       = Elf32_Phdr;
    using Shdr_type                       = Elf32_Shdr;
    static const unsigned char file_class = ELFCLASS32;
};
template <> struct elf_header_impl_types<Elf64_Ehdr>
{
    using Phdr_type                       = Elf64_Phdr;
    using Shdr_type                       = Elf64_Shdr;
    static const unsigned char file_class = ELFCLASS64;
};

template <class T> class elf_header_impl : public elf_header
{
  public:
    //------------------------------------------------------------------------------
    elf_header_impl( endianess_convertor*      convertor,
                     unsigned char             encoding,
                     const address_translator* translator )
        : convertor( convertor ), translator( translator )
    {
        header.e_ident[EI_MAG0]    = ELFMAG0;
        header.e_ident[EI_MAG1]    = ELFMAG1;
        header.e_ident[EI_MAG2]    = ELFMAG2;
        header.e_ident[EI_MAG3]    = ELFMAG3;
        header.e_ident[EI_CLASS]   = elf_header_impl_types<T>::file_class;
        header.e_ident[EI_DATA]    = encoding;
        header.e_ident[EI_VERSION] = EV_CURRENT;
        header.e_version           = ( *convertor )( (Elf_Word)EV_CURRENT );
        header.e_ehsize            = ( sizeof( header ) );
        header.e_ehsize            = ( *convertor )( header.e_ehsize );
        header.e_shstrndx          = ( *convertor )( (Elf_Half)1 );
        header.e_phentsize =
            sizeof( typename elf_header_impl_types<T>::Phdr_type );
        header.e_shentsize =
            sizeof( typename elf_header_impl_types<T>::Shdr_type );
        header.e_phentsize = ( *convertor )( header.e_phentsize );
        header.e_shentsize = ( *convertor )( header.e_shentsize );
    }

    //------------------------------------------------------------------------------
    bool load( std::istream& stream ) override
    {
        stream.seekg( ( *translator )[0] );
        stream.read( reinterpret_cast<char*>( &header ), sizeof( header ) );

        return ( stream.gcount() == sizeof( header ) );
    }

    //------------------------------------------------------------------------------
    bool save( std::ostream& stream ) const override
    {
        stream.seekp( ( *translator )[0] );
        stream.write( reinterpret_cast<const char*>( &header ),
                      sizeof( header ) );

        return stream.good();
    }

    //------------------------------------------------------------------------------
    // ELF header functions
    ELFIO_GET_ACCESS( unsigned char, class, header.e_ident[EI_CLASS] );
    ELFIO_GET_ACCESS( unsigned char, elf_version, header.e_ident[EI_VERSION] );
    ELFIO_GET_ACCESS( unsigned char, encoding, header.e_ident[EI_DATA] );
    ELFIO_GET_ACCESS( Elf_Half, header_size, header.e_ehsize );
    ELFIO_GET_ACCESS( Elf_Half, section_entry_size, header.e_shentsize );
    ELFIO_GET_ACCESS( Elf_Half, segment_entry_size, header.e_phentsize );

    ELFIO_GET_SET_ACCESS( Elf_Word, version, header.e_version );
    ELFIO_GET_SET_ACCESS( unsigned char, os_abi, header.e_ident[EI_OSABI] );
    ELFIO_GET_SET_ACCESS( unsigned char,
                          abi_version,
                          header.e_ident[EI_ABIVERSION] );
    ELFIO_GET_SET_ACCESS( Elf_Half, type, header.e_type );
    ELFIO_GET_SET_ACCESS( Elf_Half, machine, header.e_machine );
    ELFIO_GET_SET_ACCESS( Elf_Word, flags, header.e_flags );
    ELFIO_GET_SET_ACCESS( Elf_Half, section_name_str_index, header.e_shstrndx );
    ELFIO_GET_SET_ACCESS( Elf64_Addr, entry, header.e_entry );
    ELFIO_GET_SET_ACCESS( Elf_Half, sections_num, header.e_shnum );
    ELFIO_GET_SET_ACCESS( Elf64_Off, sections_offset, header.e_shoff );
    ELFIO_GET_SET_ACCESS( Elf_Half, segments_num, header.e_phnum );
    ELFIO_GET_SET_ACCESS( Elf64_Off, segments_offset, header.e_phoff );

  private:
    T                         header     = {};
    endianess_convertor*      convertor  = nullptr;
    const address_translator* translator = nullptr;
};

} // namespace ELFIO

#endif // ELF_HEADER_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_MODINFO_HPP
#define ELFIO_MODINFO_HPP

#include <string_view>
#include <vector>

namespace ELFIO {

//------------------------------------------------------------------------------
template <class S> class modinfo_section_accessor_template
{
  public:
    //------------------------------------------------------------------------------
    explicit modinfo_section_accessor_template( S* section )
        : modinfo_section( section )
    {
        process_section();
    }

    //------------------------------------------------------------------------------
    Elf_Word get_attribute_num() const { return (Elf_Word)content.size(); }

    //------------------------------------------------------------------------------
    bool
    get_attribute( Elf_Word no, std::string& field, std::string& value ) const
    {
        if ( no < content.size() ) {
            field = content[no].first;
            value = content[no].second;
            return true;
        }

        return false;
    }

    //------------------------------------------------------------------------------
    bool get_attribute( const std::string_view& field_name,
                        std::string&            value ) const
    {
        for ( const auto [first, second] : content ) {
            if ( field_name == first ) {
                value = second;
                return true;
            }
        }

        return false;
    }

    //------------------------------------------------------------------------------
    Elf_Word add_attribute( const std::string& field, const std::string& value )
    {
        Elf_Word current_position = 0;

        if ( modinfo_section ) {
            // Strings are addeded to the end of the current section data
            current_position = (Elf_Word)modinfo_section->get_size();

            std::string attribute = field + "=" + value;

            modinfo_section->append_data( attribute + '\0' );
            content.emplace_back( field, value );
        }

        return current_position;
    }

    //------------------------------------------------------------------------------
  private:
    void process_section()
    {
        const char* pdata = modinfo_section->get_data();
        if ( pdata ) {
            ELFIO::Elf_Xword i = 0;
            while ( i < modinfo_section->get_size() ) {
                while ( i < modinfo_section->get_size() && !pdata[i] )
                    i++;
                if ( i < modinfo_section->get_size() ) {
                    std::string info = pdata + i;
                    size_t      loc  = info.find( '=' );
                    content.emplace_back( info.substr( 0, loc ),
                                          info.substr( loc + 1 ) );

                    i += info.length();
                }
            }
        }
    }

    //------------------------------------------------------------------------------
  private:
    S*                                               modinfo_section;
    std::vector<std::pair<std::string, std::string>> content;
};

using modinfo_section_accessor = modinfo_section_accessor_template<section>;
using const_modinfo_section_accessor =
    modinfo_section_accessor_template<const section>;

} // namespace ELFIO

#endif // ELFIO_MODINFO_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_NOTE_HPP
#define ELFIO_NOTE_HPP

namespace ELFIO {

//------------------------------------------------------------------------------
// There are discrepancies in documentations. SCO documentation
// (http://www.sco.com/developers/gabi/latest/ch5.pheader.html#note_section)
// requires 8 byte entries alignment for 64-bit ELF file,
// but Oracle's definition uses the same structure
// for 32-bit and 64-bit formats.
// (https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-18048.html)
//
// It looks like EM_X86_64 Linux implementation is similar to Oracle's
// definition. Therefore, the same alignment works for both formats
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
template <class S, Elf_Xword ( S::*F_get_size )() const>
class note_section_accessor_template
{
  public:
    //------------------------------------------------------------------------------
    explicit note_section_accessor_template( const elfio& elf_file, S* section )
        : elf_file( elf_file ), notes( section )
    {
        process_section();
    }

    //------------------------------------------------------------------------------
    Elf_Word get_notes_num() const
    {
        return (Elf_Word)note_start_positions.size();
    }

    //------------------------------------------------------------------------------
    bool get_note( Elf_Word     index,
                   Elf_Word&    type,
                   std::string& name,
                   char*&       desc,
                   Elf_Word&    descSize ) const
    {
        if ( index >= ( notes->*F_get_size )() ) {
            return false;
        }

        const char* pData = notes->get_data() + note_start_positions[index];
        int         align = sizeof( Elf_Word );

        const endianess_convertor& convertor = elf_file.get_convertor();
        type = convertor( *(const Elf_Word*)( pData + 2 * (size_t)align ) );
        Elf_Word namesz = convertor( *(const Elf_Word*)( pData ) );
        descSize = convertor( *(const Elf_Word*)( pData + sizeof( namesz ) ) );

        Elf_Xword max_name_size =
            ( notes->*F_get_size )() - note_start_positions[index];
        if ( namesz < 1 || namesz > max_name_size ||
             (Elf_Xword)namesz + descSize > max_name_size ) {
            return false;
        }
        name.assign( pData + 3 * (size_t)align, namesz - 1 );
        if ( 0 == descSize ) {
            desc = nullptr;
        }
        else {
            desc = const_cast<char*>( pData + 3 * (size_t)align +
                                      ( ( namesz + align - 1 ) / align ) *
                                          (size_t)align );
        }

        return true;
    }

    //------------------------------------------------------------------------------
    void add_note( Elf_Word           type,
                   const std::string& name,
                   const char*        desc,
                   Elf_Word           descSize )
    {
        const endianess_convertor& convertor = elf_file.get_convertor();

        int         align       = sizeof( Elf_Word );
        Elf_Word    nameLen     = (Elf_Word)name.size() + 1;
        Elf_Word    nameLenConv = convertor( nameLen );
        std::string buffer( reinterpret_cast<char*>( &nameLenConv ), align );
        Elf_Word    descSizeConv = convertor( descSize );

        buffer.append( reinterpret_cast<char*>( &descSizeConv ), align );
        type = convertor( type );
        buffer.append( reinterpret_cast<char*>( &type ), align );
        buffer.append( name );
        buffer.append( 1, '\x00' );
        const char pad[] = { '\0', '\0', '\0', '\0' };
        if ( nameLen % align != 0 ) {
            buffer.append( pad, (size_t)align - nameLen % align );
        }
        if ( desc != nullptr && descSize != 0 ) {
            buffer.append( desc, descSize );
            if ( descSize % align != 0 ) {
                buffer.append( pad, (size_t)align - descSize % align );
            }
        }

        note_start_positions.emplace_back( ( notes->*F_get_size )() );
        notes->append_data( buffer );
    }

  private:
    //------------------------------------------------------------------------------
    void process_section()
    {
        const endianess_convertor& convertor = elf_file.get_convertor();
        const char*                data      = notes->get_data();
        Elf_Xword                  size      = ( notes->*F_get_size )();
        Elf_Xword                  current   = 0;

        note_start_positions.clear();

        // Is it empty?
        if ( nullptr == data || 0 == size ) {
            return;
        }

        Elf_Word align = sizeof( Elf_Word );
        while ( current + (Elf_Xword)3 * align <= size ) {
            Elf_Word namesz = convertor( *(const Elf_Word*)( data + current ) );
            Elf_Word descsz = convertor(
                *(const Elf_Word*)( data + current + sizeof( namesz ) ) );
            Elf_Word advance =
                (Elf_Xword)3 * sizeof( Elf_Word ) +
                ( ( namesz + align - 1 ) / align ) * (Elf_Xword)align +
                ( ( descsz + align - 1 ) / align ) * (Elf_Xword)align;
            if ( namesz < size && descsz < size && current + advance <= size ) {
                note_start_positions.emplace_back( current );
            }
            else {
                break;
            }

            current += advance;
        }
    }

    //------------------------------------------------------------------------------
  private:
    const elfio&           elf_file;
    S*                     notes;
    std::vector<Elf_Xword> note_start_positions;
};

using note_section_accessor =
    note_section_accessor_template<section, &section::get_size>;
using const_note_section_accessor =
    note_section_accessor_template<const section, &section::get_size>;
using note_segment_accessor =
    note_section_accessor_template<segment, &segment::get_file_size>;
using const_note_segment_accessor =
    note_section_accessor_template<const segment, &segment::get_file_size>;

} // namespace ELFIO

#endif // ELFIO_NOTE_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_RELOCATION_HPP
#define ELFIO_RELOCATION_HPP

namespace ELFIO {

template <typename T> struct get_sym_and_type;
template <> struct get_sym_and_type<Elf32_Rel>
{
    static int get_r_sym( Elf_Xword info )
    {
        return ELF32_R_SYM( (Elf_Word)info );
    }
    static int get_r_type( Elf_Xword info )
    {
        return ELF32_R_TYPE( (Elf_Word)info );
    }
};
template <> struct get_sym_and_type<Elf32_Rela>
{
    static int get_r_sym( Elf_Xword info )
    {
        return ELF32_R_SYM( (Elf_Word)info );
    }
    static int get_r_type( Elf_Xword info )
    {
        return ELF32_R_TYPE( (Elf_Word)info );
    }
};
template <> struct get_sym_and_type<Elf64_Rel>
{
    static int get_r_sym( Elf_Xword info ) { return ELF64_R_SYM( info ); }
    static int get_r_type( Elf_Xword info ) { return ELF64_R_TYPE( info ); }
};
template <> struct get_sym_and_type<Elf64_Rela>
{
    static int get_r_sym( Elf_Xword info ) { return ELF64_R_SYM( info ); }
    static int get_r_type( Elf_Xword info ) { return ELF64_R_TYPE( info ); }
};

//------------------------------------------------------------------------------
template <class S> class relocation_section_accessor_template
{
  public:
    //------------------------------------------------------------------------------
    explicit relocation_section_accessor_template( const elfio& elf_file,
                                                   S*           section )
        : elf_file( elf_file ), relocation_section( section )
    {
    }

    //------------------------------------------------------------------------------
    Elf_Xword get_entries_num() const
    {
        Elf_Xword nRet = 0;

        if ( 0 != relocation_section->get_entry_size() ) {
            nRet = relocation_section->get_size() /
                   relocation_section->get_entry_size();
        }

        return nRet;
    }

    //------------------------------------------------------------------------------
    bool get_entry( Elf_Xword   index,
                    Elf64_Addr& offset,
                    Elf_Word&   symbol,
                    unsigned&   type,
                    Elf_Sxword& addend ) const
    {
        if ( index >= get_entries_num() ) { // Is index valid
            return false;
        }

        if ( elf_file.get_class() == ELFCLASS32 ) {
            if ( SHT_REL == relocation_section->get_type() ) {
                generic_get_entry_rel<Elf32_Rel>( index, offset, symbol, type,
                                                  addend );
            }
            else if ( SHT_RELA == relocation_section->get_type() ) {
                generic_get_entry_rela<Elf32_Rela>( index, offset, symbol, type,
                                                    addend );
            }
        }
        else {
            if ( SHT_REL == relocation_section->get_type() ) {
                generic_get_entry_rel<Elf64_Rel>( index, offset, symbol, type,
                                                  addend );
            }
            else if ( SHT_RELA == relocation_section->get_type() ) {
                generic_get_entry_rela<Elf64_Rela>( index, offset, symbol, type,
                                                    addend );
            }
        }

        return true;
    }

    //------------------------------------------------------------------------------
    bool get_entry( Elf_Xword    index,
                    Elf64_Addr&  offset,
                    Elf64_Addr&  symbolValue,
                    std::string& symbolName,
                    unsigned&    type,
                    Elf_Sxword&  addend,
                    Elf_Sxword&  calcValue ) const
    {
        // Do regular job
        Elf_Word symbol = 0;
        bool     ret    = get_entry( index, offset, symbol, type, addend );

        // Find the symbol
        Elf_Xword     size;
        unsigned char bind;
        unsigned char symbolType;
        Elf_Half      section;
        unsigned char other;

        symbol_section_accessor symbols(
            elf_file, elf_file.sections[get_symbol_table_index()] );
        ret = ret && symbols.get_symbol( symbol, symbolName, symbolValue, size,
                                         bind, symbolType, section, other );

        if ( ret ) { // Was it successful?
            switch ( type ) {
            case R_386_NONE: // none
                calcValue = 0;
                break;
            case R_386_32: // S + A
                calcValue = symbolValue + addend;
                break;
            case R_386_PC32: // S + A - P
                calcValue = symbolValue + addend - offset;
                break;
            case R_386_GOT32: // G + A - P
                calcValue = 0;
                break;
            case R_386_PLT32: // L + A - P
                calcValue = 0;
                break;
            case R_386_COPY: // none
                calcValue = 0;
                break;
            case R_386_GLOB_DAT: // S
            case R_386_JMP_SLOT: // S
                calcValue = symbolValue;
                break;
            case R_386_RELATIVE: // B + A
                calcValue = addend;
                break;
            case R_386_GOTOFF: // S + A - GOT
                calcValue = 0;
                break;
            case R_386_GOTPC: // GOT + A - P
                calcValue = 0;
                break;
            default: // Not recognized symbol!
                calcValue = 0;
                break;
            }
        }

        return ret;
    }

    //------------------------------------------------------------------------------
    bool set_entry( Elf_Xword  index,
                    Elf64_Addr offset,
                    Elf_Word   symbol,
                    unsigned   type,
                    Elf_Sxword addend )
    {
        if ( index >= get_entries_num() ) { // Is index valid
            return false;
        }

        if ( elf_file.get_class() == ELFCLASS32 ) {
            if ( SHT_REL == relocation_section->get_type() ) {
                generic_set_entry_rel<Elf32_Rel>( index, offset, symbol, type,
                                                  addend );
            }
            else if ( SHT_RELA == relocation_section->get_type() ) {
                generic_set_entry_rela<Elf32_Rela>( index, offset, symbol, type,
                                                    addend );
            }
        }
        else {
            if ( SHT_REL == relocation_section->get_type() ) {
                generic_set_entry_rel<Elf64_Rel>( index, offset, symbol, type,
                                                  addend );
            }
            else if ( SHT_RELA == relocation_section->get_type() ) {
                generic_set_entry_rela<Elf64_Rela>( index, offset, symbol, type,
                                                    addend );
            }
        }

        return true;
    }

    //------------------------------------------------------------------------------
    void add_entry( Elf64_Addr offset, Elf_Xword info )
    {
        if ( elf_file.get_class() == ELFCLASS32 ) {
            generic_add_entry<Elf32_Rel>( offset, info );
        }
        else {
            generic_add_entry<Elf64_Rel>( offset, info );
        }
    }

    //------------------------------------------------------------------------------
    void add_entry( Elf64_Addr offset, Elf_Word symbol, unsigned type )
    {
        Elf_Xword info;
        if ( elf_file.get_class() == ELFCLASS32 ) {
            info = ELF32_R_INFO( (Elf_Xword)symbol, type );
        }
        else {
            info = ELF64_R_INFO( (Elf_Xword)symbol, type );
        }

        add_entry( offset, info );
    }

    //------------------------------------------------------------------------------
    void add_entry( Elf64_Addr offset, Elf_Xword info, Elf_Sxword addend )
    {
        if ( elf_file.get_class() == ELFCLASS32 ) {
            generic_add_entry<Elf32_Rela>( offset, info, addend );
        }
        else {
            generic_add_entry<Elf64_Rela>( offset, info, addend );
        }
    }

    //------------------------------------------------------------------------------
    void add_entry( Elf64_Addr offset,
                    Elf_Word   symbol,
                    unsigned   type,
                    Elf_Sxword addend )
    {
        Elf_Xword info;
        if ( elf_file.get_class() == ELFCLASS32 ) {
            info = ELF32_R_INFO( (Elf_Xword)symbol, type );
        }
        else {
            info = ELF64_R_INFO( (Elf_Xword)symbol, type );
        }

        add_entry( offset, info, addend );
    }

    //------------------------------------------------------------------------------
    void add_entry( string_section_accessor str_writer,
                    const char*             str,
                    symbol_section_accessor sym_writer,
                    Elf64_Addr              value,
                    Elf_Word                size,
                    unsigned char           sym_info,
                    unsigned char           other,
                    Elf_Half                shndx,
                    Elf64_Addr              offset,
                    unsigned                type )
    {
        Elf_Word str_index = str_writer.add_string( str );
        Elf_Word sym_index = sym_writer.add_symbol( str_index, value, size,
                                                    sym_info, other, shndx );
        add_entry( offset, sym_index, type );
    }

    //------------------------------------------------------------------------------
    void swap_symbols( Elf_Xword first, Elf_Xword second )
    {
        Elf64_Addr offset = 0;
        Elf_Word   symbol = 0;
        unsigned   rtype  = 0;
        Elf_Sxword addend = 0;
        for ( Elf_Word i = 0; i < get_entries_num(); i++ ) {
            get_entry( i, offset, symbol, rtype, addend );
            if ( symbol == first ) {
                set_entry( i, offset, (Elf_Word)second, rtype, addend );
            }
            if ( symbol == second ) {
                set_entry( i, offset, (Elf_Word)first, rtype, addend );
            }
        }
    }

    //------------------------------------------------------------------------------
  private:
    //------------------------------------------------------------------------------
    Elf_Half get_symbol_table_index() const
    {
        return (Elf_Half)relocation_section->get_link();
    }

    //------------------------------------------------------------------------------
    template <class T>
    void generic_get_entry_rel( Elf_Xword   index,
                                Elf64_Addr& offset,
                                Elf_Word&   symbol,
                                unsigned&   type,
                                Elf_Sxword& addend ) const
    {
        const endianess_convertor& convertor = elf_file.get_convertor();

        const T* pEntry = reinterpret_cast<const T*>(
            relocation_section->get_data() +
            index * relocation_section->get_entry_size() );
        offset        = convertor( pEntry->r_offset );
        Elf_Xword tmp = convertor( pEntry->r_info );
        symbol        = get_sym_and_type<T>::get_r_sym( tmp );
        type          = get_sym_and_type<T>::get_r_type( tmp );
        addend        = 0;
    }

    //------------------------------------------------------------------------------
    template <class T>
    void generic_get_entry_rela( Elf_Xword   index,
                                 Elf64_Addr& offset,
                                 Elf_Word&   symbol,
                                 unsigned&   type,
                                 Elf_Sxword& addend ) const
    {
        const endianess_convertor& convertor = elf_file.get_convertor();

        const T* pEntry = reinterpret_cast<const T*>(
            relocation_section->get_data() +
            index * relocation_section->get_entry_size() );
        offset        = convertor( pEntry->r_offset );
        Elf_Xword tmp = convertor( pEntry->r_info );
        symbol        = get_sym_and_type<T>::get_r_sym( tmp );
        type          = get_sym_and_type<T>::get_r_type( tmp );
        addend        = convertor( pEntry->r_addend );
    }

    //------------------------------------------------------------------------------
    template <class T>
    void generic_set_entry_rel( Elf_Xword  index,
                                Elf64_Addr offset,
                                Elf_Word   symbol,
                                unsigned   type,
                                Elf_Sxword )
    {
        const endianess_convertor& convertor = elf_file.get_convertor();

        T* pEntry = const_cast<T*>( reinterpret_cast<const T*>(
            relocation_section->get_data() +
            index * relocation_section->get_entry_size() ) );

        if ( elf_file.get_class() == ELFCLASS32 ) {
            pEntry->r_info = ELF32_R_INFO( (Elf_Xword)symbol, type );
        }
        else {
            pEntry->r_info = ELF64_R_INFO( (Elf_Xword)symbol, type );
        }
        pEntry->r_offset = decltype( pEntry->r_offset )( offset );
        pEntry->r_offset = convertor( pEntry->r_offset );
        pEntry->r_info   = convertor( pEntry->r_info );
    }

    //------------------------------------------------------------------------------
    template <class T>
    void generic_set_entry_rela( Elf_Xword  index,
                                 Elf64_Addr offset,
                                 Elf_Word   symbol,
                                 unsigned   type,
                                 Elf_Sxword addend )
    {
        const endianess_convertor& convertor = elf_file.get_convertor();

        T* pEntry = const_cast<T*>( reinterpret_cast<const T*>(
            relocation_section->get_data() +
            index * relocation_section->get_entry_size() ) );

        if ( elf_file.get_class() == ELFCLASS32 ) {
            pEntry->r_info = ELF32_R_INFO( (Elf_Xword)symbol, type );
        }
        else {
            pEntry->r_info = ELF64_R_INFO( (Elf_Xword)symbol, type );
        }
        pEntry->r_offset = decltype( pEntry->r_offset )( offset );
        pEntry->r_addend = decltype( pEntry->r_addend )( addend );
        pEntry->r_offset = convertor( pEntry->r_offset );
        pEntry->r_info   = convertor( pEntry->r_info );
        pEntry->r_addend = convertor( pEntry->r_addend );
    }

    //------------------------------------------------------------------------------
    template <class T>
    void generic_add_entry( Elf64_Addr offset, Elf_Xword info )
    {
        const endianess_convertor& convertor = elf_file.get_convertor();

        T entry;
        entry.r_offset = decltype( entry.r_offset )( offset );
        entry.r_info   = decltype( entry.r_info )( info );
        entry.r_offset = convertor( entry.r_offset );
        entry.r_info   = convertor( entry.r_info );

        relocation_section->append_data( reinterpret_cast<char*>( &entry ),
                                         sizeof( entry ) );
    }

    //------------------------------------------------------------------------------
    template <class T>
    void
    generic_add_entry( Elf64_Addr offset, Elf_Xword info, Elf_Sxword addend )
    {
        const endianess_convertor& convertor = elf_file.get_convertor();

        T entry;
        entry.r_offset = offset;
        entry.r_info   = info;
        entry.r_addend = addend;
        entry.r_offset = convertor( entry.r_offset );
        entry.r_info   = convertor( entry.r_info );
        entry.r_addend = convertor( entry.r_addend );

        relocation_section->append_data( reinterpret_cast<char*>( &entry ),
                                         sizeof( entry ) );
    }

    //------------------------------------------------------------------------------
  private:
    const elfio& elf_file;
    S*           relocation_section = nullptr;
};

using relocation_section_accessor =
    relocation_section_accessor_template<section>;
using const_relocation_section_accessor =
    relocation_section_accessor_template<const section>;

} // namespace ELFIO

#endif // ELFIO_RELOCATION_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_SECTION_HPP
#define ELFIO_SECTION_HPP

#include <string>
#include <iostream>
#include <new>
#include <limits>

namespace ELFIO {

class section
{
    friend class elfio;

  public:
    virtual ~section() = default;

    ELFIO_GET_ACCESS_DECL( Elf_Half, index );
    ELFIO_GET_SET_ACCESS_DECL( std::string, name );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Word, type );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Xword, flags );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Word, info );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Word, link );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Xword, addr_align );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Xword, entry_size );
    ELFIO_GET_SET_ACCESS_DECL( Elf64_Addr, address );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Xword, size );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Word, name_string_offset );
    ELFIO_GET_ACCESS_DECL( Elf64_Off, offset );

    virtual const char* get_data() const                                   = 0;
    virtual void        free_data() const                                  = 0;
    virtual void        set_data( const char* raw_data, Elf_Word size )    = 0;
    virtual void        set_data( const std::string& data )                = 0;
    virtual void        append_data( const char* raw_data, Elf_Word size ) = 0;
    virtual void        append_data( const std::string& data )             = 0;
    virtual void
    insert_data( Elf_Xword pos, const char* raw_data, Elf_Word size )    = 0;
    virtual void   insert_data( Elf_Xword pos, const std::string& data ) = 0;
    virtual size_t get_stream_size() const                               = 0;
    virtual void   set_stream_size( size_t value )                       = 0;

  protected:
    ELFIO_SET_ACCESS_DECL( Elf64_Off, offset );
    ELFIO_SET_ACCESS_DECL( Elf_Half, index );

    virtual bool load( std::istream&  stream,
                       std::streampos header_offset,
                       bool           is_lazy )               = 0;
    virtual void save( std::ostream&  stream,
                       std::streampos header_offset,
                       std::streampos data_offset ) = 0;
    virtual bool is_address_initialized() const     = 0;
};

template <class T> class section_impl : public section
{
  public:
    //------------------------------------------------------------------------------
    section_impl( const endianess_convertor*                    convertor,
                  const address_translator*                     translator,
                  const std::shared_ptr<compression_interface>& compression )
        : convertor( convertor ), translator( translator ),
          compression( compression )
    {
    }

    //------------------------------------------------------------------------------
    // Section info functions
    ELFIO_GET_SET_ACCESS( Elf_Word, type, header.sh_type );
    ELFIO_GET_SET_ACCESS( Elf_Xword, flags, header.sh_flags );
    ELFIO_GET_SET_ACCESS( Elf_Xword, size, header.sh_size );
    ELFIO_GET_SET_ACCESS( Elf_Word, link, header.sh_link );
    ELFIO_GET_SET_ACCESS( Elf_Word, info, header.sh_info );
    ELFIO_GET_SET_ACCESS( Elf_Xword, addr_align, header.sh_addralign );
    ELFIO_GET_SET_ACCESS( Elf_Xword, entry_size, header.sh_entsize );
    ELFIO_GET_SET_ACCESS( Elf_Word, name_string_offset, header.sh_name );
    ELFIO_GET_ACCESS( Elf64_Addr, address, header.sh_addr );
    //------------------------------------------------------------------------------
    Elf_Half get_index() const override { return index; }

    //------------------------------------------------------------------------------
    std::string get_name() const override { return name; }

    //------------------------------------------------------------------------------
    void set_name( const std::string& name_prm ) override
    {
        this->name = name_prm;
    }

    //------------------------------------------------------------------------------
    void set_address( const Elf64_Addr& value ) override
    {
        header.sh_addr = decltype( header.sh_addr )( value );
        header.sh_addr = ( *convertor )( header.sh_addr );
        is_address_set = true;
    }

    //------------------------------------------------------------------------------
    bool is_address_initialized() const override { return is_address_set; }

    //------------------------------------------------------------------------------
    const char* get_data() const override
    {
        if ( !is_loaded ) {
            load_data();
        }
        return data.get();
    }

    //------------------------------------------------------------------------------
    void free_data() const override
    {
        if ( is_lazy ) {
            data.reset( nullptr );
            is_loaded = false;
        }
    }

    //------------------------------------------------------------------------------
    void set_data( const char* raw_data, Elf_Word size ) override
    {
        if ( get_type() != SHT_NOBITS ) {
            data = std::unique_ptr<char[]>( new ( std::nothrow ) char[size] );
            if ( nullptr != data.get() && nullptr != raw_data ) {
                data_size = size;
                std::copy( raw_data, raw_data + size, data.get() );
            }
            else {
                data_size = 0;
            }
        }

        set_size( data_size );
        if ( translator->empty() ) {
            set_stream_size( data_size );
        }
    }

    //------------------------------------------------------------------------------
    void set_data( const std::string& str_data ) override
    {
        return set_data( str_data.c_str(), (Elf_Word)str_data.size() );
    }

    //------------------------------------------------------------------------------
    void append_data( const char* raw_data, Elf_Word size ) override
    {
        insert_data( get_size(), raw_data, size );
    }

    //------------------------------------------------------------------------------
    void append_data( const std::string& str_data ) override
    {
        return append_data( str_data.c_str(), (Elf_Word)str_data.size() );
    }

    //------------------------------------------------------------------------------
    void
    insert_data( Elf_Xword pos, const char* raw_data, Elf_Word size ) override
    {
        if ( get_type() != SHT_NOBITS ) {
            if ( get_size() + size < data_size ) {
                char* d = data.get();
                std::copy_backward( d + pos, d + get_size(),
                                    d + get_size() + size );
                std::copy( raw_data, raw_data + size, d + pos );
            }
            else {
                data_size = 2 * ( data_size + size );
                std::unique_ptr<char[]> new_data(
                    new ( std::nothrow ) char[data_size] );

                if ( nullptr != new_data ) {
                    char* d = data.get();
                    std::copy( d, d + pos, new_data.get() );
                    std::copy( raw_data, raw_data + size,
                               new_data.get() + pos );
                    std::copy( d + pos, d + get_size(),
                               new_data.get() + pos + size );
                    data = std::move( new_data );
                }
                else {
                    size = 0;
                }
            }
            set_size( get_size() + size );
            if ( translator->empty() ) {
                set_stream_size( get_stream_size() + size );
            }
        }
    }

    //------------------------------------------------------------------------------
    void insert_data( Elf_Xword pos, const std::string& str_data ) override
    {
        return insert_data( pos, str_data.c_str(), (Elf_Word)str_data.size() );
    }

    size_t get_stream_size() const override { return stream_size; }

    //------------------------------------------------------------------------------
    void set_stream_size( size_t value ) override { stream_size = value; }

    //------------------------------------------------------------------------------
  protected:
    //------------------------------------------------------------------------------
    ELFIO_GET_SET_ACCESS( Elf64_Off, offset, header.sh_offset );

    //------------------------------------------------------------------------------
    void set_index( const Elf_Half& value ) override { index = value; }

    bool is_compressed() const
    {
        return ( ( get_flags() & SHF_RPX_DEFLATE ) ||
                 ( get_flags() & SHF_COMPRESSED ) ) &&
               compression != nullptr;
    }

    //------------------------------------------------------------------------------
    bool load( std::istream&  stream,
               std::streampos header_offset,
               bool           is_lazy_ ) override
    {
        pstream = &stream;
        is_lazy = is_lazy_;

        if ( translator->empty() ) {
            stream.seekg( 0, std::istream::end );
            set_stream_size( size_t( stream.tellg() ) );
        }
        else {
            set_stream_size( std::numeric_limits<size_t>::max() );
        }

        stream.seekg( ( *translator )[header_offset] );
        stream.read( reinterpret_cast<char*>( &header ), sizeof( header ) );

        if ( !( is_lazy || is_loaded ) ) {
            bool ret = load_data();

            if ( is_compressed() ) {
                Elf_Xword size              = get_size();
                Elf_Xword uncompressed_size = 0;
                auto      decompressed_data = compression->inflate(
                    data.get(), convertor, size, uncompressed_size );
                if ( decompressed_data != nullptr ) {
                    set_size( uncompressed_size );
                    data = std::move( decompressed_data );
                }
            }

            return ret;
        }

        return true;
    }

    bool load_data() const
    {
        Elf_Xword size = get_size();
        if ( nullptr == data && SHT_NULL != get_type() &&
             SHT_NOBITS != get_type() && size < get_stream_size() ) {
            data.reset( new ( std::nothrow ) char[size_t( size ) + 1] );

            if ( ( 0 != size ) && ( nullptr != data ) ) {
                pstream->seekg(
                    ( *translator )[( *convertor )( header.sh_offset )] );
                pstream->read( data.get(), size );
                if ( static_cast<Elf_Xword>( pstream->gcount() ) != size ) {
                    data = nullptr;
                    return false;
                }

                // refresh size because it may have changed if we had to decompress data
                size = get_size();
                data.get()[size] =
                    0; // Ensure data is ended with 0 to avoid oob read
                data_size = decltype( data_size )( size );
            }
            else {
                data_size = 0;
            }
        }

        is_loaded = true;

        return true;
    }

    //------------------------------------------------------------------------------
    void save( std::ostream&  stream,
               std::streampos header_offset,
               std::streampos data_offset ) override
    {
        if ( 0 != get_index() ) {
            header.sh_offset = decltype( header.sh_offset )( data_offset );
            header.sh_offset = ( *convertor )( header.sh_offset );
        }

        save_header( stream, header_offset );
        if ( get_type() != SHT_NOBITS && get_type() != SHT_NULL &&
             get_size() != 0 && data != nullptr ) {
            save_data( stream, data_offset );
        }
    }

    //------------------------------------------------------------------------------
  private:
    //------------------------------------------------------------------------------
    void save_header( std::ostream& stream, std::streampos header_offset ) const
    {
        adjust_stream_size( stream, header_offset );
        stream.write( reinterpret_cast<const char*>( &header ),
                      sizeof( header ) );
    }

    //------------------------------------------------------------------------------
    void save_data( std::ostream& stream, std::streampos data_offset )
    {
        adjust_stream_size( stream, data_offset );

        if ( ( ( get_flags() & SHF_COMPRESSED ) ||
               ( get_flags() & SHF_RPX_DEFLATE ) ) &&
             compression != nullptr ) {
            Elf_Xword decompressed_size = get_size();
            Elf_Xword compressed_size   = 0;
            auto      compressed_ptr    = compression->deflate(
                data.get(), convertor, decompressed_size, compressed_size );
            stream.write( compressed_ptr.get(), compressed_size );
        }
        else {
            stream.write( get_data(), get_size() );
        }
    }

    //------------------------------------------------------------------------------
  private:
    mutable std::istream*                        pstream = nullptr;
    T                                            header  = {};
    Elf_Half                                     index   = 0;
    std::string                                  name;
    mutable std::unique_ptr<char[]>              data;
    mutable Elf_Word                             data_size      = 0;
    const endianess_convertor*                   convertor      = nullptr;
    const address_translator*                    translator     = nullptr;
    const std::shared_ptr<compression_interface> compression    = nullptr;
    bool                                         is_address_set = false;
    size_t                                       stream_size    = 0;
    mutable bool                                 is_lazy        = false;
    mutable bool                                 is_loaded      = false;
};

} // namespace ELFIO

#endif // ELFIO_SECTION_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_SEGMENT_HPP
#define ELFIO_SEGMENT_HPP

#include <iostream>
#include <vector>
#include <new>
#include <limits>

namespace ELFIO {

class segment
{
    friend class elfio;

  public:
    virtual ~segment() = default;

    ELFIO_GET_ACCESS_DECL( Elf_Half, index );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Word, type );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Word, flags );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Xword, align );
    ELFIO_GET_SET_ACCESS_DECL( Elf64_Addr, virtual_address );
    ELFIO_GET_SET_ACCESS_DECL( Elf64_Addr, physical_address );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Xword, file_size );
    ELFIO_GET_SET_ACCESS_DECL( Elf_Xword, memory_size );
    ELFIO_GET_ACCESS_DECL( Elf64_Off, offset );

    virtual const char* get_data() const  = 0;
    virtual void        free_data() const = 0;

    virtual Elf_Half add_section( section* psec, Elf_Xword addr_align ) = 0;
    virtual Elf_Half add_section_index( Elf_Half  index,
                                        Elf_Xword addr_align )          = 0;
    virtual Elf_Half get_sections_num() const                           = 0;
    virtual Elf_Half get_section_index_at( Elf_Half num ) const         = 0;
    virtual bool     is_offset_initialized() const                      = 0;

  protected:
    ELFIO_SET_ACCESS_DECL( Elf64_Off, offset );
    ELFIO_SET_ACCESS_DECL( Elf_Half, index );

    virtual const std::vector<Elf_Half>& get_sections() const = 0;

    virtual bool load( std::istream&  stream,
                       std::streampos header_offset,
                       bool           is_lazy )               = 0;
    virtual void save( std::ostream&  stream,
                       std::streampos header_offset,
                       std::streampos data_offset ) = 0;
};

//------------------------------------------------------------------------------
template <class T> class segment_impl : public segment
{
  public:
    //------------------------------------------------------------------------------
    segment_impl( const endianess_convertor* convertor,
                  const address_translator*  translator )
        : convertor( convertor ), translator( translator )
    {
    }

    //------------------------------------------------------------------------------
    // Section info functions
    ELFIO_GET_SET_ACCESS( Elf_Word, type, ph.p_type );
    ELFIO_GET_SET_ACCESS( Elf_Word, flags, ph.p_flags );
    ELFIO_GET_SET_ACCESS( Elf_Xword, align, ph.p_align );
    ELFIO_GET_SET_ACCESS( Elf64_Addr, virtual_address, ph.p_vaddr );
    ELFIO_GET_SET_ACCESS( Elf64_Addr, physical_address, ph.p_paddr );
    ELFIO_GET_SET_ACCESS( Elf_Xword, file_size, ph.p_filesz );
    ELFIO_GET_SET_ACCESS( Elf_Xword, memory_size, ph.p_memsz );
    ELFIO_GET_ACCESS( Elf64_Off, offset, ph.p_offset );

    //------------------------------------------------------------------------------
    Elf_Half get_index() const override { return index; }

    //------------------------------------------------------------------------------
    const char* get_data() const override
    {
        if ( !is_loaded ) {
            load_data();
        }
        return data.get();
    }

    //------------------------------------------------------------------------------
    void free_data() const override
    {
        if ( is_lazy ) {
            data.reset( nullptr );
            is_loaded = false;
        }
    }

    //------------------------------------------------------------------------------
    Elf_Half add_section_index( Elf_Half  sec_index,
                                Elf_Xword addr_align ) override
    {
        sections.emplace_back( sec_index );
        if ( addr_align > get_align() ) {
            set_align( addr_align );
        }

        return (Elf_Half)sections.size();
    }

    //------------------------------------------------------------------------------
    Elf_Half add_section( section* psec, Elf_Xword addr_align ) override
    {
        return add_section_index( psec->get_index(), addr_align );
    }

    //------------------------------------------------------------------------------
    Elf_Half get_sections_num() const override
    {
        return (Elf_Half)sections.size();
    }

    //------------------------------------------------------------------------------
    Elf_Half get_section_index_at( Elf_Half num ) const override
    {
        if ( num < sections.size() ) {
            return sections[num];
        }

        return Elf_Half( -1 );
    }

    //------------------------------------------------------------------------------
  protected:
    //------------------------------------------------------------------------------

    //------------------------------------------------------------------------------
    void set_offset( const Elf64_Off& value ) override
    {
        ph.p_offset   = decltype( ph.p_offset )( value );
        ph.p_offset   = ( *convertor )( ph.p_offset );
        is_offset_set = true;
    }

    //------------------------------------------------------------------------------
    bool is_offset_initialized() const override { return is_offset_set; }

    //------------------------------------------------------------------------------
    const std::vector<Elf_Half>& get_sections() const override
    {
        return sections;
    }

    //------------------------------------------------------------------------------
    void set_index( const Elf_Half& value ) override { index = value; }

    //------------------------------------------------------------------------------
    bool load( std::istream&  stream,
               std::streampos header_offset,
               bool           is_lazy_ ) override
    {
        pstream = &stream;
        is_lazy = is_lazy_;

        if ( translator->empty() ) {
            stream.seekg( 0, std::istream::end );
            set_stream_size( size_t( stream.tellg() ) );
        }
        else {
            set_stream_size( std::numeric_limits<size_t>::max() );
        }

        stream.seekg( ( *translator )[header_offset] );
        stream.read( reinterpret_cast<char*>( &ph ), sizeof( ph ) );
        is_offset_set = true;

        if ( !( is_lazy || is_loaded ) ) {
            return load_data();
        }

        return true;
    }

    //------------------------------------------------------------------------------
    bool load_data() const
    {
        if ( PT_NULL == get_type() || 0 == get_file_size() ) {
            return true;
        }

        pstream->seekg( ( *translator )[( *convertor )( ph.p_offset )] );
        Elf_Xword size = get_file_size();

        if ( size > get_stream_size() ) {
            data = nullptr;
        }
        else {
            data.reset( new ( std::nothrow ) char[(size_t)size + 1] );

            if ( nullptr != data.get() && pstream->read( data.get(), size ) ) {
                data.get()[size] = 0;
            }
            else {
                data = nullptr;
                return false;
            }
        }

        is_loaded = true;

        return true;
    }

    //------------------------------------------------------------------------------
    void save( std::ostream&  stream,
               std::streampos header_offset,
               std::streampos data_offset ) override
    {
        ph.p_offset = decltype( ph.p_offset )( data_offset );
        ph.p_offset = ( *convertor )( ph.p_offset );
        adjust_stream_size( stream, header_offset );
        stream.write( reinterpret_cast<const char*>( &ph ), sizeof( ph ) );
    }

    //------------------------------------------------------------------------------
    size_t get_stream_size() const { return stream_size; }

    //------------------------------------------------------------------------------
    void set_stream_size( size_t value ) { stream_size = value; }

    //------------------------------------------------------------------------------
  private:
    mutable std::istream*           pstream = nullptr;
    T                               ph      = {};
    Elf_Half                        index   = 0;
    mutable std::unique_ptr<char[]> data;
    std::vector<Elf_Half>           sections;
    const endianess_convertor*      convertor     = nullptr;
    const address_translator*       translator    = nullptr;
    size_t                          stream_size   = 0;
    bool                            is_offset_set = false;
    mutable bool                    is_lazy       = false;
    mutable bool                    is_loaded     = false;
};

} // namespace ELFIO

#endif // ELFIO_SEGMENT_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_STRINGS_HPP
#define ELFIO_STRINGS_HPP

#include <cstdlib>
#include <cstring>
#include <string>

namespace ELFIO {

//------------------------------------------------------------------------------
template <class S> class string_section_accessor_template
{
  public:
    //------------------------------------------------------------------------------
    explicit string_section_accessor_template( S* section )
        : string_section( section )
    {
    }

    //------------------------------------------------------------------------------
    const char* get_string( Elf_Word index ) const
    {
        if ( string_section ) {
            const char* data = string_section->get_data();
            if ( index < string_section->get_size() && nullptr != data ) {
                size_t string_length = strnlength(
                    data + index, string_section->get_size() - index );
                if ( string_length < ( string_section->get_size() - index ) )
                    return data + index;
            }
        }

        return nullptr;
    }

    //------------------------------------------------------------------------------
    Elf_Word add_string( const char* str )
    {
        Elf_Word current_position = 0;

        if ( string_section ) {
            // Strings are addeded to the end of the current section data
            current_position =
                static_cast<Elf_Word>( string_section->get_size() );

            if ( current_position == 0 ) {
                char empty_string = '\0';
                string_section->append_data( &empty_string, 1 );
                current_position++;
            }
            string_section->append_data(
                str, static_cast<Elf_Word>( std::strlen( str ) + 1 ) );
        }

        return current_position;
    }

    //------------------------------------------------------------------------------
    Elf_Word add_string( const std::string& str )
    {
        return add_string( str.c_str() );
    }

    //------------------------------------------------------------------------------
  private:
    S* string_section;
};

using string_section_accessor = string_section_accessor_template<section>;
using const_string_section_accessor =
    string_section_accessor_template<const section>;

} // namespace ELFIO

#endif // ELFIO_STRINGS_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_SYMBOLS_HPP
#define ELFIO_SYMBOLS_HPP

namespace ELFIO {

//------------------------------------------------------------------------------
template <class S> class symbol_section_accessor_template
{
  public:
    //------------------------------------------------------------------------------
    explicit symbol_section_accessor_template( const elfio& elf_file,
                                               S*           symbol_section )
        : elf_file( elf_file ), symbol_section( symbol_section )
    {
        find_hash_section();
    }

    //------------------------------------------------------------------------------
    Elf_Xword get_symbols_num() const
    {
        Elf_Xword nRet = 0;

        size_t minimum_symbol_size;
        switch ( elf_file.get_class() ) {
        case ELFCLASS32:
            minimum_symbol_size = sizeof( Elf32_Sym );
            break;
        case ELFCLASS64:
            minimum_symbol_size = sizeof( Elf64_Sym );
            break;
        default:
            return nRet;
        }

        if ( symbol_section->get_entry_size() >= minimum_symbol_size &&
             symbol_section->get_size() <= symbol_section->get_stream_size() ) {
            nRet =
                symbol_section->get_size() / symbol_section->get_entry_size();
        }

        return nRet;
    }

    //------------------------------------------------------------------------------
    bool get_symbol( Elf_Xword      index,
                     std::string&   name,
                     Elf64_Addr&    value,
                     Elf_Xword&     size,
                     unsigned char& bind,
                     unsigned char& type,
                     Elf_Half&      section_index,
                     unsigned char& other ) const
    {
        bool ret = false;

        if ( elf_file.get_class() == ELFCLASS32 ) {
            ret = generic_get_symbol<Elf32_Sym>( index, name, value, size, bind,
                                                 type, section_index, other );
        }
        else {
            ret = generic_get_symbol<Elf64_Sym>( index, name, value, size, bind,
                                                 type, section_index, other );
        }

        return ret;
    }

    //------------------------------------------------------------------------------
    bool get_symbol( const std::string& name,
                     Elf64_Addr&        value,
                     Elf_Xword&         size,
                     unsigned char&     bind,
                     unsigned char&     type,
                     Elf_Half&          section_index,
                     unsigned char&     other ) const
    {
        bool ret = false;

        if ( 0 != get_hash_table_index() ) {
            if ( hash_section->get_type() == SHT_HASH ) {
                ret = hash_lookup( name, value, size, bind, type, section_index,
                                   other );
            }
            if ( hash_section->get_type() == SHT_GNU_HASH ||
                 hash_section->get_type() == DT_GNU_HASH ) {
                if ( elf_file.get_class() == ELFCLASS32 ) {
                    ret = gnu_hash_lookup<uint32_t>(
                        name, value, size, bind, type, section_index, other );
                }
                else {
                    ret = gnu_hash_lookup<uint64_t>(
                        name, value, size, bind, type, section_index, other );
                }
            }
        }

        if ( !ret ) {
            for ( Elf_Xword i = 0; !ret && i < get_symbols_num(); i++ ) {
                std::string symbol_name;
                if ( get_symbol( i, symbol_name, value, size, bind, type,
                                 section_index, other ) ) {
                    if ( symbol_name == name ) {
                        ret = true;
                    }
                }
            }
        }

        return ret;
    }

    //------------------------------------------------------------------------------
    bool get_symbol( const Elf64_Addr& value,
                     std::string&      name,
                     Elf_Xword&        size,
                     unsigned char&    bind,
                     unsigned char&    type,
                     Elf_Half&         section_index,
                     unsigned char&    other ) const
    {

        const endianess_convertor& convertor = elf_file.get_convertor();

        Elf_Xword  idx   = 0;
        bool       match = false;
        Elf64_Addr v     = 0;

        if ( elf_file.get_class() == ELFCLASS32 ) {
            match = generic_search_symbols<Elf32_Sym>(
                [&]( const Elf32_Sym* sym ) {
                    return convertor( sym->st_value ) == value;
                },
                idx );
        }
        else {
            match = generic_search_symbols<Elf64_Sym>(
                [&]( const Elf64_Sym* sym ) {
                    return convertor( sym->st_value ) == value;
                },
                idx );
        }

        if ( match ) {
            return get_symbol( idx, name, v, size, bind, type, section_index,
                               other );
        }

        return false;
    }

    //------------------------------------------------------------------------------
    Elf_Word add_symbol( Elf_Word      name,
                         Elf64_Addr    value,
                         Elf_Xword     size,
                         unsigned char info,
                         unsigned char other,
                         Elf_Half      shndx )
    {
        Elf_Word nRet;

        if ( symbol_section->get_size() == 0 ) {
            if ( elf_file.get_class() == ELFCLASS32 ) {
                nRet = generic_add_symbol<Elf32_Sym>( 0, 0, 0, 0, 0, 0 );
            }
            else {
                nRet = generic_add_symbol<Elf64_Sym>( 0, 0, 0, 0, 0, 0 );
            }
        }

        if ( elf_file.get_class() == ELFCLASS32 ) {
            nRet = generic_add_symbol<Elf32_Sym>( name, value, size, info,
                                                  other, shndx );
        }
        else {
            nRet = generic_add_symbol<Elf64_Sym>( name, value, size, info,
                                                  other, shndx );
        }

        return nRet;
    }

    //------------------------------------------------------------------------------
    Elf_Word add_symbol( Elf_Word      name,
                         Elf64_Addr    value,
                         Elf_Xword     size,
                         unsigned char bind,
                         unsigned char type,
                         unsigned char other,
                         Elf_Half      shndx )
    {
        return add_symbol( name, value, size, ELF_ST_INFO( bind, type ), other,
                           shndx );
    }

    //------------------------------------------------------------------------------
    Elf_Word add_symbol( string_section_accessor& pStrWriter,
                         const char*              str,
                         Elf64_Addr               value,
                         Elf_Xword                size,
                         unsigned char            info,
                         unsigned char            other,
                         Elf_Half                 shndx )
    {
        Elf_Word index = pStrWriter.add_string( str );
        return add_symbol( index, value, size, info, other, shndx );
    }

    //------------------------------------------------------------------------------
    Elf_Word add_symbol( string_section_accessor& pStrWriter,
                         const char*              str,
                         Elf64_Addr               value,
                         Elf_Xword                size,
                         unsigned char            bind,
                         unsigned char            type,
                         unsigned char            other,
                         Elf_Half                 shndx )
    {
        return add_symbol( pStrWriter, str, value, size,
                           ELF_ST_INFO( bind, type ), other, shndx );
    }

    //------------------------------------------------------------------------------
    Elf_Xword arrange_local_symbols(
        std::function<void( Elf_Xword first, Elf_Xword second )> func =
            nullptr )
    {
        Elf_Xword nRet = 0;

        if ( elf_file.get_class() == ELFCLASS32 ) {
            nRet = generic_arrange_local_symbols<Elf32_Sym>( func );
        }
        else {
            nRet = generic_arrange_local_symbols<Elf64_Sym>( func );
        }

        return nRet;
    }

    //------------------------------------------------------------------------------
  private:
    //------------------------------------------------------------------------------
    void find_hash_section()
    {
        Elf_Half nSecNo = elf_file.sections.size();
        for ( Elf_Half i = 0; i < nSecNo; ++i ) {
            const section* sec = elf_file.sections[i];
            if ( sec->get_link() == symbol_section->get_index() &&
                 ( sec->get_type() == SHT_HASH ||
                   sec->get_type() == SHT_GNU_HASH ||
                   sec->get_type() == DT_GNU_HASH ) ) {
                hash_section       = sec;
                hash_section_index = i;
                break;
            }
        }
    }

    //------------------------------------------------------------------------------
    Elf_Half get_string_table_index() const
    {
        return (Elf_Half)symbol_section->get_link();
    }

    //------------------------------------------------------------------------------
    Elf_Half get_hash_table_index() const { return hash_section_index; }

    //------------------------------------------------------------------------------
    bool hash_lookup( const std::string& name,
                      Elf64_Addr&        value,
                      Elf_Xword&         size,
                      unsigned char&     bind,
                      unsigned char&     type,
                      Elf_Half&          section_index,
                      unsigned char&     other ) const
    {
        bool                       ret       = false;
        const endianess_convertor& convertor = elf_file.get_convertor();

        Elf_Word nbucket = *(const Elf_Word*)hash_section->get_data();
        nbucket          = convertor( nbucket );
        Elf_Word nchain =
            *(const Elf_Word*)( hash_section->get_data() + sizeof( Elf_Word ) );
        nchain       = convertor( nchain );
        Elf_Word val = elf_hash( (const unsigned char*)name.c_str() );
        Elf_Word y =
            *(const Elf_Word*)( hash_section->get_data() +
                                ( 2 + val % nbucket ) * sizeof( Elf_Word ) );
        y = convertor( y );
        std::string str;
        get_symbol( y, str, value, size, bind, type, section_index, other );
        while ( str != name && STN_UNDEF != y && y < nchain ) {
            y = *(const Elf_Word*)( hash_section->get_data() +
                                    ( 2 + nbucket + y ) * sizeof( Elf_Word ) );
            y = convertor( y );
            get_symbol( y, str, value, size, bind, type, section_index, other );
        }

        if ( str == name ) {
            ret = true;
        }

        return ret;
    }

    //------------------------------------------------------------------------------
    template <class T>
    bool gnu_hash_lookup( const std::string& name,
                          Elf64_Addr&        value,
                          Elf_Xword&         size,
                          unsigned char&     bind,
                          unsigned char&     type,
                          Elf_Half&          section_index,
                          unsigned char&     other ) const
    {
        bool                       ret       = false;
        const endianess_convertor& convertor = elf_file.get_convertor();

        uint32_t nbuckets    = *( (uint32_t*)hash_section->get_data() + 0 );
        uint32_t symoffset   = *( (uint32_t*)hash_section->get_data() + 1 );
        uint32_t bloom_size  = *( (uint32_t*)hash_section->get_data() + 2 );
        uint32_t bloom_shift = *( (uint32_t*)hash_section->get_data() + 3 );
        nbuckets             = convertor( nbuckets );
        symoffset            = convertor( symoffset );
        bloom_size           = convertor( bloom_size );
        bloom_shift          = convertor( bloom_shift );

        T* bloom_filter =
            (T*)( hash_section->get_data() + 4 * sizeof( uint32_t ) );

        uint32_t hash = elf_gnu_hash( (const unsigned char*)name.c_str() );
        uint32_t bloom_index = ( hash / ( 8 * sizeof( T ) ) ) % bloom_size;
        T        bloom_bits =
            ( (T)1 << ( hash % ( 8 * sizeof( T ) ) ) ) |
            ( (T)1 << ( ( hash >> bloom_shift ) % ( 8 * sizeof( T ) ) ) );

        if ( ( convertor( bloom_filter[bloom_index] ) & bloom_bits ) !=
             bloom_bits )
            return ret;

        uint32_t bucket = hash % nbuckets;
        auto*    buckets =
            (uint32_t*)( hash_section->get_data() + 4 * sizeof( uint32_t ) +
                         bloom_size * sizeof( T ) );
        auto* chains =
            (uint32_t*)( hash_section->get_data() + 4 * sizeof( uint32_t ) +
                         bloom_size * sizeof( T ) +
                         nbuckets * sizeof( uint32_t ) );

        if ( convertor( buckets[bucket] ) >= symoffset ) {
            uint32_t    chain_index = convertor( buckets[bucket] ) - symoffset;
            uint32_t    chain_hash  = convertor( chains[chain_index] );
            std::string symname;

            while ( true ) {
                if ( ( chain_hash >> 1 ) == ( hash >> 1 ) &&
                     get_symbol( chain_index + symoffset, symname, value, size,
                                 bind, type, section_index, other ) &&
                     name == symname ) {
                    ret = true;
                    break;
                }

                if ( chain_hash & 1 )
                    break;
                chain_hash = convertor( chains[++chain_index] );
            }
        }

        return ret;
    }

    //------------------------------------------------------------------------------
    template <class T> const T* generic_get_symbol_ptr( Elf_Xword index ) const
    {
        if ( 0 != symbol_section->get_data() && index < get_symbols_num() ) {
            const T* pSym = reinterpret_cast<const T*>(
                symbol_section->get_data() +
                index * symbol_section->get_entry_size() );

            return pSym;
        }

        return nullptr;
    }

    //------------------------------------------------------------------------------
    template <class T>
    bool generic_search_symbols( std::function<bool( const T* )> match,
                                 Elf_Xword&                      idx ) const
    {
        for ( Elf_Xword i = 0; i < get_symbols_num(); i++ ) {
            const T* symPtr = generic_get_symbol_ptr<T>( i );

            if ( symPtr == nullptr )
                return false;

            if ( match( symPtr ) ) {
                idx = i;
                return true;
            }
        }

        return false;
    }

    //------------------------------------------------------------------------------
    template <class T>
    bool generic_get_symbol( Elf_Xword      index,
                             std::string&   name,
                             Elf64_Addr&    value,
                             Elf_Xword&     size,
                             unsigned char& bind,
                             unsigned char& type,
                             Elf_Half&      section_index,
                             unsigned char& other ) const
    {
        bool ret = false;

        if ( nullptr != symbol_section->get_data() &&
             index < get_symbols_num() ) {
            const T* pSym = reinterpret_cast<const T*>(
                symbol_section->get_data() +
                index * symbol_section->get_entry_size() );

            const endianess_convertor& convertor = elf_file.get_convertor();

            section* string_section =
                elf_file.sections[get_string_table_index()];
            string_section_accessor str_reader( string_section );
            const char*             pStr =
                str_reader.get_string( convertor( pSym->st_name ) );
            if ( nullptr != pStr ) {
                name = pStr;
            }
            value         = convertor( pSym->st_value );
            size          = convertor( pSym->st_size );
            bind          = ELF_ST_BIND( pSym->st_info );
            type          = ELF_ST_TYPE( pSym->st_info );
            section_index = convertor( pSym->st_shndx );
            other         = pSym->st_other;

            ret = true;
        }

        return ret;
    }

    //------------------------------------------------------------------------------
    template <class T>
    Elf_Word generic_add_symbol( Elf_Word      name,
                                 Elf64_Addr    value,
                                 Elf_Xword     size,
                                 unsigned char info,
                                 unsigned char other,
                                 Elf_Half      shndx )
    {
        const endianess_convertor& convertor = elf_file.get_convertor();

        T entry;
        entry.st_name  = convertor( name );
        entry.st_value = decltype( entry.st_value )( value );
        entry.st_value = convertor( entry.st_value );
        entry.st_size  = decltype( entry.st_size )( size );
        entry.st_size  = convertor( entry.st_size );
        entry.st_info  = convertor( info );
        entry.st_other = convertor( other );
        entry.st_shndx = convertor( shndx );

        symbol_section->append_data( reinterpret_cast<char*>( &entry ),
                                     sizeof( entry ) );

        Elf_Word nRet =
            Elf_Word( symbol_section->get_size() / sizeof( entry ) - 1 );

        return nRet;
    }

    //------------------------------------------------------------------------------
    template <class T>
    Elf_Xword generic_arrange_local_symbols(
        std::function<void( Elf_Xword first, Elf_Xword second )> func )
    {
        const endianess_convertor& convertor = elf_file.get_convertor();

        Elf_Word first_not_local =
            1; // Skip the first entry. It is always NOTYPE
        Elf_Xword current = 0;
        Elf_Xword count   = get_symbols_num();

        while ( true ) {
            T* p1 = nullptr;
            T* p2 = nullptr;

            while ( first_not_local < count ) {
                p1 = const_cast<T*>(
                    generic_get_symbol_ptr<T>( first_not_local ) );
                if ( ELF_ST_BIND( convertor( p1->st_info ) ) != STB_LOCAL )
                    break;
                ++first_not_local;
            }

            current = first_not_local + 1;
            while ( current < count ) {
                p2 = const_cast<T*>( generic_get_symbol_ptr<T>( current ) );
                if ( ELF_ST_BIND( convertor( p2->st_info ) ) == STB_LOCAL )
                    break;
                ++current;
            }

            if ( first_not_local < count && current < count ) {
                if ( func )
                    func( first_not_local, current );

                std::swap( *p1, *p2 );
            }
            else {
                // Update 'info' field of the section
                symbol_section->set_info( first_not_local );
                break;
            }
        }

        return first_not_local;
    }

    //------------------------------------------------------------------------------
  private:
    const elfio&   elf_file;
    S*             symbol_section;
    Elf_Half       hash_section_index{ 0 };
    const section* hash_section{ nullptr };
};

using symbol_section_accessor = symbol_section_accessor_template<section>;
using const_symbol_section_accessor =
    symbol_section_accessor_template<const section>;

} // namespace ELFIO

#endif // ELFIO_SYMBOLS_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_UTILS_HPP
#define ELFIO_UTILS_HPP

#include <cstdint>
#include <ostream>
#include <cstring>

#define ELFIO_GET_ACCESS_DECL( TYPE, NAME ) virtual TYPE get_##NAME() const = 0

#define ELFIO_SET_ACCESS_DECL( TYPE, NAME ) \
    virtual void set_##NAME( const TYPE& value ) = 0

#define ELFIO_GET_SET_ACCESS_DECL( TYPE, NAME )       \
    virtual TYPE get_##NAME() const              = 0; \
    virtual void set_##NAME( const TYPE& value ) = 0

#define ELFIO_GET_ACCESS( TYPE, NAME, FIELD ) \
    TYPE get_##NAME() const override { return ( *convertor )( FIELD ); }

#define ELFIO_SET_ACCESS( TYPE, NAME, FIELD )     \
    void set_##NAME( const TYPE& value ) override \
    {                                             \
        FIELD = decltype( FIELD )( value );       \
        FIELD = ( *convertor )( FIELD );          \
    }
#define ELFIO_GET_SET_ACCESS( TYPE, NAME, FIELD )                        \
    TYPE get_##NAME() const override { return ( *convertor )( FIELD ); } \
    void set_##NAME( const TYPE& value ) override                        \
    {                                                                    \
        FIELD = decltype( FIELD )( value );                              \
        FIELD = ( *convertor )( FIELD );                                 \
    }

namespace ELFIO {

//------------------------------------------------------------------------------
class endianess_convertor
{
  public:
    //------------------------------------------------------------------------------
    void setup( unsigned char elf_file_encoding )
    {
        need_conversion = ( elf_file_encoding != get_host_encoding() );
    }

    //------------------------------------------------------------------------------
    uint64_t operator()( uint64_t value ) const
    {
        if ( !need_conversion ) {
            return value;
        }
        value = ( ( value & 0x00000000000000FFuLL ) << 56 ) |
                ( ( value & 0x000000000000FF00uLL ) << 40 ) |
                ( ( value & 0x0000000000FF0000uLL ) << 24 ) |
                ( ( value & 0x00000000FF000000uLL ) << 8 ) |
                ( ( value & 0x000000FF00000000uLL ) >> 8 ) |
                ( ( value & 0x0000FF0000000000uLL ) >> 24 ) |
                ( ( value & 0x00FF000000000000uLL ) >> 40 ) |
                ( ( value & 0xFF00000000000000uLL ) >> 56 );

        return value;
    }

    //------------------------------------------------------------------------------
    int64_t operator()( int64_t value ) const
    {
        if ( !need_conversion ) {
            return value;
        }
        return (int64_t)( *this )( (uint64_t)value );
    }

    //------------------------------------------------------------------------------
    uint32_t operator()( uint32_t value ) const
    {
        if ( !need_conversion ) {
            return value;
        }
        value =
            ( ( value & 0x000000FF ) << 24 ) | ( ( value & 0x0000FF00 ) << 8 ) |
            ( ( value & 0x00FF0000 ) >> 8 ) | ( ( value & 0xFF000000 ) >> 24 );

        return value;
    }

    //------------------------------------------------------------------------------
    int32_t operator()( int32_t value ) const
    {
        if ( !need_conversion ) {
            return value;
        }
        return (int32_t)( *this )( (uint32_t)value );
    }

    //------------------------------------------------------------------------------
    uint16_t operator()( uint16_t value ) const
    {
        if ( !need_conversion ) {
            return value;
        }
        value =
            (uint16_t)( ( value & 0x00FF ) << 8 ) | ( ( value & 0xFF00 ) >> 8 );

        return value;
    }

    //------------------------------------------------------------------------------
    int16_t operator()( int16_t value ) const
    {
        if ( !need_conversion ) {
            return value;
        }
        return (int16_t)( *this )( (uint16_t)value );
    }

    //------------------------------------------------------------------------------
    int8_t operator()( int8_t value ) const { return value; }

    //------------------------------------------------------------------------------
    uint8_t operator()( uint8_t value ) const { return value; }

    //------------------------------------------------------------------------------
  private:
    //------------------------------------------------------------------------------
    unsigned char get_host_encoding() const
    {
        static const int tmp = 1;
        if ( 1 == *reinterpret_cast<const char*>( &tmp ) ) {
            return ELFDATA2LSB;
        }
        else {
            return ELFDATA2MSB;
        }
    }

    //------------------------------------------------------------------------------
    bool need_conversion = false;
};

//------------------------------------------------------------------------------
struct address_translation
{
    address_translation( uint64_t start, uint64_t size, uint64_t mapped_to )
        : start( start ), size( size ), mapped_to( mapped_to ){};
    std::streampos start;
    std::streampos size;
    std::streampos mapped_to;
};

//------------------------------------------------------------------------------
class address_translator
{
  public:
    //------------------------------------------------------------------------------
    void set_address_translation( std::vector<address_translation>& addr_trans )
    {
        addr_translations = addr_trans;

        std::sort( addr_translations.begin(), addr_translations.end(),
                   []( const address_translation& a,
                       const address_translation& b ) -> bool {
                       return a.start < b.start;
                   } );
    }

    //------------------------------------------------------------------------------
    std::streampos operator[]( std::streampos value ) const
    {
        if ( addr_translations.empty() ) {
            return value;
        }

        for ( auto& t : addr_translations ) {
            if ( ( t.start <= value ) && ( ( value - t.start ) < t.size ) ) {
                return value - t.start + t.mapped_to;
            }
        }

        return value;
    }

    bool empty() const { return addr_translations.empty(); }

  private:
    std::vector<address_translation> addr_translations;
};

//------------------------------------------------------------------------------
inline uint32_t elf_hash( const unsigned char* name )
{
    uint32_t h = 0;
    uint32_t g = 0;
    while ( *name != '\0' ) {
        h = ( h << 4 ) + *name++;
        g = h & 0xf0000000;
        if ( g != 0 )
            h ^= g >> 24;
        h &= ~g;
    }
    return h;
}

//------------------------------------------------------------------------------
inline uint32_t elf_gnu_hash( const unsigned char* s )
{
    uint32_t h = 0x1505;
    for ( unsigned char c = *s; c != '\0'; c = *++s )
        h = ( h << 5 ) + h + c;
    return h;
}

//------------------------------------------------------------------------------
inline std::string to_hex_string( uint64_t value )
{
    std::string str;

    while ( value ) {
        if ( auto digit = value & 0xF; digit < 0xA ) {
            str = char( '0' + digit ) + str;
        }
        else {
            str = char( 'A' + digit - 0xA ) + str;
        }
        value >>= 4;
    }

    return "0x" + str;
}

//------------------------------------------------------------------------------
inline void adjust_stream_size( std::ostream& stream, std::streamsize offset )
{
    stream.seekp( 0, std::ios_base::end );
    if ( stream.tellp() < offset ) {
        std::streamsize size = offset - stream.tellp();
        stream.write( std::string( size_t( size ), '\0' ).c_str(), size );
    }
    stream.seekp( offset );
}

//------------------------------------------------------------------------------
inline static size_t strnlength( const char* s, size_t n )
{
    auto found = (const char*)std::memchr( s, '\0', n );
    return found ? (size_t)( found - s ) : n;
}

/**
 * Consumers should write an implementation of this class and pass an instance of it to the ELFIO::elfio constructor.
 */
class compression_interface
{
  public:
    virtual ~compression_interface() = default;
    /**
     * decompresses a compressed section
     *
     * @param data the buffer of compressed data
     * @param endianness_convertor pointer to an endianness_convertor instance, used to convert numbers to/from the target endianness.
     * @param compressed_size the size of the data buffer, in bytes
     * @param decompressed_size a reference to a variable where the decompressed buffer size will be stored.
     * @returns a smart pointer to the decompressed data.
     */
    virtual std::unique_ptr<char[]>
    inflate( const char*                data,
             const endianess_convertor* convertor,
             Elf_Xword                  compressed_size,
             Elf_Xword&                 uncompressed_size ) const = 0;

    /**
     * compresses a section
     *
     * @param data the buffer of uncompressed data
     * @param endianness_convertor pointer to an endianness_convertor instance, used to convert numbers to/from the target endianness.
     * @param decompressed_size the size of the data buffer, in bytes
     * @param compressed_size a reference to a variable where the compressed buffer size will be stored.
     * @returns a smart pointer to the compressed data.
     */
    virtual std::unique_ptr<char[]>
    deflate( const char*                data,
             const endianess_convertor* convertor,
             Elf_Xword                  decompressed_size,
             Elf_Xword&                 compressed_size ) const = 0;
};

} // namespace ELFIO

#endif // ELFIO_UTILS_HPP
#define ELFIO_VERSION "3.12"
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFIO_VERSYM_HPP
#define ELFIO_VERSYM_HPP

namespace ELFIO {

//------------------------------------------------------------------------------
template <class S> class versym_section_accessor_template
{
  public:
    //------------------------------------------------------------------------------
    explicit versym_section_accessor_template( S* section )
        : versym_section( section )
    {
        if ( section != nullptr ) {
            entries_num = decltype( entries_num )( section->get_size() /
                                                   sizeof( Elf_Half ) );
        }
    }

    //------------------------------------------------------------------------------
    Elf_Word get_entries_num() const
    {
        if ( versym_section ) {
            return entries_num;
        }
        return 0;
    }

    //------------------------------------------------------------------------------
    bool get_entry( Elf_Word no, Elf_Half& value ) const
    {
        if ( versym_section && ( no < get_entries_num() ) ) {
            value = ( (Elf_Half*)versym_section->get_data() )[no];
            return true;
        }

        return false;
    }

    //------------------------------------------------------------------------------
    bool modify_entry( Elf_Word no, Elf_Half value )
    {
        if ( versym_section && ( no < get_entries_num() ) ) {
            ( (Elf_Half*)versym_section->get_data() )[no] = value;
            return true;
        }

        return false;
    }

    //------------------------------------------------------------------------------
    bool add_entry( Elf_Half value )
    {
        if ( !versym_section ) {
            return false;
        }

        versym_section->append_data( (const char*)&value, sizeof( Elf_Half ) );
        ++entries_num;

        return true;
    }

    //------------------------------------------------------------------------------
  private:
    S*       versym_section = nullptr;
    Elf_Word entries_num    = 0;
};

using versym_section_accessor = versym_section_accessor_template<section>;
using const_versym_section_accessor =
    versym_section_accessor_template<const section>;

//------------------------------------------------------------------------------
template <class S> class versym_r_section_accessor_template
{
  public:
    //------------------------------------------------------------------------------
    versym_r_section_accessor_template( const elfio& elf_file,
                                        S*           versym_r_section )
        : elf_file( elf_file ), versym_r_section( versym_r_section ),
          entries_num( 0 )
    {
        // Find .dynamic section
        const section* dynamic_section = elf_file.sections[".dynamic"];

        if ( dynamic_section == nullptr ) {
            return;
        }

        const_dynamic_section_accessor dynamic_section_acc( elf_file,
                                                            dynamic_section );
        Elf_Xword dyn_sec_num = dynamic_section_acc.get_entries_num();
        for ( Elf_Xword i = 0; i < dyn_sec_num; ++i ) {
            Elf_Xword   tag;
            Elf_Xword   value;
            std::string str;

            if ( dynamic_section_acc.get_entry( i, tag, value, str ) &&
                 tag == DT_VERNEEDNUM ) {
                entries_num = (Elf_Word)value;
                break;
            }
        }
    }

    //------------------------------------------------------------------------------
    Elf_Word get_entries_num() const { return entries_num; }

    //------------------------------------------------------------------------------
    bool get_entry( Elf_Word     no,
                    Elf_Half&    version,
                    std::string& file_name,
                    Elf_Word&    hash,
                    Elf_Half&    flags,
                    Elf_Half&    other,
                    std::string& dep_name ) const
    {
        if ( versym_r_section == nullptr || ( no >= get_entries_num() ) ) {
            return false;
        }

        const_string_section_accessor string_section_acc(
            elf_file.sections[versym_r_section->get_link()] );

        Elfxx_Verneed* verneed = (Elfxx_Verneed*)versym_r_section->get_data();
        Elfxx_Vernaux* veraux =
            (Elfxx_Vernaux*)( (char*)verneed + verneed->vn_aux );
        for ( Elf_Word i = 0; i < no; ++i ) {
            verneed = (Elfxx_Verneed*)( (char*)verneed + verneed->vn_next );
            veraux  = (Elfxx_Vernaux*)( (char*)verneed + verneed->vn_aux );
        }

        version   = verneed->vn_version;
        file_name = string_section_acc.get_string( verneed->vn_file );
        hash      = veraux->vna_hash;
        flags     = veraux->vna_flags;
        other     = veraux->vna_other;
        dep_name  = string_section_acc.get_string( veraux->vna_name );

        return true;
    }

    //------------------------------------------------------------------------------
  private:
    const elfio& elf_file;
    S*           versym_r_section = nullptr;
    Elf_Word     entries_num      = 0;
};

using versym_r_section_accessor = versym_r_section_accessor_template<section>;
using const_versym_r_section_accessor =
    versym_r_section_accessor_template<const section>;

} // namespace ELFIO

#endif // ELFIO_VERSYM_HPP
/*
Copyright (C) 2001-present by Serge Lamikhov-Center

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#ifndef ELFTYPES_H
#define ELFTYPES_H

#ifdef __cplusplus
namespace ELFIO {
#endif

using Elf_Half   = uint16_t;
using Elf_Word   = uint32_t;
using Elf_Sword  = int32_t;
using Elf_Xword  = uint64_t;
using Elf_Sxword = int64_t;

using Elf32_Addr = uint32_t;
using Elf32_Off  = uint32_t;
using Elf64_Addr = uint64_t;
using Elf64_Off  = uint64_t;

using Elf32_Half  = Elf_Half;
using Elf64_Half  = Elf_Half;
using Elf32_Word  = Elf_Word;
using Elf64_Word  = Elf_Word;
using Elf32_Sword = Elf_Sword;
using Elf64_Sword = Elf_Sword;

///////////////////////
// ELF Header Constants

// File type
constexpr Elf_Half ET_NONE   = 0;
constexpr Elf_Half ET_REL    = 1;
constexpr Elf_Half ET_EXEC   = 2;
constexpr Elf_Half ET_DYN    = 3;
constexpr Elf_Half ET_CORE   = 4;
constexpr Elf_Half ET_LOOS   = 0xFE00;
constexpr Elf_Half ET_HIOS   = 0xFEFF;
constexpr Elf_Half ET_LOPROC = 0xFF00;
constexpr Elf_Half ET_HIPROC = 0xFFFF;

// clang-format off
// Machine number
constexpr Elf_Half EM_NONE            = 0 ; // No machine
constexpr Elf_Half EM_M32             = 1 ; // AT&T WE 32100
constexpr Elf_Half EM_SPARC           = 2 ; // SUN SPARC
constexpr Elf_Half EM_386             = 3 ; // Intel 80386
constexpr Elf_Half EM_68K             = 4 ; // Motorola m68k family
constexpr Elf_Half EM_88K             = 5 ; // Motorola m88k family
constexpr Elf_Half EM_486             = 6 ; // Intel 80486// Reserved for future use
constexpr Elf_Half EM_860             = 7 ; // Intel 80860
constexpr Elf_Half EM_MIPS            = 8 ; // MIPS R3000 (officially, big-endian only)
constexpr Elf_Half EM_S370            = 9 ; // IBM System/370
constexpr Elf_Half EM_MIPS_RS3_LE     = 10; // MIPS R3000 little-endian (Deprecated)
constexpr Elf_Half EM_res011          = 11; // Reserved
constexpr Elf_Half EM_res012          = 12; // Reserved
constexpr Elf_Half EM_res013          = 13; // Reserved
constexpr Elf_Half EM_res014          = 14; // Reserved
constexpr Elf_Half EM_PARISC          = 15; // HPPA
constexpr Elf_Half EM_res016          = 16; // Reserved
constexpr Elf_Half EM_VPP550          = 17; // Fujitsu VPP500
constexpr Elf_Half EM_SPARC32PLUS     = 18; // Sun's "v8plus"
constexpr Elf_Half EM_960             = 19; // Intel 80960
constexpr Elf_Half EM_PPC             = 20; // PowerPC
constexpr Elf_Half EM_PPC64           = 21; // 64-bit PowerPC
constexpr Elf_Half EM_S390            = 22; // IBM S/390
constexpr Elf_Half EM_SPU             = 23; // Sony/Toshiba/IBM SPU
constexpr Elf_Half EM_res024          = 24; // Reserved
constexpr Elf_Half EM_res025          = 25; // Reserved
constexpr Elf_Half EM_res026          = 26; // Reserved
constexpr Elf_Half EM_res027          = 27; // Reserved
constexpr Elf_Half EM_res028          = 28; // Reserved
constexpr Elf_Half EM_res029          = 29; // Reserved
constexpr Elf_Half EM_res030          = 30; // Reserved
constexpr Elf_Half EM_res031          = 31; // Reserved
constexpr Elf_Half EM_res032          = 32; // Reserved
constexpr Elf_Half EM_res033          = 33; // Reserved
constexpr Elf_Half EM_res034          = 34; // Reserved
constexpr Elf_Half EM_res035          = 35; // Reserved
constexpr Elf_Half EM_V800            = 36; // NEC V800 series
constexpr Elf_Half EM_FR20            = 37; // Fujitsu FR20
constexpr Elf_Half EM_RH32            = 38; // TRW RH32
constexpr Elf_Half EM_MCORE           = 39; // Motorola M*Core // May also be taken by Fujitsu MMA
constexpr Elf_Half EM_RCE             = 39; // Old name for MCore
constexpr Elf_Half EM_ARM             = 40; // ARM
constexpr Elf_Half EM_OLD_ALPHA       = 41; // Digital Alpha
constexpr Elf_Half EM_SH              = 42; // Renesas (formerly Hitachi) / SuperH SH
constexpr Elf_Half EM_SPARCV9         = 43; // SPARC v9 64-bit
constexpr Elf_Half EM_TRICORE         = 44; // Siemens Tricore embedded processor
constexpr Elf_Half EM_ARC             = 45; // ARC Cores
constexpr Elf_Half EM_H8_300          = 46; // Renesas (formerly Hitachi) H8/300
constexpr Elf_Half EM_H8_300H         = 47; // Renesas (formerly Hitachi) H8/300H
constexpr Elf_Half EM_H8S             = 48; // Renesas (formerly Hitachi) H8S
constexpr Elf_Half EM_H8_500          = 49; // Renesas (formerly Hitachi) H8/500
constexpr Elf_Half EM_IA_64           = 50; // Intel IA-64 Processor
constexpr Elf_Half EM_MIPS_X          = 51; // Stanford MIPS-X
constexpr Elf_Half EM_COLDFIRE        = 52; // Motorola Coldfire
constexpr Elf_Half EM_68HC12          = 53; // Motorola M68HC12
constexpr Elf_Half EM_MMA             = 54; // Fujitsu Multimedia Accelerator
constexpr Elf_Half EM_PCP             = 55; // Siemens PCP
constexpr Elf_Half EM_NCPU            = 56; // Sony nCPU embedded RISC processor
constexpr Elf_Half EM_NDR1            = 57; // Denso NDR1 microprocesspr
constexpr Elf_Half EM_STARCORE        = 58; // Motorola Star*Core processor
constexpr Elf_Half EM_ME16            = 59; // Toyota ME16 processor
constexpr Elf_Half EM_ST100           = 60; // STMicroelectronics ST100 processor
constexpr Elf_Half EM_TINYJ           = 61; // Advanced Logic Corp. TinyJ embedded processor
constexpr Elf_Half EM_X86_64          = 62; // Advanced Micro Devices X86-64 processor
constexpr Elf_Half EM_PDSP            = 63; // Sony DSP Processor
constexpr Elf_Half EM_PDP10           = 64; // Digital Equipment Corp. PDP-10
constexpr Elf_Half EM_PDP11           = 65; // Digital Equipment Corp. PDP-11
constexpr Elf_Half EM_FX66            = 66; // Siemens FX66 microcontroller
constexpr Elf_Half EM_ST9PLUS         = 67; // STMicroelectronics ST9+ 8/16 bit microcontroller
constexpr Elf_Half EM_ST7             = 68 ; // STMicroelectronics ST7 8-bit microcontroller
constexpr Elf_Half EM_68HC16          = 69 ; // Motorola MC68HC16 Microcontroller
constexpr Elf_Half EM_68HC11          = 70 ; // Motorola MC68HC11 Microcontroller
constexpr Elf_Half EM_68HC08          = 71 ; // Motorola MC68HC08 Microcontroller
constexpr Elf_Half EM_68HC05          = 72 ; // Motorola MC68HC05 Microcontroller
constexpr Elf_Half EM_SVX             = 73 ; // Silicon Graphics SVx
constexpr Elf_Half EM_ST19            = 74 ; // STMicroelectronics ST19 8-bit cpu
constexpr Elf_Half EM_VAX             = 75 ; // Digital VAX
constexpr Elf_Half EM_CRIS            = 76 ; // Axis Communications 32-bit embedded processor
constexpr Elf_Half EM_JAVELIN         = 77 ; // Infineon Technologies 32-bit embedded cpu
constexpr Elf_Half EM_FIREPATH        = 78 ; // Element 14 64-bit DSP processor
constexpr Elf_Half EM_ZSP             = 79 ; // LSI Logic's 16-bit DSP processor
constexpr Elf_Half EM_MMIX            = 80 ; // Donald Knuth's educational 64-bit processor
constexpr Elf_Half EM_HUANY           = 81 ; // Harvard's machine-independent format
constexpr Elf_Half EM_PRISM           = 82 ; // SiTera Prism
constexpr Elf_Half EM_AVR             = 83 ; // Atmel AVR 8-bit microcontroller
constexpr Elf_Half EM_FR30            = 84 ; // Fujitsu FR30
constexpr Elf_Half EM_D10V            = 85 ; // Mitsubishi D10V
constexpr Elf_Half EM_D30V            = 86 ; // Mitsubishi D30V
constexpr Elf_Half EM_V850            = 87 ; // NEC v850
constexpr Elf_Half EM_M32R            = 88 ; // Renesas M32R (formerly Mitsubishi M32R)
constexpr Elf_Half EM_MN10300         = 89 ; // Matsushita MN10300
constexpr Elf_Half EM_MN10200         = 90 ; // Matsushita MN10200
constexpr Elf_Half EM_PJ              = 91 ; // picoJava
constexpr Elf_Half EM_OPENRISC        = 92 ; // OpenRISC 32-bit embedded processor
constexpr Elf_Half EM_ARC_A5          = 93 ; // ARC Cores Tangent-A5
constexpr Elf_Half EM_XTENSA          = 94 ; // Tensilica Xtensa Architecture
constexpr Elf_Half EM_VIDEOCORE       = 95 ; // Alphamosaic VideoCore processor
constexpr Elf_Half EM_TMM_GPP         = 96 ; // Thompson Multimedia General Purpose Processor
constexpr Elf_Half EM_NS32K           = 97 ; // National Semiconductor 32000 series
constexpr Elf_Half EM_TPC             = 98 ; // Tenor Network TPC processor
constexpr Elf_Half EM_SNP1K           = 99 ; // Trebia SNP 1000 processor
constexpr Elf_Half EM_ST200           = 100; // STMicroelectronics ST200 microcontroller
constexpr Elf_Half EM_IP2K            = 101; // Ubicom IP2022 micro controller
constexpr Elf_Half EM_MAX             = 102; // MAX Processor
constexpr Elf_Half EM_CR              = 103; // National Semiconductor CompactRISC
constexpr Elf_Half EM_F2MC16          = 104; // Fujitsu F2MC16
constexpr Elf_Half EM_MSP430          = 105; // TI msp430 micro controller
constexpr Elf_Half EM_BLACKFIN        = 106; // ADI Blackfin
constexpr Elf_Half EM_SE_C33          = 107; // S1C33 Family of Seiko Epson processors
constexpr Elf_Half EM_SEP             = 108; // Sharp embedded microprocessor
constexpr Elf_Half EM_ARCA            = 109; // Arca RISC Microprocessor
constexpr Elf_Half EM_UNICORE         = 110; // Microprocessor series from PKU-Unity Ltd.
constexpr Elf_Half EM_EXCESS          = 111; // eXcess: 16/32/64-bit configurable embedded CPU
constexpr Elf_Half EM_DXP             = 112; // Icera Semiconductor Inc. Deep Execution Processor
constexpr Elf_Half EM_ALTERA_NIOS2    = 113; // Altera Nios II soft-core processor
constexpr Elf_Half EM_CRX             = 114; // National Semiconductor CRX
constexpr Elf_Half EM_XGATE           = 115; // Motorola XGATE embedded processor
constexpr Elf_Half EM_C166            = 116; // Infineon C16x/XC16x processor
constexpr Elf_Half EM_M16C            = 117; // Renesas M16C series microprocessors
constexpr Elf_Half EM_DSPIC30F        = 118; // Microchip Technology dsPIC30F DSignal Controller
constexpr Elf_Half EM_CE              = 119; // Freescale Communication Engine RISC core
constexpr Elf_Half EM_M32C            = 120; // Renesas M32C series microprocessors
constexpr Elf_Half EM_res121          = 121; // Reserved
constexpr Elf_Half EM_res122          = 122; // Reserved
constexpr Elf_Half EM_res123          = 123; // Reserved
constexpr Elf_Half EM_res124          = 124; // Reserved
constexpr Elf_Half EM_res125          = 125; // Reserved
constexpr Elf_Half EM_res126          = 126; // Reserved
constexpr Elf_Half EM_res127          = 127; // Reserved
constexpr Elf_Half EM_res128          = 128; // Reserved
constexpr Elf_Half EM_res129          = 129; // Reserved
constexpr Elf_Half EM_res130          = 130; // Reserved
constexpr Elf_Half EM_TSK3000         = 131; // Altium TSK3000 core
constexpr Elf_Half EM_RS08            = 132; // Freescale RS08 embedded processor
constexpr Elf_Half EM_res133          = 133; // Reserved
constexpr Elf_Half EM_ECOG2           = 134; // Cyan Technology eCOG2 microprocessor
constexpr Elf_Half EM_SCORE           = 135; // Sunplus Score
constexpr Elf_Half EM_SCORE7          = 135; // Sunplus S+core7 RISC processor
constexpr Elf_Half EM_DSP24           = 136; // New Japan Radio (NJR) 24-bit DSP Processor
constexpr Elf_Half EM_VIDEOCORE3      = 137; // Broadcom VideoCore III processor
constexpr Elf_Half EM_LATTICEMICO32   = 138; // RISC processor for Lattice FPGA architecture
constexpr Elf_Half EM_SE_C17          = 139; // Seiko Epson C17 family
constexpr Elf_Half EM_TI_C6000        = 140; // Texas Instruments TMS320C6000 DSP family
constexpr Elf_Half EM_TI_C2000        = 141; // Texas Instruments TMS320C2000 DSP family
constexpr Elf_Half EM_TI_C5500        = 142; // Texas Instruments TMS320C55x DSP family
constexpr Elf_Half EM_res143          = 143; // Reserved
constexpr Elf_Half EM_res144          = 144; // Reserved
constexpr Elf_Half EM_res145          = 145; // Reserved
constexpr Elf_Half EM_res146          = 146; // Reserved
constexpr Elf_Half EM_res147          = 147; // Reserved
constexpr Elf_Half EM_res148          = 148; // Reserved
constexpr Elf_Half EM_res149          = 149; // Reserved
constexpr Elf_Half EM_res150          = 150; // Reserved
constexpr Elf_Half EM_res151          = 151; // Reserved
constexpr Elf_Half EM_res152          = 152; // Reserved
constexpr Elf_Half EM_res153          = 153; // Reserved
constexpr Elf_Half EM_res154          = 154; // Reserved
constexpr Elf_Half EM_res155          = 155; // Reserved
constexpr Elf_Half EM_res156          = 156; // Reserved
constexpr Elf_Half EM_res157          = 157; // Reserved
constexpr Elf_Half EM_res158          = 158; // Reserved
constexpr Elf_Half EM_res159          = 159; // Reserved
constexpr Elf_Half EM_MMDSP_PLUS      = 160; // STMicroelectronics 64bit VLIW Data Signal Processor
constexpr Elf_Half EM_CYPRESS_M8C     = 161; // Cypress M8C microprocessor
constexpr Elf_Half EM_R32C            = 162; // Renesas R32C series microprocessors
constexpr Elf_Half EM_TRIMEDIA        = 163; // NXP Semiconductors TriMedia architecture family
constexpr Elf_Half EM_QDSP6           = 164; // QUALCOMM DSP6 Processor
constexpr Elf_Half EM_8051            = 165; // Intel 8051 and variants
constexpr Elf_Half EM_STXP7X          = 166; // STMicroelectronics STxP7x family
constexpr Elf_Half EM_NDS32           = 167; // Andes Technology embedded RISC processor family
constexpr Elf_Half EM_ECOG1           = 168; // Cyan Technology eCOG1X family
constexpr Elf_Half EM_ECOG1X          = 168; // Cyan Technology eCOG1X family
constexpr Elf_Half EM_MAXQ30          = 169; // Dallas Semiconductor MAXQ30 Core Micro-controllers
constexpr Elf_Half EM_XIMO16          = 170; // New Japan Radio (NJR) 16-bit DSP Processor
constexpr Elf_Half EM_MANIK           = 171; // M2000 Reconfigurable RISC Microprocessor
constexpr Elf_Half EM_CRAYNV2         = 172; // Cray Inc. NV2 vector architecture
constexpr Elf_Half EM_RX              = 173; // Renesas RX family
constexpr Elf_Half EM_METAG           = 174; // Imagination Technologies META processor architecture
constexpr Elf_Half EM_MCST_ELBRUS     = 175; // MCST Elbrus general purpose hardware architecture
constexpr Elf_Half EM_ECOG16          = 176; // Cyan Technology eCOG16 family
constexpr Elf_Half EM_CR16            = 177; // National Semiconductor CompactRISC 16-bit processor
constexpr Elf_Half EM_ETPU            = 178; // Freescale Extended Time Processing Unit
constexpr Elf_Half EM_SLE9X           = 179; // Infineon Technologies SLE9X core
constexpr Elf_Half EM_L1OM            = 180; // Intel L1OM
constexpr Elf_Half EM_INTEL181        = 181; // Reserved by Intel
constexpr Elf_Half EM_INTEL182        = 182; // Reserved by Intel
constexpr Elf_Half EM_AARCH64         = 183; // ARM AArch64
constexpr Elf_Half EM_res184          = 184; // Reserved by ARM
constexpr Elf_Half EM_AVR32           = 185; // Atmel Corporation 32-bit microprocessor family
constexpr Elf_Half EM_STM8            = 186; // STMicroeletronics STM8 8-bit microcontroller
constexpr Elf_Half EM_TILE64          = 187; // Tilera TILE64 multicore architecture family
constexpr Elf_Half EM_TILEPRO         = 188; // Tilera TILEPro multicore architecture family
constexpr Elf_Half EM_MICROBLAZE      = 189; // Xilinx MicroBlaze 32-bit RISC soft processor core
constexpr Elf_Half EM_CUDA            = 190; // NVIDIA CUDA architecture
constexpr Elf_Half EM_TILEGX          = 191; // Tilera TILE-Gx multicore architecture family
constexpr Elf_Half EM_CLOUDSHIELD     = 192; // CloudShield architecture family
constexpr Elf_Half EM_COREA_1ST       = 193; // KIPO-KAIST Core-A 1st generation processor family
constexpr Elf_Half EM_COREA_2ND       = 194; // KIPO-KAIST Core-A 2nd generation processor family
constexpr Elf_Half EM_ARC_COMPACT2    = 195; // Synopsys ARCompact V2
constexpr Elf_Half EM_OPEN8           = 196; // Open8 8-bit RISC soft processor core
constexpr Elf_Half EM_RL78            = 197; // Renesas RL78 family
constexpr Elf_Half EM_VIDEOCORE5      = 198; // Broadcom VideoCore V processor
constexpr Elf_Half EM_78KOR           = 199; // Renesas 78KOR family
constexpr Elf_Half EM_56800EX         = 200; // Freescale 56800EX Digital Signal Controller (DSC)
constexpr Elf_Half EM_BA1             = 201; // Beyond BA1 CPU architecture
constexpr Elf_Half EM_BA2             = 202; // Beyond BA2 CPU architecture
constexpr Elf_Half EM_XCORE           = 203; // XMOS xCORE processor family
constexpr Elf_Half EM_MCHP_PIC        = 204; // Microchip 8-bit PIC(r) family
constexpr Elf_Half EM_INTEL205        = 205; // Reserved by Intel
constexpr Elf_Half EM_INTEL206        = 206; // Reserved by Intel
constexpr Elf_Half EM_INTEL207        = 207; // Reserved by Intel
constexpr Elf_Half EM_INTEL208        = 208; // Reserved by Intel
constexpr Elf_Half EM_INTEL209        = 209; // Reserved by Intel
constexpr Elf_Half EM_KM32            = 210; // KM211 KM32 32-bit processor
constexpr Elf_Half EM_KMX32           = 211; // KM211 KMX32 32-bit processor
constexpr Elf_Half EM_KMX16           = 212; // KM211 KMX16 16-bit processor
constexpr Elf_Half EM_KMX8            = 213; // KM211 KMX8 8-bit processor
constexpr Elf_Half EM_KVARC           = 214; // KM211 KVARC processor
constexpr Elf_Half EM_CDP             = 215; // Paneve CDP architecture family
constexpr Elf_Half EM_COGE            = 216; // Cognitive Smart Memory Processor
constexpr Elf_Half EM_COOL            = 217; // iCelero CoolEngine
constexpr Elf_Half EM_NORC            = 218; // Nanoradio Optimized RISC
constexpr Elf_Half EM_CSR_KALIMBA     = 219; // CSR Kalimba architecture family
constexpr Elf_Half EM_Z80             = 220; // Zilog Z80
constexpr Elf_Half EM_VISIUM          = 221; // Controls and Data Services VISIUMcore processor
constexpr Elf_Half EM_FT32            = 222; // FTDI Chip FT32 high performance 32-bit RISC architecture
constexpr Elf_Half EM_MOXIE           = 223; // Moxie processor family
constexpr Elf_Half EM_AMDGPU          = 224; // AMD GPU architecture
constexpr Elf_Half EM_RISCV           = 243; // RISC-V
constexpr Elf_Half EM_LANAI           = 244; // Lanai processor
constexpr Elf_Half EM_CEVA            = 245; // CEVA Processor Architecture Family
constexpr Elf_Half EM_CEVA_X2         = 246; // CEVA X2 Processor Family
constexpr Elf_Half EM_BPF             = 247; // Linux BPF  in-kernel virtual machine
constexpr Elf_Half EM_GRAPHCORE_IPU   = 248; // Graphcore Intelligent Processing Unit
constexpr Elf_Half EM_IMG1            = 249; // Imagination Technologies
constexpr Elf_Half EM_NFP             = 250; // Netronome Flow Processor (P)
constexpr Elf_Half EM_CSKY            = 252; // C-SKY processor family
constexpr Elf_Half EM_ARC_COMPACT3_64 = 253; // Synopsys ARCv2.3 64-bit
constexpr Elf_Half EM_MCS6502         = 254; // MOS Technology MCS 6502 processor
constexpr Elf_Half EM_ARC_COMPACT3    = 255; // Synopsys ARCv2.3 32-bit
constexpr Elf_Half EM_KVX             = 256; // Kalray VLIW core of the MPPA processor family
constexpr Elf_Half EM_65816           = 257; // WDC 65816/65C816
constexpr Elf_Half EM_LOONGARCH       = 258; // Loongson Loongarch
constexpr Elf_Half EM_KF32            = 259; // ChipON KungFu32

constexpr Elf_Half EM_MT                = 0x2530; // Morpho Techologies MT processor
constexpr Elf_Half EM_ALPHA             = 0x9026; // Alpha
constexpr Elf_Half EM_WEBASSEMBLY       = 0x4157; // Web Assembly
constexpr Elf_Half EM_DLX               = 0x5aa5; // OpenDLX
constexpr Elf_Half EM_XSTORMY16         = 0xad45; // Sanyo XStormy16 CPU core
constexpr Elf_Half EM_IQ2000            = 0xFEBA; // Vitesse IQ2000
constexpr Elf_Half EM_M32C_OLD          = 0xFEB;
constexpr Elf_Half EM_NIOS32            = 0xFEBB; // Altera Nios
constexpr Elf_Half EM_CYGNUS_MEP        = 0xF00D; // Toshiba MeP Media Engine
constexpr Elf_Half EM_ADAPTEVA_EPIPHANY = 0x1223; // Adapteva EPIPHANY
constexpr Elf_Half EM_CYGNUS_FRV        = 0x5441; // Fujitsu FR-V
constexpr Elf_Half EM_S12Z              = 0x4DEF; // Freescale S12Z
// clang-format on

// File version
constexpr unsigned char EV_NONE    = 0;
constexpr unsigned char EV_CURRENT = 1;

// Identification index
constexpr unsigned char EI_MAG0       = 0;
constexpr unsigned char EI_MAG1       = 1;
constexpr unsigned char EI_MAG2       = 2;
constexpr unsigned char EI_MAG3       = 3;
constexpr unsigned char EI_CLASS      = 4;
constexpr unsigned char EI_DATA       = 5;
constexpr unsigned char EI_VERSION    = 6;
constexpr unsigned char EI_OSABI      = 7;
constexpr unsigned char EI_ABIVERSION = 8;
constexpr unsigned char EI_PAD        = 9;
constexpr unsigned char EI_NIDENT     = 16;

// Magic number
constexpr unsigned char ELFMAG0 = 0x7F;
constexpr unsigned char ELFMAG1 = 'E';
constexpr unsigned char ELFMAG2 = 'L';
constexpr unsigned char ELFMAG3 = 'F';

// File class
constexpr unsigned char ELFCLASSNONE = 0;
constexpr unsigned char ELFCLASS32   = 1;
constexpr unsigned char ELFCLASS64   = 2;

// Encoding
constexpr unsigned char ELFDATANONE = 0;
constexpr unsigned char ELFDATA2LSB = 1;
constexpr unsigned char ELFDATA2MSB = 2;

// clang-format off
// OS extensions
constexpr unsigned char ELFOSABI_NONE    = 0;  // No extensions or unspecified
constexpr unsigned char ELFOSABI_HPUX    = 1;  // Hewlett-Packard HP-UX
constexpr unsigned char ELFOSABI_NETBSD  = 2;  // NetBSD
constexpr unsigned char ELFOSABI_LINUX   = 3;  // Linux
constexpr unsigned char ELFOSABI_HURD    = 4;  // GNU Hurd
constexpr unsigned char ELFOSABI_SOLARIS = 6;  // Sun Solaris
constexpr unsigned char ELFOSABI_AIX     = 7;  // AIX
constexpr unsigned char ELFOSABI_IRIX    = 8;  // IRIX
constexpr unsigned char ELFOSABI_FREEBSD = 9;  // FreeBSD
constexpr unsigned char ELFOSABI_TRU64   = 10; // Compaq TRU64 UNIX
constexpr unsigned char ELFOSABI_MODESTO = 11; // Novell Modesto
constexpr unsigned char ELFOSABI_OPENBSD = 12; // Open BSD
constexpr unsigned char ELFOSABI_OPENVMS = 13; // Open VMS
constexpr unsigned char ELFOSABI_NSK     = 14; // Hewlett-Packard Non-Stop Kernel
constexpr unsigned char ELFOSABI_AROS    = 15; // Amiga Research OS
constexpr unsigned char ELFOSABI_FENIXOS = 16; // The FenixOS highly scalable multi-core OS
constexpr unsigned char ELFOSABI_NUXI    = 17; // Nuxi CloudABI
constexpr unsigned char ELFOSABI_OPENVOS = 18; // Stratus Technologies OpenVOS
constexpr unsigned char ELFOSABI_ARM     = 97; // ARM
constexpr unsigned char ELFOSABI_STANDALONE	= 255; // Standalone (embedded) application

// 64-255 Architecture-specific value range
// AMDGPU OS for HSA compatible compute kernels
constexpr unsigned char ELFOSABI_AMDGPU_HSA = 64;
// AMDGPU OS for AMD PAL compatible graphics
// shaders and compute kernels
constexpr unsigned char ELFOSABI_AMDGPU_PAL = 65;
// AMDGPU OS for Mesa3D compatible graphics
// shaders and compute kernels
constexpr unsigned char ELFOSABI_AMDGPU_MESA3D = 66;
// clang-format on

constexpr unsigned char ELFABIVERSION_AMDGPU_HSA_V2 = 0;
constexpr unsigned char ELFABIVERSION_AMDGPU_HSA_V3 = 1;
constexpr unsigned char ELFABIVERSION_AMDGPU_HSA_V4 = 2;

// AMDGPU specific e_flags
constexpr Elf_Word EF_AMDGPU_MACH = 0x0ff; // AMDGPU processor selection mask.
// Indicates if the XNACK target feature is
// enabled for all code contained in the ELF.
constexpr Elf_Word EF_AMDGPU_XNACK = 0x100;

constexpr Elf_Word EF_AMDGPU_FEATURE_XNACK_V2               = 0x01;
constexpr Elf_Word EF_AMDGPU_FEATURE_TRAP_HANDLER_V2        = 0x02;
constexpr Elf_Word EF_AMDGPU_FEATURE_XNACK_V3               = 0x100;
constexpr Elf_Word EF_AMDGPU_FEATURE_SRAMECC_V3             = 0x200;
constexpr Elf_Word EF_AMDGPU_FEATURE_XNACK_V4               = 0x300;
constexpr Elf_Word EF_AMDGPU_FEATURE_XNACK_UNSUPPORTED_V4   = 0x000;
constexpr Elf_Word EF_AMDGPU_FEATURE_XNACK_ANY_V4           = 0x100;
constexpr Elf_Word EF_AMDGPU_FEATURE_XNACK_OFF_V4           = 0x200;
constexpr Elf_Word EF_AMDGPU_FEATURE_XNACK_ON_V4            = 0x300;
constexpr Elf_Word EF_AMDGPU_FEATURE_SRAMECC_V4             = 0xc00;
constexpr Elf_Word EF_AMDGPU_FEATURE_SRAMECC_UNSUPPORTED_V4 = 0x000;
constexpr Elf_Word EF_AMDGPU_FEATURE_SRAMECC_ANY_V4         = 0x400;
constexpr Elf_Word EF_AMDGPU_FEATURE_SRAMECC_OFF_V4         = 0x800;
constexpr Elf_Word EF_AMDGPU_FEATURE_SRAMECC_ON_V4          = 0xc00;

// AMDGPU processors
constexpr Elf_Word EF_AMDGPU_MACH_NONE       = 0x000; // Unspecified processor.
constexpr Elf_Word EF_AMDGPU_MACH_R600_R600  = 0x001;
constexpr Elf_Word EF_AMDGPU_MACH_R600_R630  = 0x002;
constexpr Elf_Word EF_AMDGPU_MACH_R600_RS880 = 0x003;
constexpr Elf_Word EF_AMDGPU_MACH_R600_RV670 = 0x004;
constexpr Elf_Word EF_AMDGPU_MACH_R600_RV710 = 0x005;
constexpr Elf_Word EF_AMDGPU_MACH_R600_RV730 = 0x006;
constexpr Elf_Word EF_AMDGPU_MACH_R600_RV770 = 0x007;
constexpr Elf_Word EF_AMDGPU_MACH_R600_CEDAR = 0x008;
constexpr Elf_Word EF_AMDGPU_MACH_R600_CYPRESS        = 0x009;
constexpr Elf_Word EF_AMDGPU_MACH_R600_JUNIPER        = 0x00a;
constexpr Elf_Word EF_AMDGPU_MACH_R600_REDWOOD        = 0x00b;
constexpr Elf_Word EF_AMDGPU_MACH_R600_SUMO           = 0x00c;
constexpr Elf_Word EF_AMDGPU_MACH_R600_BARTS          = 0x00d;
constexpr Elf_Word EF_AMDGPU_MACH_R600_CAICOS         = 0x00e;
constexpr Elf_Word EF_AMDGPU_MACH_R600_CAYMAN         = 0x00f;
constexpr Elf_Word EF_AMDGPU_MACH_R600_TURKS          = 0x010;
constexpr Elf_Word EF_AMDGPU_MACH_R600_RESERVED_FIRST = 0x011;
constexpr Elf_Word EF_AMDGPU_MACH_R600_RESERVED_LAST  = 0x01f;
constexpr Elf_Word EF_AMDGPU_MACH_R600_FIRST = EF_AMDGPU_MACH_R600_R600;
constexpr Elf_Word EF_AMDGPU_MACH_R600_LAST  = EF_AMDGPU_MACH_R600_TURKS;

// AMDGCN-based processors.
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX600        = 0x020;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX601        = 0x021;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX700        = 0x022;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX701        = 0x023;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX702        = 0x024;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX703        = 0x025;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX704        = 0x026;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_RESERVED_0X27 = 0x027;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX801        = 0x028;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX802        = 0x029;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX803        = 0x02a;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX810        = 0x02b;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX900        = 0x02c;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX902        = 0x02d;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX904        = 0x02e;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX906        = 0x02f;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX908        = 0x030;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX909        = 0x031;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX90C        = 0x032;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX1010       = 0x033;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX1011       = 0x034;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX1012       = 0x035;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX1030       = 0x036;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX1031       = 0x037;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX1032       = 0x038;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX1033       = 0x039;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX602        = 0x03a;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX705        = 0x03b;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX805        = 0x03c;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_RESERVED_0X3D = 0x03d;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX1034       = 0x03e;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX90A        = 0x03f;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_RESERVED_0X40 = 0x040;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_RESERVED_0X41 = 0x041;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_GFX1013       = 0x042;
// First/last AMDGCN-based processors.
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_FIRST = EF_AMDGPU_MACH_AMDGCN_GFX600;
constexpr Elf_Word EF_AMDGPU_MACH_AMDGCN_LAST  = EF_AMDGPU_MACH_AMDGCN_GFX1013;

/////////////////////
// Sections constants

// Section indexes
constexpr Elf_Word SHN_UNDEF     = 0;
constexpr Elf_Word SHN_LORESERVE = 0xFF00;
constexpr Elf_Word SHN_LOPROC    = 0xFF00;
constexpr Elf_Word SHN_HIPROC    = 0xFF1F;
constexpr Elf_Word SHN_LOOS      = 0xFF20;
constexpr Elf_Word SHN_HIOS      = 0xFF3F;
constexpr Elf_Word SHN_ABS       = 0xFFF1;
constexpr Elf_Word SHN_COMMON    = 0xFFF2;
constexpr Elf_Word SHN_XINDEX    = 0xFFFF;
constexpr Elf_Word SHN_HIRESERVE = 0xFFFF;

// Section types
constexpr Elf_Word SHT_NULL               = 0;
constexpr Elf_Word SHT_PROGBITS           = 1;
constexpr Elf_Word SHT_SYMTAB             = 2;
constexpr Elf_Word SHT_STRTAB             = 3;
constexpr Elf_Word SHT_RELA               = 4;
constexpr Elf_Word SHT_HASH               = 5;
constexpr Elf_Word SHT_DYNAMIC            = 6;
constexpr Elf_Word SHT_NOTE               = 7;
constexpr Elf_Word SHT_NOBITS             = 8;
constexpr Elf_Word SHT_REL                = 9;
constexpr Elf_Word SHT_SHLIB              = 10;
constexpr Elf_Word SHT_DYNSYM             = 11;
constexpr Elf_Word SHT_INIT_ARRAY         = 14;
constexpr Elf_Word SHT_FINI_ARRAY         = 15;
constexpr Elf_Word SHT_PREINIT_ARRAY      = 16;
constexpr Elf_Word SHT_GROUP              = 17;
constexpr Elf_Word SHT_SYMTAB_SHNDX       = 18;
constexpr Elf_Word SHT_GNU_ATTRIBUTES     = 0x6ffffff5;
constexpr Elf_Word SHT_GNU_HASH           = 0x6ffffff6;
constexpr Elf_Word SHT_GNU_LIBLIST        = 0x6ffffff7;
constexpr Elf_Word SHT_CHECKSUM           = 0x6ffffff8;
constexpr Elf_Word SHT_LOSUNW             = 0x6ffffffa;
constexpr Elf_Word SHT_SUNW_move          = 0x6ffffffa;
constexpr Elf_Word SHT_SUNW_COMDAT        = 0x6ffffffb;
constexpr Elf_Word SHT_SUNW_syminfo       = 0x6ffffffc;
constexpr Elf_Word SHT_GNU_verdef         = 0x6ffffffd;
constexpr Elf_Word SHT_GNU_verneed        = 0x6ffffffe;
constexpr Elf_Word SHT_GNU_versym         = 0x6fffffff;
constexpr Elf_Word SHT_LOOS               = 0x60000000;
constexpr Elf_Word SHT_HIOS               = 0x6fffffff;
constexpr Elf_Word SHT_LOPROC             = 0x70000000;
constexpr Elf_Word SHT_ARM_EXIDX          = 0x70000001;
constexpr Elf_Word SHT_ARM_PREEMPTMAP     = 0x70000002;
constexpr Elf_Word SHT_ARM_ATTRIBUTES     = 0x70000003;
constexpr Elf_Word SHT_ARM_DEBUGOVERLAY   = 0x70000004;
constexpr Elf_Word SHT_ARM_OVERLAYSECTION = 0x70000005;
constexpr Elf_Word SHT_HIPROC             = 0x7FFFFFFF;
constexpr Elf_Word SHT_LOUSER             = 0x80000000;
// Used by Nintendo Wii U
constexpr Elf_Word SHT_RPL_EXPORTS  = 0x80000001;
constexpr Elf_Word SHT_RPL_IMPORTS  = 0x80000002;
constexpr Elf_Word SHT_RPL_CRCS     = 0x80000003;
constexpr Elf_Word SHT_RPL_FILEINFO = 0x80000004;
constexpr Elf_Word SHT_HIUSER       = 0xFFFFFFFF;

// Section attribute flags
constexpr Elf_Xword SHF_WRITE            = 0x1;
constexpr Elf_Xword SHF_ALLOC            = 0x2;
constexpr Elf_Xword SHF_EXECINSTR        = 0x4;
constexpr Elf_Xword SHF_MERGE            = 0x10;
constexpr Elf_Xword SHF_STRINGS          = 0x20;
constexpr Elf_Xword SHF_INFO_LINK        = 0x40;
constexpr Elf_Xword SHF_LINK_ORDER       = 0x80;
constexpr Elf_Xword SHF_OS_NONCONFORMING = 0x100;
constexpr Elf_Xword SHF_GROUP            = 0x200;
constexpr Elf_Xword SHF_TLS              = 0x400;
constexpr Elf_Xword SHF_COMPRESSED       = 0x800;
constexpr Elf_Xword SHF_GNU_RETAIN       = 0x200000;
constexpr Elf_Xword SHF_GNU_MBIND        = 0x01000000;
// flag used in Nintendo RPX/RPL to indicate section data is compressed
constexpr Elf_Xword SHF_RPX_DEFLATE = 0x08000000;
constexpr Elf_Xword SHF_MASKOS      = 0x0FF00000;
constexpr Elf_Xword SHF_MIPS_GPREL  = 0x10000000;
constexpr Elf_Xword SHF_ORDERED     = 0x40000000;
constexpr Elf_Xword SHF_EXCLUDE     = 0x80000000;
constexpr Elf_Xword SHF_MASKPROC    = 0xF0000000;

// Section group flags
constexpr Elf_Word GRP_COMDAT   = 0x1;
constexpr Elf_Word GRP_MASKOS   = 0x0ff00000;
constexpr Elf_Word GRP_MASKPROC = 0xf0000000;

// Symbol binding
constexpr unsigned char STB_LOCAL    = 0;
constexpr unsigned char STB_GLOBAL   = 1;
constexpr unsigned char STB_WEAK     = 2;
constexpr unsigned char STB_LOOS     = 10;
constexpr unsigned char STB_HIOS     = 12;
constexpr unsigned char STB_MULTIDEF = 13;
constexpr unsigned char STB_LOPROC   = 13;
constexpr unsigned char STB_HIPROC   = 15;

// Values of note segment descriptor types for core files
constexpr Elf_Word NT_PRSTATUS   = 1; // Contains copy of prstatus struct
constexpr Elf_Word NT_FPREGSET   = 2; // Contains copy of fpregset struct
constexpr Elf_Word NT_PRPSINFO   = 3; // Contains copy of prpsinfo struct
constexpr Elf_Word NT_TASKSTRUCT = 4; // Contains copy of task struct
constexpr Elf_Word NT_AUXV       = 6; // Contains copy of Elfxx_auxv_t
constexpr Elf_Word NT_SIGINFO    = 0x53494749; // Fields of siginfo_t.
constexpr Elf_Word NT_FILE       = 0x46494c45; // Description of mapped files.

// Note segments for core files on dir-style procfs systems.
constexpr Elf_Word NT_PSTATUS      = 10; // Has a struct pstatus
constexpr Elf_Word NT_FPREGS       = 12; // Has a struct fpregset
constexpr Elf_Word NT_PSINFO       = 13; // Has a struct psinfo
constexpr Elf_Word NT_LWPSTATUS    = 16; // Has a struct lwpstatus_t
constexpr Elf_Word NT_LWPSINFO     = 17; // Has a struct lwpsinfo_t
constexpr Elf_Word NT_WIN32PSTATUS = 18; // Has a struct win32_pstatus

// clang-format off

// Note name must be "LINUX"    
constexpr Elf_Word NT_PRXFPREG             = 0x46e62b7f; // Contains a user_xfpregs_struct
constexpr Elf_Word NT_PPC_VMX              = 0x100;      // PowerPC Altivec/VMX registers
constexpr Elf_Word NT_PPC_VSX              = 0x102;      // PowerPC VSX registers
constexpr Elf_Word NT_PPC_TAR              = 0x103;      // PowerPC Target Address Register
constexpr Elf_Word NT_PPC_PPR              = 0x104;      // PowerPC Program Priority Register
constexpr Elf_Word NT_PPC_DSCR             = 0x105;      // PowerPC Data Stream Control Register
constexpr Elf_Word NT_PPC_EBB              = 0x106;      // PowerPC Event Based Branch Registers
constexpr Elf_Word NT_PPC_PMU              = 0x107;      // PowerPC Performance Monitor Registers
constexpr Elf_Word NT_PPC_TM_CGPR          = 0x108;      // PowerPC TM checkpointed GPR Registers
constexpr Elf_Word NT_PPC_TM_CFPR          = 0x109;      // PowerPC TM checkpointed FPR Registers
constexpr Elf_Word NT_PPC_TM_CVMX          = 0x10a;      // PowerPC TM checkpointed VMX Registers
constexpr Elf_Word NT_PPC_TM_CVSX          = 0x10b;      // PowerPC TM checkpointed VSX Registers
constexpr Elf_Word NT_PPC_TM_SPR           = 0x10c;      // PowerPC TM Special Purpose Registers
constexpr Elf_Word NT_PPC_TM_CTAR          = 0x10d;      // PowerPC TM checkpointed TAR
constexpr Elf_Word NT_PPC_TM_CPPR          = 0x10e;      // PowerPC TM checkpointed PPR
constexpr Elf_Word NT_PPC_TM_CDSCR         = 0x10f;      // PowerPC TM checkpointed Data SCR
constexpr Elf_Word NT_386_TLS              = 0x200;      // x86 TLS information
constexpr Elf_Word NT_386_IOPERM           = 0x201;      // x86 io permissions
constexpr Elf_Word NT_X86_XSTATE           = 0x202;      // x86 XSAVE extended state
constexpr Elf_Word NT_X86_CET              = 0x203;      // x86 CET state.
constexpr Elf_Word NT_S390_HIGH_GPRS       = 0x300;      // S/390 upper halves of GPRs
constexpr Elf_Word NT_S390_TIMER           = 0x301;      // S390 timer
constexpr Elf_Word NT_S390_TODCMP          = 0x302;      // S390 TOD clock comparator
constexpr Elf_Word NT_S390_TODPREG         = 0x303;      // S390 TOD programmable register
constexpr Elf_Word NT_S390_CTRS            = 0x304;      // S390 control registers
constexpr Elf_Word NT_S390_PREFIX          = 0x305;      // S390 prefix register
constexpr Elf_Word NT_S390_LAST_BREAK      = 0x306;      // S390 breaking event address
constexpr Elf_Word NT_S390_SYSTEM_CALL     = 0x307;      // S390 system call restart data
constexpr Elf_Word NT_S390_TDB             = 0x308;      // S390 transaction diagnostic block
constexpr Elf_Word NT_S390_VXRS_LOW        = 0x309;      // S390 vector registers 0-15 upper half
constexpr Elf_Word NT_S390_VXRS_HIGH       = 0x30a;      // S390 vector registers 16-31
constexpr Elf_Word NT_S390_GS_CB           = 0x30b;      // s390 guarded storage registers
constexpr Elf_Word NT_S390_GS_BC           = 0x30c;      // s390 guarded storage broadcast control block
constexpr Elf_Word NT_ARM_VFP              = 0x400;      // ARM VFP registers
constexpr Elf_Word NT_ARM_TLS              = 0x401;      // AArch TLS registers
constexpr Elf_Word NT_ARM_HW_BREAK         = 0x402;      // AArch hardware breakpoint registers
constexpr Elf_Word NT_ARM_HW_WATCH         = 0x403;      // AArch hardware watchpoint registers
constexpr Elf_Word NT_ARM_SVE              = 0x405;      // AArch SVE registers.
constexpr Elf_Word NT_ARM_PAC_MASK         = 0x406;      // AArch pointer authentication code masks
constexpr Elf_Word NT_ARM_PACA_KEYS        = 0x407;      // ARM pointer authentication address keys
constexpr Elf_Word NT_ARM_PACG_KEYS        = 0x408;      // ARM pointer authentication generic keys
constexpr Elf_Word NT_ARM_TAGGED_ADDR_CTRL = 0x409;      // AArch64 tagged address control (prctl())
constexpr Elf_Word NT_ARM_PAC_ENABLED_KEYS = 0x40a;      // AArch64 pointer authentication enabled keys (prctl())
constexpr Elf_Word NT_ARC_V2               = 0x600;      // ARC HS accumulator/extra registers.
constexpr Elf_Word NT_LARCH_CPUCFG         = 0xa00;      // LoongArch CPU config registers
constexpr Elf_Word NT_LARCH_CSR            = 0xa01;      // LoongArch Control State Registers
constexpr Elf_Word NT_LARCH_LSX            = 0xa02;      // LoongArch SIMD eXtension registers
constexpr Elf_Word NT_LARCH_LASX           = 0xa03;      // LoongArch Advanced SIMD eXtension registers
constexpr Elf_Word NT_RISCV_CSR            = 0x900;      // RISC-V Control and Status Registers

// Note name must be "CORE"
constexpr Elf_Word NT_LARCH_LBT = 0xa04; // LoongArch Binary Translation registers

/* The range 0xff000000 to 0xffffffff is set aside for notes that don't
   originate from any particular operating system.  */
constexpr Elf_Word NT_GDB_TDESC = 0xff000000; // Contains copy of GDB's target description XML.
constexpr Elf_Word NT_MEMTAG    = 0xff000001; // Contains a copy of the memory tags.
/* ARM-specific NT_MEMTAG types.  */
constexpr Elf_Word NT_MEMTAG_TYPE_AARCH_MTE = 0x400; // MTE memory tags for AArch64.

constexpr Elf_Word NT_STAPSDT = 3; // Note segment for SystemTap probes.

// Note name is "FreeBSD"
constexpr Elf_Word NT_FREEBSD_THRMISC            = 7;  // Thread miscellaneous info.
constexpr Elf_Word NT_FREEBSD_PROCSTAT_PROC      = 8;  // Procstat proc data.
constexpr Elf_Word NT_FREEBSD_PROCSTAT_FILES     = 9;  // Procstat files data.
constexpr Elf_Word NT_FREEBSD_PROCSTAT_VMMAP     = 10; // Procstat vmmap data.
constexpr Elf_Word NT_FREEBSD_PROCSTAT_GROUPS    = 11; // Procstat groups data.
constexpr Elf_Word NT_FREEBSD_PROCSTAT_UMASK     = 12; // Procstat umask data.
constexpr Elf_Word NT_FREEBSD_PROCSTAT_RLIMIT    = 13; // Procstat rlimit data.
constexpr Elf_Word NT_FREEBSD_PROCSTAT_OSREL     = 14; // Procstat osreldate data.
constexpr Elf_Word NT_FREEBSD_PROCSTAT_PSSTRINGS = 15; // Procstat ps_strings data.
constexpr Elf_Word NT_FREEBSD_PROCSTAT_AUXV      = 16; // Procstat auxv data.
constexpr Elf_Word NT_FREEBSD_PTLWPINFO          = 17; // Thread ptrace miscellaneous info.

// Note name must start with  "NetBSD-CORE"
constexpr Elf_Word NT_NETBSDCORE_PROCINFO  = 1;  // Has a struct procinfo
constexpr Elf_Word NT_NETBSDCORE_AUXV      = 2;  // Has auxv data
constexpr Elf_Word NT_NETBSDCORE_LWPSTATUS = 24; // Has LWPSTATUS data
constexpr Elf_Word NT_NETBSDCORE_FIRSTMACH = 32; // start of machdep note types

// Note name is "OpenBSD"
constexpr Elf_Word NT_OPENBSD_PROCINFO = 10;
constexpr Elf_Word NT_OPENBSD_AUXV     = 11;
constexpr Elf_Word NT_OPENBSD_REGS     = 20;
constexpr Elf_Word NT_OPENBSD_FPREGS   = 21;
constexpr Elf_Word NT_OPENBSD_XFPREGS  = 22;
constexpr Elf_Word NT_OPENBSD_WCOOKIE  = 23;

// Note name must start with "SPU"
constexpr Elf_Word NT_SPU = 1;

// Values of note segment descriptor types for object files
constexpr Elf_Word NT_VERSION    = 1; // Contains a version string.
constexpr Elf_Word NT_ARCH       = 2; // Contains an architecture string.
constexpr Elf_Word NT_GO_BUILDID = 4; // Contains GO buildid data.

// Values for notes in non-core files using name "GNU"
constexpr Elf_Word NT_GNU_ABI_TAG         = 1;
constexpr Elf_Word NT_GNU_HWCAP           = 2; // Used by ld.so and kernel vDSO.
constexpr Elf_Word NT_GNU_BUILD_ID        = 3; // Generated by ld --build-id.
constexpr Elf_Word NT_GNU_GOLD_VERSION    = 4; // Generated by gold.
constexpr Elf_Word NT_GNU_PROPERTY_TYPE_0 = 5; // Generated by gcc.
// clang-format on

constexpr Elf_Word NT_GNU_BUILD_ATTRIBUTE_OPEN = 0x100;
constexpr Elf_Word NT_GNU_BUILD_ATTRIBUTE_FUNC = 0x101;

// Symbol types
constexpr Elf_Word STT_NOTYPE            = 0;
constexpr Elf_Word STT_OBJECT            = 1;
constexpr Elf_Word STT_FUNC              = 2;
constexpr Elf_Word STT_SECTION           = 3;
constexpr Elf_Word STT_FILE              = 4;
constexpr Elf_Word STT_COMMON            = 5;
constexpr Elf_Word STT_TLS               = 6;
constexpr Elf_Word STT_LOOS              = 10;
constexpr Elf_Word STT_AMDGPU_HSA_KERNEL = 10;
constexpr Elf_Word STT_HIOS              = 12;
constexpr Elf_Word STT_LOPROC            = 13;
constexpr Elf_Word STT_HIPROC            = 15;

// Symbol visibility
constexpr unsigned char STV_DEFAULT   = 0;
constexpr unsigned char STV_INTERNAL  = 1;
constexpr unsigned char STV_HIDDEN    = 2;
constexpr unsigned char STV_PROTECTED = 3;

// Undefined name
constexpr Elf_Word STN_UNDEF = 0;

// Relocation types
//   X86
constexpr unsigned R_386_NONE               = 0;
constexpr unsigned R_X86_64_NONE            = 0;
constexpr unsigned R_AMDGPU_NONE            = 0;
constexpr unsigned R_386_32                 = 1;
constexpr unsigned R_X86_64_64              = 1;
constexpr unsigned R_AMDGPU_ABS32_LO        = 1;
constexpr unsigned R_386_PC32               = 2;
constexpr unsigned R_X86_64_PC32            = 2;
constexpr unsigned R_AMDGPU_ABS32_HI        = 2;
constexpr unsigned R_386_GOT32              = 3;
constexpr unsigned R_X86_64_GOT32           = 3;
constexpr unsigned R_AMDGPU_ABS64           = 3;
constexpr unsigned R_386_PLT32              = 4;
constexpr unsigned R_X86_64_PLT32           = 4;
constexpr unsigned R_AMDGPU_REL32           = 4;
constexpr unsigned R_386_COPY               = 5;
constexpr unsigned R_X86_64_COPY            = 5;
constexpr unsigned R_AMDGPU_REL64           = 5;
constexpr unsigned R_386_GLOB_DAT           = 6;
constexpr unsigned R_X86_64_GLOB_DAT        = 6;
constexpr unsigned R_AMDGPU_ABS32           = 6;
constexpr unsigned R_386_JMP_SLOT           = 7;
constexpr unsigned R_X86_64_JUMP_SLOT       = 7;
constexpr unsigned R_AMDGPU_GOTPCREL        = 7;
constexpr unsigned R_386_RELATIVE           = 8;
constexpr unsigned R_X86_64_RELATIVE        = 8;
constexpr unsigned R_AMDGPU_GOTPCREL32_LO   = 8;
constexpr unsigned R_386_GOTOFF             = 9;
constexpr unsigned R_X86_64_GOTPCREL        = 9;
constexpr unsigned R_AMDGPU_GOTPCREL32_HI   = 9;
constexpr unsigned R_386_GOTPC              = 10;
constexpr unsigned R_X86_64_32              = 10;
constexpr unsigned R_AMDGPU_REL32_LO        = 10;
constexpr unsigned R_386_32PLT              = 11;
constexpr unsigned R_X86_64_32S             = 11;
constexpr unsigned R_AMDGPU_REL32_HI        = 11;
constexpr unsigned R_X86_64_16              = 12;
constexpr unsigned R_X86_64_PC16            = 13;
constexpr unsigned R_AMDGPU_RELATIVE64      = 13;
constexpr unsigned R_386_TLS_TPOFF          = 14;
constexpr unsigned R_X86_64_8               = 14;
constexpr unsigned R_386_TLS_IE             = 15;
constexpr unsigned R_X86_64_PC8             = 15;
constexpr unsigned R_386_TLS_GOTIE          = 16;
constexpr unsigned R_X86_64_DTPMOD64        = 16;
constexpr unsigned R_386_TLS_LE             = 17;
constexpr unsigned R_X86_64_DTPOFF64        = 17;
constexpr unsigned R_386_TLS_GD             = 18;
constexpr unsigned R_X86_64_TPOFF64         = 18;
constexpr unsigned R_386_TLS_LDM            = 19;
constexpr unsigned R_X86_64_TLSGD           = 19;
constexpr unsigned R_386_16                 = 20;
constexpr unsigned R_X86_64_TLSLD           = 20;
constexpr unsigned R_386_PC16               = 21;
constexpr unsigned R_X86_64_DTPOFF32        = 21;
constexpr unsigned R_386_8                  = 22;
constexpr unsigned R_X86_64_GOTTPOFF        = 22;
constexpr unsigned R_386_PC8                = 23;
constexpr unsigned R_X86_64_TPOFF32         = 23;
constexpr unsigned R_386_TLS_GD_32          = 24;
constexpr unsigned R_X86_64_PC64            = 24;
constexpr unsigned R_386_TLS_GD_PUSH        = 25;
constexpr unsigned R_X86_64_GOTOFF64        = 25;
constexpr unsigned R_386_TLS_GD_CALL        = 26;
constexpr unsigned R_X86_64_GOTPC32         = 26;
constexpr unsigned R_386_TLS_GD_POP         = 27;
constexpr unsigned R_X86_64_GOT64           = 27;
constexpr unsigned R_386_TLS_LDM_32         = 28;
constexpr unsigned R_X86_64_GOTPCREL64      = 28;
constexpr unsigned R_386_TLS_LDM_PUSH       = 29;
constexpr unsigned R_X86_64_GOTPC64         = 29;
constexpr unsigned R_386_TLS_LDM_CALL       = 30;
constexpr unsigned R_X86_64_GOTPLT64        = 30;
constexpr unsigned R_386_TLS_LDM_POP        = 31;
constexpr unsigned R_X86_64_PLTOFF64        = 31;
constexpr unsigned R_386_TLS_LDO_32         = 32;
constexpr unsigned R_386_TLS_IE_32          = 33;
constexpr unsigned R_386_TLS_LE_32          = 34;
constexpr unsigned R_X86_64_GOTPC32_TLSDESC = 34;
constexpr unsigned R_386_TLS_DTPMOD32       = 35;
constexpr unsigned R_X86_64_TLSDESC_CALL    = 35;
constexpr unsigned R_386_TLS_DTPOFF32       = 36;
constexpr unsigned R_X86_64_TLSDESC         = 36;
constexpr unsigned R_386_TLS_TPOFF32        = 37;
constexpr unsigned R_X86_64_IRELATIVE       = 37;
constexpr unsigned R_386_SIZE32             = 38;
constexpr unsigned R_386_TLS_GOTDESC        = 39;
constexpr unsigned R_386_TLS_DESC_CALL      = 40;
constexpr unsigned R_386_TLS_DESC           = 41;
constexpr unsigned R_386_IRELATIVE          = 42;
constexpr unsigned R_386_GOT32X             = 43;
constexpr unsigned R_X86_64_GNU_VTINHERIT   = 250;
constexpr unsigned R_X86_64_GNU_VTENTRY     = 251;
//   AArch64
constexpr unsigned R_AARCH64_NONE                         = 0;
constexpr unsigned R_AARCH64_P32_ABS32                    = 1;
constexpr unsigned R_AARCH64_P32_COPY                     = 180;
constexpr unsigned R_AARCH64_P32_GLOB_DAT                 = 181;
constexpr unsigned R_AARCH64_P32_JUMP_SLOT                = 182;
constexpr unsigned R_AARCH64_P32_RELATIVE                 = 183;
constexpr unsigned R_AARCH64_P32_TLS_DTPMOD               = 184;
constexpr unsigned R_AARCH64_P32_TLS_DTPREL               = 185;
constexpr unsigned R_AARCH64_P32_TLS_TPREL                = 186;
constexpr unsigned R_AARCH64_P32_TLSDESC                  = 187;
constexpr unsigned R_AARCH64_P32_IRELATIVE                = 188;
constexpr unsigned R_AARCH64_ABS64                        = 257;
constexpr unsigned R_AARCH64_ABS32                        = 258;
constexpr unsigned R_AARCH64_ABS16                        = 259;
constexpr unsigned R_AARCH64_PREL64                       = 260;
constexpr unsigned R_AARCH64_PREL32                       = 261;
constexpr unsigned R_AARCH64_PREL16                       = 262;
constexpr unsigned R_AARCH64_MOVW_UABS_G0                 = 263;
constexpr unsigned R_AARCH64_MOVW_UABS_G0_NC              = 264;
constexpr unsigned R_AARCH64_MOVW_UABS_G1                 = 265;
constexpr unsigned R_AARCH64_MOVW_UABS_G1_NC              = 266;
constexpr unsigned R_AARCH64_MOVW_UABS_G2                 = 267;
constexpr unsigned R_AARCH64_MOVW_UABS_G2_NC              = 268;
constexpr unsigned R_AARCH64_MOVW_UABS_G3                 = 269;
constexpr unsigned R_AARCH64_MOVW_SABS_G0                 = 270;
constexpr unsigned R_AARCH64_MOVW_SABS_G1                 = 271;
constexpr unsigned R_AARCH64_MOVW_SABS_G2                 = 272;
constexpr unsigned R_AARCH64_LD_PREL_LO19                 = 273;
constexpr unsigned R_AARCH64_ADR_PREL_LO21                = 274;
constexpr unsigned R_AARCH64_ADR_PREL_PG_HI21             = 275;
constexpr unsigned R_AARCH64_ADR_PREL_PG_HI21_NC          = 276;
constexpr unsigned R_AARCH64_ADD_ABS_LO12_NC              = 277;
constexpr unsigned R_AARCH64_LDST8_ABS_LO12_NC            = 278;
constexpr unsigned R_AARCH64_TSTBR14                      = 279;
constexpr unsigned R_AARCH64_CONDBR19                     = 280;
constexpr unsigned R_AARCH64_JUMP26                       = 282;
constexpr unsigned R_AARCH64_CALL26                       = 283;
constexpr unsigned R_AARCH64_LDST16_ABS_LO12_NC           = 284;
constexpr unsigned R_AARCH64_LDST32_ABS_LO12_NC           = 285;
constexpr unsigned R_AARCH64_LDST64_ABS_LO12_NC           = 286;
constexpr unsigned R_AARCH64_MOVW_PREL_G0                 = 287;
constexpr unsigned R_AARCH64_MOVW_PREL_G0_NC              = 288;
constexpr unsigned R_AARCH64_MOVW_PREL_G1                 = 289;
constexpr unsigned R_AARCH64_MOVW_PREL_G1_NC              = 290;
constexpr unsigned R_AARCH64_MOVW_PREL_G2                 = 291;
constexpr unsigned R_AARCH64_MOVW_PREL_G2_NC              = 292;
constexpr unsigned R_AARCH64_MOVW_PREL_G3                 = 293;
constexpr unsigned R_AARCH64_LDST128_ABS_LO12_NC          = 299;
constexpr unsigned R_AARCH64_MOVW_GOTOFF_G0               = 300;
constexpr unsigned R_AARCH64_MOVW_GOTOFF_G0_NC            = 301;
constexpr unsigned R_AARCH64_MOVW_GOTOFF_G1               = 302;
constexpr unsigned R_AARCH64_MOVW_GOTOFF_G1_NC            = 303;
constexpr unsigned R_AARCH64_MOVW_GOTOFF_G2               = 304;
constexpr unsigned R_AARCH64_MOVW_GOTOFF_G2_NC            = 305;
constexpr unsigned R_AARCH64_MOVW_GOTOFF_G3               = 306;
constexpr unsigned R_AARCH64_GOTREL64                     = 307;
constexpr unsigned R_AARCH64_GOTREL32                     = 308;
constexpr unsigned R_AARCH64_GOT_LD_PREL19                = 309;
constexpr unsigned R_AARCH64_LD64_GOTOFF_LO15             = 310;
constexpr unsigned R_AARCH64_ADR_GOT_PAGE                 = 311;
constexpr unsigned R_AARCH64_LD64_GOT_LO12_NC             = 312;
constexpr unsigned R_AARCH64_LD64_GOTPAGE_LO15            = 313;
constexpr unsigned R_AARCH64_TLSGD_ADR_PREL21             = 512;
constexpr unsigned R_AARCH64_TLSGD_ADR_PAGE21             = 513;
constexpr unsigned R_AARCH64_TLSGD_ADD_LO12_NC            = 514;
constexpr unsigned R_AARCH64_TLSGD_MOVW_G1                = 515;
constexpr unsigned R_AARCH64_TLSGD_MOVW_G0_NC             = 516;
constexpr unsigned R_AARCH64_TLSLD_ADR_PREL21             = 517;
constexpr unsigned R_AARCH64_TLSLD_ADR_PAGE21             = 518;
constexpr unsigned R_AARCH64_TLSLD_ADD_LO12_NC            = 519;
constexpr unsigned R_AARCH64_TLSLD_MOVW_G1                = 520;
constexpr unsigned R_AARCH64_TLSLD_MOVW_G0_NC             = 521;
constexpr unsigned R_AARCH64_TLSLD_LD_PREL19              = 522;
constexpr unsigned R_AARCH64_TLSLD_MOVW_DTPREL_G2         = 523;
constexpr unsigned R_AARCH64_TLSLD_MOVW_DTPREL_G1         = 524;
constexpr unsigned R_AARCH64_TLSLD_MOVW_DTPREL_G1_NC      = 525;
constexpr unsigned R_AARCH64_TLSLD_MOVW_DTPREL_G0         = 526;
constexpr unsigned R_AARCH64_TLSLD_MOVW_DTPREL_G0_NC      = 527;
constexpr unsigned R_AARCH64_TLSLD_ADD_DTPREL_HI12        = 528;
constexpr unsigned R_AARCH64_TLSLD_ADD_DTPREL_LO12        = 529;
constexpr unsigned R_AARCH64_TLSLD_ADD_DTPREL_LO12_NC     = 530;
constexpr unsigned R_AARCH64_TLSLD_LDST8_DTPREL_LO12      = 531;
constexpr unsigned R_AARCH64_TLSLD_LDST8_DTPREL_LO12_NC   = 532;
constexpr unsigned R_AARCH64_TLSLD_LDST16_DTPREL_LO12     = 533;
constexpr unsigned R_AARCH64_TLSLD_LDST16_DTPREL_LO12_NC  = 534;
constexpr unsigned R_AARCH64_TLSLD_LDST32_DTPREL_LO12     = 535;
constexpr unsigned R_AARCH64_TLSLD_LDST32_DTPREL_LO12_NC  = 536;
constexpr unsigned R_AARCH64_TLSLD_LDST64_DTPREL_LO12     = 537;
constexpr unsigned R_AARCH64_TLSLD_LDST64_DTPREL_LO12_NC  = 538;
constexpr unsigned R_AARCH64_TLSIE_MOVW_GOTTPREL_G1       = 539;
constexpr unsigned R_AARCH64_TLSIE_MOVW_GOTTPREL_G0_NC    = 540;
constexpr unsigned R_AARCH64_TLSIE_ADR_GOTTPREL_PAGE21    = 541;
constexpr unsigned R_AARCH64_TLSIE_LD64_GOTTPREL_LO12_NC  = 542;
constexpr unsigned R_AARCH64_TLSIE_LD_GOTTPREL_PREL19     = 543;
constexpr unsigned R_AARCH64_TLSLE_MOVW_TPREL_G2          = 544;
constexpr unsigned R_AARCH64_TLSLE_MOVW_TPREL_G1          = 545;
constexpr unsigned R_AARCH64_TLSLE_MOVW_TPREL_G1_NC       = 546;
constexpr unsigned R_AARCH64_TLSLE_MOVW_TPREL_G0          = 547;
constexpr unsigned R_AARCH64_TLSLE_MOVW_TPREL_G0_NC       = 548;
constexpr unsigned R_AARCH64_TLSLE_ADD_TPREL_HI12         = 549;
constexpr unsigned R_AARCH64_TLSLE_ADD_TPREL_LO12         = 550;
constexpr unsigned R_AARCH64_TLSLE_ADD_TPREL_LO12_NC      = 551;
constexpr unsigned R_AARCH64_TLSLE_LDST8_TPREL_LO12       = 552;
constexpr unsigned R_AARCH64_TLSLE_LDST8_TPREL_LO12_NC    = 553;
constexpr unsigned R_AARCH64_TLSLE_LDST16_TPREL_LO12      = 554;
constexpr unsigned R_AARCH64_TLSLE_LDST16_TPREL_LO12_NC   = 555;
constexpr unsigned R_AARCH64_TLSLE_LDST32_TPREL_LO12      = 556;
constexpr unsigned R_AARCH64_TLSLE_LDST32_TPREL_LO12_NC   = 557;
constexpr unsigned R_AARCH64_TLSLE_LDST64_TPREL_LO12      = 558;
constexpr unsigned R_AARCH64_TLSLE_LDST64_TPREL_LO12_NC   = 559;
constexpr unsigned R_AARCH64_TLSDESC_LD_PREL19            = 560;
constexpr unsigned R_AARCH64_TLSDESC_ADR_PREL21           = 561;
constexpr unsigned R_AARCH64_TLSDESC_ADR_PAGE21           = 562;
constexpr unsigned R_AARCH64_TLSDESC_LD64_LO12            = 563;
constexpr unsigned R_AARCH64_TLSDESC_ADD_LO12             = 564;
constexpr unsigned R_AARCH64_TLSDESC_OFF_G1               = 565;
constexpr unsigned R_AARCH64_TLSDESC_OFF_G0_NC            = 566;
constexpr unsigned R_AARCH64_TLSDESC_LDR                  = 567;
constexpr unsigned R_AARCH64_TLSDESC_ADD                  = 568;
constexpr unsigned R_AARCH64_TLSDESC_CALL                 = 569;
constexpr unsigned R_AARCH64_TLSLE_LDST128_TPREL_LO12     = 570;
constexpr unsigned R_AARCH64_TLSLE_LDST128_TPREL_LO12_NC  = 571;
constexpr unsigned R_AARCH64_TLSLD_LDST128_DTPREL_LO12    = 572;
constexpr unsigned R_AARCH64_TLSLD_LDST128_DTPREL_LO12_NC = 573;
constexpr unsigned R_AARCH64_COPY                         = 1024;
constexpr unsigned R_AARCH64_GLOB_DAT                     = 1025;
constexpr unsigned R_AARCH64_JUMP_SLOT                    = 1026;
constexpr unsigned R_AARCH64_RELATIVE                     = 1027;
constexpr unsigned R_AARCH64_TLS_DTPMOD                   = 1028;
constexpr unsigned R_AARCH64_TLS_DTPMOD64                 = 1028;
constexpr unsigned R_AARCH64_TLS_DTPREL                   = 1029;
constexpr unsigned R_AARCH64_TLS_DTPREL64                 = 1029;
constexpr unsigned R_AARCH64_TLS_TPREL                    = 1030;
constexpr unsigned R_AARCH64_TLS_TPREL64                  = 1030;
constexpr unsigned R_AARCH64_TLSDESC                      = 1031;

// Segment types
constexpr Elf_Word PT_NULL         = 0;
constexpr Elf_Word PT_LOAD         = 1;
constexpr Elf_Word PT_DYNAMIC      = 2;
constexpr Elf_Word PT_INTERP       = 3;
constexpr Elf_Word PT_NOTE         = 4;
constexpr Elf_Word PT_SHLIB        = 5;
constexpr Elf_Word PT_PHDR         = 6;
constexpr Elf_Word PT_TLS          = 7;
constexpr Elf_Word PT_LOOS         = 0X60000000;
constexpr Elf_Word PT_GNU_EH_FRAME = 0X6474E550; // Frame unwind information
constexpr Elf_Word PT_GNU_STACK    = 0X6474E551; // Stack flags
constexpr Elf_Word PT_GNU_RELRO    = 0X6474E552; // Read only after relocs
constexpr Elf_Word PT_GNU_PROPERTY = 0X6474E553; // GNU property
constexpr Elf_Word PT_GNU_MBIND_LO = 0X6474E555; // Mbind segments start
constexpr Elf_Word PT_GNU_MBIND_HI = 0X6474F554; // Mbind segments finish
constexpr Elf_Word PT_PAX_FLAGS    = 0X65041580;
constexpr Elf_Word PT_OPENBSD_RANDOMIZE = 0X65A3DBE6;
constexpr Elf_Word PT_OPENBSD_WXNEEDED  = 0X65A3DBE7;
constexpr Elf_Word PT_OPENBSD_BOOTDATA  = 0X65A41BE6;
constexpr Elf_Word PT_SUNWBSS           = 0X6FFFFFFA;
constexpr Elf_Word PT_SUNWSTACK         = 0X6FFFFFFB;
constexpr Elf_Word PT_HIOS              = 0X6FFFFFFF;
constexpr Elf_Word PT_LOPROC            = 0X70000000;
constexpr Elf_Word PT_HIPROC            = 0X7FFFFFFF;

// Segment flags
constexpr Elf_Word PF_X        = 1;          // Execute
constexpr Elf_Word PF_W        = 2;          // Write
constexpr Elf_Word PF_R        = 4;          // Read
constexpr Elf_Word PF_MASKOS   = 0x0ff00000; // Unspecified
constexpr Elf_Word PF_MASKPROC = 0xf0000000; // Unspecified

// Dynamic Array Tags
constexpr Elf_Word DT_NULL            = 0;
constexpr Elf_Word DT_NEEDED          = 1;
constexpr Elf_Word DT_PLTRELSZ        = 2;
constexpr Elf_Word DT_PLTGOT          = 3;
constexpr Elf_Word DT_HASH            = 4;
constexpr Elf_Word DT_STRTAB          = 5;
constexpr Elf_Word DT_SYMTAB          = 6;
constexpr Elf_Word DT_RELA            = 7;
constexpr Elf_Word DT_RELASZ          = 8;
constexpr Elf_Word DT_RELAENT         = 9;
constexpr Elf_Word DT_STRSZ           = 10;
constexpr Elf_Word DT_SYMENT          = 11;
constexpr Elf_Word DT_INIT            = 12;
constexpr Elf_Word DT_FINI            = 13;
constexpr Elf_Word DT_SONAME          = 14;
constexpr Elf_Word DT_RPATH           = 15;
constexpr Elf_Word DT_SYMBOLIC        = 16;
constexpr Elf_Word DT_REL             = 17;
constexpr Elf_Word DT_RELSZ           = 18;
constexpr Elf_Word DT_RELENT          = 19;
constexpr Elf_Word DT_PLTREL          = 20;
constexpr Elf_Word DT_DEBUG           = 21;
constexpr Elf_Word DT_TEXTREL         = 22;
constexpr Elf_Word DT_JMPREL          = 23;
constexpr Elf_Word DT_BIND_NOW        = 24;
constexpr Elf_Word DT_INIT_ARRAY      = 25;
constexpr Elf_Word DT_FINI_ARRAY      = 26;
constexpr Elf_Word DT_INIT_ARRAYSZ    = 27;
constexpr Elf_Word DT_FINI_ARRAYSZ    = 28;
constexpr Elf_Word DT_RUNPATH         = 29;
constexpr Elf_Word DT_FLAGS           = 30;
constexpr Elf_Word DT_ENCODING        = 32;
constexpr Elf_Word DT_PREINIT_ARRAY   = 32;
constexpr Elf_Word DT_PREINIT_ARRAYSZ = 33;
constexpr Elf_Word DT_MAXPOSTAGS      = 34;
constexpr Elf_Word DT_LOOS            = 0x6000000D;
constexpr Elf_Word DT_HIOS            = 0x6ffff000;
constexpr Elf_Word DT_GNU_HASH        = 0x6ffffef5;
constexpr Elf_Word DT_TLSDESC_PLT     = 0x6ffffef6;
constexpr Elf_Word DT_TLSDESC_GOT     = 0x6ffffef7;
constexpr Elf_Word DT_GNU_CONFLICT    = 0x6ffffef8;
constexpr Elf_Word DT_GNU_LIBLIST     = 0x6ffffef9;
constexpr Elf_Word DT_CONFIG          = 0x6ffffefa;
constexpr Elf_Word DT_DEPAUDIT        = 0x6ffffefb;
constexpr Elf_Word DT_AUDIT           = 0x6ffffefc;
constexpr Elf_Word DT_PLTPAD          = 0x6ffffefd;
constexpr Elf_Word DT_MOVETAB         = 0x6ffffefe;
constexpr Elf_Word DT_SYMINFO         = 0x6ffffeff;
constexpr Elf_Word DT_ADDRRNGHI       = 0x6ffffeff;
constexpr Elf_Word DT_VERSYM          = 0x6ffffff0;
constexpr Elf_Word DT_RELACOUNT       = 0x6ffffff9;
constexpr Elf_Word DT_RELCOUNT        = 0x6ffffffa;
constexpr Elf_Word DT_FLAGS_1         = 0x6ffffffb;
constexpr Elf_Word DT_VERDEF          = 0x6ffffffc;
constexpr Elf_Word DT_VERDEFNUM       = 0x6ffffffd;
constexpr Elf_Word DT_VERNEED         = 0x6ffffffe;
constexpr Elf_Word DT_VERNEEDNUM      = 0x6fffffff;
constexpr Elf_Word DT_LOPROC          = 0x70000000;
constexpr Elf_Word DT_HIPROC          = 0x7FFFFFFF;

// DT_FLAGS values
constexpr Elf_Word DF_ORIGIN     = 0x1;
constexpr Elf_Word DF_SYMBOLIC   = 0x2;
constexpr Elf_Word DF_TEXTREL    = 0x4;
constexpr Elf_Word DF_BIND_NOW   = 0x8;
constexpr Elf_Word DF_STATIC_TLS = 0x10;

// Legal values for d_tag (dynamic entry type).
constexpr Elf_Word AT_NULL          = 0;  // End of vector
constexpr Elf_Word AT_IGNORE        = 1;  // Entry should be ignored
constexpr Elf_Word AT_EXECFD        = 2;  // File descriptor of program
constexpr Elf_Word AT_PHDR          = 3;  // Program headers for program
constexpr Elf_Word AT_PHENT         = 4;  // Size of program header entry
constexpr Elf_Word AT_PHNUM         = 5;  // Number of program headers
constexpr Elf_Word AT_PAGESZ        = 6;  // System page size
constexpr Elf_Word AT_BASE          = 7;  // Base address of interpreter
constexpr Elf_Word AT_FLAGS         = 8;  // Flags
constexpr Elf_Word AT_ENTRY         = 9;  // Entry point of program
constexpr Elf_Word AT_NOTELF        = 10; // Program is not ELF
constexpr Elf_Word AT_UID           = 11; // Real uid
constexpr Elf_Word AT_EUID          = 12; // Effective uid
constexpr Elf_Word AT_GID           = 13; // Real gid
constexpr Elf_Word AT_EGID          = 14; // Effective gid
constexpr Elf_Word AT_CLKTCK        = 17; // Frequency of times()
constexpr Elf_Word AT_PLATFORM      = 15; // String identifying platform.
constexpr Elf_Word AT_HWCAP         = 16; // Hints about processor capabilities.
constexpr Elf_Word AT_FPUCW         = 18; // Used FPU control word.
constexpr Elf_Word AT_DCACHEBSIZE   = 19; // Data cache block size.
constexpr Elf_Word AT_ICACHEBSIZE   = 20; // Instruction cache block size.
constexpr Elf_Word AT_UCACHEBSIZE   = 21; // Unified cache block size.
constexpr Elf_Word AT_IGNOREPPC     = 22; // Entry should be ignored.
constexpr Elf_Word AT_SECURE        = 23; // Boolean, was exec setuid-like?
constexpr Elf_Word AT_BASE_PLATFORM = 24; // String identifying real platforms.
constexpr Elf_Word AT_RANDOM        = 25; // Address of 16 random bytes.
constexpr Elf_Word AT_HWCAP2  = 26; // More hints about processor capabilities.
constexpr Elf_Word AT_EXECFN  = 31; // Filename of executable.
constexpr Elf_Word AT_SYSINFO = 32; // EP to the system call in the vDSO.
constexpr Elf_Word AT_SYSINFO_EHDR = 33; // Start of the ELF header of the vDSO.
constexpr Elf_Word AT_L1I_CACHESHAPE    = 34;
constexpr Elf_Word AT_L1D_CACHESHAPE    = 35;
constexpr Elf_Word AT_L2_CACHESHAPE     = 36;
constexpr Elf_Word AT_L3_CACHESHAPE     = 37;
constexpr Elf_Word AT_L1I_CACHESIZE     = 40;
constexpr Elf_Word AT_L1I_CACHEGEOMETRY = 41;
constexpr Elf_Word AT_L1D_CACHESIZE     = 42;
constexpr Elf_Word AT_L1D_CACHEGEOMETRY = 43;
constexpr Elf_Word AT_L2_CACHESIZE      = 44;
constexpr Elf_Word AT_L2_CACHEGEOMETRY  = 45;
constexpr Elf_Word AT_L3_CACHESIZE      = 46;

// ELF file header
struct Elf32_Ehdr
{
    unsigned char e_ident[EI_NIDENT];
    Elf_Half      e_type;
    Elf_Half      e_machine;
    Elf_Word      e_version;
    Elf32_Addr    e_entry;
    Elf32_Off     e_phoff;
    Elf32_Off     e_shoff;
    Elf_Word      e_flags;
    Elf_Half      e_ehsize;
    Elf_Half      e_phentsize;
    Elf_Half      e_phnum;
    Elf_Half      e_shentsize;
    Elf_Half      e_shnum;
    Elf_Half      e_shstrndx;
};

struct Elf64_Ehdr
{
    unsigned char e_ident[EI_NIDENT];
    Elf_Half      e_type;
    Elf_Half      e_machine;
    Elf_Word      e_version;
    Elf64_Addr    e_entry;
    Elf64_Off     e_phoff;
    Elf64_Off     e_shoff;
    Elf_Word      e_flags;
    Elf_Half      e_ehsize;
    Elf_Half      e_phentsize;
    Elf_Half      e_phnum;
    Elf_Half      e_shentsize;
    Elf_Half      e_shnum;
    Elf_Half      e_shstrndx;
};

// Section header
struct Elf32_Shdr
{
    Elf_Word   sh_name;
    Elf_Word   sh_type;
    Elf_Word   sh_flags;
    Elf32_Addr sh_addr;
    Elf32_Off  sh_offset;
    Elf_Word   sh_size;
    Elf_Word   sh_link;
    Elf_Word   sh_info;
    Elf_Word   sh_addralign;
    Elf_Word   sh_entsize;
};

struct Elf64_Shdr
{
    Elf_Word   sh_name;
    Elf_Word   sh_type;
    Elf_Xword  sh_flags;
    Elf64_Addr sh_addr;
    Elf64_Off  sh_offset;
    Elf_Xword  sh_size;
    Elf_Word   sh_link;
    Elf_Word   sh_info;
    Elf_Xword  sh_addralign;
    Elf_Xword  sh_entsize;
};

// Segment header
struct Elf32_Phdr
{
    Elf_Word   p_type;
    Elf32_Off  p_offset;
    Elf32_Addr p_vaddr;
    Elf32_Addr p_paddr;
    Elf_Word   p_filesz;
    Elf_Word   p_memsz;
    Elf_Word   p_flags;
    Elf_Word   p_align;
};

struct Elf64_Phdr
{
    Elf_Word   p_type;
    Elf_Word   p_flags;
    Elf64_Off  p_offset;
    Elf64_Addr p_vaddr;
    Elf64_Addr p_paddr;
    Elf_Xword  p_filesz;
    Elf_Xword  p_memsz;
    Elf_Xword  p_align;
};

// Symbol table entry
struct Elf32_Sym
{
    Elf_Word      st_name;
    Elf32_Addr    st_value;
    Elf_Word      st_size;
    unsigned char st_info;
    unsigned char st_other;
    Elf_Half      st_shndx;
};

struct Elf64_Sym
{
    Elf_Word      st_name;
    unsigned char st_info;
    unsigned char st_other;
    Elf_Half      st_shndx;
    Elf64_Addr    st_value;
    Elf_Xword     st_size;
};

#define ELF_ST_BIND( i )    ( ( i ) >> 4 )
#define ELF_ST_TYPE( i )    ( ( i ) & 0xf )
#define ELF_ST_INFO( b, t ) ( ( ( b ) << 4 ) + ( ( t ) & 0xf ) )

#define ELF_ST_VISIBILITY( o ) ( ( o ) & 0x3 )

// Relocation entries
struct Elf32_Rel
{
    Elf32_Addr r_offset;
    Elf_Word   r_info;
};

struct Elf32_Rela
{
    Elf32_Addr r_offset;
    Elf_Word   r_info;
    Elf_Sword  r_addend;
};

struct Elf64_Rel
{
    Elf64_Addr r_offset;
    Elf_Xword  r_info;
};

struct Elf64_Rela
{
    Elf64_Addr r_offset;
    Elf_Xword  r_info;
    Elf_Sxword r_addend;
};

#define ELF32_R_SYM( i )     ( ( i ) >> 8 )
#define ELF32_R_TYPE( i )    ( (unsigned char)( i ) )
#define ELF32_R_INFO( s, t ) ( ( ( s ) << 8 ) + (unsigned char)( t ) )

#define ELF64_R_SYM( i )  ( ( i ) >> 32 )
#define ELF64_R_TYPE( i ) ( ( i ) & 0xffffffffL )
#define ELF64_R_INFO( s, t ) \
    ( ( ( (int64_t)( s ) ) << 32 ) + ( ( t ) & 0xffffffffL ) )

// Dynamic structure
struct Elf32_Dyn
{
    Elf_Sword d_tag;
    union {
        Elf_Word   d_val;
        Elf32_Addr d_ptr;
    } d_un;
};

struct Elf64_Dyn
{
    Elf_Sxword d_tag;
    union {
        Elf_Xword  d_val;
        Elf64_Addr d_ptr;
    } d_un;
};

struct Elfxx_Verneed
{
    Elf_Half vn_version;
    Elf_Half vn_cnt;
    Elf_Word vn_file;
    Elf_Word vn_aux;
    Elf_Word vn_next;
};

struct Elfxx_Vernaux
{
    Elf_Word vna_hash;
    Elf_Half vna_flags;
    Elf_Half vna_other;
    Elf_Word vna_name;
    Elf_Word vna_next;
};

// ELF auxiliary vectors, they are usually run-time information
// being passed to program when the kernel is loading it.
// This is now required,
// because in order to initialize the stack cookie
// to protect against buffer overflows,
// most of libc ask us to have a valid pointer for the AT_RANDOM entry.
// glibc for example crashes if you don't.
// https://sourceware.org/git/?p=glibc.git;a=blob;f=csu/libc-start.c;h=543560f36c33b07a1fbe1b7e4578374fe8007b1f;hb=HEAD#l308
// This is also useful to be able to reconstruct at run-time
// the ELF headers, if ELF headers were erased after loading.
// Although this library is targeted to be parsing files only,
// I assume auxiliary vectors could be also used to get
// more information about the ELF binary at run-time in future.
// The main purpose is also for ELF injectors.
struct Elf32_auxv
{
    uint32_t a_type; // Entry type

    union {
        uint32_t a_val; // Integer value, usually a pointer
    } a_un;
};

struct Elf64_auxv
{
    uint64_t a_type; // Entry type

    union {
        uint64_t a_val; // Integer value, usually a pointer
    } a_un;
};

struct Elf32_Chdr
{
    Elf32_Word ch_type; // The compression algorithm used
    Elf32_Word ch_size; //The size, in	bytes, of the uncompressed section data
    Elf32_Word
        ch_addralign; // The address alignment of the	uncompressed section data
};

struct Elf64_Chdr
{
    Elf64_Word ch_type;     //The compression algorithm used
    Elf64_Word ch_reserved; // Reserved
    Elf_Xword  ch_size; //The size, in	bytes, of the uncompressed section data
    Elf_Xword
        ch_addralign; //The address alignment of the	uncompressed section data
};

#ifdef __cplusplus
} // namespace ELFIO
#endif

#endif // ELFTYPES_H
#include "../runtime/common.h"
#include "../runtime/crypto.h"
#include "../runtime/loader.h"
#include "objects.h"
#include "osutils.h"
#include "streams.h"
#include "files.h"
#include "processors.h"
#include "lang.h"
#include "core.h"
#include "dwarf.h"
#include "pefile.h"
#include "macfile.h"
#include "elffile.h"
#include "packer.h"
#include "intel.h"
#include "objc.h"
#include <intrin.h>

/**
 * IntelCommand
 */

IntelCommand::IntelCommand(IFunction *owner, OperandSize size, uint64_t address)
	: BaseCommand(owner), address_(address), size_(size), type_(cmUnknown), flags_(0), preffix_command_(cmUnknown), 
	base_segment_(segDefault), command_pos_(0), original_dump_size_(0), section_options_(0), vex_operand_(0), 
	ext_vm_entry_(NULL), begin_section_cryptor_(NULL), end_section_cryptor_(NULL), seh_handler_(NULL)
{
	vm_command_info_list_ = new IntelCommandInfoList(size);
	if (address_)
		include_option(roClearOriginalCode);
#ifdef CHECKED
	update_hash();
#endif
}

IntelCommand::IntelCommand(IFunction *owner, OperandSize size, IntelCommandType type, IntelOperand operand1, IntelOperand operand2, IntelOperand operand3)
	: BaseCommand(owner), address_(0), size_(size), type_(cmUnknown), flags_(0), preffix_command_(cmUnknown), base_segment_(segDefault), 
	command_pos_(0), original_dump_size_(0), section_options_(0), vex_operand_(0), ext_vm_entry_(NULL), begin_section_cryptor_(NULL),
	end_section_cryptor_(NULL), seh_handler_(NULL)
{
	vm_command_info_list_ = new IntelCommandInfoList(size);
	type_ = type;
	operand_[0] = operand1;
	operand_[1] = operand2;
	operand_[2] = operand3;
	for (size_t i = 0; i < _countof(operand_); i++) {
		IntelOperand *operand = &operand_[i];
		if (operand->size == osDefault)
			operand->size = size_;
		if (operand->address_size == osDefault)
			operand->address_size = size_;
	}
#ifdef CHECKED
	update_hash();
#endif
}

IntelCommand::IntelCommand(IFunction *owner, OperandSize size, const std::string &value)
	: BaseCommand(owner, value), address_(0), size_(size), type_(cmUnknown), flags_(0), 
	preffix_command_(cmUnknown), base_segment_(segDefault), command_pos_(0), original_dump_size_(0), section_options_(0),
	vex_operand_(0), ext_vm_entry_(NULL), begin_section_cryptor_(NULL), end_section_cryptor_(NULL), seh_handler_(NULL)
{
	vm_command_info_list_ = new IntelCommandInfoList(size);
	type_ = cmDB;
#ifdef CHECKED
	update_hash();
#endif
}

IntelCommand::IntelCommand(IFunction *owner, OperandSize size, const os::unicode_string &value)
	: BaseCommand(owner, value), address_(0), size_(size), type_(cmUnknown), flags_(0),
	preffix_command_(cmUnknown), base_segment_(segDefault), command_pos_(0), original_dump_size_(0), section_options_(0),
	ext_vm_entry_(NULL), begin_section_cryptor_(NULL), end_section_cryptor_(NULL), seh_handler_(NULL)
{
	vm_command_info_list_ = new IntelCommandInfoList(size);
	type_ = cmDB;
#ifdef CHECKED
	update_hash();
#endif
}

IntelCommand::IntelCommand(IFunction *owner, OperandSize size, const Data &value)
	: BaseCommand(owner, value), address_(0), size_(size), type_(cmUnknown), flags_(0),
	preffix_command_(cmUnknown), base_segment_(segDefault), command_pos_(0), original_dump_size_(0), section_options_(0),
	ext_vm_entry_(NULL), begin_section_cryptor_(NULL), end_section_cryptor_(NULL), seh_handler_(NULL)
{
	vm_command_info_list_ = new IntelCommandInfoList(size);
	type_ = cmDB;
#ifdef CHECKED
	update_hash();
#endif
}

void IntelCommand::Init(IntelCommandType type, IntelOperand operand1, IntelOperand operand2, IntelOperand operand3)
{
	type_ = type;
	operand_[0] = operand1;
	operand_[1] = operand2;
	operand_[2] = operand3;
	for (size_t i = 0; i < _countof(operand_); i++) {
		IntelOperand *operand = &operand_[i];
		if (operand->size == osDefault)
			operand->size = size_;
		if (operand->address_size == osDefault)
			operand->address_size = size_;
	}
}

void IntelCommand::Init(const Data &data)
{
	type_ = cmDB;
	set_dump(data.data(), data.size());
}

void IntelCommand::InitUnknown()
{
	clear();
	type_ = cmUnknown;
	PushByte(0);
}

IntelCommand::IntelCommand(IFunction *owner, const IntelCommand &src)
	: BaseCommand(owner, src), section_options_(0), ext_vm_entry_(NULL), begin_section_cryptor_(NULL), end_section_cryptor_(NULL)
{ 
	vm_command_info_list_ = new IntelCommandInfoList(src.size());
	address_ = src.address_;
	size_ = src.size_;
	type_ = src.type_;
	flags_ = src.flags_;
	preffix_command_ = src.preffix_command_;
	base_segment_ = src.base_segment_;
	command_pos_ = src.command_pos_;
	original_dump_size_ = src.original_dump_size_;
	vex_operand_ = src.vex_operand_;
	seh_handler_ = src.seh_handler_;

	for (size_t i = 0; i < _countof(operand_); i++) {
		operand_[i] = src.operand_[i];
	}
#ifdef CHECKED
	update_hash();
#endif
}

IntelCommand::~IntelCommand()
{
	delete vm_command_info_list_;
}

void IntelCommand::clear()
{
	type_ = cmUnknown;
	base_segment_ = segDefault;
	preffix_command_ = cmUnknown;
	flags_ = 0;
	command_pos_ = 0;
	for (size_t i = 0; i < _countof(operand_); i++) {
		operand_[i].Clear();
	}
	vm_command_info_list_->clear();
	BaseCommand::clear();
}

IntelCommand *IntelCommand::Clone(IFunction *owner) const
{
	IntelCommand *command = new IntelCommand(owner, *this);
	return command;
}

bool IntelCommand::is_data() const
{
	return (type_ == cmDB || type_ == cmDW || type_ == cmDD || type_ == cmDQ || type_ == cmSleb || type_ == cmUleb || type_ == cmDC);
}

bool IntelCommand::is_end() const
{
	return (type_ == cmRet || type_ == cmIret || type_ == cmJmp || ((type_ == cmCall || type_ == cmJmpWithFlag) && (options() & roUseAsJmp)) || is_data());
}

static const char *size_name[] = {
	"byte",
	"word",
	"dword",
	"qword",
	"tbyte",
	"oword",
	"xmmword",
	"ymmword",
	"fword"
};

static const char *segment_name[] = {
	"es",
	"cs",
	"ss",
	"ds",
	"fs",
	"gs"
};

static const char *registr_name[4][22] = {
	{"al","cl","dl","bl","spl","bpl","sil","dil","r8b","r9b","r10b","r11b","r12b","r13b","r14b","r15b","fl","tl","rl","il","kl","el"},
	{"ax","cx","dx","bx","sp","bp","si","di","r8w","r9w","r10w","r11w","r12w","r13w","r14w","r15w","fx","tx","rx","ix","kx","ex"},
	{"eax","ecx","edx","ebx","esp","ebp","esi","edi","r8d","r9d","r10d","r11d","r12d","r13d","r14d","r15d","efx","etx","erx","eix","ekx","eex"},
	{"rax","rcx","rdx","rbx","rsp","rbp","rsi","rdi","r8","r9","r10","r11","r12","r13","r14","r15","rfx","rtx","rrx","rix","rkx","rex"}
};

bool IntelCommand::GetOperandText(std::string &str, size_t index) const
{
	const IntelOperand *operand = &operand_[index];

	if (operand->type == otNone)
		return false;

	str.clear();
	if (operand->type & otMemory) {
		if (operand->show_size)
			str.append(size_name[operand->size]).append(" ptr ");

		if (base_segment_ != segDefault && type_ != cmLea)
			str.append(segment_name[base_segment_]).append(":");

		str.append("[");
		if (operand->type & otBaseRegistr)
			str.append(registr_name[operand->address_size][operand->base_registr]);
	}

	if (operand->type & otRegistr) {
		if (operand->type & otMemory) {
			if (operand->type & otBaseRegistr)
				str.append("+");
			str.append(registr_name[operand->address_size][operand->registr]);
			if (operand->scale_registr)
				str.append(string_format("*%d", 2 << (operand->scale_registr - 1)));
		} else {
			str.append(operand->size > osQWord ? "???" : registr_name[operand->size][operand->registr]);
		}
	} else if (operand->type & otHiPartRegistr) {
		str.append(std::string(registr_name[osWord][operand->registr & 3], 1));
		str.append("h");
	} else if (operand->type & otFPURegistr) {
		str.append(string_format("st%d", operand->registr));
	} else if (operand->type & otSegmentRegistr) {
		str.append(operand->registr > segGS ? "???" : segment_name[operand->registr]);
	} else if (operand->type & otControlRegistr) {
		str.append(string_format("cr%d", operand->registr));
	} else if (operand->type & otDebugRegistr) {
		str.append(string_format("dr%d", operand->registr));
	} else if (operand->type & otMMXRegistr) {
		str.append(string_format("mm%d", operand->registr));
	} else if (operand->type & otXMMRegistr) {
		str.append(string_format((operand->size == osYMMWord) ? "ymm%d" : "xmm%d", operand->registr));
	}

	if (operand->type & otValue) {
		int64_t value = operand->value;
		bool is_neg = (value < 0 && (operand->size > operand->value_size || (operand->type & (otMemory | otRegistr | otBaseRegistr)) > otMemory));
		if (is_neg) {
			str.append("-");
			value = -value;
		} else if (operand->type & (otRegistr | otBaseRegistr)) {
			str.append("+");
		}

		if (operand->type == otValue && operand->size == osFWord) {
			switch (operand->value_size) {
			case osWord:
				str.append(string_format("%.4X:%.4X", static_cast<uint16_t>(operand->value >> 16), static_cast<uint16_t>(operand->value)));
				break;
			case osDWord:
				str.append(string_format("%.4X:%.8X", static_cast<uint16_t>(operand->value >> 32), static_cast<uint32_t>(operand->value)));
				break;
			}
		} else {
			switch (operand->value_size) {
			case osByte:
				str.append(string_format("%.2X", static_cast<uint8_t>(value)));
				break;
			case osWord:
				str.append(string_format("%.4X", static_cast<uint16_t>(value)));
				break;
			case osDWord:
				str.append(string_format("%.8X", static_cast<uint32_t>(value)));
				break;
			case osQWord:
				str.append(string_format("%.16llX", value));
				break;
			}
		}
	}

	if (operand->type & otMemory)
		str.append("]");

	return true;
}

std::string IntelCommand::text() const
{
	std::string res, operand_text;
	size_t i;

	if (type_ == cmDB) {
		res.append(intel_command_name[type_]);
		for (i = 0; i < dump_size(); i++) {
			if (i > 0)
				res.append(",");
			res.append(string_format(" %.2X", dump(i)));
		}
	} else {
		if (options() & roLockPrefix)
			res.append("lock ");

		if (preffix_command_ != cmUnknown)
			res.append(intel_command_name[preffix_command_]).append(" ");

		if (options() & roVexPrefix)
			res.append("v");

		if (type_ == cmJCXZ && operand_[1].size > osWord) {
			res.append(operand_[1].size == osDWord ? "jecxz" : "jrcxz");
		} else {
			res.append(intel_command_name[type_]);
		}

		if (flags_) {
			if (options() & roInverseFlag)
				res.append("n");
			switch (flags_) {
			case fl_O:
				res.append("o");
				break;
			case fl_C:
				res.append("b");
				break;
			case fl_Z:
				res.append("z");
				break;
			case fl_C | fl_Z:
				res.append("be");
				break;
			case fl_P:
				res.append("p");
				break;
			case fl_S | fl_O:
				res.append("l");
				break;
			case fl_S:
				res.append("s");
				break;
			case fl_Z | fl_S | fl_O:
				res.append("le");
				break;
			default:
				res.append("?");
				break;
			}
		}

		switch (type_) {
		case cmLods:
		case cmScas:
		case cmCmps:
		case cmMovs:
		case cmStos:
		case cmIns:
		case cmOuts:
			res.append(std::string(size_name[operand_[0].size], 1));
			break;
		case cmPusha:
		case cmPopa:
		case cmPushf:
		case cmPopf:
		case cmIret:
			if (operand_[0].size > osWord)
				res.append(std::string(size_name[operand_[0].size], 1));
			break;
		case cmXlat:
			res.append(std::string(size_name[osByte], 1));
			break;
		case cmRet:
			if ((options() & roFar) != 0)
				res.append("f");
			break;
		}

		for (i = 0; i < _countof(operand_); i++) {
			if (vex_operand_ && (vex_operand_ & 0x3) == i) {
				res.append(", ");
				res.append(string_format((vex_operand_ & 4) ? "ymm%d" : "xmm%d", (vex_operand_ >> 4) & 0x0f));
			}

			if (!GetOperandText(operand_text, i))
				break;

			if (i > 0)
				res.append(",");
			res.append(" ").append(operand_text);
		}
	}

	return res;
}

CommentInfo IntelCommand::comment()
{
	CommentInfo res = BaseCommand::comment();
	if (res.type != ttUnknown)
		return res;

	res.type = ttNone;
	if ((options() & roFar) == 0) {
		IArchitecture *file = owner()->owner()->owner();
		if (file) {
			size_t operand_index = NOT_ID;
			for (size_t i = 2; i > 0; i--) {
				if (operand_[i - 1].type == otValue || operand_[i - 1].type == (otMemory | otValue)) {
					operand_index = i - 1;
					break;
				}
			}
			if (operand_index != NOT_ID) {
				uint64_t address = operand_[operand_index].value;
				if (IRelocation *relocation = operand_[operand_index].relocation) {
					if (IImportFunction *import_function = file->import_list()->GetFunctionByAddress(relocation->address())) {
						res.value = string_format("%c %s", 3, import_function->full_name().c_str());
						res.type = ttImport;
					} else if (ISymbol *symbol = relocation->symbol()) {
						address = symbol->address();
						res.value = string_format("%c %s", 3, symbol->display_name().c_str());
						if (file->export_list()->GetExportByAddress(address))
							res.type = ttExport;
						else if (file->segment_list()->GetMemoryTypeByAddress(address) & mtExecutable)
							res.type = ttFunction;
						else
							res.type = ttVariable;
					}
				} else if (IImportFunction *import_function = file->import_list()->GetFunctionByAddress(address)) {
					res.value = string_format("%c %s", 3, import_function->full_name().c_str());
					res.type = ttImport;
				} else if (IRelocation *relocation = file->relocation_list() ? file->relocation_list()->GetRelocationByAddress(address) : NULL) {
					if (ISymbol *symbol = relocation->symbol()) {
						address = symbol->address();
						res.value = string_format("%c %s", 3, symbol->display_name().c_str());
						if (file->export_list()->GetExportByAddress(address))
							res.type = ttExport;
						else if (file->segment_list()->GetMemoryTypeByAddress(address) & mtExecutable)
							res.type = ttFunction;
						else
							res.type = ttVariable;
					}
				} else if (MapFunction *map_function = file->map_function_list()->GetFunctionByAddress(address)) {
					if (map_function->type() == otData) {
						if (map_function->name().compare("`string'") == 0) {
							std::string str = file->ReadString(address);
							if (!str.empty()) {
								res.value = string_format("%c string \"%s\"", 3, DisplayString(str).c_str());
								res.type = ttString;
							}
						}
						else {
							res.value = string_format("%c %s", 3, map_function->name().c_str());
							res.type = ttVariable;
						}
					}
					else {
						res.value = string_format("%c %s", 3, map_function->name().c_str());
						switch (map_function->type()) {
						case otString:
							res.type = ttString;
							break;
						case otExport:
							res.type = ttExport;
							break;
						default:
							res.type = ttFunction;
							break;
						}
					}
				} else if (type_ == cmLea || operand_[operand_index].type == otValue) {
					if (type_ == cmCall || type_ == cmJmp || type_ == cmJmpWithFlag || type_ == cmLoope || type_ == cmLoopne || type_ == cmLoop || type_ == cmJCXZ) {
						res.value = (next_address() > address) ? char(2) : char(4);
						res.type = ttJmp;
					}
					else {
						std::string str = file->ReadString(address);
						if (!str.empty()) {
							res.value = string_format("%c string \"%s\"", 3, DisplayString(str).c_str());
							res.type = ttString;
						}
					}
				}
			}
		}
	}

	set_comment(res);

	return res;
}

std::string IntelCommand::dump_str() const
{
	std::string res;
	if (type_ == cmUnknown) {
		for (size_t i = 0; i < dump_size(); i++) {
			res += "??";
		}
		return res;
	}

	res = BaseCommand::dump_str();

	size_t i, c;
	c = 0;
	for (i = 0; i < command_pos_; i++) {
		res.insert((i + 1) * 2 + c, ":");
		c++;
	}
	for (i = 0; i < _countof(operand_); i++) {
		const IntelOperand *operand = &operand_[i];
		if (operand->type == otNone)
			break;

		if ((operand->type & otValue) && operand->value_pos) {
			res.insert(operand->value_pos * 2 + c, " ");
			c++;
		}
	}

	return res;
}

std::string IntelCommand::display_address() const
{
	return DisplayValue(size(), address());
}

bool IntelCommand::is_equal(const IntelCommand &command) const
{
	if (type_ != command.type_)
		return false;
	for (size_t i = 0; i < _countof(operand_); i++) {
		if (operand_[i] != command.operand_[i])
			return false;
	}
	return true;
}

IntelOperand *IntelCommand::GetFreeOperand()
{
	for (size_t i = 0; i < _countof(operand_); i++) {
		IntelOperand *operand = &operand_[i];
		if (operand->type == otNone) {
			operand->Clear();
			return operand;
		}
	}

	return NULL;
}

static OperandSize GetOperandSize(uint8_t code, const DisasmContext &ctx)
{
	if ((code & 1) == 0)
		return osByte;
	if (ctx.rex_prefix & rexW)
		return osQWord;
	if (ctx.lower_reg)
		return osWord;
	return osDWord;
}

static OperandSize GetDefaultOperandSize(const DisasmContext &ctx)
{
	if ((ctx.rex_prefix & rexW) == 0 && ctx.lower_reg)
		return osWord;
	return ctx.file->cpu_address_size();
}

static OperandSize GetAddressSize(const DisasmContext &ctx)
{
	OperandSize cpu_address_size = ctx.file->cpu_address_size();

	if (ctx.lower_address)
		return (cpu_address_size == osQWord) ? osDWord : osWord;
	return cpu_address_size;
}

void IntelCommand::ReadFlags(uint8_t code)
{
	switch ((code >> 1) & 7) {
	case 0x00:
		flags_ = fl_O;
		break;
	case 0x01:
		flags_ = fl_C;
		break;
	case 0x02:
		flags_ = fl_Z;
		break;
	case 0x03:
		flags_ = fl_C | fl_Z;
		break;
	case 0x04:
		flags_ = fl_S;
		break;
	case 0x05:
		flags_ = fl_P;
		break;
	case 0x06:
		flags_ = fl_S | fl_O;
		break;
	case 0x07:
		flags_ = fl_Z | fl_S | fl_O;
		break;
	}

	if (code & 1)
		include_option(roInverseFlag);
}

void IntelCommand::ReadReg(uint8_t code, OperandSize operand_size, OperandType operand_type, const DisasmContext &ctx)
{
	IntelOperand *operand = GetFreeOperand();
	if (operand == NULL)
		throw std::runtime_error("ReadReg no free operands");

	operand->type = operand_type;
	operand->size = operand_size;
	operand->registr = (code & 7);

	if (ctx.rex_prefix && operand_type == otRegistr) {
		if (ctx.rex_prefix & rexB)
			operand->registr |= 8;
	} else if (operand_type == otRegistr && operand_size == osByte && operand->registr >= 4) {
		operand->type = otHiPartRegistr;
		operand->registr &= 3;
	}
}

void IntelCommand::ReadRegFromRM(uint8_t code, OperandSize operand_size, OperandType operand_type, const DisasmContext &ctx)
{
	IntelOperand *operand = GetFreeOperand();
	if (operand == NULL)
		throw std::runtime_error("ReadRegFromRM no free operands");

	operand->type = operand_type;
	operand->size = operand_size;
	operand->registr = ((code >> 3) & 7);

	if (ctx.rex_prefix && (operand_type == otRegistr || operand_type == otDebugRegistr || operand_type == otControlRegistr || operand_type == otXMMRegistr)) {
		if (ctx.rex_prefix & rexR)
			operand->registr |= 8;
	} else if (operand_type == otRegistr && operand_size == osByte && operand->registr >= 4) {
		operand->type = otHiPartRegistr;
		operand->registr &= 3;
	}
}

void IntelCommand::ReadRM(uint8_t code, OperandSize operand_size, OperandType operand_type, bool show_size, const DisasmContext &ctx)
{
	IntelOperand *operand = GetFreeOperand();
	if (operand == NULL)
		throw std::runtime_error("ReadRM no free operands");

	OperandSize value_size = osByte;
	uint8_t sib;

	switch (code & 0xc0) {
	case 0x00:
		if ((!ctx.lower_address && (code & 7) == 5) || (ctx.lower_address && (code & 7) == 6)) {
			operand->type = otMemory | otValue;
			value_size = GetAddressSize(ctx);
		} else {
			operand->type = otMemory | otRegistr;
		}
		break;
	case 0x40:
		operand->type = otMemory | otRegistr | otValue;
		break;
	case 0x80:
		operand->type = otMemory | otRegistr | otValue;
		value_size = GetAddressSize(ctx);
		break;
	default:
		operand->type = operand_type;
		break;
	}
	operand->size = operand_size;

	if (operand->type & otMemory) {
		operand->show_size = show_size;
		operand->address_size = GetAddressSize(ctx);

		if (operand->address_size == osWord) {
			if ((code & 7) < 4) {
				operand->base_registr = (code & 2) == 0 ? regEBX : regEBP;
				operand->type |= otBaseRegistr;
			}

			if (operand->type & otRegistr) {
				switch (code & 7) {
				case 0x00:
					operand->registr = regESI;
					operand->base_registr = regEBX;
					break;
				case 0x01:
					operand->registr = regEDI;
					operand->base_registr = regEBX;
					break;
				case 0x02:
					operand->registr = regESI;
					operand->base_registr = regEBP;
					break;
				case 0x03:
					operand->registr = regEDI;
					operand->base_registr = regEBP;
					break;
				case 0x04:
					operand->registr = regESI;
					break;
				case 0x05:
					operand->registr = regEDI;
					break;
				case 0x06:
					operand->registr = regEBP;
					break;
				case 0x07:
					operand->registr = regEBX;
					break;
				}
			}
		} else {
			if ((code & 7) == 4) {
				sib = ReadByte(*ctx.file);
				operand->registr = ((sib >> 3) & 7);
				operand->base_registr = (sib & 7);
				operand->type |= otBaseRegistr;

				if (ctx.rex_prefix) {
					if (ctx.rex_prefix & rexB)
						operand->base_registr |= 8;
					if (ctx.rex_prefix & rexX)
						operand->registr |= 8;
				}

				if (operand->registr == regESP)
					operand->type &= ~otRegistr;
				else
					operand->scale_registr = (sib >> 6);

				if ((code & 0xc0) == 0 && (operand->base_registr & 7) == regEBP) {
					operand->type &= ~otBaseRegistr;
					operand->type |= otValue;
				}

				if (operand->type & otValue) {
					switch (code & 0xc0) {
					case 0x00:
						value_size = osDWord;
						break;
					case 0x40:
						value_size = osByte;
						break;
					case 0x80:
						value_size = osDWord;
						break;
					}
				}
			} else {
				operand->registr = (code & 7);
				if (ctx.rex_prefix) {
					if (ctx.rex_prefix & rexB)
						operand->registr |= 8;
				}
			}
		}

		if (operand->type & otValue) {
			operand->value_size = value_size;
			operand->value_pos = static_cast<uint8_t>(dump_size());
			switch (value_size) {
			case osByte:
				operand->value = ByteToInt64(ReadByte(*ctx.file));
				break;
			case osWord:
				operand->value = WordToInt64(ReadWord(*ctx.file));
				break;
			case osDWord:
				operand->value = DWordToInt64(ReadDWord(*ctx.file));
				break;
			case osQWord:
				operand->value = DWordToInt64(ReadDWord(*ctx.file));
				if (operand->type == (otValue | otMemory))
					operand->is_large_value = true;
				break;
			}
		}
	} else {
		operand->registr = (code & 7);
		if (ctx.rex_prefix && (operand_type == otRegistr || operand_type == otDebugRegistr || operand_type == otControlRegistr || operand_type == otXMMRegistr)) {
			if (ctx.rex_prefix & rexB)
				operand->registr |= 8;
		} else if (operand_type == otRegistr && operand_size == osByte && operand->registr >= 4) {
			operand->type = otHiPartRegistr;
			operand->registr &= 3;
		}
	}
}

IntelOperand *IntelCommand::ReadValue(OperandSize operand_size, OperandSize value_size, const DisasmContext &ctx)
{
	IntelOperand *operand = GetFreeOperand();
	if (operand == NULL)
		throw std::runtime_error("ReadValue no free operands");

	operand->type = otValue;
	operand->size = operand_size;
	operand->value_size = value_size;
	operand->value_pos = static_cast<uint8_t>(dump_size());

	switch (value_size) {
	case osByte:
		operand->value = ByteToInt64(ReadByte(*ctx.file));
		break;
	case osWord:
		operand->value = WordToInt64(ReadWord(*ctx.file));
		break;
	case osDWord:
		operand->value = DWordToInt64(ReadDWord(*ctx.file));
		break;
	case osQWord:
		operand->value = ReadQWord(*ctx.file);
		break;
	}

	if (operand_size == osFWord)
		operand->value |= static_cast<uint64_t>(ReadWord(*ctx.file)) << (value_size == osWord ? 16 : 32);

	return operand;
}

void IntelCommand::ReadValueAddAddress(OperandSize operand_size, OperandSize value_size, const DisasmContext &ctx)
{
	IntelOperand *operand = ReadValue(operand_size, value_size, ctx);
	operand->value += next_address();
	operand->value_size = operand_size;

	switch (operand_size) {
	case osWord:
		operand->value = static_cast<uint16_t>(operand->value);
		break;
	case osDWord:
		operand->value = static_cast<uint32_t>(operand->value);
		break;
	}
}

uint64_t IntelCommand::ReadValueFromFile(IArchitecture &file, OperandSize value_size)
{
	DisasmContext ctx;
	IntelOperand *operand;

	switch (value_size) {
	case osByte:
		type_ = cmDB;
		break;
	case osWord:
		type_ = cmDW;
		break;
	case osDWord:
		type_ = cmDD;
		break;
	case osQWord:
		type_ = cmDQ;
		break;
	default:
		throw std::runtime_error("Invalid value size");
	}

	ctx.file = &file;
	ctx.lower_address = false;
	ctx.lower_reg = false;
	ctx.rex_prefix = 0;

	operand = ReadValue(value_size, value_size, ctx);
	operand->fixup = file.fixup_list()->GetFixupByAddress(address() + operand->value_pos);

	if (file.relocation_list())
		operand->relocation = file.relocation_list()->GetRelocationByAddress(address() + operand->value_pos);

	return operand->value;
}

enum OperandFlags {
	of_None = 0,

	of_Registr = 0x01000000,
	of_DebugRegistr = 0x02000000,
	of_ControlRegistr = 0x03000000,
	of_FPURegistr = 0x04000000,
	of_MMXRegistr = 0x05000000,
	of_XMMRegistr = 0x06000000,
	of_Value = 0x07000000,
	of_SegmentRegistr = 0x08000000,

	of_RM = 0x10000000,
	of_RegRM = 0x20000000,
	of_Reg = 0x30000000,
	of_Const = 0x40000000,
	of_Relative = 0x50000000,
	of_Far = 0x60000000,
	of_Memory = 0x70000000,
	of_XReg = 0x80000000,

	of_size = 0x00000100,
	of_mem_word = 0x00000200,
	of_mem_only = 0x00000400,
	of_reg_only = 0x00000800,

	of_value_b = 0x00000001,
	of_value_w = 0x00000002,
	of_value_z = 0x00000003,
	of_value_v = 0x00000004,

	of_E = (of_RM | of_Registr),
	of_G = (of_RegRM | of_Registr),
	of_IB = (of_Value | of_value_b),
	of_IW = (of_Value | of_value_w),
	of_IZ = (of_Value | of_value_z),
	of_IV = (of_Value | of_value_v),
	of_M = (of_RM | of_Registr | of_mem_only),
	of_J = (of_Value | of_Relative),
	of_S = (of_RegRM | of_SegmentRegistr),
	of_A = (of_Value | of_Far),
	of_O = (of_Value | of_Memory),
	of_V = (of_RegRM | of_XMMRegistr),
	of_W = (of_RM | of_XMMRegistr),
	of_X = (of_XReg | of_XMMRegistr),
	of_ST = (of_Const | of_FPURegistr),
	of_U = (of_RM | of_XMMRegistr | of_reg_only),
	of_C = (of_RegRM | of_ControlRegistr),
	of_R = (of_RM | of_Registr | of_reg_only),
	of_D = (of_RegRM | of_DebugRegistr),
	of_Q = (of_RM | of_MMXRegistr),
	of_P = (of_RegRM | of_MMXRegistr),
	of_N = (of_RM | of_MMXRegistr | of_reg_only),
	of_FI = (of_Const | of_Value),
	of_FS = (of_Const | of_SegmentRegistr),
	of_FG = (of_Const | of_Registr),
	of_Z = (of_Reg | of_Registr),

	of_b = 0x00010000, 
	of_w = 0x00020000, 
	of_v = 0x00030000,
	of_d = 0x00040000,
	of_z = 0x00050000,
	of_p = 0x00060000,
	of_t = 0x00070000,
	of_q = 0x00080000,
	of_s = 0x00090000,
	of_dq = 0x000E0000,
	of_qq = 0x000F0000,
	of_o = 0x00130000,
	of_x = 0x00150000,
	of_vdef = 0x00FC0000,
	of_cpu = 0x00FD0000,
	of_adr = 0x00FE0000,
	of_def = 0x00FF0000,

	of_Eb = (of_E | of_b),
	of_Ew = (of_E | of_w),
	of_Ed = (of_E | of_d),
	of_Eq = (of_E | of_q),
	of_Ev = (of_E | of_v),
	of_Ex = (of_E | of_x | of_size),
	of_Edef = (of_E | of_def),
	of_Gb = (of_G | of_b),
	of_Gw = (of_G | of_w),
	of_Gd = (of_G | of_d),
	of_Gv = (of_G | of_v),
	of_Gz = (of_G | of_z),
	of_Gx = (of_G | of_x),
	of_FGb = (of_FG | of_b),
	of_FGw = (of_FG | of_w),
	of_FGv = (of_FG | of_v),
	of_IBb = (of_IB | of_b),
	of_IBv = (of_IB | of_v),
	of_IZv = (of_IZ | of_v),
	of_IVv = (of_IV | of_v),
	of_IWw = (of_IW | of_w),
	of_Ma = (of_M | of_v),
	of_FSdef = (of_FS | of_def),
	of_Jb = (of_J | of_b),
	of_Jz = (of_J | of_z),
	of_Sw = (of_S | of_w),
	of_Mb = (of_M | of_b),
	of_Mw = (of_M | of_w),
	of_Mv = (of_M | of_v),
	of_Md = (of_M | of_d),
	of_Mq = (of_M | of_q),
	of_Mt = (of_M | of_t),
	of_Ms = (of_M | of_s),
	of_Mp = (of_M | of_p),
	of_Mdq = (of_M | of_dq),
	of_Mdef = (of_M | of_vdef | of_size),
	of_Mx = (of_M | of_x),
	of_Ap = (of_A | of_p),
	of_Ob = (of_O | of_b),
	of_Ov = (of_O | of_v),
	of_FIb = (of_FI | of_b),
	of_Vdq = (of_V | of_dq),
	of_Vqq = (of_V | of_qq),
	of_Vdef = (of_V | of_vdef),
	of_Ww = (of_W | of_w | of_size),
	of_Wd = (of_W | of_d | of_size),
	of_Wq = (of_W | of_q | of_size),
	of_Wdq = (of_W | of_dq | of_size),
	of_Wdef = (of_W | of_vdef | of_size),
	of_Xdq = (of_X | of_dq),
	of_Xdef = (of_X | of_vdef),
	of_Udq = (of_U | of_dq),
	of_Udef = (of_U | of_vdef),
	of_Nq = (of_N | of_q),
	of_Zb = (of_Z | of_b),
	of_Zv = (of_Z | of_v),
	of_Zdef = (of_Z | of_def),
	of_Rcpu = (of_R | of_cpu),
	of_Ccpu = (of_C | of_cpu),
	of_Dcpu = (of_D | of_cpu),
	of_Qd = (of_Q | of_d),
	of_Qq = (of_Q | of_q),
	of_Pq = (of_P | of_q),
};

void IntelCommand::ReadCommand(IntelCommandType type, uint32_t of_1, uint32_t of_2, uint32_t of_3, DisasmContext &ctx)
{
	size_t i;
	uint32_t of;
	uint8_t code;
	OperandSize os;
	IntelOperand *operand;
	OperandType ot;
	bool need_read_code;
	uint32_t ofs[] = {of_1, of_2, of_3};

	type_ = type;

	if (ctx.use_last_byte) {
		code = dump(dump_size() - 1);
		need_read_code = false;
	} else {
		code = 0;
		need_read_code = true;
	}

	for (i = 0; i < _countof(ofs); i++) {
		of = ofs[i];

		if (of == of_None)
			break;

		switch (of & 0x00FF0000) {
		case of_b:
			os = osByte;
			break;
		case of_w:
			os = osWord;
			break;
		case of_d:
			os = osDWord;
			break;
		case of_q:
			os = osQWord;
			break;
		case of_v:
			os = GetOperandSize(1, ctx);
			break;
		case of_z:
			os = ((ctx.rex_prefix & rexW) == 0 && ctx.lower_reg) ? osWord : osDWord;
			break;
		case of_x:
			os = (ctx.rex_prefix & rexW) ? osQWord : osDWord;
			break;
		case of_adr:
			os = GetAddressSize(ctx);
			break;
		case of_def:
			os = GetDefaultOperandSize(ctx);
			break;
		case of_p:
			os = osFWord;
			break;
		case of_t:
			os = osTByte;
			break;
		case of_cpu:
			os = size_;
			break;
		case of_s:
			// FIXME
			os = osByte;
			break;
		case of_o:
			os = osOWord;
			break;
		case of_dq:
			os = osXMMWord;
			break;
		case of_qq:
			os = osYMMWord;
			break;
		case of_vdef:
			os = ((options() & roVexPrefix) && (ctx.rex_prefix & 0x80)) ? osYMMWord : osXMMWord;
			break;
		default:
			os = osByte;
			break;
		}

		switch (of & 0x0F000000) {
		case of_Registr:
			ot = otRegistr;
			break;
		case of_DebugRegistr:
			ot = otDebugRegistr;
			break;
		case of_ControlRegistr:
			ot = otControlRegistr;
			break;
		case of_FPURegistr:
			ot = otFPURegistr;
			break;
		case of_MMXRegistr:
			ot = otMMXRegistr;
			break;
		case of_XMMRegistr:
			ot = otXMMRegistr;
			break;
		case of_Value:
			ot = otValue;
			break;
		case of_SegmentRegistr:
			ot = otSegmentRegistr;
			break;
		default:
			operand_[i].size = os;
			continue;
		}

		if (ot == otValue) {
			switch (of & 0xF0000000) {
			case of_Relative:
				ReadValueAddAddress(GetDefaultOperandSize(ctx), os, ctx);
				break;
			case of_Const:
				operand = &operand_[i];
				operand->type = otValue;
				operand->size = os;
				operand->value_size = os;
				operand->value = (of & 0xFF);
				break;
			case of_Far:
				ReadValue(os, GetDefaultOperandSize(ctx), ctx);
				break;
			case of_Memory:
				ReadValue(os, GetAddressSize(ctx), ctx);
				operand_[i].type |= otMemory;
				break;
			default:
				switch (of & 0x0F) {
				case of_value_b:
					ReadValue(os, osByte, ctx);
					break;
				case of_value_w:
					ReadValue(os, osWord, ctx);
					break;
				case of_value_z:
					ReadValue(os, (ctx.lower_reg) ? osWord : osDWord, ctx);
					break;
				case of_value_v:
					ReadValue(os, GetOperandSize(1, ctx), ctx);
					break;
				}
				break;
			}
		} else {
			switch (of & 0xF0000000) {
			case of_RM:
				if (need_read_code) {
					code = ReadByte(*ctx.file);
					need_read_code = false;
				}
				ReadRM(code, os, ot, (of & of_size) != 0, ctx);
				operand = &operand_[i];
				if ((operand->type & otMemory) == 0) {
					if ((of & of_mem_only) != 0) {
						type_ = cmDB;
						return;
					}
				} else {
					if ((of & of_reg_only) != 0) {
						type_ = cmDB;
						return;
					}
					if ((of & of_mem_word) != 0)
						operand->size = osWord;
				}
				break;
			case of_RegRM:
				if (need_read_code) {
					code = ReadByte(*ctx.file);
					need_read_code = false;
				}
				ReadRegFromRM(code, os, ot, ctx);
				break;
			case of_Reg:
				ReadReg((of & 0xff), os, ot, ctx);
				break;
			case of_XReg:
				code = ReadByte(*ctx.file);
				ReadReg((code >> 4), os, ot, ctx);
				break;
			case of_Const:
				operand = &operand_[i];
				operand->type = ot;
				operand->size = os;
				operand->registr = (of & 7);
				break;
			}

			operand = &operand_[i];
			switch (operand->type) {
			case otSegmentRegistr:
				if (operand->registr > segGS) {
					type_ = cmDB;
					return;
				}
				break;
			case otControlRegistr:
				if (operand->registr == 1
					|| operand->registr == 5
					|| operand->registr == 6
					|| operand->registr >= 9) {
					type_ = cmDB;
					return;
				}
				break;
			case otDebugRegistr:
				if (operand->registr >= 8) {
					type_ = cmDB;
					return;
				}
				break;
			}
		}
	}
};

size_t IntelCommand::ReadFromFile(IArchitecture &file)
{
	uint8_t code, prefix;
	OperandSize os;
	DisasmContext ctx;
	IntelOperand *operand;
	uint8_t vex_bytes[2];
	size_t i, vex_operand_index;
	
	clear();
	size_ = file.cpu_address_size();

	ctx.file = &file;
	ctx.lower_address = false;
	ctx.lower_reg = false;
	ctx.rex_prefix = 0;
	ctx.use_last_byte = false;
	ctx.vex_registr = 0;

	vex_operand_index = 0;
	prefix = 0;
	vex_bytes[0] = 0;
	vex_bytes[1] = 0;
	while (type_ == cmUnknown) {
		command_pos_ = dump_size();
		code = vex_bytes[0] ? vex_bytes[0] : ReadByte(file);
		switch (code) {
			case 0x00: 
				ReadCommand(cmAdd, of_Eb, of_Gb, of_None, ctx); 
				break;
			case 0x01:
				ReadCommand(cmAdd, of_Ev, of_Gv, of_None, ctx); 
				break;
			case 0x02:
				ReadCommand(cmAdd, of_Gb, of_Eb, of_None, ctx);
				break;
			case 0x03:
				ReadCommand(cmAdd, of_Gv, of_Ev, of_None, ctx);
				break;
			case 0x04:
				ReadCommand(cmAdd, of_FGb | regEAX, of_IBb, of_None, ctx);
				break;
			case 0x05:
				ReadCommand(cmAdd, of_FGv | regEAX, of_IZv, of_None, ctx);
				break;
			case 0x06:
				if (size_ == osQWord)  {
					type_ = cmDB;
				} else {
					ReadCommand(cmPush, of_FSdef | segES, of_None, of_None, ctx);
				}
				break;
			case 0x07:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					ReadCommand(cmPop, of_FSdef | segES, of_None, of_None, ctx);
				}
				break;
			case 0x08:
				ReadCommand(cmOr, of_Eb, of_Gb, of_None, ctx);
				break;
			case 0x09:
				ReadCommand(cmOr, of_Ev, of_Gv, of_None, ctx);
				break;
			case 0x0a:
				ReadCommand(cmOr, of_Gb, of_Eb, of_None, ctx);
				break;
			case 0x0b:
				ReadCommand(cmOr, of_Gv, of_Ev, of_None, ctx);
				break;
			case 0x0c:
				ReadCommand(cmOr, of_FGb | regEAX, of_IBb, of_None, ctx);
				break;
			case 0x0d:
				ReadCommand(cmOr, of_FGv | regEAX, of_IZv, of_None, ctx);
				break;
			case 0x0e:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					ReadCommand(cmPush, of_FSdef | segCS, of_None, of_None, ctx);
				}
				break;

			// Secondary Opcode Map
			case 0x0f:
				code = vex_bytes[1] ? vex_bytes[1] : ReadByte(file);
				switch (code) {
					case 0x00:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						switch ((code >> 3) & 7) {
							case 0x00:
								ReadCommand(cmSldt, of_Ev | of_mem_word, of_None, of_None, ctx);
								break;
							case 0x01:
								ReadCommand(cmStr, of_Ev | of_mem_word, of_None, of_None, ctx);
								break;
							case 0x02:
								ReadCommand(cmLldt, of_Ew, of_None, of_None, ctx);
								break;
							case 0x03:
								ReadCommand(cmLtr, of_Ew, of_None, of_None, ctx);
								break;
							case 0x04:
								ReadCommand(cmVerr, of_Ew, of_None, of_None, ctx);
								break;
							case 0x05:
								ReadCommand(cmVerw, of_Ew, of_None, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x01:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						if (code >= 0xc0) {
							switch (code) {
								case 0xc1:
									type_ = cmVmcall;
									break;
								case 0xc2:
									type_ = cmVmlaunch;
									break;
								case 0xc3:
									type_ = cmVmresume;
									break;
								case 0xc4:
									type_ = cmVmxoff;
									break;
								case 0xc8:
									type_ = cmMonitor;
									break;
								case 0xc9:
									type_ = cmMwait;
									break;
								case 0xd0:
									type_ = cmXgetbv;
									break;
								case 0xd1:
									type_ = cmXsetbv;
									break;
								case 0xd8:
									type_ = cmVmrun;
									break;
								case 0xd9:
									type_ = cmVmmcall;
									break;		
								case 0xda:
									type_ = cmVmload;
									break;
								case 0xdb:
									type_ = cmVmsave;
									break;
								case 0xdc:
									type_ = cmStgi;
									break;
								case 0xdd:
									type_ = cmClgi;
									break;
								case 0xde:
									type_ = cmSkinit;
									break;
								case 0xdf:
									type_ = cmInvlpga;
									break;
								case 0xf8:
									type_ = cmSwapgs;
									break;
								case 0xf9:
									type_ = cmRdtscp;
									break;
								default:
									type_ = cmDB;
									break;
							}
						} else {
							switch ((code >> 3) & 7) {
								case 0x00:
									ReadCommand(cmSgdt, of_Ms, of_None, of_None, ctx);
									break;
								case 0x01:
									ReadCommand(cmSidt, of_Ms, of_None, of_None, ctx);
									break;
								case 0x02:
									ReadCommand(cmLgdt, of_Ms, of_None, of_None, ctx);
									break;
								case 0x03:
									ReadCommand(cmLidt, of_Ms, of_None, of_None, ctx);
									break;
								case 0x04:
									ReadCommand(cmSmsw, of_Ev | of_mem_word, of_None, of_None, ctx);
									break;
								case 0x06:
									ReadCommand(cmLmsw, of_Ew, of_None, of_None, ctx);
									break;
								case 0x07:
									ReadCommand(cmInvlpg, of_Mb, of_None, of_None, ctx);
									break;
								default:
									type_ = cmDB;
									break;
							}
						}
						break;
					case 0x02:
						ReadCommand(cmLar, of_Gv, of_Ew, of_None, ctx);
						break;
					case 0x03:
						ReadCommand(cmLsl, of_Gv, of_Ew, of_None, ctx);
						break;
					case 0x05:
						type_ = cmSyscall;
						break;
					case 0x06:
						type_ = cmClts;
						break;
					case 0x07:
						type_ = cmSysret;
						break;
					case 0x08:
						type_ = cmInvd;
						break;
					case 0x09:
						type_ = cmWbinvd;
						break;
					case 0x0b:
						type_ = cmUd2;
						break;
					case 0x0d:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						switch ((code >> 3) & 7) {
							case 0x00:
								ReadCommand(cmPrefetch, of_Mb, of_None, of_None, ctx);
								break;
							case 0x01:
								ReadCommand(cmPrefetchw, of_Mb, of_None, of_None, ctx);
								break;
							default:
								ReadCommand(cmPrefetch, of_Mb, of_None, of_None, ctx);
								break;
						}
						break;
					case 0x0e:
						type_ = cmFemms;
						break;
					case 0x10:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovups, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovupd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovsd, of_Vdq, of_Wq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovss, of_Vdq, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x11:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovups, of_Wdef, of_Vdef, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovupd, of_Wdef, of_Vdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovsd, of_Wq, of_Vdq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovss, of_Wd, of_Vdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x12:
						switch (prefix) {
							case 0x00:
								code = ReadByte(file);
								ctx.use_last_byte = true;
								if ((code & 0xc0) == 0xc0) {
									vex_operand_index = 1;
									ReadCommand(cmMovhlps, of_Vdq, of_Udq, of_None, ctx);
								} else {
									vex_operand_index = 1;
									ReadCommand(cmMovlps, of_Vdq, of_Mq, of_None, ctx);
								}
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmMovlpd, of_Vdq, of_Mq, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovddup, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovsldup, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x13:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovlps, of_Mq, of_Vdq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovlpd, of_Mq, of_Vdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x14:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmUnpcklps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmUnpcklpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x15:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmUnpckhps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmUnpckhpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x16:
						switch (prefix) {
							case 0x00:
								code = ReadByte(file);
								ctx.use_last_byte = true;
								if ((code & 0xc0) == 0xc0) {
									ReadCommand(cmMovlhps, of_Vdq, of_Udq, of_None, ctx);
								} else {
									ReadCommand(cmMovhps, of_Vdq, of_Mq, of_None, ctx);
								}
								break;
							case 0x66:
								ReadCommand(cmMovhpd, of_Vdq, of_Mq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovshdup, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x17:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovhps, of_Mq, of_Vdq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovhpd, of_Mq, of_Vdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x18:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						switch ((code >> 3) & 7) {
							case 0x00:
								ReadCommand(cmPrefetchnta, of_Mb, of_None, of_None, ctx);
								break;
							case 0x01:
								ReadCommand(cmPrefetcht0, of_Mb, of_None, of_None, ctx);
								break;
							case 0x02:
								ReadCommand(cmPrefetcht1, of_Mb, of_None, of_None, ctx);
								break;
							case 0x03:
								ReadCommand(cmPrefetcht2, of_Mb, of_None, of_None, ctx);
								break;
							default:
								type_ = cmNop;
								break;
						}
						break;
					case 0x19: case 0x1a: case 0x1b: case 0x1c: case 0x1d: case 0x1e: case 0x1f:
						ReadCommand(cmNop, of_Ev, of_None, of_None, ctx);
						break;
					case 0x20:
						ReadCommand(cmMov, of_Rcpu, of_Ccpu, of_None, ctx);
						break;
					case 0x21:
						ReadCommand(cmMov, of_Rcpu, of_Dcpu, of_None, ctx);
						break;
					case 0x22:
						ReadCommand(cmMov, of_Ccpu, of_Rcpu, of_None, ctx);
						break;
					case 0x23:
						ReadCommand(cmMov, of_Dcpu, of_Rcpu, of_None, ctx);
						break;
					case 0x28:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovaps, of_Vdq, of_Wdq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovapd, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x29:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovaps, of_Wdq, of_Vdq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovapd, of_Wdq, of_Vdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x2a:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmCvtpi2ps, of_Vdq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmCvtpi2pd, of_Vdq, of_Qq, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmCvtsi2sd, of_Vdq, of_Ex, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmCvtsi2ss, of_Vdq, of_Ex, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x2b:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovntps, of_Mdef, of_Vdef, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovntpd, of_Mdef, of_Vdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovntsd, of_Mq, of_Vdq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovntss, of_Md, of_Vdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x2c:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmCvttps2pi, of_Pq, of_Wdq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmCvttpd2pi, of_Pq, of_Wdq, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								ReadCommand(cmCvttsd2si, of_Gx, of_Wq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmCvttss2si, of_Gx, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x2d:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmCvtps2pi, of_Pq, of_Wq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmCvtpd2pi, of_Pq, of_Wdq, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								ReadCommand(cmCvtsd2si, of_Gx, of_Wq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmCvtss2si, of_Gx, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x2e:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmUcomiss, of_Vdq, of_Wd, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmUcomisd, of_Vdq, of_Wq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x2f:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmComiss, of_Vdq, of_Wdq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmComisd, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x30:
						type_ = cmWrmsr;
						break;

					case 0x31:
						type_ = cmRdtsc;
						break;

					case 0x32:
						type_ = cmRdmsr;
						break;

					case 0x33:
						type_ = cmRdpmc;
						break;

					case 0x34:
						if (size_ == osQWord)
							type_ = cmDB;
						else
							type_ = cmSysenter;
						break;

					case 0x35:
						if (size_ == osQWord)
							type_ = cmDB;
						else
							type_ = cmSysexit;
						break;

					case 0x37:
						type_ = cmGetsec;
						break;

					case 0x38:
						code = ReadByte(file);
						switch (code) {
							case 0x00:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPshufb, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPshufb, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x01:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPhaddw, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPhaddw, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x02:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPhaddd, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPhaddd, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x03:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPhaddsw, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPhaddsw, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x04:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPmaddubsw, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPmaddubsw, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x05:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPhsubw, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPhsubw, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x06:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPhsubd, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPhsubd, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x07:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPhsubsw, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPhsubsw, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x08:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPsignb, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPsignb, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x09:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPsignw, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPsignw, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x0a:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPsignd, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPsignd, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x0b:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPmulhrsw, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPmulhrsw, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x0c:
								switch (prefix) {
									case 0x66:
										if (options() & roVexPrefix) {
											vex_operand_index = 1;
											ReadCommand(cmVpermilps, of_Vdef, of_Wdef, of_None, ctx);
										} else
											type_ = cmDB;
										break;
									default:
										type_ = cmDB;
										break;
									}
								break;
							case 0x0d:
								switch (prefix) {
									case 0x66:
										if (options() & roVexPrefix) {
											vex_operand_index = 1;
											ReadCommand(cmVpermilpd, of_Vdef, of_Wdef, of_None, ctx);
										} else
											type_ = cmDB;
										break;
									default:
										type_ = cmDB;
										break;
									}
								break;
							case 0x0e:
								switch (prefix) {
									case 0x66:
										if (options() & roVexPrefix)
											ReadCommand(cmVtestps, of_Vdef, of_Wdef, of_None, ctx);
										else
											type_ = cmDB;
										break;
									default:
										type_ = cmDB;
										break;
									}
								break;
							case 0x0f:
								switch (prefix) {
									case 0x66:
										if (options() & roVexPrefix)
											ReadCommand(cmVtestpd, of_Vdef, of_Wdef, of_None, ctx);
										else
											type_ = cmDB;
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x10:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPblendvb, of_Vdef, of_Wdef, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x14:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPblendps, of_Vdef, of_Wdef, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x15:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPblendpd, of_Vdef, of_Wdef, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x17:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPtest, of_Vdef, of_Wdef, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x18:
								switch (prefix) {
								case 0x66:
									ReadCommand(cmVbroadcastss, of_Vdef, of_Wd, of_None, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x19:
								switch (prefix) {
								case 0x66:
									if (ctx.rex_prefix & 0x80)
										ReadCommand(cmVbroadcastsd, of_Vdef, of_Wq, of_None, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x1a:
								switch (prefix) {
								case 0x66:
									if (ctx.rex_prefix & 0x80)
										ReadCommand(cmVbroadcastf128, of_Vdef, of_Wdq, of_None, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x1c:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPabsb, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPabsb, of_Vdef, of_Wdef, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x1d:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPabsw, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPabsw, of_Vdef, of_Wdef, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x1e:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPabsd, of_Pq, of_Qq, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPabsd, of_Vdef, of_Wdef, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x20:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmovsxbw, of_Vdef, of_Wq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x21:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmovsxbd, of_Vdef, of_Wd, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x22:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmovsxbq, of_Vdef, of_Ww, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x23:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmovsxwd, of_Vdef, of_Wq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x24:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmovsxwq, of_Vdef, of_Wd, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x25:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmovsxdq, of_Vdef, of_Wq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x28:
								switch (prefix) {
									case 0x66:
										vex_operand_index = 1;
										ReadCommand(cmPmuldq, of_Vdef, of_Wdef, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x29:
								switch (prefix) {
									case 0x66:
										vex_operand_index = 1;
										ReadCommand(cmPcmpeqq, of_Vdef, of_Wdef, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x2a:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmMovntdqa, of_Vdef, of_Mdef, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x2b:
								switch (prefix) {
									case 0x66:
										vex_operand_index = 1;
										ReadCommand(cmPackusdw, of_Vdef, of_Wdef, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x2c:
								switch (prefix) {
								case 0x66:
									vex_operand_index = 1;
									ReadCommand(cmMaskmovps, of_Vdef, of_Mdef, of_None, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x2d:
								switch (prefix) {
								case 0x66:
									vex_operand_index = 1;
									ReadCommand(cmMaskmovpd, of_Vdef, of_Mdef, of_None, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x2e:
								switch (prefix) {
								case 0x66:
									vex_operand_index = 1;
									ReadCommand(cmMaskmovps, of_Mdef, of_Vdef, of_None, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x2f:
								switch (prefix) {
								case 0x66:
									vex_operand_index = 1;
									ReadCommand(cmMaskmovpd, of_Mdef, of_Vdef, of_None, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x30:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmovzxbw, of_Vdq, of_Wq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x31:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmovzxbd, of_Vdq, of_Wd, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x32:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmovzxbq, of_Vdq, of_Ww, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x33:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmovzxwd, of_Vdq, of_Wq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x34:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmovzxwq, of_Vdq, of_Wd, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x35:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmovzxdq, of_Vdq, of_Wq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x37:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPcmpgtq, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x38:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPminsb, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x39:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPminsd, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x3a:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPminuw, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x3b:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPminud, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x3c:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmaxsb, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x3d:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmaxsd, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x3e:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmaxuw, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x3f:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPmaxud, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x40:
								switch (prefix) {
								case 0x66:
									ReadCommand(cmPmulld, of_Vdq, of_Wdq, of_None, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;

							case 0x9d:
								switch (prefix) {
									case 0x66:
										vex_operand_index = 1;
										if (ctx.rex_prefix & rexW)
											ReadCommand(cmFnmadd132sd, of_Vdq, of_Wq, of_None, ctx);
										else
											ReadCommand(cmFnmadd132ss, of_Vdq, of_Wd, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;

							case 0xad:
								switch (prefix) {
									case 0x66:
										vex_operand_index = 1;
										if (ctx.rex_prefix & rexW)
											ReadCommand(cmFnmadd213sd, of_Vdq, of_Wq, of_None, ctx);
										else
											ReadCommand(cmFnmadd213ss, of_Vdq, of_Wd, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;

							case 0xbd:
								switch (prefix) {
									case 0x66:
										vex_operand_index = 1;
										if (ctx.rex_prefix & rexW)
											ReadCommand(cmFnmadd231sd, of_Vdq, of_Wq, of_None, ctx);
										else
											ReadCommand(cmFnmadd231ss, of_Vdq, of_Wd, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;

							case 0xdb:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmAesimc, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0xdc:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmAesenc, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0xdd:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmAesenclast, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0xde:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmAesdec, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0xdf:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmAesdeclast, of_Vdq, of_Wdq, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0xf0:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmMovbe, of_Gv, of_Mv, of_None, ctx);
										break;
									case 0xf2:
										preffix_command_ = cmUnknown;
										ReadCommand(cmCrc32, of_Gx, of_Mb | of_size, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0xf1:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmMovbe, of_Mv, of_Gv, of_None, ctx);
										break;
									case 0xf2:
										preffix_command_ = cmUnknown;
										ReadCommand(cmCrc32, of_Gx, of_Mv | of_size, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;

							// FIXME
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x3a:
						code = ReadByte(file);
						switch (code) {
							case 0x04:
								switch (prefix) {
								case 0x66:
									if (options() & roVexPrefix)
										ReadCommand(cmVpermilps, of_Vdef, of_Wdef, of_IBb, ctx);
									else
										type_ = cmDB;
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x05:
								switch (prefix) {
								case 0x66:
									if (options() & roVexPrefix)
										ReadCommand(cmVpermilpd, of_Vdef, of_Wdef, of_IBb, ctx);
									else
										type_ = cmDB;
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x06:
								switch (prefix) {
								case 0x66:
									if (options() & roVexPrefix) {
										vex_operand_index = 1;
										ReadCommand(cmVperm2f128, of_Vdef, of_Wdef, of_IBb, ctx);
									} else
										type_ = cmDB;
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x08:
								switch (prefix) {
								case 0x66:
									ReadCommand(cmRoundps, of_Vdef, of_Wdef, of_IBb, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x09:
								switch (prefix) {
								case 0x66:
									ReadCommand(cmRoundpd, of_Vdef, of_Wdef, of_IBb, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x0c:
								switch (prefix) {
								case 0x66:
									vex_operand_index = 1;
									ReadCommand(cmBlendps, of_Vdef, of_Wdef, of_IBb, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x0d:
								switch (prefix) {
								case 0x66:
									vex_operand_index = 1;
									ReadCommand(cmBlendpd, of_Vdef, of_Wdef, of_IBb, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x0e:
								switch (prefix) {
								case 0x66:
									ReadCommand(cmPblendw, of_Vdq, of_Wdq, of_IBb, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x0f:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPalignr, of_Pq, of_Qq, of_IBb, ctx);
										break;
									case 0x66:
										ReadCommand(cmPalignr, of_Vdq, of_Wdq, of_IBb, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x14:
								switch (prefix) {
								case 0x66:
									ReadCommand(cmPextrb, of_Ed, of_Vdq, of_IBb, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x16:
								switch (prefix) {
								case 0x66:
									if (ctx.rex_prefix & rexW)
										ReadCommand(cmPextrq, of_Eq, of_Vdq, of_IBb, ctx);
									else
										ReadCommand(cmPextrd, of_Ed, of_Vdq, of_IBb, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x18:
								switch (prefix) {
								case 0x66:
									vex_operand_index = 1;
									ReadCommand(cmInsertf128, of_Vdef, of_Wdq, of_IBb, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x19:
								switch (prefix) {
								case 0x66:
									ReadCommand(cmExtractf128, of_Wdq, of_Vqq, of_IBb, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x20:
								switch (prefix) {
									case 0x66:
										vex_operand_index = 1;
										ReadCommand(cmPinsrb, of_Vdq, of_Eb, of_IBb, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x22:
								switch (prefix) {
									case 0x66:
										vex_operand_index = 1;
										if (ctx.rex_prefix & rexW)
											ReadCommand(cmPinsrq, of_Vdq, of_Eq, of_IBb, ctx);
										else
											ReadCommand(cmPinsrd, of_Vdq, of_Ed, of_IBb, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x40:
								switch (prefix) {
								case 0x66:
									vex_operand_index = 1;
									ReadCommand(cmDpps, of_Vdef, of_Wdef, of_IBb, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x4a:
								switch (prefix) {
								case 0x66:
									vex_operand_index = 1;
									ReadCommand(cmBlendvps, of_Vdef, of_Wdef, of_Xdef, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x4b:
								switch (prefix) {
								case 0x66:
									vex_operand_index = 1;
									ReadCommand(cmBlendvpd, of_Vdef, of_Wdef, of_Xdef, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0x63:
								switch (prefix) {
								case 0x66:
									ReadCommand(cmPcmpistri, of_Vdq, of_Wdq, of_IBb, ctx);
									break;
								default:
									type_ = cmDB;
									break;
								}
								break;
							case 0xdf:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmAeskeygenassist, of_Vdq, of_Wdq, of_IBb, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							default:
								type_ = cmDB;
						}
						break;

					case 0x40: case 0x41: case 0x42: case 0x43: case 0x44: case 0x45: case 0x46: case 0x47:
					case 0x48: case 0x49: case 0x4a: case 0x4b: case 0x4c: case 0x4d: case 0x4e: case 0x4f:
						ReadFlags(code);
						ReadCommand(cmCmov, of_Gv, of_Ev, of_None, ctx);
						break;
					case 0x50:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovmskps, of_Gd, of_Udef, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovmskpd, of_Gd, of_Udef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x51:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmSqrtps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmSqrtpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								ReadCommand(cmSqrtsd, of_Vdq, of_Wq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmSqrtss, of_Vdq, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x52:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmRsqrtps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmRsqrtss, of_Vdq, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x53:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmRcpps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmRcpss, of_Vdq, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x54:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmAndps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmAndpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x55:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmAndnps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmAndnpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x56:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmOrps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmOrpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x57:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmXorps, of_Vdef, of_Wdq, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmXorpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x58:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmAddps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmAddpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmAddsd, of_Vdq, of_Wq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmAddss, of_Vdq, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x59:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmMulps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmMulpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmMulsd, of_Vdq, of_Wq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmMulss, of_Vdq, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x5a:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmCvtps2pd, of_Vdef, of_Wdq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmCvtpd2ps, of_Vdq, of_Wdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmCvtsd2ss, of_Vdq, of_Wq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmCvtss2sd, of_Vdq, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x5b:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmCvtdq2ps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmCvtps2dq, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmCvttps2dq, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x5c:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmSubps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmSubpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmSubsd, of_Vdq, of_Wq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmSubss, of_Vdq, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x5d:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmMinps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmMinpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmMinsd, of_Vdq, of_Wq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmMinss, of_Vdq, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x5e:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmDivps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmDivpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmDivsd, of_Vdq, of_Wq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmDivss, of_Vdq, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x5f:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmMaxps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmMaxpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmMaxsd, of_Vdq, of_Wq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmMaxss, of_Vdq, of_Wd, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x60:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPunpcklbw, of_Pq, of_Qd, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPunpcklbw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x61:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPunpcklwd, of_Pq, of_Qd, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPunpcklwd, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x62:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPunpckldq, of_Pq, of_Qd, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPunpckldq, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x63:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPacksswb, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPacksswb, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x64:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPcmpgtb, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPcmpgtb, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x65:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPcmpgtw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPcmpgtw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x66:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPcmpgtd, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPcmpgtd, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x67:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPackuswb, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPackuswb, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x68:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPunpckhbw, of_Pq, of_Qd, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPunpckhbw, of_Vdq, of_Wq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x69:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPunpckhwd, of_Pq, of_Qd, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPunpckhwd, of_Vdq, of_Wq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x6a:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPunpckhdq, of_Pq, of_Qd, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPunpckhdq, of_Vdq, of_Wq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x6b:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPackssdw, of_Pq, of_Qd, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPackssdw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x6c:
						switch (prefix) {
							case 0x66:
								ReadCommand(cmPunpcklqdq, of_Vdq, of_Wq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x6d:
						switch (prefix) {
							case 0x66:
								ReadCommand(cmPunpckhqdq, of_Vdq, of_Wq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x6e:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovd, of_Pq, of_Ex, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovd, of_Vdq, of_Ex, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x6f:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovq, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovdqa, of_Vdq, of_Wdq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovdqu, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x70:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPshufw, of_Pq, of_Qq, of_IBb, ctx);
								break;
							case 0x66:
								ReadCommand(cmPshufd, of_Vdq, of_Wdq, of_IBb, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								ReadCommand(cmPshuflw, of_Vdq, of_Wdq, of_IBb, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmPshufhw, of_Vdq, of_Wdq, of_IBb, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x71:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						switch ((code >> 3) & 7) {
							case 0x02:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPsrlw, of_Nq, of_IBb, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPsrlw, of_Udq, of_IBb, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x04:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPsraw, of_Nq, of_IBb, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPsraw, of_Udq, of_IBb, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x06:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPsllw, of_Nq, of_IBb, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPsllw, of_Udq, of_IBb, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x72:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						switch ((code >> 3) & 7) {
							case 0x02:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPsrld, of_Nq, of_IBb, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPsrld, of_Udq, of_IBb, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x04:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPsrad, of_Nq, of_IBb, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPsrad, of_Udq, of_IBb, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x06:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPslld, of_Nq, of_IBb, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPslld, of_Udq, of_IBb, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x73:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						switch ((code >> 3) & 7) {
							case 0x02:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPsrlq, of_Nq, of_IBb, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPsrlq, of_Udq, of_IBb, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x03:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPsrldq, of_Udq, of_IBb, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x06:
								switch (prefix) {
									case 0x00:
										ReadCommand(cmPsllq, of_Nq, of_IBb, of_None, ctx);
										break;
									case 0x66:
										ReadCommand(cmPsllq, of_Udq, of_IBb, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							case 0x07:
								switch (prefix) {
									case 0x66:
										ReadCommand(cmPslldq, of_Udq, of_IBb, of_None, ctx);
										break;
									default:
										type_ = cmDB;
										break;
								}
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x74:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPcmpeqb, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmPcmpeqb, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x75:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPcmpeqw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmPcmpeqw, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x76:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPcmpeqd, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmPcmpeqd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x77:
						if (prefix == 0)
							if (options() & roVexPrefix) {
								type_ = ctx.rex_prefix & 0x80 ? cmVzeroall : cmVzeroupper;
							}
							else {
								type_ = cmEmms;
							}
						else
							type_ = cmDB;
						break;

					case 0x78:
						/* Stick on Intel decoding here; ignore AMD. */
						if (prefix == 0) {
							type_ = cmVmread;
							os = size_;
							code = ReadByte(file);
							ReadRM(code, os, otRegistr, false, ctx);
							ReadRegFromRM(code, os, otRegistr, ctx);
						} else {
							type_ = cmDB;
						}
						break;

					case 0x79:
						/* Stick on Intel decoding here; ignore AMD. */
						if (prefix == 0) {
							type_ = cmVmwrite;
							os = size_;
							code = ReadByte(file);
							ReadRegFromRM(code, os, otRegistr, ctx);
							ReadRM(code, os, otRegistr, false, ctx);
						} else {
							type_ = cmDB;
						}
						break;

					case 0x7c:
						switch (prefix) {
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmHaddpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmHaddps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x7d:
						switch (prefix) {
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmHsubpd, of_Vdef, of_Wdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmHsubps, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x7e:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovd, of_Ex, of_Pq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovd, of_Ex, of_Vdq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovq, of_Vdq, of_Wq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0x7f:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovq, of_Qq, of_Pq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovdqa, of_Wdq, of_Vdq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovdqu, of_Wdef, of_Vdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0x80: case 0x81: case 0x82: case 0x83: case 0x84: case 0x85: case 0x86: case 0x87:
					case 0x88: case 0x89: case 0x8a: case 0x8b: case 0x8c: case 0x8d: case 0x8e: case 0x8f:
						ReadFlags(code);
						ReadCommand(cmJmpWithFlag, of_Jz, of_None, of_None, ctx);
						break;

					case 0x90: case 0x91: case 0x92: case 0x93: case 0x94: case 0x95: case 0x96: case 0x97:
					case 0x98: case 0x99: case 0x9a: case 0x9b: case 0x9c: case 0x9d: case 0x9e: case 0x9f:
						ReadFlags(code);
						ReadCommand(cmSetXX, of_Eb, of_None, of_None, ctx);
						break;
					case 0xa0:
						ReadCommand(cmPush, of_FSdef | segFS, of_None, of_None, ctx);
						break;
					case 0xa1:
						ReadCommand(cmPop, of_FSdef | segFS, of_None, of_None, ctx);
						break;
					case 0xa2:
						type_ = cmCpuid;
						break;
					case 0xa3:
						ReadCommand(cmBt, of_Ev, of_Gv, of_None, ctx);
						break;
					case 0xa4:
						ReadCommand(cmShld, of_Ev, of_Gv, of_IBb, ctx);
						break;
					case 0xa5:
						ReadCommand(cmShld, of_Ev, of_Gv, of_FGb | regECX, ctx);
						break;
					case 0xa8:
						ReadCommand(cmPush, of_FSdef | segGS, of_None, of_None, ctx);
						break;
					case 0xa9:
						ReadCommand(cmPop, of_FSdef | segGS, of_None, of_None, ctx);
						break;
					case 0xaa:
						type_ = cmRsm;
						break;
					case 0xab:
						ReadCommand(cmBts, of_Ev, of_Gv, of_None, ctx);
						break;
					case 0xac:
						ReadCommand(cmShrd, of_Ev, of_Gv, of_IBb, ctx);
						break;
					case 0xad:
						ReadCommand(cmShrd, of_Ev, of_Gv, of_FGb | regECX, ctx);
						break;
					case 0xae:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						switch ((code >> 3) & 7) {
							case 0x00:
								ReadCommand(cmFxsave, of_M, of_None, of_None, ctx);
								break;
							case 0x01:
								ReadCommand(cmFxrstor, of_M, of_None, of_None, ctx);
								break;
							case 0x02:
								ReadCommand(cmLdmxcsr, of_Md, of_None, of_None, ctx);
								break;
							case 0x03:
								ReadCommand(cmStmxcsr, of_Md, of_None, of_None, ctx);
								break;
							case 0x04:
								ReadCommand(cmXsave, of_M, of_None, of_None, ctx);
								break;
							case 0x05:
								if ((code & 0xc0) == 0xc0) {
									type_ = cmLfence;
								} else {
									ReadCommand(cmXrstor, of_M, of_None, of_None, ctx);
								}
								break;
							case 0x06:
								if ((code & 0xc0) == 0xc0) {
									type_ = cmMfence;
								} else {
									ReadCommand(cmXsaveopt, of_M, of_None, of_None, ctx);
								}
								break;
							case 0x07:
								if ((code & 0xc0) == 0xc0) {
									type_ = cmSfence;
								} else {
									ReadCommand(cmClflush, of_M, of_None, of_None, ctx);
								}
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xaf:
						ReadCommand(cmImul, of_Gv, of_Ev, of_None, ctx);
						break;
					case 0xb0:
						ReadCommand(cmCmpxchg, of_Eb, of_Gb, of_None, ctx);
						break;
					case 0xb1:
						ReadCommand(cmCmpxchg, of_Ev, of_Gv, of_None, ctx);
						break;
					case 0xb2:
						ReadCommand(cmLss, of_Gz, of_Mp, of_None, ctx);
						break;
					case 0xb3:
						ReadCommand(cmBtr, of_Ev, of_Gv, of_None, ctx);
						break;
					case 0xb4:
						ReadCommand(cmLfs, of_Gz, of_Mp, of_None, ctx);
						break;
					case 0xb5:
						ReadCommand(cmLgs, of_Gz, of_Mp, of_None, ctx);
						break;
					case 0xb6:
						ReadCommand(cmMovzx, of_Gv, of_Eb | of_size, of_None, ctx);
						break;
					case 0xb7:
						ReadCommand(cmMovzx, of_Gv, of_Ew | of_size, of_None, ctx);
						break;
					case 0xb8:
						switch (prefix) {
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmPopcnt, of_Gv, of_Ev, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xb9:
						switch (prefix) {
							case 0x00:
							case 0x66:
								type_ = cmUd1;
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xba:
						if (prefix == 0 || prefix == 0x66) {
							code = ReadByte(file);
							ctx.use_last_byte = true;
							switch ((code >> 3) & 7) { 
								case 0x04:
									ReadCommand(cmBt, of_Ev | of_size, of_IBb, of_None, ctx);
									break;
								case 0x05:
									ReadCommand(cmBts, of_Ev | of_size, of_IBb, of_None, ctx);
									break;
								case 0x06:
									ReadCommand(cmBtr, of_Ev | of_size, of_IBb, of_None, ctx);
									break;
								case 0x07:
									ReadCommand(cmBtc, of_Ev | of_size, of_IBb, of_None, ctx);
									break;
								default:
									type_ = cmDB;
									break;
							}
						} else {
							type_ = cmDB;
						}
						break;

					case 0xbb:
						switch (prefix) {
							case 0x00:
							case 0x66:
								ReadCommand(cmBtc, of_Ev, of_Gv, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0xbc:
						switch (prefix) {
							case 0x00:
							case 0x66:
								ReadCommand(cmBsf, of_Gv, of_Ev, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmTzcnt, of_Gv, of_Ev, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xbd:
						switch (prefix) {
							case 0x00:
							case 0x66:
								ReadCommand(cmBsr, of_Gv, of_Ev, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmLzcnt, of_Gv, of_Ev, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xbe:
						switch (prefix) {
							case 0x00:
							case 0x66:
								ReadCommand(cmMovsx, of_Gv, of_Eb | of_size, of_None, ctx);
								break;
							default:
								type_ = cmDB;
						}
						break;
					case 0xbf:
						switch (prefix) {
							case 0x00:
							case 0x66:
								ReadCommand(cmMovsx, of_Gv, of_Ew | of_size, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xc0:
						ReadCommand(cmXadd, of_Eb, of_Gb, of_None, ctx);
						break;
					case 0xc1:
						ReadCommand(cmXadd, of_Ev, of_Gv, of_None, ctx);
						break;
					case 0xc2:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmCmpps, of_Vdef, of_Wdef, of_IBb, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmCmppd, of_Vdef, of_Wdef, of_IBb, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmCmpsd, of_Vdq, of_Wq, of_IBb, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								vex_operand_index = 1;
								ReadCommand(cmCmpss, of_Vdq, of_Wd, of_IBb, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0xc3:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovnti, of_Mx, of_Gx, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0xc4:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPinsrw, of_Pq, of_Ew | of_size, of_IBb, ctx);
								break;
							case 0x66:
								ReadCommand(cmPinsrw, of_Vdq, of_Ew | of_size, of_IBb, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0xc5:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPextrw, of_Gd, of_Nq, of_IBb, ctx);
								break;
							case 0x66:
								ReadCommand(cmPextrw, of_Gd, of_Udq, of_IBb, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0xc6:
						switch (prefix) {
							case 0x00:
								vex_operand_index = 1;
								ReadCommand(cmShufps, of_Vdef, of_Wdef, of_IBb, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmShufpd, of_Vdef, of_Wdef, of_IBb, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0xc7:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						switch ((code >> 3) & 7) { 
							case 0x01:
								ReadCommand(cmCmpxchg8b, of_Mq, of_None, of_None, ctx);
								break;
							case 0x06:
								if (code && 0xc0 == 0xc0)
									ReadCommand(cmRdrand, of_Zv | code, of_None, of_None, ctx);
								else
									ReadCommand(cmVmptrld, of_Mq, of_None, of_None, ctx);
								break;
							case 0x07:
								if (code && 0xc0 == 0xc0)
									ReadCommand(cmRdseed, of_Zv | code, of_None, of_None, ctx);
								else
									ReadCommand(cmVmptrst, of_Mq, of_None, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0xc8: case 0xc9: case 0xca: case 0xcb: case 0xcc: case 0xcd: case 0xce: case 0xcf:
						ReadCommand(cmBswap, of_Zv | code, of_None, of_None, ctx);
						break;
					case 0xd0:
						switch (prefix) {
							case 0x66:
								ReadCommand(cmAddsubpd, of_Vdq, of_Wdq, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								ReadCommand(cmAddsubps, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xd1:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsrlw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsrlw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xd2:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsrld, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsrld, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xd3:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsrlq, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsrlq, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xd4:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPaddq, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPaddq, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xd5:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPmullw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPmullw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xd6:
						switch (prefix) {
							case 0x66:
								ReadCommand(cmMovq, of_Wq, of_Vdq, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovdq2q, of_Pq, of_Udq, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmMovq2dq, of_Vdq, of_Nq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xd7:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPmovmskb, of_Gd, of_Nq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPmovmskb, of_Gd, of_Udq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xd8:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsubusb, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsubusb, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xd9:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsubusw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsubusw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xda:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPminub, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPminub, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xdb:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPand, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPand, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xdc:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPaddusb, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPaddusb, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xdd:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPaddusw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPaddusw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xde:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPmaxub, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPmaxub, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xdf:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPandn, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPandn, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xe0:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPavgb, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPavgb, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xe1:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsraw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsraw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xe2:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsrad, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsrad, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xe3:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPavgw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPavgw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xe4:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPmulhuw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPmulhuw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xe5:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPmulhw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPmulhw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xe6:
						switch (prefix) {
							case 0x66:
								ReadCommand(cmCvttpd2dq, of_Vdq, of_Wdef, of_None, ctx);
								break;
							case 0xF2:
								preffix_command_ = cmUnknown;
								ReadCommand(cmCvtpd2dq, of_Vdq, of_Wdef, of_None, ctx);
								break;
							case 0xF3:
								preffix_command_ = cmUnknown;
								ReadCommand(cmCvtdq2pd, of_Vdef, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xe7:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMovntq, of_Mq, of_Pq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMovntdq, of_Mdq, of_Vdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xe8:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsubsb, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsubsb, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xe9:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsubsw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsubsw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xea:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPminsw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPminsw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xeb:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPor, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPor, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xec:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPaddsb, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPaddsb, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xed:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPaddsw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPaddsw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xee:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPmaxsw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPmaxsw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xef:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPxor, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								vex_operand_index = 1;
								ReadCommand(cmPxor, of_Vdef, of_Wdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0xf0:
						switch (prefix) {
							case 0xF2:
								preffix_command_ = cmUnknown;
								ReadCommand(cmLddqu, of_Vdef, of_Mdef, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;

					case 0xf1:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsllw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsllw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xf2:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPslld, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPslld, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xf3:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsllq, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsllq, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xf4:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPmuludq, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPmuludq, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xf5:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPmaddwd, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPmaddwd, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xf6:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsadbw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsadbw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xf7:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmMaskmovq, of_Pq, of_Nq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmMaskmovdqu, of_Vdq, of_Udq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xf8:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsubb, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsubb, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xf9:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsubw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsubw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xfa:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsubd, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsubd, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xfb:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPsubq, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPsubq, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xfc:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPaddb, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPaddb, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xfd:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPaddw, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPaddw, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xfe:
						switch (prefix) {
							case 0x00:
								ReadCommand(cmPaddd, of_Pq, of_Qq, of_None, ctx);
								break;
							case 0x66:
								ReadCommand(cmPaddd, of_Vdq, of_Wdq, of_None, ctx);
								break;
							default:
								type_ = cmDB;
								break;
						}
						break;
					case 0xff:
						type_ = cmUd0;
						break;

					default:
						type_ = cmDB;
						break;
			}
			break;

			// End

			case 0x10:
				ReadCommand(cmAdc, of_Eb, of_Gb, of_None, ctx);
				break;
			case 0x11:
				ReadCommand(cmAdc, of_Ev, of_Gv, of_None, ctx);
				break;
			case 0x12:
				ReadCommand(cmAdc, of_Gb, of_Eb, of_None, ctx);
				break;
			case 0x13:
				ReadCommand(cmAdc, of_Gv, of_Ev, of_None, ctx);
				break;
			case 0x14:
				ReadCommand(cmAdc, of_FGb | regEAX, of_IBb, of_None, ctx);
				break;
			case 0x15:
				ReadCommand(cmAdc, of_FGv | regEAX, of_IZv, of_None, ctx);
				break;
			case 0x16:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					ReadCommand(cmPush, of_FSdef | segSS, of_None, of_None, ctx);
				}
				break;
			case 0x17:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					ReadCommand(cmPop, of_FSdef | segSS, of_None, of_None, ctx);
				}
				break;
			case 0x18:
				ReadCommand(cmSbb, of_Eb, of_Gb, of_None, ctx);
				break;
			case 0x19:
				ReadCommand(cmSbb, of_Ev, of_Gv, of_None, ctx);
				break;
			case 0x1a:
				ReadCommand(cmSbb, of_Gb, of_Eb, of_None, ctx);
				break;
			case 0x1b:
				ReadCommand(cmSbb, of_Gv, of_Ev, of_None, ctx);
				break;
			case 0x1c:
				ReadCommand(cmSbb, of_FGb | regEAX, of_IBb, of_None, ctx);
				break;
			case 0x1d: 
				ReadCommand(cmSbb, of_FGv | regEAX, of_IZv, of_None, ctx);
				break;
			case 0x1e:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					ReadCommand(cmPush, of_FSdef | segDS, of_None, of_None, ctx);
				}
				break;
			case 0x1f:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					ReadCommand(cmPop, of_FSdef | segDS, of_None, of_None, ctx);
				}
				break;
			case 0x20:
				ReadCommand(cmAnd, of_Eb, of_Gb, of_None, ctx);
				break;
			case 0x21:
				ReadCommand(cmAnd, of_Ev, of_Gv, of_None, ctx);
				break;
			case 0x22:
				ReadCommand(cmAnd, of_Gb, of_Eb, of_None, ctx);
				break;
			case 0x23:
				ReadCommand(cmAnd, of_Gv, of_Ev, of_None, ctx);
				break;
			case 0x24:
				ReadCommand(cmAnd, of_FGb | regEAX, of_IBb, of_None, ctx);
				break;
			case 0x25:
				ReadCommand(cmAnd, of_FGv | regEAX, of_IZv, of_None, ctx);
				break;
			case 0x26:
				base_segment_ = segES;
				ctx.rex_prefix = 0;
				break;
			case 0x27:
				type_ = (size_ == osQWord) ? cmDB : cmDaa;
				break;
			case 0x28:
				ReadCommand(cmSub, of_Eb, of_Gb, of_None, ctx);
				break;
			case 0x29:
				ReadCommand(cmSub, of_Ev, of_Gv, of_None, ctx);
				break;
			case 0x2a:
				ReadCommand(cmSub, of_Gb, of_Eb, of_None, ctx);
				break;
			case 0x2b:
				ReadCommand(cmSub, of_Gv, of_Ev, of_None, ctx);
				break;
			case 0x2c:
				ReadCommand(cmSub, of_FGb | regEAX, of_IBb, of_None, ctx);
				break;
			case 0x2d:
				ReadCommand(cmSub, of_FGv | regEAX, of_IZv, of_None, ctx);
				break;
			case 0x2e:
				base_segment_ = segCS; ctx.rex_prefix = 0;
				break;
			case 0x2f:
				type_ = (size_ == osQWord) ? cmDB : cmDas;
				break;
			case 0x30:
				ReadCommand(cmXor, of_Eb, of_Gb, of_None, ctx);
				break;
			case 0x31:
				ReadCommand(cmXor, of_Ev, of_Gv, of_None, ctx);
				break;
			case 0x32:
				ReadCommand(cmXor, of_Gb, of_Eb, of_None, ctx);
				break;
			case 0x33:
				ReadCommand(cmXor, of_Gv, of_Ev, of_None, ctx);
				break;
			case 0x34:
				ReadCommand(cmXor, of_FGb | regEAX, of_IBb, of_None, ctx);
				break;
			case 0x35:
				ReadCommand(cmXor, of_FGv | regEAX, of_IZv, of_None, ctx);
				break;
			case 0x36:
				base_segment_ = segSS;
				ctx.rex_prefix = 0;
				break;
			case 0x37:
				type_ = (size_ == osQWord) ? cmDB : cmAaa;
				break;
			case 0x38:
				ReadCommand(cmCmp, of_Eb, of_Gb, of_None, ctx);
				break;
			case 0x39:
				ReadCommand(cmCmp, of_Ev, of_Gv, of_None, ctx);
				break;
			case 0x3a:
				ReadCommand(cmCmp, of_Gb, of_Eb, of_None, ctx);
				break;
			case 0x3b:
				ReadCommand(cmCmp, of_Gv, of_Ev, of_None, ctx);
				break;
			case 0x3c:
				ReadCommand(cmCmp, of_FGb | regEAX, of_IBb, of_None, ctx);
				break;
			case 0x3d:
				ReadCommand(cmCmp, of_FGv | regEAX, of_IZv, of_None, ctx);
				break;
			case 0x3e:
				base_segment_ = segDS;
				ctx.rex_prefix = 0;
				break;
			case 0x3f:
				type_ = (size_ == osQWord) ? cmDB : cmAas;
				break;
			case 0x40: case 0x41: case 0x42: case 0x43: case 0x44: case 0x45: case 0x46: case 0x47:
				if (size_ == osQWord) {
					ctx.rex_prefix = code;
				} else {
					ReadCommand(cmInc, of_Zdef | code, of_None, of_None, ctx);
				}
				break;
			case 0x48: case 0x49: case 0x4a: case 0x4b: case 0x4c: case 0x4d: case 0x4e: case 0x4f:
				if (size_ == osQWord) {
					ctx.rex_prefix = code;
				} else {
					ReadCommand(cmDec, of_Zdef | code, of_None, of_None, ctx);
				}
				break;
			case 0x50: case 0x51: case 0x52: case 0x53: case 0x54: case 0x55: case 0x56: case 0x57:
				ReadCommand(cmPush, of_Zdef | code, of_None, of_None, ctx);
				break;
			case 0x58: case 0x59: case 0x5a: case 0x5b: case 0x5c: case 0x5d: case 0x5e: case 0x5f:
				ReadCommand(cmPop, of_Zdef | code, of_None, of_None, ctx);
				break;
			case 0x60:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					ReadCommand(cmPusha, of_def, of_None, of_None, ctx);
				}
				break;
			case 0x61:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					ReadCommand(cmPopa, of_def, of_None, of_None, ctx);
				}
				break;
			case 0x62:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					ReadCommand(cmBound, of_Gv, of_Ma, of_None, ctx);
				}
				break;
			case 0x63:
				if (size_ == osQWord) {
					ReadCommand(cmMovsxd, of_Gv, of_Ed | of_size, of_None, ctx);
				} else {
					ReadCommand(cmArpl, of_Ew, of_Gw, of_None, ctx);
				}
				break;
			case 0x64:
				base_segment_ = segFS;
				ctx.rex_prefix = 0;
				break;
			case 0x65:
				base_segment_ = segGS;
				ctx.rex_prefix = 0;
				break;
			case 0x66:
				ctx.lower_reg = true;
				if (prefix == 0)
					prefix = code;
				break;
			case 0x67:
				ctx.lower_address = true;
				break;
			case 0x68:
				ReadCommand(cmPush, of_IZ | of_def, of_None, of_None, ctx);
				break;
			case 0x69:
				ReadCommand(cmImul, of_Gv, of_Ev, of_IZv, ctx);
				break;
			case 0x6a:
				ReadCommand(cmPush, of_IB | of_def, of_None, of_None, ctx);
				break;
			case 0x6b:
				ReadCommand(cmImul, of_Gv, of_Ev, of_IBv, ctx);
				break;
			case 0x6c:
				ReadCommand(cmIns, of_b, of_adr, of_None, ctx);
				break;
			case 0x6d:
				ReadCommand(cmIns, of_z, of_adr, of_None, ctx);
				break;
			case 0x6e:
				ReadCommand(cmOuts, of_b, of_adr, of_None, ctx);
				break;
			case 0x6f:
				ReadCommand(cmOuts, of_z, of_adr, of_None, ctx);
				break;
			case 0x70: case 0x71: case 0x72: case 0x73: case 0x74: case 0x75: case 0x76: case 0x77:
			case 0x78: case 0x79: case 0x7a: case 0x7b: case 0x7c: case 0x7d: case 0x7e: case 0x7f:
				ReadFlags(code);
				ReadCommand(cmJmpWithFlag, of_Jb, of_adr, of_None, ctx);
				break;
			case 0x80:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmAdd, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x01:
						ReadCommand(cmOr, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x02:
						ReadCommand(cmAdc, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x03:
						ReadCommand(cmSbb, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x04:
						ReadCommand(cmAnd, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x05:
						ReadCommand(cmSub, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x06:
						ReadCommand(cmXor, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x07:
						ReadCommand(cmCmp, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0x81:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmAdd, of_Ev | of_size, of_IZv, of_None, ctx);
						break;
					case 0x01:
						ReadCommand(cmOr, of_Ev | of_size, of_IZv, of_None, ctx);
						break;
					case 0x02:
						ReadCommand(cmAdc, of_Ev | of_size, of_IZv, of_None, ctx);
						break;
					case 0x03:
						ReadCommand(cmSbb, of_Ev | of_size, of_IZv, of_None, ctx);
						break;
					case 0x04:
						ReadCommand(cmAnd, of_Ev | of_size, of_IZv, of_None, ctx);
						break;
					case 0x05:
						ReadCommand(cmSub, of_Ev | of_size, of_IZv, of_None, ctx);
						break;
					case 0x06:
						ReadCommand(cmXor, of_Ev | of_size, of_IZv, of_None, ctx);
						break;
					case 0x07:
						ReadCommand(cmCmp, of_Ev | of_size, of_IZv, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0x82:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					code = ReadByte(file);
					ctx.use_last_byte = true;
					switch ((code >> 3) & 7) {
						case 0x00:
							ReadCommand(cmAdd, of_Eb | of_size, of_IBb, of_None, ctx);
							break;
						case 0x01:
							ReadCommand(cmOr, of_Eb | of_size, of_IBb, of_None, ctx);
							break;
						case 0x02:
							ReadCommand(cmAdc, of_Eb | of_size, of_IBb, of_None, ctx);
							break;
						case 0x03:
							ReadCommand(cmSbb, of_Eb | of_size, of_IBb, of_None, ctx);
							break;
						case 0x04:
							ReadCommand(cmAnd, of_Eb | of_size, of_IBb, of_None, ctx);
							break;
						case 0x05:
							ReadCommand(cmSub, of_Eb | of_size, of_IBb, of_None, ctx);
							break;
						case 0x06:
							ReadCommand(cmXor, of_Eb | of_size, of_IBb, of_None, ctx);
							break;
						case 0x07:
							ReadCommand(cmCmp, of_Eb | of_size, of_IBb, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				}
				break;
			case 0x83:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmAdd, of_Ev | of_size, of_IBv, of_None, ctx);
						break;
					case 0x01:
						ReadCommand(cmOr, of_Ev | of_size, of_IBv, of_None, ctx);
						break;
					case 0x02:
						ReadCommand(cmAdc, of_Ev | of_size, of_IBv, of_None, ctx);
						break;
					case 0x03:
						ReadCommand(cmSbb, of_Ev | of_size, of_IBv, of_None, ctx);
						break;
					case 0x04:
						ReadCommand(cmAnd, of_Ev | of_size, of_IBv, of_None, ctx);
						break;
					case 0x05:
						ReadCommand(cmSub, of_Ev | of_size, of_IBv, of_None, ctx);
						break;
					case 0x06:
						ReadCommand(cmXor, of_Ev | of_size, of_IBv, of_None, ctx);
						break;
					case 0x07:
						ReadCommand(cmCmp, of_Ev | of_size, of_IBv, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0x84:
				ReadCommand(cmTest, of_Eb, of_Gb, of_None, ctx);
				break;
			case 0x85:
				ReadCommand(cmTest, of_Ev, of_Gv, of_None, ctx);
				break;
			case 0x86:
				ReadCommand(cmXchg, of_Eb, of_Gb, of_None, ctx);
				break;
			case 0x87:
				ReadCommand(cmXchg, of_Ev, of_Gv, of_None, ctx);
				break;
			case 0x88:
				ReadCommand(cmMov, of_Eb, of_Gb, of_None, ctx);
				break;
			case 0x89:
				ReadCommand(cmMov, of_Ev, of_Gv, of_None, ctx);
				break;
			case 0x8a:
				ReadCommand(cmMov, of_Gb, of_Eb, of_None, ctx);
				break;
			case 0x8b:
				ReadCommand(cmMov, of_Gv, of_Ev, of_None, ctx);
				break;
			case 0x8c:
				ReadCommand(cmMov, of_Ev | of_mem_word, of_Sw, of_None, ctx);
				break;
			case 0x8d:
				ReadCommand(cmLea, of_Gv, of_Mv, of_None, ctx);
				break;
			case 0x8e:
				ReadCommand(cmMov, of_Sw, of_Ew, of_None, ctx);
				break;
			case 0x8f:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmPop, of_Edef | of_size, of_None, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0x90:
				if (prefix == 0xF3) {
					preffix_command_ = cmUnknown;
					type_ = cmPause;
				} else {
					if (size_ == osQWord && (ctx.rex_prefix & rexB) != 0) {
						ReadCommand(cmXchg, of_Zv | regEAX, of_FGv | regEAX, of_None, ctx);
					} else {
						type_ = cmNop;
					}
				}
				break;
			case 0x91: case 0x92: case 0x93: case 0x94: case 0x95: case 0x96: case 0x97:
				ReadCommand(cmXchg, of_Zv | code, of_FGv | regEAX, of_None, ctx);
				break;
			case 0x98:
				os = GetOperandSize(1, ctx);
				switch (os) {
					case osWord:
						type_ = cmCbw;
						break;
					case osDWord:
						type_ = cmCwde;
						break;
					default:
						type_ = cmCdqe;
						break;
				}
				break;
			case 0x99:
				os = GetOperandSize(1, ctx);
				switch (os) {
					case osWord:
						type_ = cmCwd;
						break;
					case osDWord:
						type_ = cmCdq;
						break;
					default:
						type_ = cmCqo;
						break;
				}
				break;
			case 0x9a:
				if (size_ == osQWord) 
					type_ = cmDB;
				else {
					include_option(roFar);
					ReadCommand(cmCall, of_Ap, of_None, of_None, ctx);
				}
				break;
			case 0x9b:
				type_ = cmWait;
				{
					Data old_dump;
					for (i = 0; i < dump_size(); i++) {
						old_dump.PushByte(dump(i));
					}
					uint64_t pos = file.Tell();
					code = ReadByte(file);
					switch (code) {
					case 0xd9:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						if ((code & 0xc0) != 0xc0) {
							switch ((code >> 3) & 7) {
							case 0x06:
								ReadCommand(cmFstenv, of_Mb, of_None, of_None, ctx);
								break;
							case 0x07:
								ReadCommand(cmFstcw, of_Mw | of_size, of_None, of_None, ctx);
								break;
							}
						}
						break;
					case 0xdb:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						switch (code) {
						case 0xe2:
							type_ = cmFclex;
							break;
						case 0xe3:
							type_ = cmFinit;
							break;
						}
						break;
					case 0xdd:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						if ((code & 0xc0) != 0xc0) {
							switch ((code >> 3) & 7) {
							case 0x06:
								ReadCommand(cmFsave, of_Mb, of_None, of_None, ctx);
								break;
							case 0x07:
								ReadCommand(cmFstsw, of_Mw | of_size, of_None, of_None, ctx);
								break;
							}
						}
						break;
					case 0xdf:
						code = ReadByte(file);
						ctx.use_last_byte = true;
						if (code == 0xe0)
							ReadCommand(cmFstsw, of_FGw | regEAX, of_None, of_None, ctx);
						break;
					}
					if (type_ == cmWait) {
						set_dump(old_dump.data(), old_dump.size());
						file.Seek(pos);
					}
				}
				break;
			case 0x9c:
				ReadCommand(cmPushf, of_def, of_None, of_None, ctx);
				break;
			case 0x9d:
				ReadCommand(cmPopf, of_def, of_None, of_None, ctx);
				break;
			case 0x9e:
				ReadCommand(cmSahf, of_b, of_None, of_None, ctx);
				break;
			case 0x9f:
				ReadCommand(cmLahf, of_b, of_None, of_None, ctx);
				break;
			case 0xa0:
				ReadCommand(cmMov, of_FGb | regEAX, of_Ob, of_None, ctx);
				break;
			case 0xa1:
				ReadCommand(cmMov, of_FGv | regEAX, of_Ov, of_None, ctx);
				break;
			case 0xa2:
				ReadCommand(cmMov, of_Ob, of_FGb | regEAX, of_None, ctx);
				break;
			case 0xa3:
				ReadCommand(cmMov, of_Ov, of_FGv | regEAX, of_None, ctx);
				break;
			case 0xa4:
				ReadCommand(cmMovs, of_b, of_adr, of_None, ctx);
				break;
			case 0xa5:
				ReadCommand(cmMovs, of_v, of_adr, of_None, ctx);
				break;
			case 0xa6:
				ReadCommand(cmCmps, of_b, of_adr, of_None, ctx);
				break;
			case 0xa7:
				ReadCommand(cmCmps, of_v, of_adr, of_None, ctx);
				break;
			case 0xa8:
				ReadCommand(cmTest, of_FGb | regEAX, of_IBb, of_None, ctx);
				break;
			case 0xa9:
				ReadCommand(cmTest, of_FGv | regEAX, of_IZv, of_None, ctx);
				break;
			case 0xaa:
				ReadCommand(cmStos, of_b, of_adr, of_None, ctx);
				break;
			case 0xab:
				ReadCommand(cmStos, of_v, of_adr, of_None, ctx);
				break;
			case 0xac:
				ReadCommand(cmLods, of_b, of_adr, of_None, ctx);
				break;
			case 0xad:
				ReadCommand(cmLods, of_v, of_adr, of_None, ctx);
				break;
			case 0xae:
				ReadCommand(cmScas, of_b, of_adr, of_None, ctx);
				break;
			case 0xaf:
				ReadCommand(cmScas, of_v, of_adr, of_None, ctx);
				break;
			case 0xb0: case 0xb1: case 0xb2: case 0xb3: case 0xb4: case 0xb5: case 0xb6: case 0xb7:
				ReadCommand(cmMov, of_Zb | code, of_IBb, of_None, ctx);
				break;
			case 0xb8: case 0xb9: case 0xba: case 0xbb: case 0xbc: case 0xbd: case 0xbe: case 0xbf:
				ReadCommand(cmMov, of_Zv | code, of_IVv, of_None, ctx);
				break;
			case 0xc0:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmRol, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x01:
						ReadCommand(cmRor, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x02:
						ReadCommand(cmRcl, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x03:
						ReadCommand(cmRcr, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x04:
						ReadCommand(cmShl, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x05:
						ReadCommand(cmShr, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x06:
						ReadCommand(cmSal, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x07:
						ReadCommand(cmSar, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0xc1:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmRol, of_Ev | of_size, of_IBb, of_None, ctx);
						break;
					case 0x01:
						ReadCommand(cmRor, of_Ev | of_size, of_IBb, of_None, ctx);
						break;
					case 0x02:
						ReadCommand(cmRcl, of_Ev | of_size, of_IBb, of_None, ctx);
						break;
					case 0x03:
						ReadCommand(cmRcr, of_Ev | of_size, of_IBb, of_None, ctx);
						break;
					case 0x04:
						ReadCommand(cmShl, of_Ev | of_size, of_IBb, of_None, ctx);
						break;
					case 0x05:
						ReadCommand(cmShr, of_Ev | of_size, of_IBb, of_None, ctx);
						break;
					case 0x06:
						ReadCommand(cmSal, of_Ev | of_size, of_IBb, of_None, ctx);
						break;
					case 0x07:
						ReadCommand(cmSar, of_Ev | of_size, of_IBb, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0xc2:
				ReadCommand(cmRet, of_IWw, of_None, of_None, ctx);
				break;
			case 0xc3:
				type_ = cmRet;
				break;
			case 0xc4:
				code = ReadByte(file);
				if (size_ == osDWord && (code & 0xc0) == 0) {
					ctx.use_last_byte = true;
					ReadCommand(cmLes, of_Gz, of_Mp, of_None, ctx);
				} else {
					if (prefix || ctx.rex_prefix || (options() & roLockPrefix))
						type_ = cmDB;
					else {
						include_option(roVexPrefix);
						uint8_t vex_1 = code;
						uint8_t vex_2 = ReadByte(file);
						switch (vex_1 & 0x1f) {
						case 1:
							vex_bytes[0] = 0x0f;
							break;
						case 2:
							vex_bytes[0] = 0x0f;
							vex_bytes[1] = 0x38;
							break;
						case 3:
							vex_bytes[0] = 0x0f;
							vex_bytes[1] = 0x3a;
							break;
						default:
							type_ = cmDB;
						}
						switch (vex_2 & 3) {
						case 1:
							prefix = 0x66;
							break;
						case 2:
							prefix = 0xf3;
							break;
						case 3:
							prefix = 0xf2;
							break;
						}
						ctx.rex_prefix = static_cast<uint8_t>(~vex_1) >> 5; // REX.RXB
						ctx.rex_prefix |= (vex_2 & 0x80) >> 4; // REX.W
						ctx.rex_prefix |= (vex_2 & 4) << 5; // VEX.L
						ctx.vex_registr = ((~vex_2) >> 3) & 0xf;
					}
				}
				break;
			case 0xc5:
				code = ReadByte(file);
				if (size_ == osDWord && (code & 0xc0) == 0) {
					ctx.use_last_byte = true;
					ReadCommand(cmLds, of_Gz, of_Mp, of_None, ctx);
				} else {
					if (prefix || ctx.rex_prefix || (options() & roLockPrefix))
						type_ = cmDB;
					else {
						include_option(roVexPrefix);
						uint8_t vex_1 = code;
						vex_bytes[0] = 0x0f;
						switch (vex_1 & 3) {
						case 1:
							prefix = 0x66;
							break;
						case 2:
							prefix = 0xf3;
							break;
						case 3:
							prefix = 0xf2;
							break;
						}
						ctx.rex_prefix = (static_cast<uint8_t>(~vex_1) & 0x80) >> 5;  // REX.R
						ctx.rex_prefix |= (vex_1 & 4) << 5; // VEX.L
						ctx.vex_registr = ((~vex_1) >> 3) & 0xf;
					}
				}
				break;
			case 0xc6:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmMov, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0xc7:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmMov, of_Ev | of_size, of_IZv, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0xc8:
				ReadCommand(cmEnter, of_IWw, of_IBb, of_None, ctx);
				break;
			case 0xc9:
				type_ = cmLeave;
				break;
			case 0xca:
				include_option(roFar);
				ReadCommand(cmRet, of_IWw, of_None, of_None, ctx);
				break;
			case 0xcb:
				include_option(roFar);
				type_ = cmRet;
				break;
			case 0xcc:
				ReadCommand(cmInt, of_FIb | 3, of_None, of_None, ctx);
				break;
			case 0xcd:
				ReadCommand(cmInt, of_IBb, of_None, of_None, ctx);
				break;
			case 0xce:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					type_ = cmInto;
				}
				break;
			case 0xcf:
				ReadCommand(cmIret, of_v, of_None, of_None, ctx);
				break;
			case 0xd0:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmRol, of_Eb | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x01:
						ReadCommand(cmRor, of_Eb | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x02:
						ReadCommand(cmRcl, of_Eb | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x03:
						ReadCommand(cmRcr, of_Eb | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x04:
						ReadCommand(cmShl, of_Eb | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x05:
						ReadCommand(cmShr, of_Eb | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x06:
						ReadCommand(cmSal, of_Eb | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x07:
						ReadCommand(cmSar, of_Eb | of_size, of_FIb | 1, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0xd1:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmRol, of_Ev | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x01:
						ReadCommand(cmRor, of_Ev | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x02:
						ReadCommand(cmRcl, of_Ev | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x03:
						ReadCommand(cmRcr, of_Ev | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x04:
						ReadCommand(cmShl, of_Ev | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x05:
						ReadCommand(cmShr, of_Ev | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x06:
						ReadCommand(cmSal, of_Ev | of_size, of_FIb | 1, of_None, ctx);
						break;
					case 0x07:
						ReadCommand(cmSar, of_Ev | of_size, of_FIb | 1, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0xd2:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmRol, of_Eb | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x01:
						ReadCommand(cmRor, of_Eb | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x02:
						ReadCommand(cmRcl, of_Eb | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x03:
						ReadCommand(cmRcr, of_Eb | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x04:
						ReadCommand(cmShl, of_Eb | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x05:
						ReadCommand(cmShr, of_Eb | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x06:
						ReadCommand(cmSal, of_Eb | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x07:
						ReadCommand(cmSar, of_Eb | of_size, of_FGb | regECX, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0xd3:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmRol, of_Ev | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x01:
						ReadCommand(cmRor, of_Ev | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x02:
						ReadCommand(cmRcl, of_Ev | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x03:
						ReadCommand(cmRcr, of_Ev | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x04:
						ReadCommand(cmShl, of_Ev | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x05:
						ReadCommand(cmShr, of_Ev | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x06:
						ReadCommand(cmSal, of_Ev | of_size, of_FGb | regECX, of_None, ctx);
						break;
					case 0x07:
						ReadCommand(cmSar, of_Ev | of_size, of_FGb | regECX, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0xd4:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					ReadCommand(cmAam, of_IBb, of_None, of_None, ctx);
				}
				break;
			case 0xd5:
				if (size_ == osQWord) {
					type_ = cmDB;
				} else {
					ReadCommand(cmAad, of_IBb, of_None, of_None, ctx);
				}
				break;
			case 0xd7:
				ReadCommand(cmXlat, of_adr, of_None, of_None, ctx);
				break;
			case 0xd8:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				if ((code & 0xc0) != 0xc0) {
					switch ((code >> 3) & 7) {
						case 0x00:
							ReadCommand(cmFadd, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x01:
							ReadCommand(cmFmul, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x02:
							ReadCommand(cmFcom, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x03:
							ReadCommand(cmFcomp, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x04:
							ReadCommand(cmFsub, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x05:
							ReadCommand(cmFsubr, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x06:
							ReadCommand(cmFdiv, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x07:
							ReadCommand(cmFdivr, of_Md | of_size, of_None, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				} else {
					switch ((code >> 3) & 7) {
						case 0x00:
							ReadCommand(cmFadd, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0x01:
							ReadCommand(cmFmul, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0x02:
							ReadCommand(cmFcom, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0x03:
							ReadCommand(cmFcomp, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0x04:
							ReadCommand(cmFsub, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0x05:
							ReadCommand(cmFsubr, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0x06:
							ReadCommand(cmFdiv, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0x07:
							ReadCommand(cmFdivr, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				}
				break;
			case 0xd9:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				if ((code & 0xc0) != 0xc0) {
					switch ((code >> 3) & 7) {
						case 0x00:
							ReadCommand(cmFld, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x02:
							ReadCommand(cmFst, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x03:
							ReadCommand(cmFstp, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x04:
							ReadCommand(cmFldenv, of_Mb, of_None, of_None, ctx);
							break;
						case 0x05:
							ReadCommand(cmFldcw, of_Mw | of_size, of_None, of_None, ctx);
							break;
						case 0x06:
							ReadCommand(cmFnstenv, of_Mb, of_None, of_None, ctx);
							break;
						case 0x07:
							ReadCommand(cmFnstcw, of_Mw | of_size, of_None, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				} else {
					switch (code) {
						case 0xc0: case 0xc1: case 0xc2: case 0xc3: 
						case 0xc4: case 0xc5: case 0xc6: case 0xc7:
							ReadCommand(cmFld, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0xc8: case 0xc9: case 0xca: case 0xcb:
						case 0xcc: case 0xcd: case 0xce: case 0xcf:
							ReadCommand(cmFxch, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0xd0:
							type_ = cmFnop;
							break;
						case 0xd8: case 0xd9: case 0xda: case 0xdb:
						case 0xdc: case 0xdd: case 0xde: case 0xdf:
							ReadCommand(cmFstp1, of_ST | code, of_None, of_None, ctx);
							break;
						case 0xe0:
							type_ = cmFchs;
							break;
						case 0xe1:
							type_ = cmFabs;
							break;
						case 0xe4:
							type_ = cmFtst;
							break;
						case 0xe5:
							type_ = cmFxam;
							break;
						case 0xe8:
							type_ = cmFld1;
							break;
						case 0xe9:
							type_ = cmFldl2t;
							break;
						case 0xea:
							type_ = cmFldl2e;
							break;
						case 0xeb:
							type_ = cmFldpi;
							break;
						case 0xec:
							type_ = cmFldlg2;
							break;
						case 0xed:
							type_ = cmFldln2;
							break;
						case 0xee:
							type_ = cmFldz;
							break;
						case 0xf0:
							type_ = cmF2xm1;
							break;
						case 0xf1:
							type_ = cmFyl2x;
							break;
						case 0xf2:
							type_ = cmFptan;
							break;
						case 0xf3:
							type_ = cmFpatan;
							break;
						case 0xf4:
							type_ = cmFxtract;
							break;
						case 0xf5:
							type_ = cmFprem1;
							break;
						case 0xf6:
							type_ = cmFdecstp;
							break;
						case 0xf7:
							type_ = cmFincstp;
							break;
						case 0xf8:
							type_ = cmFprem;
							break;
						case 0xf9:
							type_ = cmFyl2xp1;
							break;
						case 0xfa:
							type_ = cmFsqrt;
							break;
						case 0xfb:
							type_ = cmFsincos;
							break;
						case 0xfc:
							type_ = cmFrndint;
							break;
						case 0xfd:
							type_ = cmFscale;
							break;
						case 0xfe:
							type_ = cmFsin;
							break;
						case 0xff:
							type_ = cmFcos;
							break;
						default:
							type_ = cmDB;
							break;
					}
				}
				break;
			case 0xda:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				if ((code & 0xc0) != 0xc0) {
					switch ((code >> 3) & 7) {
						case 0x00:
							ReadCommand(cmFiadd, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x01:
							ReadCommand(cmFimul, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x02:
							ReadCommand(cmFicom, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x03:
							ReadCommand(cmFicomp, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x04:
							ReadCommand(cmFisub, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x05:
							ReadCommand(cmFisubr, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x06:
							ReadCommand(cmFidiv, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x07:
							ReadCommand(cmFidivr, of_Md | of_size, of_None, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				} else {
					switch (code) {
						case 0xc0: case 0xc1: case 0xc2: case 0xc3: 
						case 0xc4: case 0xc5: case 0xc6: case 0xc7:
							ReadCommand(cmFcmovb, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0xc8: case 0xc9: case 0xca: case 0xcb: 
						case 0xcc: case 0xcd: case 0xce: case 0xcf:
							ReadCommand(cmFcmove, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0xd0: case 0xd1: case 0xd2: case 0xd3: 
						case 0xd4: case 0xd5: case 0xd6: case 0xd7:
							ReadCommand(cmFcmovbe, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0xd8: case 0xd9: case 0xda: case 0xdb: 
						case 0xdc: case 0xdd: case 0xde: case 0xdf:
							ReadCommand(cmFcmovu, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0xe9:
							type_ = cmFucompp;
							break;
						default:
							type_ = cmDB;
							break;
					}
				}
				break;
			case 0xdb:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				if ((code & 0xc0) != 0xc0) {
					switch ((code >> 3) & 7) {
						case 0x00:
							ReadCommand(cmFild, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x01:
							ReadCommand(cmFisttp, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x02:
							ReadCommand(cmFist, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x03:
							ReadCommand(cmFistp, of_Md | of_size, of_None, of_None, ctx);
							break;
						case 0x05:
							ReadCommand(cmFld, of_Mt | of_size, of_None, of_None, ctx);
							break;
						case 0x07:
							ReadCommand(cmFstp, of_Mt | of_size, of_None, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				} else {
					switch (code) {
						case 0xc0: case 0xc1: case 0xc2: case 0xc3: 
						case 0xc4: case 0xc5: case 0xc6: case 0xc7:
							ReadCommand(cmFcmovnb, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0xc8: case 0xc9: case 0xca: case 0xcb: 
						case 0xcc: case 0xcd: case 0xce: case 0xcf:
							ReadCommand(cmFcmovne, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0xd0: case 0xd1: case 0xd2: case 0xd3: 
						case 0xd4: case 0xd5: case 0xd6: case 0xd7:
							ReadCommand(cmFcmovnbe, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0xd8: case 0xd9: case 0xda: case 0xdb: 
						case 0xdc: case 0xdd: case 0xde: case 0xdf:
							ReadCommand(cmFcmovnu, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0xe2:
							type_ = cmFnclex;
							break;
						case 0xe3:
							type_ = cmFninit;
							break;
						case 0xe8: case 0xe9: case 0xea: case 0xeb: 
						case 0xec: case 0xed: case 0xee: case 0xef:
							ReadCommand(cmFucomi, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0xf0: case 0xf1: case 0xf2: case 0xf3: 
						case 0xf4: case 0xf5: case 0xf6: case 0xf7:
							ReadCommand(cmFcomi, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				}
				break;
			case 0xdc:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				if ((code & 0xc0) != 0xc0) {
					switch ((code >> 3) & 7) {
						case 0x00:
							ReadCommand(cmFadd, of_Mq | of_size, of_None, of_None, ctx);
							break;
						case 0x01:
							ReadCommand(cmFmul, of_Mq | of_size, of_None, of_None, ctx);
							break;
						case 0x02:
							ReadCommand(cmFcom, of_Mq | of_size, of_None, of_None, ctx);
							break;
						case 0x03:
							ReadCommand(cmFcomp, of_Mq | of_size, of_None, of_None, ctx);
							break;
						case 0x04:
							ReadCommand(cmFsub, of_Mq | of_size, of_None, of_None, ctx);
							break;
						case 0x05:
							ReadCommand(cmFsubr, of_Mq | of_size, of_None, of_None, ctx);
							break;
						case 0x06:
							ReadCommand(cmFdiv, of_Mq | of_size, of_None, of_None, ctx);
							break;
						case 0x07:
							ReadCommand(cmFdivr, of_Mq | of_size, of_None, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				} else {
					switch ((code >> 3) & 7) {
						case 0x00:
							ReadCommand(cmFadd, of_ST | code, of_ST | 0, of_None, ctx);
							break;
						case 0x01:
							ReadCommand(cmFmul, of_ST | code, of_ST | 0, of_None, ctx);
							break;
						case 0x02:
							ReadCommand(cmFcom2, of_ST | code, of_None, of_None, ctx);
							break;
						case 0x03:
							ReadCommand(cmFcomp3, of_ST | code, of_None, of_None, ctx);
							break;
						case 0x04:
							ReadCommand(cmFsubr, of_ST | code, of_ST | 0, of_None, ctx);
							break;
						case 0x05:
							ReadCommand(cmFsub, of_ST | code, of_ST | 0, of_None, ctx);
							break;
						case 0x06:
							ReadCommand(cmFdivr, of_ST | code, of_ST | 0, of_None, ctx);
							break;
						case 0x07:
							ReadCommand(cmFdiv, of_ST | code, of_ST | 0, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				}
				break;
			case 0xdd:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				if ((code & 0xc0) != 0xc0) {
					switch ((code >> 3) & 7) {
						case 0x00:
							ReadCommand(cmFld, of_Mq | of_size, of_None, of_None, ctx);
							break;
						case 0x01:
							ReadCommand(cmFisttp, of_Mq | of_size, of_None, of_None, ctx);
							break;
						case 0x02:
							ReadCommand(cmFst, of_Mq | of_size, of_None, of_None, ctx);
							break;
						case 0x03:
							ReadCommand(cmFstp, of_Mq | of_size, of_None, of_None, ctx);
							break;
						case 0x04:
							ReadCommand(cmFrstor, of_Mb, of_None, of_None, ctx);
							break;
						case 0x06:
							ReadCommand(cmFnsave, of_Mb, of_None, of_None, ctx);
							break;
						case 0x07:
							ReadCommand(cmFnstsw, of_Mw | of_size, of_None, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				} else {
					switch ((code >> 3) & 7) {
						case 0x00:
							ReadCommand(cmFfree, of_ST | code, of_None, of_None, ctx);
							break;
						case 0x01:
							ReadCommand(cmFxch4, of_ST | code, of_None, of_None, ctx);
							break;
						case 0x02:
							ReadCommand(cmFst, of_ST | code, of_None, of_None, ctx);
							break;
						case 0x03:
							ReadCommand(cmFstp, of_ST | code, of_None, of_None, ctx);
							break;
						case 0x04:
							ReadCommand(cmFucom, of_ST | code, of_None, of_None, ctx);
							break;
						case 0x05:
							ReadCommand(cmFucomp, of_ST | code, of_None, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				}
				break;
			case 0xde:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				if ((code & 0xc0) != 0xc0) {
					switch ((code >> 3) & 7) {
						case 0x00:
							ReadCommand(cmFiadd, of_Mw | of_size, of_None, of_None, ctx);
							break;
						case 0x01:
							ReadCommand(cmFimul, of_Mw | of_size, of_None, of_None, ctx);
							break;
						case 0x02:
							ReadCommand(cmFicom, of_Mw | of_size, of_None, of_None, ctx);
							break;
						case 0x03:
							ReadCommand(cmFicomp, of_Mw | of_size, of_None, of_None, ctx);
							break;
						case 0x04:
							ReadCommand(cmFisub, of_Mw | of_size, of_None, of_None, ctx);
							break;
						case 0x05:
							ReadCommand(cmFisubr, of_Mw | of_size, of_None, of_None, ctx);
							break;
						case 0x06:
							ReadCommand(cmFidiv, of_Mw | of_size, of_None, of_None, ctx);
							break;
						case 0x07:
							ReadCommand(cmFidivr, of_Mw | of_size, of_None, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				} else {
					switch (code) {
						case 0xc0: case 0xc1: case 0xc2: case 0xc3: 
						case 0xc4: case 0xc5: case 0xc6: case 0xc7:
							ReadCommand(cmFaddp, of_ST | code, of_ST | 0, of_None, ctx);
							break;
						case 0xc8: case 0xc9: case 0xca: case 0xcb: 
						case 0xcc: case 0xcd: case 0xce: case 0xcf:
							ReadCommand(cmFmulp, of_ST | code, of_ST | 0, of_None, ctx);
							break;
						case 0xd0: case 0xd1: case 0xd2: case 0xd3: 
						case 0xd4: case 0xd5: case 0xd6: case 0xd7:
							ReadCommand(cmFcomp5, of_ST | code, of_None, of_None, ctx);
							break;
						case 0xd9: 
							type_ = cmFcompp;
							break;
						case 0xe0: case 0xe1: case 0xe2: case 0xe3: 
						case 0xe4: case 0xe5: case 0xe6: case 0xe7:
							ReadCommand(cmFsubrp, of_ST | code, of_ST | 0, of_None, ctx);
							break;
						case 0xe8: case 0xe9: case 0xea: case 0xeb: 
						case 0xec: case 0xed: case 0xee: case 0xef:
							ReadCommand(cmFsubp, of_ST | code, of_ST | 0, of_None, ctx);
							break;
						case 0xf0: case 0xf1: case 0xf2: case 0xf3: 
						case 0xf4: case 0xf5: case 0xf6: case 0xf7:
							ReadCommand(cmFdivrp, of_ST | code, of_ST | 0, of_None, ctx);
							break;
						case 0xf8: case 0xf9: case 0xfa: case 0xfb: 
						case 0xfc: case 0xfd: case 0xfe: case 0xff:
							ReadCommand(cmFdivp, of_ST | code, of_ST | 0, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				}
				break;
			case 0xdf:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				if ((code & 0xc0) != 0xc0) {
					switch ((code >> 3) & 7) {
						case 0x00:
							ReadCommand(cmFild, of_Mw | of_size, of_None, of_None, ctx);
							break;
						case 0x01:
							ReadCommand(cmFisttp, of_Mw | of_size, of_None, of_None, ctx);
							break;
						case 0x02:
							ReadCommand(cmFist, of_Mw | of_size, of_None, of_None, ctx);
							break;
						case 0x03:
							ReadCommand(cmFistp, of_Mw | of_size, of_None, of_None, ctx);
							break;
						case 0x04:
							ReadCommand(cmFbld, of_Mt, of_None, of_None, ctx);
							break;
						case 0x05:
							ReadCommand(cmFild, of_Mq | of_size, of_None, of_None, ctx);
							break;
						case 0x06:
							ReadCommand(cmFbstp, of_Mt, of_None, of_None, ctx);
							break;
						case 0x07:
							ReadCommand(cmFistp, of_Mq | of_size, of_None, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				} else {
					switch (code) {
						case 0xc0: case 0xc1: case 0xc2: case 0xc3: 
						case 0xc4: case 0xc5: case 0xc6: case 0xc7:
							ReadCommand(cmFfreep, of_ST | code, of_None, of_None, ctx);
							break;
						case 0xc8: case 0xc9: case 0xca: case 0xcb: 
						case 0xcc: case 0xcd: case 0xce: case 0xcf:
							ReadCommand(cmFxch7, of_ST | code, of_None, of_None, ctx);
							break;
						case 0xd0: case 0xd1: case 0xd2: case 0xd3: 
						case 0xd4: case 0xd5: case 0xd6: case 0xd7:
							ReadCommand(cmFstp8, of_ST | code, of_None, of_None, ctx);
							break;
						case 0xd8: case 0xd9: case 0xda: case 0xdb: 
						case 0xdc: case 0xdd: case 0xde: case 0xdf:
							ReadCommand(cmFstp9, of_ST | code, of_None, of_None, ctx);
							break;
						case 0xe0:
							ReadCommand(cmFnstsw, of_FGw | regEAX, of_None, of_None, ctx);
							break;
						case 0xe8: case 0xe9: case 0xea: case 0xeb: 
						case 0xec: case 0xed: case 0xee: case 0xef:
							ReadCommand(cmFucomip, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						case 0xf0: case 0xf1: case 0xf2: case 0xf3: 
						case 0xf4: case 0xf5: case 0xf6: case 0xf7:
							ReadCommand(cmFcomip, of_ST | 0, of_ST | code, of_None, ctx);
							break;
						default:
							type_ = cmDB;
							break;
					}
				}
				break;
			case 0xe0: 
				ReadCommand(cmLoopne, of_Jb, of_adr, of_None, ctx);
				break;
			case 0xe1: 
				ReadCommand(cmLoope, of_Jb, of_adr, of_None, ctx);
				break;
			case 0xe2: 
				ReadCommand(cmLoop, of_Jb, of_adr, of_None, ctx);
				break;
			case 0xe3: 
				ReadCommand(cmJCXZ, of_Jb, of_adr, of_None, ctx);
				break;
			case 0xe4: 
				ReadCommand(cmIn, of_FGb | regEAX, of_IBb, of_None, ctx);
				break;
			case 0xe5: 
				ReadCommand(cmIn, of_FGv | regEAX, of_IBb, of_None, ctx);
				break;
			case 0xe6: 
				ReadCommand(cmOut, of_IBb, of_FGb | regEAX, of_None, ctx);
				break;
			case 0xe7: 
				ReadCommand(cmOut, of_IBb, of_FGv | regEAX, of_None, ctx);
				break;
			case 0xe8:
				ReadCommand(cmCall, of_Jz, of_None, of_None, ctx);
				break;
			case 0xe9:
				ReadCommand(cmJmp, of_Jz, of_None, of_None, ctx);
				break;
			case 0xea:
				if (size_ == osQWord)
					type_ = cmDB;
				else {
					include_option(roFar);
					ReadCommand(cmJmp, of_Ap, of_None, of_None, ctx);
				}
				break;
			case 0xeb:
				ReadCommand(cmJmp, of_Jb, of_None, of_None, ctx);
				break;
			case 0xec: 
				ReadCommand(cmIn, of_FGb | regEAX, of_FGw | regEDX, of_None, ctx);
				break;
			case 0xed: 
				ReadCommand(cmIn, of_FGv | regEAX, of_FGw | regEDX, of_None, ctx);
				break;
			case 0xee:
				ReadCommand(cmOut, of_FGw | regEDX, of_FGb | regEAX, of_None, ctx);
				break;
			case 0xef:
				ReadCommand(cmOut, of_FGw | regEDX, of_FGv | regEAX, of_None, ctx);
				break;
			case 0xf0:
				include_option(roLockPrefix);
				break;
			case 0xf1:
				ReadCommand(cmInt, of_FIb | 1, of_None, of_None, ctx);
				break;
			case 0xf2:
				preffix_command_ = cmRepne;
				prefix = code;
				break;
			case 0xf3:
				preffix_command_ = cmRep;
				prefix = code;
				break;
			case 0xf4:
				type_ = cmHlt;
				break;
			case 0xf5:
				type_ = cmCmc;
				break;
			case 0xf6:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
					case 0x01:
						ReadCommand(cmTest, of_Eb | of_size, of_IBb, of_None, ctx);
						break;
					case 0x02:
						ReadCommand(cmNot, of_Eb | of_size, of_None, of_None, ctx);
						break;
					case 0x03:
						ReadCommand(cmNeg, of_Eb | of_size, of_None, of_None, ctx);
						break;
					case 0x04:
						ReadCommand(cmMul, of_Eb | of_size, of_None, of_None, ctx);
						break;
					case 0x05:
						ReadCommand(cmImul, of_Eb | of_size, of_None, of_None, ctx);
						break;
					case 0x06:
						ReadCommand(cmDiv, of_Eb | of_size, of_None, of_None, ctx);
						break;
					case 0x07:
						ReadCommand(cmIdiv, of_Eb | of_size, of_None, of_None, ctx);
						break;
				}
				break;
			case 0xf7:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
					case 0x01:
						ReadCommand(cmTest, of_Ev | of_size, of_IZv, of_None, ctx);
						break;
					case 0x02:
						ReadCommand(cmNot, of_Ev | of_size, of_None, of_None, ctx);
						break;
					case 0x03:
						ReadCommand(cmNeg, of_Ev | of_size, of_None, of_None, ctx);
						break;
					case 0x04:
						ReadCommand(cmMul, of_Ev | of_size, of_None, of_None, ctx);
						break;
					case 0x05:
						ReadCommand(cmImul, of_Ev | of_size, of_None, of_None, ctx);
						break;
					case 0x06:
						ReadCommand(cmDiv, of_Ev | of_size, of_None, of_None, ctx);
						break;
					case 0x07:
						ReadCommand(cmIdiv, of_Ev | of_size, of_None, of_None, ctx);
						break;
				}
				break;
			case 0xf8:
				type_ = cmClc;
				break;
			case 0xf9:
				type_ = cmStc;
				break;
			case 0xfa:
				type_ = cmCli;
				break;
			case 0xfb:
				type_ = cmSti;
				break;
			case 0xfc:
				type_ = cmCld;
				break;
			case 0xfd:
				type_ = cmStd;
				break;
			case 0xfe:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmInc, of_Eb | of_size, of_None, of_None, ctx);
						break;
					case 0x01:
						ReadCommand(cmDec, of_Eb | of_size, of_None, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;
			case 0xff:
				code = ReadByte(file);
				ctx.use_last_byte = true;
				switch ((code >> 3) & 7) {
					case 0x00:
						ReadCommand(cmInc, of_Ev | of_size, of_None, of_None, ctx);
						break;
					case 0x01:
						ReadCommand(cmDec, of_Ev | of_size, of_None, of_None, ctx);
						break;
					case 0x02:
						ReadCommand(cmCall, of_Edef | of_size, of_None, of_None, ctx);
						break;
					case 0x03:
						include_option(roFar);
						ReadCommand(cmCall, of_Mp | of_size, of_None, of_None, ctx);
						break;
					case 0x04:
						ReadCommand(cmJmp, of_Edef | of_size, of_None, of_None, ctx);
						break;
					case 0x05:
						include_option(roFar);
						ReadCommand(cmJmp, of_Mp | of_size, of_None, of_None, ctx);
						break;
					case 0x06:
						ReadCommand(cmPush, of_Edef | of_size, of_None, of_None, ctx);
						break;
					default:
						type_ = cmDB;
						break;
				}
				break;

			default:
				type_ = cmDB;
				break;
		}
	}

	if ((options() & roVexPrefix) && vex_operand_index) {
		vex_operand_ = (vex_operand_index & 3) | (operand_[0].size == osYMMWord ? 4 : 0) | (ctx.vex_registr << 4);
	}

	if (file.seh_handler_list())
		set_seh_handler(file.seh_handler_list()->GetHandlerByAddress(address_));

	for (i = 0; i < _countof(operand_); i++) {
		operand = &operand_[i];
		if (operand->type & otValue) {
			if (operand->is_large_value)
				operand->value += next_address();
			operand->fixup = file.fixup_list()->GetFixupByAddress(address() + operand->value_pos);

			if (file.relocation_list())
				operand->relocation = file.relocation_list()->GetRelocationByAddress(address() + operand->value_pos);
		}
	}

	original_dump_size_ = dump_size();

	return original_dump_size_; 
}

void IntelCommand::ReadArray(IArchitecture &file, size_t len)
{
	type_ = cmDB;
	Read(file, len);
	original_dump_size_ = dump_size();
}

uint8_t IntelCommand::ReadDataByte(EncodedData &data, size_t *pos)
{
	uint8_t res = data.ReadByte(pos);

	Init(cmDB);
	set_dump(&res, sizeof(res));
	return res;
}

uint16_t IntelCommand::ReadDataWord(EncodedData &data, size_t *pos)
{
	uint16_t res = data.ReadWord(pos);

	Init(cmDW, IntelOperand(otValue, osWord, 0, res));
	set_dump(&res, sizeof(res));
	return res;
}

uint32_t IntelCommand::ReadDataDWord(EncodedData &data, size_t *pos)
{
	uint32_t res = data.ReadDWord(pos);

	Init(cmDD, IntelOperand(otValue, osDWord, 0, res));
	set_dump(&res, sizeof(res));
	return res;
}

uint64_t IntelCommand::ReadDataQWord(EncodedData &data, size_t *pos)
{
	uint64_t res = data.ReadQWord(pos);

	Init(cmDQ, IntelOperand(otValue, osQWord, 0, res));
	set_dump(&res, sizeof(res));
	return res;
}

uint64_t IntelCommand::ReadUleb128(EncodedData &data, size_t *pos)
{
	size_t old_pos = *pos;
	uint64_t res = data.ReadUleb128(pos);

	Init(cmUleb, IntelOperand(otValue, osQWord, 0, res));
	set_dump(data.data() + old_pos, *pos - old_pos);

	original_dump_size_ = dump_size();
	return res;
}

int64_t IntelCommand::ReadSleb128(EncodedData &data, size_t *pos)
{
	size_t old_pos = *pos;
	int64_t res = data.ReadSleb128(pos);

	Init(cmSleb, IntelOperand(otValue, osQWord, 0, res));
	set_dump(data.data() + old_pos, *pos - old_pos);
	return res;
}

uint64_t IntelCommand::ReadEncoding(EncodedData &data, uint8_t encoding, size_t *pos)
{
	uint64_t base;
	switch (encoding & 0x70) {
	case DW_EH_PE_pcrel:
		base = data.address() + *pos;
		break;
	case DW_EH_PE_datarel:
		base = data.address();
		break;
	default:
		base = 0;
		break;
	}

	switch (encoding & 0x0f) {
	case DW_EH_PE_absptr:
		if (data.pointer_size() == osDWord)
			return base + static_cast<int32_t>(ReadDataDWord(data, pos));
		if (data.pointer_size() == osQWord)
			return base + static_cast<int64_t>(ReadDataQWord(data, pos));
		break;
	case DW_EH_PE_uleb128:
		return base + ReadUleb128(data, pos);
	case DW_EH_PE_sleb128:
		return base + ReadSleb128(data, pos);
	case DW_EH_PE_udata2:
		return base + ReadDataWord(data, pos);
	case DW_EH_PE_sdata2:
		return base + static_cast<int16_t>(ReadDataWord(data, pos));
	case DW_EH_PE_udata4:
		return base + ReadDataDWord(data, pos);
	case DW_EH_PE_sdata4:
		return base + static_cast<int32_t>(ReadDataDWord(data, pos));
	case DW_EH_PE_udata8:
		return base + ReadDataQWord(data, pos);
	case DW_EH_PE_sdata8:
		return base + static_cast<int64_t>(ReadDataQWord(data, pos));
	}
	throw std::runtime_error("Invalid encoding");
}

std::string IntelCommand::ReadString(EncodedData &data, size_t *pos)
{
	std::string res = data.ReadString(pos);

	Init(cmDB);
	set_dump(res.c_str(), res.size() + 1);
	return res;
}

void IntelCommand::ReadData(EncodedData &data, size_t size, size_t *pos)
{
	std::vector<uint8_t> res;
	for (size_t i = 0; i < size; i++) {
		res.push_back(data.ReadByte(pos));
	}

	Init(cmDB);
	set_dump(res.data(), res.size());
}

int32_t IntelCommand::ReadCompressedValue(IArchitecture &file)
{
	uint32_t res;
	uint8_t b = ReadByte(file);
	if ((b & 1) == 0)
		res = b >> 1;
	else if ((b & 2) == 0) {
		res = b >> 2;
		res |= ReadByte(file) << 6;
	}
	else if ((b & 4) == 0) {
		res = b >> 3;
		res |= ReadByte(file) << 5;
		res |= ReadByte(file) << 13;
	}
	else if ((b & 8) == 0) {
		res = b >> 4;
		res |= ReadByte(file) << 4;
		res |= ReadByte(file) << 12;
		res |= ReadByte(file) << 20;
	}
	else
		res = ReadDWord(file);

	Init(cmDC, IntelOperand(otValue, osDWord, 0, res));

	return res;
}

void IntelCommand::set_address(uint64_t address)
{
	address_ = address;

	if (type_ == cmJmp || type_ == cmCall || type_ == cmJmpWithFlag || type_ == cmLoop || type_ == cmLoope || type_ == cmLoopne || type_ == cmJCXZ) {
		if (operand_[0].type == otValue) {
			CompileToNative();
			return;
		}
	}

	if (size_ == osQWord) {
		for (size_t i = 0; i < _countof(operand_); i++) {
			IntelOperand *operand = &operand_[i];
			if (operand->type == otNone)
				break;

			if (operand->type == (otMemory | otValue) && operand->is_large_value)
				WriteDWord(operand->value_pos, static_cast<uint32_t>(operand->value - next_address()));
		}
	}
}

void IntelCommand::PushReg(size_t operand_index, uint8_t add_code, AsmContext &ctx)
{
	IntelOperand *operand = &operand_[operand_index];
	uint8_t registr = operand->registr;

	switch (operand->type) {
		case otRegistr:
			if (registr > 7) {
				registr &= 7;
				ctx.rex_prefix |= rexB;
			} else if (operand->size == osByte && registr > 3) {
				ctx.rex_prefix |= 0x40;
			}
			break;
		case otHiPartRegistr:
			registr |= 4;
			break;
		case otControlRegistr:
		case otDebugRegistr:
			if (registr > 7) {
				registr &= 7;
				ctx.rex_prefix |= rexB;
			}
			break;
	}
	PushByte(add_code | registr);
}

void IntelCommand::PushRegAndRM(size_t reg_operand_index, size_t rm_operand_index, AsmContext &ctx)
{
	IntelOperand *operand = &operand_[reg_operand_index];
	uint8_t registr = operand->registr;

	switch (operand->type) {
	case otRegistr:
		if (registr > 7) {
			registr &= 7;
			ctx.rex_prefix |= rexR;
		} else if (operand->size == osByte && registr > 3) {
			ctx.rex_prefix |= 0x40;
		}
		break;
	case otHiPartRegistr:
		registr |= 4;
		break;
	case otControlRegistr:
	case otDebugRegistr:
	case otXMMRegistr:
		if (registr > 7) {
			registr &= 7;
			ctx.rex_prefix |= rexR;
		}
		break;
	case otSegmentRegistr:
	case otMMXRegistr:
		break;
	default:
		throw std::runtime_error("Runtime error at PushRegAndRM: " + text());
	}

	PushRM(rm_operand_index, registr << 3, ctx);
}

void IntelCommand::PushRM(size_t operand_index, uint8_t add_code, AsmContext &ctx)
{
	IntelOperand *operand = &operand_[operand_index];
	uint8_t registr;

	switch (operand->type) {
	case otRegistr:
		registr = operand->registr;
		if (registr > 7) {
			registr &= 7;
			ctx.rex_prefix |= rexB;
		} else if (operand->size == osByte && registr > 3) {
			ctx.rex_prefix |= 0x40;
		}
		PushByte(add_code | 0xc0 | registr);
		break;
	case otDebugRegistr:
	case otControlRegistr:
	case otXMMRegistr:
		registr = operand->registr;
		if (registr > 7) {
			registr &= 7;
			ctx.rex_prefix |= rexB;
		}
		PushByte(add_code | 0xc0 | registr);
		break;
	case otHiPartRegistr:
		registr = operand->registr | 4;
		PushByte(add_code | 0xc0 | registr);
		break;
	default:
		if (operand->type & otMemory) {
			IntelOperand new_operand, *mem_operand = operand;
			if (((mem_operand->type & (otBaseRegistr | otRegistr | otValue)) == otRegistr && (mem_operand->registr & 7) == 5) ||
				((mem_operand->type & (otBaseRegistr | otRegistr | otValue)) == (otBaseRegistr | otRegistr) && (mem_operand->base_registr & 7) == 5)) {
				new_operand = *mem_operand;
				mem_operand = &new_operand;
				mem_operand->type |= otValue;
				mem_operand->value_size = osByte;
				mem_operand->value = 0;
			}

			if (mem_operand->type & otValue) {
				if ((mem_operand->type & (otRegistr | otBaseRegistr)) == 0) {
					add_code |= 0x5;
				} else {
					add_code |= (mem_operand->value_size == osByte) ? 0x40 : 0x80;
				}
			}

			if (mem_operand->type & otBaseRegistr) {
				PushByte(add_code | 0x4);

				if (mem_operand->type & otRegistr) {
					registr = mem_operand->registr;
					if (registr > 7) {
						registr &= 7;
						ctx.rex_prefix |= rexX;
					}
					add_code = (mem_operand->scale_registr << 6) | (registr << 3);
				} else {
					add_code = 0x20;
				}

				registr = mem_operand->base_registr;
				if (registr > 7) {
					registr &= 7;
					ctx.rex_prefix |= rexB;
				}

				PushByte(add_code | registr);
			} else if (mem_operand->type & otRegistr) {
				registr = mem_operand->registr;
				if (mem_operand->scale_registr) {
					if (registr > 7) {
						registr &= 7;
						ctx.rex_prefix |= rexX;
					}
					PushByte((add_code & ~0xc0) | 0x4);
					PushByte((mem_operand->scale_registr << 6) | (registr << 3) | 0x5);
				} else {
					if (registr > 7) {
						registr &= 7;
						ctx.rex_prefix |= rexB;
					}
					PushByte(add_code | registr);
					if (registr == 4)
						PushByte((registr << 3) | 0x4);
				}
			} else {
				PushByte(add_code);
			}

			if (mem_operand->type & otValue) {
				mem_operand->value_pos = static_cast<uint8_t>(dump_size());
				if (mem_operand->value_size == osByte && !mem_operand->is_large_value) {
					PushByte(static_cast<uint8_t>(mem_operand->value));
				} else {
					PushDWord(static_cast<uint32_t>(mem_operand->value));
				}
			}
		} else {
			throw std::runtime_error("Runtime error at PushRM: " + text());
		}
	}
}

void IntelCommand::PushBytePrefix(uint8_t prefix)
{
	PushByte(prefix);
	command_pos_ = dump_size();
}

void IntelCommand::PushWordPrefix()
{
	PushBytePrefix(0x66);
}

void IntelCommand::PushPrefix(AsmContext &ctx)
{
	switch (operand_[0].size) {
	case osWord:
		PushWordPrefix();
		break;
	case osQWord:
		ctx.rex_prefix = rexW;
		break;
	}
}

void IntelCommand::PushFlags(uint8_t add_code)
{
	uint8_t b;

	switch (flags_) {
	case fl_O:
		b = 0;
		break;
	case fl_C:
		b = 2;
		break;
	case fl_Z:
		b = 4;
		break;
	case fl_C | fl_Z:
		b = 6;
		break;
	case fl_S:
		b = 8;
		break;
	case fl_P:
		b = 0xa;
		break;
	case fl_S | fl_O:
		b = 0xc;
		break;
	case fl_Z | fl_S | fl_O:
		b = 0xe;
		break;
	default:
		b = 0;
	}

	if ((options() & roInverseFlag) != 0)
		b |= 1;

	PushByte(add_code | b);
}

void IntelCommand::CompileToNative()
{
	if (type() == cmDB)
		return;

	BaseCommand::clear();

	IntelOperand *operand, *operand1, *mem_operand;
	AsmContext ctx;
	uint8_t i;
	uint8_t b;
	IntelSegment segment;

	if (options() & roLockPrefix)
		PushByte(0xf0);

	switch (preffix_command_) {
	case cmRepne:
		PushByte(0xf2);
		break;
	case cmRep:
	case cmRepe:
		PushByte(0xf3);
		break;
	}

	if (base_segment_ != segDefault) {
		for (i = 0; i < _countof(operand_); i++) {
			operand = &operand_[i];
			if (operand->type & otMemory) {
				if (operand->type & otBaseRegistr) {
					b = operand->base_registr;
				} else if (operand->type & otRegistr) {
					b = operand->registr;
				} else {
					b = regEAX;
				}
				segment = (b == regEBP || b == regESP) ? segSS : segDS;
				if (segment != base_segment_) {
					switch (base_segment_) { //-V719
					case segES: 
						PushByte(0x26);
						break;
					case segSS: 
						PushByte(0x36);
						break;
					case segCS: 
						PushByte(0x2e);
						break;
					case segDS: 
						PushByte(0x3e);
						break;
					case segFS: 
						PushByte(0x64);
						break;
					case segGS: 
						PushByte(0x65);
						break;
					}
				}
			}
		}
	}

	command_pos_ = dump_size();
	ctx.rex_prefix = 0;
	switch (type()) {
		case cmDW:
			operand = &operand_[0];
			operand->value_pos = static_cast<uint8_t>(dump_size());
			PushWord(static_cast<uint16_t>(operand->value));
			break;

		case cmDD:
			operand = &operand_[0];
			operand->value_pos = static_cast<uint8_t>(dump_size());
			PushDWord(static_cast<uint32_t>(operand->value));
			break;

		case cmDQ:
			operand = &operand_[0];
			operand->value_pos = static_cast<uint8_t>(dump_size());
			PushQWord(operand->value);
			break;

		case cmUleb:
			operand = &operand_[0];
			operand->value_pos = static_cast<uint8_t>(dump_size());
			{
				EncodedData data;
				data.WriteUleb128(operand->value);
				if (options() & roFillNop) {
					for (size_t j = data.size(); j < original_dump_size_ + 1; j++) {
						data[j - 1] = data[j - 1] | 0x80;
						data.push_back(0);
					}
				}
				for (i = 0; i < data.size(); i++) {
					PushByte(data[i]);
				}
			}
			break;

		case cmSleb:
			operand = &operand_[0];
			operand->value_pos = static_cast<uint8_t>(dump_size());
			{
				EncodedData data;
				data.WriteSleb128(operand->value);
				for (i = 0; i < data.size(); i++) {
					PushByte(data[i]);
				}
			}
			break;

		case cmDC:
			operand = &operand_[0];
			operand->value_pos = static_cast<uint8_t>(dump_size());
			if (options() & roFillNop) {
				PushByte(0x0f);
				PushDWord(static_cast<uint32_t>(operand->value));
			}
			else {
				uint32_t value = static_cast<uint32_t>(operand->value);
				if (value < 0x80) {
					PushByte(static_cast<uint8_t>((value << 1) + 0));
				}
				else if (value < 0x80 * 0x80) {
					PushByte(static_cast<uint8_t>((value << 2) + 1));
					PushByte(static_cast<uint8_t>(value >> 6));
				}
				else if (value < 0x80 * 0x80 * 0x80) {
					PushByte(static_cast<uint8_t>((value << 3) + 3));
					PushByte(static_cast<uint8_t>(value >> 5));
					PushByte(static_cast<uint8_t>(value >> 13));
				}
				else if (value < 0x80 * 0x80 * 0x80 * 0x80) {
					PushByte(static_cast<uint8_t>((value << 4) + 7));
					PushByte(static_cast<uint8_t>(value >> 4));
					PushByte(static_cast<uint8_t>(value >> 12));
					PushByte(static_cast<uint8_t>(value >> 20));
				}
				else {
					PushByte(0x0f);
					PushDWord(value);
				}
			}
			break;

		case cmPush:
			operand = &operand_[0];
			if (operand->size == osWord)
				PushWordPrefix();

			switch (operand->type) {
			case otRegistr:
				PushReg(0, 0x50, ctx);
				break;
			case otValue:
				if (operand->value_size == osByte) {
					PushByte(0x6a);
				} else {
					PushByte(0x68);
				}
				operand->value_pos = static_cast<uint8_t>(dump_size());
				switch (operand->value_size) {
				case osByte:
					PushByte(static_cast<uint8_t>(operand->value));
					break;
				case osWord:
					PushWord(static_cast<uint16_t>(operand->value));
					break;
				default:
					PushDWord(static_cast<uint32_t>(operand->value));
					break;
				}
				break;
			case otSegmentRegistr:
				switch (operand->registr) {
				case segES:
					if (size_ == osDWord)
						PushByte(0x06);
					break;
				case segCS:
					if (size_ == osDWord)
						PushByte(0x0e);
					break;
				case segSS:
					if (size_ == osDWord)
						PushByte(0x16);
					break;
				case segDS:
					if (size_ == osDWord)
						PushByte(0x1e);
					break;
				case segFS:
					PushByte(0x0f);
					PushByte(0xa0);
					break;
				case segGS:
					PushByte(0x0f);
					PushByte(0xa8);
					break;
				}
				break;
			default:
				if (operand->type & otMemory) {
					PushByte(0xff);
					PushRM(0, 0x30, ctx);
				}
			}
			break;

		case cmPop:
			operand = &operand_[0];
			if (operand->size == osWord)
				PushWordPrefix();

			switch (operand->type) {
			case otRegistr:
				PushReg(0, 0x58, ctx);
				break;
			case otSegmentRegistr:
				switch (operand->registr) {
				case segES:
					if (size_ == osDWord)
						PushByte(0x07);
					break;
				case segCS:
					if (size_ == osDWord)
						PushByte(0x0f);
					break;
				case segSS:
					if (size_ == osDWord)
						PushByte(0x17);
					break;
				case segDS:
					if (size_ == osDWord)
						PushByte(0x1f);
					break;
				case segFS:
					PushByte(0x0f);
					PushByte(0xa1);
					break;
				case segGS:
					PushByte(0x0f);
					PushByte(0xa9);
					break;
				}
				break;
			default:
				if (operand->type & otMemory) {
					PushByte(0x8f);
					PushRM(0, 0x00, ctx);
				}
			}
			break;

		case cmPusha:
			if (size_ == osDWord) {
				if (operand_[0].size == osWord)
					PushWordPrefix();
				PushByte(0x60);
			}
			break;

		case cmPopa:
			if (size_ == osDWord) {
				if (operand_[0].size == osWord)
					PushWordPrefix();
				PushByte(0x61);
			}
			break;

		case cmPushf:
			if (operand_[0].size == osWord)
				PushWordPrefix();
			PushByte(0x9c);
			break;

		case cmPopf:
			if (operand_[0].size == osWord)
				PushWordPrefix();
			PushByte(0x9d);
			break;

		case cmNop:
			PushByte(0x90);
			break;

		case cmPause:
			PushByte(0xf3);
			PushByte(0x90);
			break;

		case cmRdtsc:
			PushByte(0x0f);
			PushByte(0x31);
			break;

		case cmCpuid:
			PushByte(0x0f);
			PushByte(0xa2);
			break;

		case cmCmc:
			PushByte(0xf5);
			break;

		case cmClc:
			PushByte(0xf8);
			break;

		case cmStc:
			PushByte(0xf9);
			break;

		case cmCld:
			PushByte(0xfc);
			break;

		case cmStd:
			PushByte(0xfd);
			break;

		case cmSahf:
			PushByte(0x9e);
			break;

		case cmLahf:
			PushByte(0x9f);
			break;

		case cmCbw:
			PushByte(0x66);
			PushByte(0x98);
			break;

		case cmCwde:
			PushByte(0x98);
			break;

		case cmCdqe:
			if (size_ == osQWord) {
				PushByte(0x48);
				PushByte(0x98);
			}
			break;

		case cmCwd:
			PushByte(0x66);
			PushByte(0x99);
			break;

		case cmCdq:
			PushByte(0x99);
			break;

		case cmCqo:
			if (size_ == osQWord) {
				PushByte(0x48);
				PushByte(0x99);
			}
			break;

		case cmRet:
			operand = &operand_[0];
			b = (options() & roFar) ? 8 : 0;
			switch (operand->type) {
			case otNone:
				PushByte(0xc3 | b);
				break;
			case otValue:
				PushByte(0xc2 | b);
				PushWord(static_cast<uint16_t>(operand->value));
				break;
			}
			break;

		case cmIret:
			if (operand_[0].size == osWord)
				PushWordPrefix();
			PushByte(0xcf);
			break;

		case cmJmp:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if (operand1->type == otValue) {
				PushByte(0xea);
				operand->value_pos = static_cast<uint8_t>(dump_size());
				PushDWord(static_cast<uint32_t>(operand->value));
				operand1->value_pos = static_cast<uint8_t>(dump_size());
				PushWord(static_cast<uint16_t>(operand1->value));
			} else if (options() & roFar) {
				PushByte(0xff);
				PushRM(0, 0x28, ctx);
			} else if (operand->type == otValue) {
				PushByte(0xe9);
				operand->value_pos = static_cast<uint8_t>(dump_size());
				PushDWord(static_cast<uint32_t>(operand->value - next_address() - 4));
			} else {
				PushByte(0xff);
				PushRM(0, 0x20, ctx);
			}
			break;

		case cmCall:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if (operand1->type == otValue) {
				PushByte(0x9a);
				operand->value_pos = static_cast<uint8_t>(dump_size());
				PushDWord(static_cast<uint32_t>(operand->value));
				operand1->value_pos = static_cast<uint8_t>(dump_size());
				PushWord(static_cast<uint16_t>(operand1->value));
			} else if (options() & roFar) {
				PushByte(0xff);
				PushRM(0, 0x18, ctx);
			} else if (operand->type == otValue) {
				PushByte(0xe8);
				operand->value_pos = static_cast<uint8_t>(dump_size());
				PushDWord(static_cast<uint32_t>(operand->value - next_address() - 4));
			} else {
				PushByte(0xff);
				PushRM(0, 0x10, ctx);
			}
			break;

		case cmSyscall:
			PushByte(0x0f);
			PushByte(0x05);
			break;

		case cmSysenter:
			if (size_ == osDWord) {
				PushByte(0x0f);
				PushByte(0x34);
			}
			break;

		case cmSetXX:
			PushByte(0x0f);
			PushFlags(0x90);
			PushRM(0, 0, ctx);
			break;

		case cmJmpWithFlag:
			operand = &operand_[0];
			PushByte(0x0f);
			PushFlags(0x80);
			operand->value_pos = static_cast<uint8_t>(dump_size());
			PushDWord(static_cast<uint32_t>(operand->value - next_address() - 4));
			break;

		case cmLoopne:
			operand = &operand_[0];
			PushByte(0xe0);
			operand->value_pos = static_cast<uint8_t>(dump_size());
			PushByte(static_cast<uint8_t>(operand->value - next_address() - 1));
			break;

		case cmLoope:
			operand = &operand_[0];
			PushByte(0xe1);
			operand->value_pos = static_cast<uint8_t>(dump_size());
			PushByte(static_cast<uint8_t>(operand->value - next_address() - 1));
			break;

		case cmLoop:
			operand = &operand_[0];
			PushByte(0xe2);
			operand->value_pos = static_cast<uint8_t>(dump_size());
			PushByte(static_cast<uint8_t>(operand->value - next_address() - 1));
			break;

		case cmJCXZ:
			if (operand_[1].size == osWord)
				PushBytePrefix(0x67);
			operand = &operand_[0];
			PushByte(0xe3);
			operand->value_pos = static_cast<uint8_t>(dump_size());
			PushByte(static_cast<uint8_t>(operand->value - next_address() - 1));
			break;

		case cmMovs:
			operand = &operand_[0];
			PushPrefix(ctx);
			PushByte((operand->size == osByte) ? 0xa4 : 0xa5);
			break;

		case cmCmps:
			operand = &operand_[0];
			PushPrefix(ctx);
			PushByte((operand->size == osByte) ? 0xa6 : 0xa7);
			break;

		case cmStos:
			operand = &operand_[0];
			PushPrefix(ctx);
			PushByte((operand->size == osByte) ? 0xaa : 0xab);
			break;

		case cmLods:
			operand = &operand_[0];
			PushPrefix(ctx);
			PushByte((operand->size == osByte) ? 0xac : 0xad);
			break;

		case cmScas:
			operand = &operand_[0];
			PushPrefix(ctx);
			PushByte((operand->size == osByte) ? 0xae : 0xaf);
			break;

		case cmCmov:
			PushPrefix(ctx);
			PushByte(0x0f);
			PushFlags(0x40);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmIn:
			operand = &operand_[0];
			PushByte(0xec | ((operand->size == osByte) ? 0 : 1));
			break;

		case cmInt:
			operand = &operand_[0];
			switch (operand->value) {
				case 0:
					PushByte(0xce);
					break;
				case 3:
					PushByte(0xcc);
					break;
				default:
					PushByte(0xcd);
					PushByte(static_cast<uint8_t>(operand->value));
					break;
			}
			break;

		case cmAdd: case cmOr: case cmAdc: case cmSbb: case cmAnd: case cmSub: case cmXor: case cmCmp:
			operand = &operand_[0];
			operand1 = &operand_[1];
			switch (type_) {
			case cmAdd: b = 0 << 3; break;
			case cmOr: b = 1 << 3; break;
			case cmAdc: b = 2 << 3; break;
			case cmSbb: b = 3 << 3; break;
			case cmAnd: b = 4 << 3; break;
			case cmSub: b = 5 << 3; break;
			case cmXor: b = 6 << 3; break;
			case cmCmp: b = 7 << 3; break;
			}
			PushPrefix(ctx);
			if (operand1->type == otValue) {
				i = (operand->size == osByte) ? 0 : 1;
				if (operand->type == otRegistr && operand->registr == regEAX && operand->size == operand1->value_size) {
					PushByte(b | 0x4 | i);
				} else {
					if (operand->size != osByte && operand1->value_size == osByte)
						i |= 2;
					PushByte(0x80 | i);
					PushRM(0, b, ctx);
				}

				operand1->value_pos = static_cast<uint8_t>(dump_size());
				switch (operand1->value_size) {
				case osByte:
					PushByte(static_cast<uint8_t>(operand1->value));
					break;
				case osWord:
					PushWord(static_cast<uint16_t>(operand1->value));
					break;
				default:
					PushDWord(static_cast<uint32_t>(operand1->value));
					break;
				}
			} else {
				i = (operand->type & otMemory) ? 0 : 1;
				PushByte(b | (i << 1) | ((operand->size == osByte) ? 0 : 1));
				PushRegAndRM(1 - i, i, ctx);
			}
			break;

		case cmTest:
			operand = &operand_[0];
			operand1 = &operand_[1];
			i = (operand->size == osByte) ? 0 : 1;
			PushPrefix(ctx);
			if (operand1->type == otValue) {
				if (operand->type == otRegistr && operand->registr == regEAX) {
					PushByte(0xa8 | i);
				} else {
					PushByte(0xf6 | i);
					PushRM(0, 0, ctx);
				}

				operand1->value_pos = static_cast<uint8_t>(dump_size());
				switch (operand1->value_size) {
				case osByte:
					PushByte(static_cast<uint8_t>(operand1->value));
					break;
				case osWord:
					PushWord(static_cast<uint16_t>(operand1->value));
					break;
				default:
					PushDWord(static_cast<uint32_t>(operand1->value));
					break;
				}
			} else {
				PushByte(0x84 | i);
				i = (operand->type & otMemory) ? 0 : 1;
				PushRegAndRM(1 - i, i, ctx);
			}
			break;

		case cmXchg:
			operand = &operand_[0];
			operand1 = &operand_[1];
			PushPrefix(ctx);
			if (operand->size != osByte && operand->type == otRegistr && operand1->type == otRegistr && 
				(operand->registr == regEAX || operand1->registr == regEAX)) {
				i = (operand1->registr == regEAX) ? 0 : 1;
				PushReg(i, 0x90, ctx);
			} else {
				i = (operand->type & otMemory) ? 0 : 1;
				PushByte(0x86 | ((operand->size == osByte) ? 0 : 1));
				PushRegAndRM(1 - i, i, ctx);
			}
			break;

		case cmXadd:
			operand = &operand_[0];
			PushPrefix(ctx);
			PushByte(0x0f);
			PushByte(0xc0 | ((operand->size == osByte) ? 0 : 1));
			PushRegAndRM(1, 0, ctx);
			break;

		case cmLea:
			PushPrefix(ctx);
			PushByte(0x8d);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmNot: case cmNeg: case cmMul: case cmDiv: case cmIdiv: 
			operand = &operand_[0];
			switch (type_) {
			case cmNot: b = 2 << 3; break;
			case cmNeg: b = 3 << 3; break;
			case cmMul: b = 4 << 3; break;
			//unreachable case cmImul: b = 5 << 3; break;
			case cmDiv: b = 6 << 3; break;
			case cmIdiv: b = 7 << 3; break;
			}
			i = (operand->size == osByte) ? 0 : 1;
			PushPrefix(ctx);
			PushByte(0xf6 | i);
			PushRM(0, b, ctx);
			break;

		case cmImul:
			PushPrefix(ctx);
			if (operand_[2].type != otNone) {
				operand = &operand_[2];
				i = (operand->value_size == osByte) ? 1 : 0;
				PushByte(0x69 | (i << 1));
				PushRegAndRM(0, 1, ctx);
				switch (operand->value_size) {
				case osByte:
					PushByte(static_cast<uint8_t>(operand->value));
					break;
				case osWord:
					PushWord(static_cast<uint16_t>(operand->value));
					break;
				default:
					PushDWord(static_cast<uint32_t>(operand->value));
					break;
				}
			} else if (operand_[1].type != otNone) {
				PushByte(0x0f);
				PushByte(0xaf);
				PushRegAndRM(0, 1, ctx);
			} else {
				operand = &operand_[0];
				i = (operand->size == osByte) ? 0 : 1;
				PushByte(0xf6 | i);
				PushRM(0, 0x28, ctx);
			}
			break;

		case cmInc: case cmDec:
			operand = &operand_[0];
			b = (type_ == cmInc) ? 0 : 8;
			PushPrefix(ctx);
			if (operand->type == otRegistr && size_ != osQWord && size_ == operand->size) {
				PushReg(0, 0x40 | b, ctx);
			} else {
				i = (operand->size == osByte) ? 0 : 1;
				PushByte(0xfe | i);
				PushRM(0, b, ctx);
			}
			break;

		case cmShl: case cmShr: case cmRol: case cmRor: case cmRcl: case cmRcr: case cmSal: case cmSar:
			operand = &operand_[0];
			operand1 = &operand_[1];
			i = (operand->size == osByte) ? 0 : 1;
			switch (type_) {
			case cmRol: b = 0 << 3; break;
			case cmRor: b = 1 << 3; break;
			case cmRcl: b = 2 << 3; break;
			case cmRcr: b = 3 << 3; break;
			case cmShl: b = 4 << 3; break;
			case cmShr: b = 5 << 3; break;
			case cmSal: b = 6 << 3; break;
			case cmSar: b = 7 << 3; break;
			}
			PushPrefix(ctx);
			if (operand1->type == otRegistr && operand1->registr == regECX && operand1->size == osByte) {
				PushByte(0xd2 | i);
				PushRM(0, b, ctx);
			} else if (operand1->type == otValue) {
				if (operand1->value == 1) {
					PushByte(0xd0 | i);
					PushRM(0, b, ctx);
				} else {
					PushByte(0xc0 | i);
					PushRM(0, b, ctx);
					PushByte(static_cast<uint8_t>(operand1->value));
				}
			}
			break;

		case cmShld: case cmShrd:
			operand = &operand_[2];
			PushPrefix(ctx);
			PushByte(0x0f);
			PushByte((type_ == cmShld ? 0xa4 : 0xac) | ((operand->type == otValue) ? 0 : 1));
			PushRegAndRM(1, 0, ctx);
			if (operand->type == otValue)
				PushByte(static_cast<uint8_t>(operand->value));
			break;

		case cmBsr:
			PushPrefix(ctx);
			PushByte(0x0f);
			PushByte(0xbd);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmBsf: 
			PushPrefix(ctx);
			PushByte(0x0f);
			PushByte(0xbc);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmBt: case cmBts: case cmBtr: case cmBtc: 
			//operand = &operand_[0];
			operand1 = &operand_[1];
			PushPrefix(ctx);
			PushByte(0x0f);
			if (operand1->type == otValue) {
				PushByte(0xba);
				switch (type_) {
				case cmBt: b = 4 << 3; break;
				case cmBts: b = 5 << 3; break;
				case cmBtr: b = 6 << 3; break;
				case cmBtc: b = 7 << 3; break;
				}
				PushRM(0, b, ctx);
				PushByte(static_cast<uint8_t>(operand1->value));
			} else {
				switch (type_) {
				case cmBt: b = 0 << 3; break;
				case cmBts: b = 1 << 3; break;
				case cmBtr: b = 2 << 3; break;
				case cmBtc: b = 3 << 3; break;
				}
				PushByte(0xa3 | b);
				PushRegAndRM(1, 0, ctx);
			}
			break;

		case cmMovups: case cmMovupd: case cmMovsd: case cmMovss:
			operand = &operand_[0];
			i = (operand->type & otMemory) ? 0 : 1;
			switch (type_) {
			case cmMovupd: PushBytePrefix(0x66); break;
			case cmMovsd: PushBytePrefix(0xf2); break;
			case cmMovss: PushBytePrefix(0xf3); break;
			}
			PushByte(0x0f);
			PushByte(0x10 | (1 - i));
			PushRegAndRM(1 - i, i, ctx);
			break;

		case cmMovaps: case cmMovapd:
			operand = &operand_[0];
			i = (operand->type & otMemory) ? 0 : 1;
			switch (type_) {
			case cmMovapd: PushBytePrefix(0x66); break;
			}
			PushByte(0x0f);
			PushByte(0x28 | (1 - i));
			PushRegAndRM(1 - i, i, ctx);
			break;

		case cmMovsx:
			operand1 = &operand_[1];
			if (operand1->size < osDWord) {
				PushPrefix(ctx);
				PushByte(0x0f);
				PushByte(0xbe | ((operand1->size == osWord) ? 1 : 0));
				PushRegAndRM(0, 1, ctx);
			}
			break;

		case cmMovsxd:
			if (size_ == osQWord) {
				PushPrefix(ctx);
				PushByte(0x63);
				PushRegAndRM(0, 1, ctx);
			}
			break;

		case cmMovzx:
			operand1 = &operand_[1];
			if (operand1->size < osDWord) {
				PushPrefix(ctx);
				PushByte(0x0f);
				PushByte(0xb6 | ((operand1->size == osWord) ? 1 : 0));
				PushRegAndRM(0, 1, ctx);
			}
			break;

		case cmMov:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if (operand1->type == otValue) {
				PushPrefix(ctx);
				i = (operand->size == osByte) ? 0 : 1;
				if (operand->type == otRegistr && operand1->value_size == operand->size) {
					PushReg(0, static_cast<uint8_t>(0xb0 | (i << 3)), ctx);
				} else {
					PushByte(0xc6 | i);
					PushRM(0, 0, ctx);
				}
				operand1->value_pos = static_cast<uint8_t>(dump_size());
				switch (operand1->value_size) {
				case osByte:
					PushByte(static_cast<uint8_t>(operand1->value));
					break;
				case osWord:
					PushWord(static_cast<uint16_t>(operand1->value));
					break;
				case osDWord:
					PushDWord(static_cast<uint32_t>(operand1->value));
					break;
				case osQWord:
					PushQWord(operand1->value);
					break;
				}
			} else if ((operand->type | operand1->type) & otControlRegistr) {
				i = (operand->type == otControlRegistr) ? 1 : 0;
				PushByte(0x0f);
				PushByte(0x20 | (i << 1));
				PushRegAndRM(1 - i, i, ctx);
			} else if ((operand->type | operand1->type) & otDebugRegistr) {
				i = (operand->type == otDebugRegistr) ? 1 : 0;
				PushByte(0x0f);
				PushByte(0x21 | (i << 1));
				PushRegAndRM(1 - i, i, ctx);
			} else if ((operand->type | operand1->type) & otSegmentRegistr) {
				i = (operand->type == otSegmentRegistr) ? 1 : 0;
				if (operand->size == osWord)
					PushWordPrefix();
				PushByte(0x8c | (i << 1));
				PushRegAndRM(1 - i, i, ctx);
			} else {
				i = (operand->type & otMemory) ? 0 : 1;
				PushPrefix(ctx);
				operand = &operand_[1 - i];
				mem_operand = &operand_[i];
				if (operand->type == otRegistr && operand->registr == regEAX && mem_operand->type == (otValue | otMemory) && !mem_operand->is_large_value) {
					PushByte(0xa1 | ((1 - i) << 1));
					mem_operand->value_pos = static_cast<uint8_t>(dump_size());
					if (size_ == osDWord) {
						PushDWord(static_cast<uint32_t>(mem_operand->value));
					} else {
						PushQWord(mem_operand->value);
					}
				} else {
					PushByte(0x88 | (i << 1) | ((operand->size == osByte) ? 0 : 1));
					PushRegAndRM(1 - i, i, ctx);
				}
			}
			break;

		case cmMovd:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr) {
				i = (operand->type == otXMMRegistr) ? 1 : 0;
				PushBytePrefix(0x66);
				PushByte(0x0f);
				PushByte(i ? 0x6e : 0x7e);
				PushRegAndRM(1 - i, i, ctx);
			} else if ((operand->type | operand1->type) & otMMXRegistr) {
				i = (operand->type == otMMXRegistr) ? 1 : 0;
				PushByte(0x0f);
				PushByte(i ? 0x6e : 0x7e);
				PushRegAndRM(1 - i, i, ctx);
			}
			break;

		case cmMovdqa:
			operand = &operand_[0];
			i = (operand->type == otXMMRegistr) ? 1 : 0;
			PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(i ? 0x6f : 0x7f);
			PushRegAndRM(1 - i, i, ctx);
			break;

		case cmMovq:
			operand = &operand_[0];
			operand1 = &operand_[1];
			i = (operand->type & otMemory) ? 0 : 1;
			if ((operand->type | operand1->type) & otXMMRegistr) {
				PushBytePrefix(i ? 0xf3 : 0x66);
				PushByte(0x0f);
				PushByte(i ? 0x7e : 0xd6);
				PushRegAndRM(1 - i, i, ctx);
			} else if ((operand->type | operand1->type) & otMMXRegistr) {
				PushByte(0x0f);
				PushByte(i ? 0x6f : 0x7f);
				PushRegAndRM(1 - i, i, ctx);
			}
			break;

		case cmMovdqu:
			operand = &operand_[0];
			i = (operand->type & otMemory) ? 0 : 1;
			PushBytePrefix(0xf3);
			PushByte(0x0f);
			PushByte(i ? 0x6f : 0x7f);
			PushRegAndRM(1 - i, i, ctx);
			break;

		case cmPslldq:
			PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0x73);
			PushReg(0, 0xc0 | (7 << 3), ctx);
			PushByte(static_cast<uint8_t>(operand_[1].value));
			break;

		case cmPunpcklqdq:
			PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0x6c);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmPunpckhqdq:
			PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0x6d);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmPsrld:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr)
				PushBytePrefix(0x66);
			if (operand1->type == otValue) {
				PushByte(0x0f);
				PushByte(0x72);
				PushReg(0, 0xc0 | (2 << 3), ctx);
				PushByte(static_cast<uint8_t>(operand_[1].value));
			}
			else {
				PushByte(0x0f);
				PushByte(0xd2);
				PushRegAndRM(0, 1, ctx);
			}
			break;

		case cmPsrlq:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr)
				PushBytePrefix(0x66);
			if (operand1->type == otValue) {
				PushByte(0x0f);
				PushByte(0x73);
				PushReg(0, 0xc0 | (2 << 3), ctx);
				PushByte(static_cast<uint8_t>(operand_[1].value));
			} else {
				PushByte(0x0f);
				PushByte(0xd3);
				PushRegAndRM(0, 1, ctx);
			}
			break;

		case cmPaddq:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr)
				PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0xd4);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmPsubq:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr)
				PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0xfb);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmPand:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr)
				PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0xdb);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmPinsrw:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr)
				PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0xc4);
			PushRegAndRM(0, 1, ctx);
			PushByte(static_cast<uint8_t>(operand_[2].value));
			break;

		case cmPextrw:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr)
				PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0xc5);
			PushRegAndRM(0, 1, ctx);
			PushByte(static_cast<uint8_t>(operand_[2].value));
			break;

		case cmShufpd:
			operand = &operand_[0];
			operand1 = &operand_[1];
			PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0xc6);
			PushRegAndRM(0, 1, ctx);
			PushByte(static_cast<uint8_t>(operand_[2].value));
			break;

		case cmPshufd:
			PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0x70);
			PushRegAndRM(0, 1, ctx);
			PushByte(static_cast<uint8_t>(operand_[2].value));
			break;

		case cmPshuflw:
			PushBytePrefix(0xf2);
			PushByte(0x0f);
			PushByte(0x70);
			PushRegAndRM(0, 1, ctx);
			PushByte(static_cast<uint8_t>(operand_[2].value));
			break;

		case cmPaddd:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr)
				PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0xfe);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmPsubd:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr)
				PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0xfa);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmPunpcklbw:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr)
				PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0x60);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmPunpcklwd:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr)
				PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0x61);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmPunpckldq:
			operand = &operand_[0];
			operand1 = &operand_[1];
			if ((operand->type | operand1->type) & otXMMRegistr)
				PushBytePrefix(0x66);
			PushByte(0x0f);
			PushByte(0x62);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmMovlpd:
			operand = &operand_[1];
			if (operand->type == otXMMRegistr) {
				PushBytePrefix(0x66);
				PushByte(0x0f);
				PushByte(0x13);
				PushRegAndRM(1, 0, ctx);
			}
			break;

		case cmMovlhps:
			PushByte(0x0f);
			PushByte(0x16);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmMovhlps:
			PushByte(0x0f);
			PushByte(0x12);
			PushRegAndRM(0, 1, ctx);
			break;

		case cmFld:
			operand = &operand_[0];
			if (operand->type == otFPURegistr) {
				PushByte(0xd9);
				PushReg(0, 0xc0, ctx);
			} else {
				switch (operand->size) {
				case osDWord:
					PushByte(0xd9);
					PushRM(0, 0, ctx);
					break;
				case osQWord:
					PushByte(0xdd);
					PushRM(0, 0, ctx);
					break;
				case osTByte:
					PushByte(0xdb);
					PushRM(0, 5 << 3, ctx);
				}
			}
			break;

		case cmFild:
			operand = &operand_[0];
			switch (operand->size) {
			case osWord:
				PushByte(0xdf);
				PushRM(0, 0, ctx);
				break;
			case osDWord:
				PushByte(0xdb);
				PushRM(0, 0, ctx);
				break;
			case osQWord:
				PushByte(0xdf);
				PushRM(0, 5 << 3, ctx);
				break;
			}
			break;

		case cmFadd:
			operand = &operand_[0];
			if (operand->type == otFPURegistr) {
				if (operand->registr == 0) {
					PushByte(0xd8);
					PushRM(1, 0xc0, ctx);
				} else {
					PushByte(0xdc);
					PushRM(0, 0xc0, ctx);
				}
			} else {
				switch (operand->size) {
				case osDWord:
					PushByte(0xd8);
					PushRM(0, 0, ctx);
					break;
				case osQWord:
					PushByte(0xdc);
					PushRM(0, 0, ctx);
					break;
				}
			}
			break;

		case cmFsub:
			operand = &operand_[0];
			if (operand->type == otFPURegistr) {
				if (operand->registr == 0) {
					PushByte(0xd8);
					PushRM(1, 0xc0 | (4 << 3), ctx);
				} else {
					PushByte(0xdc);
					PushRM(0, 0xc0 | (5 << 3), ctx);
				}
			} else {
				switch (operand->size) {
				case osDWord:
					PushByte(0xd8);
					PushRM(0, 4 << 3, ctx);
					break;
				case osQWord:
					PushByte(0xdc);
					PushRM(0, 4 << 3, ctx);
					break;
				}
			}
			break;

		case cmFsubr:
			operand = &operand_[0];
			if (operand->type == otFPURegistr) {
				if (operand->registr == 0) {
					PushByte(0xd8);
					PushRM(1, 0xc0 | (5 << 3), ctx);
				} else {
					PushByte(0xdc);
					PushRM(0, 0xc0 | (4 << 3), ctx);
				}
			} else {
				switch (operand->size) {
				case osDWord:
					PushByte(0xd8);
					PushRM(0, 5 << 3, ctx);
					break;
				case osQWord:
					PushByte(0xdc);
					PushRM(0, 5 << 3, ctx);
					break;
				}
			}
			break;

		case cmFst:
			operand = &operand_[0];
			if (operand->type == otFPURegistr) {
				PushByte(0xdd);
				PushRM(0, 0xc0 | (2 << 3), ctx);
			} else {
				switch (operand->size) {
				case osDWord:
					PushByte(0xd9);
					PushRM(0, 2 << 3, ctx);
					break;
				case osQWord:
					PushByte(0xdd);
					PushRM(0, 2 << 3, ctx);
					break;
				}
			}
			break;

		case cmFstp:
			operand = &operand_[0];
			if (operand->type == otFPURegistr) {
				PushByte(0xdd);
				PushRM(0, 0xc0 | (3 << 3), ctx);
			} else {
				switch (operand->size) {
				case osDWord:
					PushByte(0xd9);
					PushRM(0, 3 << 3, ctx);
					break;
				case osQWord:
					PushByte(0xdd);
					PushRM(0, 3 << 3, ctx);
					break;
				case osTByte:
					PushByte(0xdb);
					PushRM(0, 7 << 3, ctx);
					break;
				}
			}
			break;

		case cmFist:
			operand = &operand_[0];
			switch (operand->size) {
			case osWord:
				PushByte(0xdf);
				PushRM(0, 2 << 3, ctx);
				break;
			case osDWord:
				PushByte(0xdb);
				PushRM(0, 2 << 3, ctx);
				break;
			}
			break;

		case cmFistp:
			operand = &operand_[0];
			switch (operand->size) {
			case osWord:
				PushByte(0xdf);
				PushRM(0, 3 << 3, ctx);
				break;
			case osDWord:
				PushByte(0xdb);
				PushRM(0, 3 << 3, ctx);
				break;
			case osQWord:
				PushByte(0xdf);
				PushRM(0, 7 << 3, ctx);
				break;
			}
			break;

		case cmFisub:
			operand = &operand_[0];
			switch (operand->size) {
			case osWord:
				PushByte(0xde);
				PushRM(0, 4 << 3, ctx);
				break;
			case osDWord:
				PushByte(0xda);
				PushRM(0, 4 << 3, ctx);
				break;
			}
			break;

		case cmFdiv:
			operand = &operand_[0];
			if (operand->type == otFPURegistr) {
				if (operand->registr == 0) {
					PushByte(0xd8);
					PushRM(1, 0xc0 | (6 << 3), ctx);
				} else {
					PushByte(0xdc);
					PushRM(0, 0xc0 | (7 << 3), ctx);
				}
			} else {
				switch (operand->size) {
				case osDWord:
					PushByte(0xd8);
					PushRM(0, 6 << 3, ctx);
					break;
				case osQWord:
					PushByte(0xdc);
					PushRM(0, 6 << 3, ctx);
					break;
				}
			}
			break;

		case cmFmul:
			operand = &operand_[0];
			if (operand->type == otFPURegistr) {
				if (operand->registr == 0) {
					PushByte(0xd8);
					PushRM(1, 0xc0 | (1 << 3), ctx);
				} else {
					PushByte(0xdc);
					PushRM(0, 0xc0 | (1 << 3), ctx);
				}
			} else {
				switch (operand->size) {
				case osDWord:
					PushByte(0xd8);
					PushRM(0, 1 << 3, ctx);
					break;
				case osQWord:
					PushByte(0xdc);
					PushRM(0, 1 << 3, ctx);
					break;
				}
			}
			break;

		case cmFcomp:
			operand = &operand_[0];
			if (operand->type == otFPURegistr) {
				PushByte(0xd8);
				PushRM(0, 0xc0 | (3 << 3), ctx);
			} else {
				switch (operand->size) {
				case osDWord:
					PushByte(0xd8);
					PushRM(0, 3 << 3, ctx);
					break;
				case osQWord:
					PushByte(0xdc);
					PushRM(0, 3 << 3, ctx);
					break;
				}
			}
			break;

		case cmFnstcw:
			PushByte(0xd9);
			PushRM(0, 7 << 3, ctx);
			break;

		case cmFstcw:
			PushByte(0x9b);
			PushByte(0xd9);
			PushRM(0, 7 << 3, ctx);
			break;

		case cmFnstsw:
			PushByte(0xdd);
			PushRM(0, 7 << 3, ctx);
			break;

		case cmFstsw:
			PushByte(0x9b);
			PushByte(0xdd);
			PushRM(0, 7 << 3, ctx);
			break;

		case cmFldcw:
			PushByte(0xd9);
			PushRM(0, 5 << 3, ctx);
			break;

		case cmWait:
			PushByte(0x9b);
			break;

		case cmFchs:
			PushByte(0xd9);
			PushByte(0xe0);
			break;

		case cmFsqrt:
			PushByte(0xd9);
			PushByte(0xfa);
			break;

		case cmF2xm1:
			PushByte(0xd9);
			PushByte(0xf0);
			break;

		case cmFabs:
			PushByte(0xd9);
			PushByte(0xe1);
			break;

		case cmFclex:
			PushByte(0x9b);
			PushByte(0xdb);
			PushByte(0xe2);
			break;

		case cmFcos:
			PushByte(0xd9);
			PushByte(0xff);
			break;

		case cmFdecstp:
			PushByte(0xd9);
			PushByte(0xf6);
			break;

		case cmFincstp:
			PushByte(0xd9);
			PushByte(0xf7);
			break;

		case cmFinit:
			PushByte(0x9b);
			PushByte(0xdb);
			PushByte(0xe3);
			break;

		case cmFldln2:
			PushByte(0xd9);
			PushByte(0xed);
			break;

		case cmFldz:
			PushByte(0xd9);
			PushByte(0xee);
			break;

		case cmFld1:
			PushByte(0xd9);
			PushByte(0xe8);
			break;

		case cmFldpi:
			PushByte(0xd9);
			PushByte(0xeb);
			break;

		case cmFpatan:
			PushByte(0xd9);
			PushByte(0xf3);
			break;

		case cmFprem:
			PushByte(0xd9);
			PushByte(0xf8);
			break;

		case cmFprem1:
			PushByte(0xd9);
			PushByte(0xf5);
			break;

		case cmFptan:
			PushByte(0xd9);
			PushByte(0xf2);
			break;

		case cmFrndint:
			PushByte(0xd9);
			PushByte(0xfc);
			break;

		case cmFsin:
			PushByte(0xd9);
			PushByte(0xfe);
			break;

		case cmFtst:
			PushByte(0xd9);
			PushByte(0xe4);
			break;

		case cmFyl2x:
			PushByte(0xd9);
			PushByte(0xf1);
			break;

		case cmFldlg2:
			PushByte(0xd9);
			PushByte(0xec);
			break;

		case cmBswap:
			operand = &operand_[0];
			if (operand->type == otRegistr) {
				PushPrefix(ctx);
				PushByte(0x0f);
				PushReg(0, 0xc8, ctx);
			}
			break;

		case cmUd2:
			PushByte(0x0f);
			PushByte(0x0b);
			break;

		case cmPxor:
			operand = &operand_[0];
			if (operand->type == otMMXRegistr) {
				PushByte(0x0f);
				PushByte(0xef);
				PushRegAndRM(0, 1, ctx);
			} else if (operand->type == otXMMRegistr) {
				PushByte(0x66);
				PushByte(0x0f);
				PushByte(0xef);
				PushRegAndRM(0, 1, ctx);
			}
			break;

		case cmXorps:
			operand = &operand_[0];
			if (operand->type == otXMMRegistr) {
				PushByte(0x0f);
				PushByte(0x57);
				PushRegAndRM(0, 1, ctx);
			}
			break;

		case cmCrc:
			PushByte(0xcc);
			break;
	}

	if (ctx.rex_prefix) {
		if (size_ == osQWord) {
			InsertByte(command_pos_, 0x40 | ctx.rex_prefix);
			command_pos_++;
			for (i = 0; i < _countof(operand_); i++) {
				operand = &operand_[i];
				if (operand->type == otNone)
					break;
				if (operand->type & otValue)
					operand->value_pos++;
			}
		} else {
			// 32-bit commands can not have REX preffix
			command_pos_ = dump_size();
		}
	}

	if (command_pos_ == dump_size())
		throw std::runtime_error("Runtime error at CompileToNative: " + text());

	for (i = 0; i < _countof(operand_); i++) {
		operand = &operand_[i];
		if (operand->is_large_value)
			WriteDWord(operand->value_pos, static_cast<uint32_t>(operand->value - next_address()));
	}

	if (options() & roFillNop) {
		for (size_t j = dump_size(); j < original_dump_size_; j++) {
			PushByte(0x90);
		}
	}
}

void IntelCommand::set_operand_value(size_t operand_index, uint64_t value)
{
	operand_[operand_index].value = value;
}

void IntelCommand::set_operand_fixup(size_t operand_index, IFixup *fixup)
{
	operand_[operand_index].fixup = fixup;
}

void IntelCommand::set_operand_relocation(size_t operand_index, IRelocation *relocation)
{
	operand_[operand_index].relocation = relocation;
}

void IntelCommand::set_operand_scale(size_t operand_index, uint8_t value)
{
	operand_[operand_index].scale_registr = value;
}

void IntelCommand::set_link_value(size_t link_index, uint64_t value)
{
	IntelVMCommand *vm_command = vm_links_[link_index];
	vm_command->set_value(value);
	vm_command->Compile();
}

void IntelCommand::set_jmp_value(size_t link_index, uint64_t value)
{
	IntelVMCommand *vm_command = jmp_links_[link_index];
	vm_command->set_value(value);
	vm_command->Compile();
}

void IntelCommand::ReadFromBuffer(Buffer &buffer, IArchitecture &file)
{
	uint8_t b;
	uint16_t opt;
	size_t i, j, r;
	uint32_t dw;
	uint64_t add_address = file.image_base();

	r = buffer.ReadByte();
	address_ = buffer.ReadDWord() + add_address;
	type_ = static_cast<IntelCommandType>(buffer.ReadWord());
	BaseCommand::ReadFromBuffer(buffer, file);

	if (r & 0x8)
		preffix_command_ = static_cast<IntelCommandType>(buffer.ReadWord());

	original_dump_size_ = (r & 0x10) ? buffer.ReadWord() : buffer.ReadByte();

	if (r & 0x40)
		base_segment_ = static_cast<IntelSegment>(buffer.ReadByte());

	if (r & 0x80)
		flags_ = buffer.ReadWord();

	if (type_ == cmDB) {
		for (i = 0; i < original_dump_size_; i++) {
			PushByte(buffer.ReadByte());
		}
	} else {
		for (i = 0; i < original_dump_size_; i++) {
			PushByte(0);
		}
		for (j = 0; j < (r & 3); j++) {
			IntelOperand *operand = &operand_[j];
			operand->size = static_cast<OperandSize>(buffer.ReadByte());
			opt = buffer.ReadWord();
			operand->type = opt & 0xfff;

			if (operand->type & (otRegistr | otSegmentRegistr | otControlRegistr | otDebugRegistr | otFPURegistr | otHiPartRegistr | otMMXRegistr | otXMMRegistr))
				operand->registr = buffer.ReadByte();

			if (operand->type & otBaseRegistr)
				operand->base_registr = buffer.ReadByte();

			if (operand->type & otValue) {
				operand->value_size = static_cast<OperandSize>(buffer.ReadByte());
				if (opt & 0x9000) {
					dw = buffer.ReadDWord();
					operand->value = dw + add_address;
				} else {
					switch (operand->value_size) {
					case osByte: 
						operand->value = ByteToInt64(buffer.ReadByte());
						break;
					case osWord: 
						operand->value = WordToInt64(buffer.ReadWord());
						break;
					case osDWord: 
						operand->value = DWordToInt64(buffer.ReadDWord());
						break;
					case osQWord: 
						operand->value = buffer.ReadQWord();
						break;
					}
				}

				if (opt & 0x8000) {
					b = buffer.ReadByte();
					if (b == 1) {
						operand->fixup = NEED_FIXUP;
					} else if (b == 2) {
						operand->is_large_value = true;
					}
				}
			}

			if (operand->type & otMemory) {
				if (opt & 0x4000)
					operand->scale_registr = buffer.ReadByte();
				operand->address_size = (opt & 0x2000) ? static_cast<OperandSize>(buffer.ReadByte()) : size_;
			}
		}
	}
}

void IntelCommand::WriteToFile(IArchitecture &file)
{
	for (size_t i = 0; i < _countof(operand_); i++) {
		IntelOperand *operand = &operand_[i];
		if (operand->type == otNone)
			break;

		if (operand->type & otValue) {
			if (operand->fixup) {
				if (operand->fixup == NEED_FIXUP) {
					ISection *segment = file.segment_list()->GetSectionByAddress(address_);
					operand->fixup = file.fixup_list()->AddDefault(file.cpu_address_size(), segment && (segment->memory_type() & mtExecutable) != 0);
				}
				operand->fixup->set_address(address_ + operand->value_pos);
			}
			if (operand->relocation)
				operand->relocation->set_address(address_ + operand->value_pos);
		}
	}

	if (seh_handler_) {
		if (seh_handler_ == NEED_SEH_HANDLER) {
			seh_handler_ = file.seh_handler_list()->Add(address());
		}
		else {
			seh_handler_->set_address(address());
		}
	}

	BaseCommand::WriteToFile(file);
}

void IntelCommand::Rebase(uint64_t delta_base)
{
	if (!address_)
		return;

	if ((type_ == cmJmp || type_ == cmCall || type_ == cmJmpWithFlag) && operand_[0].type == otValue) {
		operand_[0].value += delta_base;
	} else {
		for (size_t i = 0; i < _countof(operand_); i++) {
			IntelOperand *operand = &operand_[i];
			if (operand->type == otNone)
				break;

			if ((operand->type & otValue) && (operand->fixup || operand->is_large_value))
				operand->value += delta_base;
		}
	}

	address_ += delta_base;

#ifdef CHECKED
	update_hash();
#endif
}

IntelVMCommand *IntelCommand::AddVMCommand(const CompileContext &ctx, IntelCommandType command_type, OperandType operand_type, OperandSize operand_size, uint64_t value, uint32_t options, IFixup *fixup)
{
	bool need_popf = false;
	if ((command_type == cmAdd || command_type == cmNor || command_type == cmNand || command_type == cmShr || command_type == cmShl) && !value) {
		need_popf = true;
		value = true;
	}

	IntelVMCommand *vm_command = NULL;
#ifdef ULTIMATE
	if ((owner()->compilation_options() & coLockToKey) && command_type == cmPush && operand_type == otValue && (options & voLinkCommand)) {
		vm_command = new IntelVMCommand(this, command_type, operand_type, osDWord, value, options);
		vm_command->set_crypt_command(cmXadd, operand_size, ctx.options.licensing_manager->product_code());
	}
#endif
	if (!vm_command)
		vm_command = new IntelVMCommand(this, command_type, operand_type, operand_size, value, options);

	AddObject(vm_command);
	if (options & voLinkCommand)
		vm_links_.push_back(vm_command);
	if (command_type == cmJmp)
		jmp_links_.push_back(vm_command);

	uint32_t new_options = options & (voSectionCommand | voNoCRC);
	if (need_popf)
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty, new_options);

	if ((ctx.options.flags & cpMemoryProtection) && (new_options & voNoCRC) == 0 && vm_command->command_type() == cmPush && vm_command->operand_type() == otValue && vm_command->size() > osByte) {
		new_options |= voNoCRC;
		IntelVMCommand *address_command = AddVMCommand(ctx, cmPush, otValue, size_, 0, new_options | voFixup);
		AddVMCommand(ctx, cmPush, otMemory, vm_command->size(), segDS, new_options);
		AddVMCommand(ctx, cmAdd, otNone, vm_command->size(), false, new_options);

		internal_links_.Add(vlCRCValue, address_command, vm_command);
	}

	if (vm_command->crypt_command() == cmXadd) {
		size_t i;
		IntelVMCommand *cur_command = vm_command;
		// read session key
		uint64_t address = ctx.runtime->export_list()->GetAddressByType(atLoaderData);
		IntelVMCommand *from_command = AddVMCommand(ctx, cmPush, otValue, size_, address, new_options | voFixup);
		ICommand *to_command = ctx.file->function_list()->GetCommandByAddress(address, true);
		if (to_command)
			internal_links_.Add(vlNone, from_command, to_command);
		AddVMCommand(ctx, cmPush, otMemory, size_, segDS, new_options);
		AddVMCommand(ctx, cmPush, otValue, size_, ctx.runtime_var_index[VAR_SESSION_KEY] * OperandSizeToValue(size_), new_options);
		AddVMCommand(ctx, cmAdd, otNone, size_, false);
		AddVMCommand(ctx, cmPush, otMemory, size_, segDS, new_options);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regETX, new_options);
		// add session key
		AddVMCommand(ctx, cmPush, otRegistr, osDWord, regETX, new_options);
		AddVMCommand(ctx, cmAdd, otNone, osDWord, false, new_options);
		for (i = 1; i < 4; i++) {
			cur_command->set_link_command(AddVMCommand(ctx, cmPush, otValue, osDWord, 0, new_options));
			// add session key
			AddVMCommand(ctx, cmPush, otRegistr, osDWord, regETX, new_options);
			AddVMCommand(ctx, cmAdd, otNone, osDWord, false, new_options);
			cur_command = cur_command->link_command();
		}
		AddVMCommand(ctx, cmPush, otRegistr, size_, regESP, new_options);

		address = ctx.runtime->export_list()->GetAddressByType(atDecryptBuffer);
		from_command = AddVMCommand(ctx, cmPush, otValue, size_, address, new_options | voFixup);
		to_command = ctx.file->function_list()->GetCommandByAddress(address, true);
		if (to_command)
			internal_links_.Add(vlNone, from_command, to_command);
		AddVMCommand(ctx, cmCall, otNone, size_, 1, new_options);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty, new_options);

		// correct stack
		if (ctx.file->calling_convention() == ccCdecl)
			AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty, new_options);
		if (size_ == osQWord) {
			AddVMCommand(ctx, cmPop, otRegistr, osQWord, regEmpty, new_options);
		} else {
			AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty, new_options);
			AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty, new_options);
			AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty, new_options);
		}

		// add session key
		if (size_ == osQWord) {
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP, new_options);
			AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToStack(osDWord), new_options);
			AddVMCommand(ctx, cmAdd, otNone, size_, false, new_options);
			AddVMCommand(ctx, cmPush, otMemory, osDWord, segSS, new_options);

			AddVMCommand(ctx, cmPush, otRegistr, osDWord, regETX, new_options);
			AddVMCommand(ctx, cmAdd, otNone, osDWord, false);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP, new_options);
			AddVMCommand(ctx, cmPush, otValue, size_, 2 * OperandSizeToStack(osDWord), new_options);
			AddVMCommand(ctx, cmAdd, otNone, size_, false, new_options);
			AddVMCommand(ctx, cmPop, otMemory, osDWord, segSS, new_options);
		}
		AddVMCommand(ctx, cmPush, otRegistr, osDWord, regETX, new_options);
		AddVMCommand(ctx, cmAdd, otNone, osDWord, false, new_options);
	}

	if ((options & voFixup) && (ctx.options.flags & cpStripFixups) == 0) {
		if (vm_command->is_data()) {
			vm_command->set_fixup(fixup);
		} else {
			FixupType fixup_type = (fixup && fixup != NEED_FIXUP) ? fixup->type() : ftHighLow;
			switch (fixup_type) {
			case ftHigh:
				AddVMCommand(ctx, cmPush, otRegistr, operand_size, regERX, new_options);
				AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty, new_options);
				AddVMCommand(ctx, cmPush, otValue, osWord, 0, new_options);
				if (options & voInverseValue) {
					AddVMCommand(ctx, cmPush, otRegistr, size_, regESP, new_options);
					AddVMCommand(ctx, cmPush, otMemory, operand_size, segSS, new_options);
					AddVMCommand(ctx, cmNor, otNone, operand_size, false, new_options);
					AddVMCommand(ctx, cmPush, otValue, operand_size, 1, new_options);
					AddVMCommand(ctx, cmAdd, otNone, operand_size, false, new_options);
				}
				AddVMCommand(ctx, cmAdd, otNone, operand_size, false, new_options);
				break;

			case ftLow:
				AddVMCommand(ctx, cmPush, otValue, osWord, 0, options);
				AddVMCommand(ctx, cmPush, otRegistr, osWord, regERX, new_options);
				if (options & voInverseValue) {
					AddVMCommand(ctx, cmPush, otRegistr, size_, regESP, new_options);
					AddVMCommand(ctx, cmPush, otMemory, operand_size, segSS, new_options);
					AddVMCommand(ctx, cmNor, otNone, operand_size, false, new_options);
					AddVMCommand(ctx, cmPush, otValue, operand_size, 1, new_options);
					AddVMCommand(ctx, cmAdd, otNone, operand_size, false, new_options);
				}
				AddVMCommand(ctx, cmAdd, otNone, operand_size, false, new_options);
				break;

			case ftHighLow:
				AddVMCommand(ctx, cmPush, otRegistr, operand_size, regERX, new_options);
				if (options & voInverseValue) {
					AddVMCommand(ctx, cmPush, otRegistr, operand_size, regERX, new_options);
					AddVMCommand(ctx, cmNor, otNone, operand_size, false, new_options);
					AddVMCommand(ctx, cmPush, otValue, operand_size, 1, new_options);
					AddVMCommand(ctx, cmAdd, otNone, operand_size, false, new_options);
				}
				AddVMCommand(ctx, cmAdd, otNone, operand_size, false, new_options);
				break;
			}
		}
	}

	if (command_type == cmRet || command_type == cmIret || command_type == cmJmp)
		section_options_ |= rtCloseSection;

	return vm_command;
}

void IntelCommand::AddCorrectOperandSizeSection(const CompileContext &ctx, OperandSize src, OperandSize dst)
{
	int i = (int)(OperandSizeToStack(dst) - OperandSizeToStack(src));
	switch (i) {
	case -2:
		AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);
		break;
	case -4:
		AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
		break;
	case -6:
		AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);
		AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
		break;
	case 2:
		AddVMCommand(ctx, cmPush, otValue, osWord, 0);
		break;
	case 4:
		AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
		break;
	case 6:
		AddVMCommand(ctx, cmPush, otValue, osWord, 0);
		AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
		break;
	}
}

void IntelCommand::AddRegistrAndValueSection(const CompileContext &ctx, uint8_t registr, OperandSize registr_size, uint64_t value, bool need_pushf)
{
	if (rand() & 1) {
		AddVMCommand(ctx, cmPush, otRegistr, registr_size, registr);
		AddVMCommand(ctx, cmPush, otRegistr, registr_size, registr);

		AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, registr_size, false);
		AddVMCommand(ctx, cmPush, otValue, registr_size, ~value);
		AddVMCommand(ctx, cmNor, otNone, registr_size, need_pushf);
	} else {
		AddVMCommand(ctx, cmPush, otRegistr, registr_size, registr);
		AddVMCommand(ctx, cmPush, otValue, registr_size, value);
		AddVMCommand(ctx, cmNand, otNone, registr_size, false);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
		AddVMCommand(ctx, cmPush, otMemory, registr_size, segSS);
		AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, registr_size, need_pushf);
	}
}

void IntelCommand::AddRegistrOrValueSection(const CompileContext &ctx, uint8_t registr, OperandSize registr_size, uint64_t value, bool need_pushf)
{
	AddVMCommand(ctx, cmPush, otRegistr, registr_size, registr);
	AddVMCommand(ctx, cmPush, otValue, registr_size, value);
	AddVMCommand(ctx, cmNor, otNone, registr_size, false);

	AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
	AddVMCommand(ctx, cmPush, otMemory, registr_size, segSS);
	AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, registr_size, need_pushf);
}

void IntelCommand::AddCombineFlagsSection(const CompileContext &ctx, uint16_t mask)
{
	AddRegistrAndValueSection(ctx, regEFX, size_, mask);
	AddRegistrAndValueSection(ctx, regEIX, size_, ~mask);
	AddVMCommand(ctx, cmAdd, otNone, size_, false);
	AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);
}

void IntelCommand::AddCorrectFlagSection(const CompileContext &ctx, uint16_t flags)
{
	AddRegistrAndValueSection(ctx, regEFX, size_, flags);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);
	AddVMCommand(ctx, cmPush, otValue, size_, flags);
	AddVMCommand(ctx, cmNor, otNone, size_, false);
	AddVMCommand(ctx, cmNor, otNone, size_, false);
	AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);
}

void IntelCommand::AddExtractFlagSection(const CompileContext &ctx, uint16_t flags, bool is_inverse, uint8_t extract_to)
{
	bool one_bit = (flags & (flags - 1)) == 0;
	uint16_t check_flag = one_bit ? flags : (uint16_t)fl_Z;
	int c = 0;

	if (check_flag > extract_to) {
		while (check_flag > extract_to) {
			c++;
			check_flag >>= 1;
		}
	} else if (check_flag < extract_to) {
		while (check_flag < extract_to) {
			c--;
			check_flag <<= 1;
		}
	}
	if (c != 0)
		AddVMCommand(ctx, cmPush, otValue, osWord, abs(c));

	if (one_bit) {
		AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);
		if (!is_inverse) {
			AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);
			AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);
		}
		AddVMCommand(ctx, cmPush, otValue, size_ , ~flags);
		AddVMCommand(ctx, cmNor, otNone, size_, false);
	} else {
		bool is_os = (flags & fl_OS) == fl_OS;
		if (is_os) {
			AddRegistrAndValueSection(ctx, regEFX, size_, fl_S, true);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty);

			AddRegistrAndValueSection(ctx, regEFX, size_, fl_O, true);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regEIX);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
			AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX);
			AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);

			AddVMCommand(ctx, cmNor, otNone, size_, false);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX);
			AddVMCommand(ctx, cmNor, otNone, size_, false);

			AddVMCommand(ctx, cmNor, otNone, size_, false);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);

			if (is_inverse) {
				AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
				AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
				AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);
				AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);
			}
			check_flag = flags & ~fl_OS;
		} else {
			check_flag = flags;
		}

		if (check_flag) {
			AddRegistrAndValueSection(ctx, regEFX, size_, check_flag, true);
			AddVMCommand(ctx, cmPop, otRegistr, size_, is_os ? regEIX : regETX);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty);

			if (is_os) {
				AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX);
				AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX);
				AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);

				AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);

				if (is_inverse) {
					AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
					AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);
				}

				AddVMCommand(ctx, cmNor, otNone, size_, false);
				AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);
			}

			if (!is_inverse) {
				AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
				AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
				AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);
				AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);
			}
		}

		AddRegistrAndValueSection(ctx, regETX, size_, fl_Z);
	}

	if (c != 0)
		AddVMCommand(ctx, c > 0 ? cmShr : cmShl, otNone, size_, false);
}

void IntelCommand::AddJmpWithFlagSection(const CompileContext &ctx, IntelCommandType jmp_command_type)
{
	OperandSize os = operand_[1].size;
	uint8_t extract_to;
#ifdef DEMO
	extract_to = static_cast<uint8_t>(OperandSizeToStack(size_));

	AddVMCommand(ctx, cmPush, otValue, size_, 0, voLinkCommand);
	AddVMCommand(ctx, cmPush, otValue, size_, 0, voLinkCommand);

	AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
#else
	extract_to = 1;
#endif

	switch (jmp_command_type) {
	case cmCmpxchg:
		AddExtractFlagSection(ctx, fl_Z, false, extract_to);
		break;

	case cmJmpWithFlag:
		AddExtractFlagSection(ctx, flags_, (options() & roInverseFlag) != 0, extract_to);
		break;

	case cmJCXZ:
		AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);

		AddVMCommand(ctx, cmPush, otValue, os, 0);
		AddVMCommand(ctx, cmPush, otRegistr, os, regECX);
		AddVMCommand(ctx, cmAdd, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);
		AddVMCommand(ctx, cmPop, otRegistr, os, regEmpty);

		AddExtractFlagSection(ctx, fl_Z, false, extract_to);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);

		AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
		break;

	case cmLoop: case cmRep:
		AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);

		AddVMCommand(ctx, cmPush, otValue, os, -1);
		AddVMCommand(ctx, cmPush, otRegistr, os, regECX);
		AddVMCommand(ctx, cmAdd, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);
		AddVMCommand(ctx, cmPop, otRegistr, os, regECX);

		AddExtractFlagSection(ctx, fl_Z, true, extract_to);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);

		AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
		break;

	case cmLoopne: case cmRepne: case cmLoope: case cmRepe:
		AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);

		AddVMCommand(ctx, cmPush, otValue, os, -1);
		AddVMCommand(ctx, cmPush, otRegistr, os, regECX);
		AddVMCommand(ctx, cmAdd, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);
		AddVMCommand(ctx, cmPop, otRegistr, os, regECX);

		if (jmp_command_type == cmLoope || jmp_command_type == cmRepe) {
			AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);
			AddVMCommand(ctx, cmNor, otNone, size_, false);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);
		}

		AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);
		AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
		AddVMCommand(ctx, cmNor, otNone, size_, false);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
		AddVMCommand(ctx, cmPush, otMemory, size_, segSS);

		AddVMCommand(ctx, cmNor, otNone, size_, false);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);

		AddExtractFlagSection(ctx, fl_Z, true, extract_to);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);

		AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
		break;
	}

#ifdef DEMO
	AddVMCommand(ctx, cmAdd, otNone, size_, false);

	AddVMCommand(ctx, cmPush, otMemory, size_, segSS);

	AddVMCommand(ctx, cmPop, otRegistr, size_, regEIX);
	AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty);
	AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty);

	AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX);
#else
	AddVMCommand(ctx, cmPush, otValue, size_, (uint64_t)-1);
	AddVMCommand(ctx, cmAdd, otNone, size_, false);
	AddVMCommand(ctx, cmPop, otRegistr, size_, regEIX);

	// first address AND !condition
	AddVMCommand(ctx, cmPush, otValue, size_, 0, voLinkCommand);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX);
	AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);
	AddVMCommand(ctx, cmNand, otNone, size_, false);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
	AddVMCommand(ctx, cmPush, otMemory, size_, segSS);
	AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);

	// second address AND condition
	AddVMCommand(ctx, cmPush, otValue, size_, 0, voLinkCommand);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX);
	AddVMCommand(ctx, cmNand, otNone, size_, false);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
	AddVMCommand(ctx, cmPush, otMemory, size_, segSS);
	AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);

	// OR addresses 
	AddVMCommand(ctx, cmAdd, otNone, size_, false);
#endif

	AddVMCommand(ctx, cmPush, otRegistr, size_, regERX);
	AddVMCommand(ctx, cmAdd, otNone, size_, false);
	AddEndSection(ctx, cmJmp, 0, voUseEndSectionCryptor);
}

void IntelCommand::AddBeginSection(const CompileContext &ctx, uint32_t options)
{
	options |= voSectionCommand;

	if (count() == 0)
		section_options_ |= rtBeginSection;

	SectionCryptor *section_cryptor;
	if (options & voUseBeginSectionCryptor) {
		section_cryptor = begin_section_cryptor_;
	} else if (options & voUseEndSectionCryptor) {
		section_cryptor = end_section_cryptor_;
	} else {
		section_cryptor = NULL;
	}

	ByteList *registr_order = (section_cryptor) ? section_cryptor->end_cryptor()->registr_order() : reinterpret_cast<IntelVirtualMachine *>(block()->virtual_machine())->registr_order();

	AddVMCommand(ctx, cmPop, otRegistr, size_, regERX, options);
	options &= ~voLinkCommand;

	for (size_t i = registr_order->size(); i > 0; i--) {
		uint8_t reg = registr_order->at(i - 1);
		AddVMCommand(ctx, cmPop, otRegistr, size_, reg, options);
	}

	AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty, options);
	AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty, options);
}

static IntelCommandType CryptorCommandToIntel(CryptCommandType crypt_command)
{
	IntelCommandType res;
	switch (crypt_command) {
	case ccAdd:
		res = cmAdd;
		break;
	case ccSub:
		res = cmSub;
		break;
	case ccXor:
		res = cmXor;
		break;
	case ccInc:
		res = cmInc;
		break;
	case ccDec:
		res = cmDec;
		break;
	case ccBswap:
		res = cmBswap;
		break;
	case ccRol:
		res = cmRol;
		break;
	case ccRor:
		res = cmRor;
		break;
	case ccNot:
		res = cmNot;
		break;
	case ccNeg:
		res = cmNeg;
		break;
	default:
		res = cmUnknown;
		break;
	}

	return res;
}

void IntelCommand::AddCryptorSection(const CompileContext &ctx, ValueCryptor *cryptor, bool is_decrypt)
{
	if (!cryptor)
		return;

	CompileContext new_ctx = ctx;
	new_ctx.options.flags &= ~cpMemoryProtection;

	size_t i;
	IntelCommand tmp_command(owner(), size_);
	tmp_command.set_block(block());
	tmp_command.include_option(roNoSaveFlags);
	IntelOperand first_operand = IntelOperand(otMemory | otRegistr, cryptor->size(), regESP);
	size_t c = cryptor->count();
	for (i = 0; i < c; i++) {
		ValueCommand *value_command = cryptor->item(is_decrypt ? c - i - 1 : i);
		IntelCommandType command_type = CryptorCommandToIntel(value_command->type(is_decrypt));
		if (command_type == cmUnknown)
			throw std::runtime_error("Unknown cryptor command");

		IntelOperand second_operand;
		if (command_type == cmAdd || command_type == cmSub || command_type == cmXor || command_type == cmRol || command_type == cmRor)
			second_operand = IntelOperand(otValue, (command_type == cmRol || command_type == cmRor) ? osByte : cryptor->size(), 0, value_command->value());
		tmp_command.Init(command_type, first_operand, second_operand);
		tmp_command.CompileToVM(new_ctx);
	}
	for (i = 0; i < tmp_command.count(); i++) {
		AddObject(tmp_command.item(i)->Clone(this));
	}
}

void IntelCommand::AddCheckBreakpointSection(const CompileContext &ctx, OperandSize address_size)
{
	if (address_size < size_) {
		AddVMCommand(ctx, cmPop, otRegistr, address_size, regEIX);
		AddVMCommand(ctx, cmPush, otRegistr, address_size, regEIX);
		AddVMCommand(ctx, cmPush, otValue, osDWord, 0, 0);
		AddVMCommand(ctx, cmPush, otRegistr, address_size, regEIX);
	}
	else {
		AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
		AddVMCommand(ctx, cmPush, otMemory, address_size, segSS);
	}

	AddVMCommand(ctx, cmPush, otMemory, osWord, segDS);
	AddVMCommand(ctx, cmPop, otRegistr, osWord, regEIX);

	AddVMCommand(ctx, cmPush, otRegistr, osByte, regEIX);
	AddVMCommand(ctx, cmPush, otValue, osByte, 0 - 0xcc); // short "int 03"
	AddVMCommand(ctx, cmAdd, otNone, osByte, true);
	AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);
	AddVMCommand(ctx, cmPop, otRegistr, osByte, regEmpty);

	AddVMCommand(ctx, cmPush, otRegistr, osWord, regEIX);
	AddVMCommand(ctx, cmPush, otValue, osWord, 0 - 0x03cd); // long "int 03"
	AddVMCommand(ctx, cmAdd, otNone, osWord, true);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
	AddVMCommand(ctx, cmNor, otNone, size_, false);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
	AddVMCommand(ctx, cmPush, otMemory, size_, segSS);
	AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);
	AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);
	AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);

	AddVMCommand(ctx, cmPush, otRegistr, osWord, regEIX);
	AddVMCommand(ctx, cmPush, otValue, osWord, 0 - 0x0b0f); // "ud2"
	AddVMCommand(ctx, cmAdd, otNone, osWord, true);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
	AddVMCommand(ctx, cmNor, otNone, size_, false);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
	AddVMCommand(ctx, cmPush, otMemory, size_, segSS);
	AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);
	AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);
	AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);

	// extract Z flag to random value
	AddVMCommand(ctx, cmPush, otValue, osWord, 6);
	AddVMCommand(ctx, cmPush, otRegistr, address_size, regETX);
	AddVMCommand(ctx, cmShr, otNone, address_size, false);
	AddVMCommand(ctx, cmPush, otValue, address_size, ~1);
	AddVMCommand(ctx, cmNor, otNone, address_size, false);
	AddVMCommand(ctx, cmPush, otValue, address_size, (uint64_t)-1);
	AddVMCommand(ctx, cmAdd, otNone, address_size, false);
	AddVMCommand(ctx, cmPush, otValue, address_size, rand32());
	AddVMCommand(ctx, cmNand, otNone, address_size, false);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
	AddVMCommand(ctx, cmPush, otMemory, address_size, segSS);
	AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, address_size, false);

	AddVMCommand(ctx, cmAdd, otNone, address_size, false);
}

void IntelCommand::AddCheckCRCSection(const CompileContext &ctx, OperandSize address_size)
{
	AddVMCommand(ctx, cmRdtsc, otNone, size_, 0);
	AddVMCommand(ctx, cmAdd, otNone, osDWord, false);
	AddVMCommand(ctx, cmPush, otValue, osDWord, rand32());
	AddVMCommand(ctx, cmAdd, otNone, osDWord, false);
	AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEIX);

	IntelVMCommand *vm_command = AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
	internal_links_.Add(vlCRCTableCount, vm_command, NULL);
	AddVMCommand(ctx, cmPush, otRegistr, osDWord, regEIX);
	AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
	AddVMCommand(ctx, cmDiv, otNone, osDWord, true);
	AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty);

	AddVMCommand(ctx, cmPush, otValue, osDWord, sizeof(CRCInfo::POD));
	AddVMCommand(ctx, cmMul, otNone, osDWord, true);
	AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty);

	AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
	AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEIX);

	AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);

	if (size_ == osQWord)
		AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
	AddVMCommand(ctx, cmPush, otRegistr, osDWord, regEIX);
	vm_command = AddVMCommand(ctx, cmPush, otValue, size_, 0, voFixup);
	internal_links_.Add(vlCRCTableAddress, vm_command, NULL);
	AddVMCommand(ctx, cmAdd, otNone, size_, false);
	AddVMCommand(ctx, cmPop, otRegistr, size_, regEIX);

	if (address_size == osQWord)
		AddVMCommand(ctx, cmPush, otValue, osDWord, 0);

	if (size_ == osQWord)
		AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX);
	assert(sizeof(CRCInfo::POD) == 12);
	AddVMCommand(ctx, cmPush, otValue, size_, offsetof(CRCInfo::POD, size));
	AddVMCommand(ctx, cmAdd, otNone, size_, false);
	AddVMCommand(ctx, cmPush, otMemory, osDWord, segDS);
	AddCryptorSection(ctx, ctx.file->function_list()->crc_cryptor(), true);

	if (size_ == osQWord)
		AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
	AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX);
	AddVMCommand(ctx, cmPush, otMemory, osDWord, segDS);
	AddCryptorSection(ctx, ctx.file->function_list()->crc_cryptor(), true);
	AddVMCommand(ctx, cmPush, otValue, size_, ctx.file->image_base(), voFixup);
	AddVMCommand(ctx, cmAdd, otNone, size_, false);

	AddVMCommand(ctx, cmCrc, otNone, size_, 0);

	AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX);
	AddVMCommand(ctx, cmPush, otValue, size_, offsetof(CRCInfo::POD, hash));
	AddVMCommand(ctx, cmAdd, otNone, size_, false);
	AddVMCommand(ctx, cmPush, otMemory, osDWord, segDS);

	AddVMCommand(ctx, cmAdd, otNone, osDWord, false);

	AddVMCommand(ctx, cmAdd, otNone, address_size, false);
}

void IntelCommand::AddEndSection(const CompileContext &ctx, IntelCommandType end_command, uint8_t end_value, uint32_t options)
{
	options |= voSectionCommand;

	SectionCryptor *section_cryptor;
	if (options & voUseBeginSectionCryptor) {
		section_cryptor = begin_section_cryptor_;
	} else if (options & voUseEndSectionCryptor) {
		section_cryptor = end_section_cryptor_;
	} else {
		section_cryptor = NULL;
	}

	ByteList *registr_order;
	if (section_cryptor)
		registr_order = section_cryptor->end_cryptor()->registr_order();
	else if (end_command == cmJmp && end_value == 0xff)
		registr_order = link()->to_command()->block()->virtual_machine()->registr_order();
	else 
		registr_order = block()->virtual_machine()->registr_order();

	switch (end_command) {
	case cmRet:
		{
			OperandSize address_size = (end_value == 1) ? osDWord : size_;
			if (ctx.options.flags & cpCheckDebugger)
				AddCheckBreakpointSection(ctx, address_size);
			if (ctx.options.flags & cpMemoryProtection)
				AddCheckCRCSection(ctx, address_size);
		}
		break;

	case cmJmp:
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEIX, options);
		AddVMCommand(ctx, cmPush, otRegistr, size_, regEmpty, options);
		AddVMCommand(ctx, cmPush, otRegistr, size_, regEmpty, options);
		break;
	}

	for (size_t i = 0; i < registr_order->size(); i++) {
		uint8_t reg = registr_order->at(i);
		AddVMCommand(ctx, cmPush, otRegistr, size_, reg, options);
	}

	if (end_command != cmRet)
		AddVMCommand(ctx, cmPush, otRegistr, size_, regERX, options);

	section_options_ |= rtEndSection;

	if (end_command != cmNop) {
		if (end_command == cmJmp)
			AddVMCommand(ctx, cmPush, otRegistr, size_, regEIX, options);
		AddVMCommand(ctx, end_command, otNone, size_, end_value, options);
	}
}

uint64_t IntelCommand::AddStoreEIPSection(const CompileContext &ctx, uint64_t prev_eip)
{
	if (ctx.file->runtime_function_list() && ctx.file->runtime_function_list()->count()) {
		uint64_t value;
		AddressRange *range = address_range();
		if (range) {
			FunctionInfo *info = range->owner();
			uint64_t end_prolog = info->begin() + info->prolog_size();
			if (range->original_begin() > end_prolog || !address_) {
				value = range->original_begin();
			} else if (address_ <= end_prolog) {
				value = address_;
			} else {
				value = end_prolog;
			}
		} else {
			value = 0;
		}
		if (prev_eip != value) {
			AddVMCommand(ctx, cmPush, otValue, size_, value, voFixup);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regExtended + 0);
		}
		return value;
	}
	return -1;
}

void IntelCommand::AddStoreExtRegistrSection(const CompileContext &ctx, uint8_t registr)
{
	if (ctx.file->runtime_function_list() && ctx.file->runtime_function_list()->count()) {
		uint8_t ext_registr;
		if (registr == regESP) {
			ext_registr = regExtended + 1;
		} else {
			if (!address_range() || address_range()->owner()->frame_registr() != registr)
				return;

			switch (registr) {
			case regEBP:
				ext_registr = regExtended + 2;
				break;
			case regESI:
				ext_registr = regExtended + 3;
				break;
			case regEDI:
				ext_registr = regExtended + 4;
				break;
			case regEBX:
				ext_registr = regExtended + 5;
				break;
			default:
				return;
			}
		}

		AddVMCommand(ctx, cmPush, otRegistr, size_, registr);
		AddVMCommand(ctx, cmPop, otRegistr, size_, ext_registr);
	}
}

void IntelCommand::AddStoreExtRegistersSection(const CompileContext &ctx)
{
	if (ctx.file->runtime_function_list() && ctx.file->runtime_function_list()->count()) {
		AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regExtended + 1);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regEBP);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regExtended + 2);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regESI);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regExtended + 3);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regEDI);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regExtended + 4);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regEBX);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regExtended + 5);
	}
}

void IntelCommand::AddExtSection(const CompileContext &ctx, IntelCommand *next_command)
{
	if (next_command) {
		if (ctx.options.flags & cpEncryptBytecode) {
			block()->AddCorrectCommand(AddVMCommand(ctx, cmPush, otValue, size_, rand64(), voSectionCommand));
		} else {
			AddVMCommand(ctx, cmPush, otRegistr, size(), regEmpty, voSectionCommand);
		}
		AddVMCommand(ctx, cmPush, otRegistr, size(), regEmpty, voSectionCommand);
		end_section_cryptor_ = next_command->begin_section_cryptor_;
		AddEndSection(ctx, cmNop, 0, voUseEndSectionCryptor);
		item(count() - 1)->include_option(voInitOffset);
	} else {
		AddBeginSection(ctx, voUseBeginSectionCryptor);
		if ((section_options() & rtLinkedToExt) && begin_section_cryptor_) {
			if (ctx.options.flags & cpEncryptBytecode) {
				block()->AddCorrectCommand(AddVMCommand(ctx, cmPush, otValue, size_, rand64(), voSectionCommand));
			} else {
				AddVMCommand(ctx, cmPush, otRegistr, size_, regEmpty, voSectionCommand);
			}
			AddVMCommand(ctx, cmPush, otRegistr, size_, regEmpty, voSectionCommand);
			AddEndSection(ctx, cmNop);
			item(count() - 1)->include_option(voInitOffset);
			section_options_ &= ~rtEndSection;
			size_t c = count();
			AddBeginSection(ctx);
			ext_vm_entry_ = item(c);
		}
	}
}

void IntelCommand::AddCorrectESPSection(const CompileContext &ctx, OperandSize operand_size, size_t value)
{
	size_t i, j;
	IntelVMCommand *vm_command;

	j = 0;
	for (i = count(); i > 0; i--) {
		vm_command = item(i - 1);
		if (vm_command->options() & voSectionCommand) {
			j = i;
			break;
		}
	}

	for (i = j; i < count() - 1; i++) {
		vm_command = item(i);
		value += vm_command->GetStackLevel();
	}

	if (value) {
		AddVMCommand(ctx, cmPush, otValue, operand_size, value);
		AddVMCommand(ctx, cmAdd, otNone, operand_size, false);
	}
}

void IntelCommand::CompileOperand(const CompileContext &ctx, size_t operand_index, uint32_t options)
{
	IntelOperand *operand = &operand_[operand_index];
	OperandSize operand_size = operand->size;
	uint32_t vm_options = 0;
	if (operand->type & otValue) {
		if (operand->fixup || (options & coFixup) || operand->is_large_value)
			vm_options |= voFixup;
		if (link() && link()->operand_index() == (int)operand_index)
			vm_options |= voLinkCommand;
	}
	if (options & coAsWord) {
		operand_size = osWord;
	} else if (options & coAsPointer) {
		operand_size = size_;
	}
	
	switch (operand->type) {
	case otSegmentRegistr:
		if (options & coSaveResult) {
			AddVMCommand(ctx, cmPop, otSegmentRegistr, osWord, operand->registr);
			AddCorrectOperandSizeSection(ctx, operand_size, osWord);
		} else {
			AddCorrectOperandSizeSection(ctx, osWord, operand_size);
			AddVMCommand(ctx, cmPush, otSegmentRegistr, osWord, operand->registr);
		}
		break;

	case otDebugRegistr:
		if (options & coSaveResult) {
			AddVMCommand(ctx, cmPop, otDebugRegistr, operand_size, operand->registr);
		} else {
			AddVMCommand(ctx, cmPush, otDebugRegistr, operand_size, operand->registr);
		}
		break;

	case otControlRegistr:
		if (options & coSaveResult) {
			AddVMCommand(ctx, cmPop, otControlRegistr, operand_size, operand->registr);
		} else {
			AddVMCommand(ctx, cmPush, otControlRegistr, operand_size, operand->registr);
		}
		break;

	case otHiPartRegistr:
		if (options & coSaveResult) {
			AddVMCommand(ctx, cmPop, otHiPartRegistr, operand_size, operand->registr);
		} else {
			AddVMCommand(ctx, cmPush, otHiPartRegistr, operand_size, operand->registr);
		}
		break;

	case otRegistr:
		if (options & coSaveResult) {
			AddVMCommand(ctx, cmPop, otRegistr, operand_size, operand->registr);
			if (size_ == osQWord && operand_size == osDWord) {
              AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
              AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, operand->registr);
			}
			AddStoreExtRegistrSection(ctx, operand->registr);
		} else {
			AddVMCommand(ctx, cmPush, otRegistr, operand_size, operand->registr);
			if (operand->registr == regESP)
				AddCorrectESPSection(ctx, operand_size, 0);
		}
		break;

	case otValue:
		if ((options & coInverse) && (vm_options & voFixup) == 0) {
			AddVMCommand(ctx, cmPush, otValue, operand_size, ~operand->value, vm_options, operand->fixup);
			options &= ~coInverse;
		} else 
			AddVMCommand(ctx, cmPush, otValue, operand_size, operand->value, vm_options, operand->fixup);
		break;

	default:
		if (operand->type & otMemory) {
			if (operand->type & otBaseRegistr) {
				AddCorrectOperandSizeSection(ctx, operand->address_size, size_);
				AddVMCommand(ctx, cmPush, otRegistr, operand->address_size, operand->base_registr);
				if (operand->base_registr == regESP)
					AddCorrectESPSection(ctx, size_, type_ == cmPop ? OperandSizeToStack(operand_size) : 0);
			}
			if (operand->type & otRegistr) {
				if (operand->scale_registr > 0)
					AddVMCommand(ctx, cmPush, otValue, osWord, operand->scale_registr);
				AddCorrectOperandSizeSection(ctx, operand->address_size, size_);
				AddVMCommand(ctx, cmPush, otRegistr, operand->address_size, operand->registr);
				if (operand->registr == regESP)
					AddCorrectESPSection(ctx, size_, type_ == cmPop ? OperandSizeToStack(operand_size) : 0);
				if (operand->scale_registr > 0)
					AddVMCommand(ctx, cmShl, otNone, size_, false);
				if (operand->type & otBaseRegistr)
					AddVMCommand(ctx, cmAdd, otNone, size_, false);
			}
			if (operand->type & otValue) {
				AddVMCommand(ctx, cmPush, otValue, size_, operand->value, vm_options, operand->fixup);
				if (operand->type & (otBaseRegistr | otRegistr))
					AddVMCommand(ctx, cmAdd, otNone, size_, false);
			}

			if ((options & coAsPointer) == 0) {
				if (options & coSaveResult) {
					AddVMCommand(ctx, cmPop, otMemory, operand_size, operand->effective_base_segment(base_segment_));
				} else {
					AddVMCommand(ctx, cmPush, otMemory, operand_size, operand->effective_base_segment(base_segment_));
				}
			}
		}
	}

	if (options & coInverse) {
		if (operand->type & otMemory) {
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, operand_size, segSS);
		} else {
			CompileOperand(ctx, operand_index);
		}
		AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, operand_size, false);
	}
}

void IntelCommand::CompileToVM(const CompileContext &ctx)
{
	if (link() && link()->type() == ltNative) {
		AddVMCommand(ctx, cmPush, otValue, size_, 0, voLinkCommand | voFixup);
		AddEndSection(ctx, cmRet);
		return;
	}

	size_t i;
	OperandSize os, adr_os;
	IntelOperand *operand;
	uint16_t flags;
	size_t value;
	bool save_flags = (options() & roNoSaveFlags) == 0;

	if ((options() & roLockPrefix) && type_ != cmXchg) {
		switch (type_) {
		case cmAdd: case cmAnd: case cmSub: case cmXor: case cmOr: case cmXadd:
			i = (operand_[0].type & otMemory) ? 0 : 1;
			CompileOperand(ctx, 1 - i);
			CompileOperand(ctx, i, coAsPointer);
			AddVMCommand(ctx, type_, otMemory, operand_[0].size, operand_[i].effective_base_segment(base_segment_));
			AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEFX : regEmpty);
			if (type_ == cmXadd)
				CompileOperand(ctx, 1 - i, coSaveResult);
			break;
		default:
			throw std::runtime_error("Runtime error at CompileToVM: " + text());
		}
	} else
	switch (type_) {
	case cmBt: case cmBtr: case cmBts: case cmBtc:
		uint8_t mask;
		switch (operand_[0].size) {
		case osWord: mask = 15; break;
		case osDWord: mask = 31; break;
		default: mask = 63; break;
		}

		if (operand_[0].type & otMemory) {
			os = osByte;
			uint8_t old_mask = mask;
			mask = 7;

			if (operand_[1].type == otValue) {
				AddVMCommand(ctx, cmPush, otValue, osWord, operand_[1].value & mask);
				AddVMCommand(ctx, cmPush, otValue, size_, (operand_[1].value & old_mask) >> 3);
			} else {
				CompileOperand(ctx, 1, coAsWord);
				AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
				AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
				AddVMCommand(ctx, cmNor, otNone, osWord, false);
				AddVMCommand(ctx, cmPush, otValue, osWord, ~mask);
				AddVMCommand(ctx, cmNor, otNone, osWord, false);

				AddVMCommand(ctx, cmPush, otValue, osWord, 3);
				AddCorrectOperandSizeSection(ctx, operand_[1].size, size_);
				CompileOperand(ctx, 1);
				AddVMCommand(ctx, cmShr, otNone, size_, false);
			}

			CompileOperand(ctx, 0, coAsPointer);
			AddVMCommand(ctx, cmAdd, otNone, size_, false);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
			AddVMCommand(ctx, cmPush, otMemory, osByte, operand_[0].effective_base_segment(base_segment_));
			AddVMCommand(ctx, cmShr, otNone, os, false);
		} else {
			os = operand_[0].size;

			if (operand_[1].type == otValue) {
				AddVMCommand(ctx, cmPush, otValue, osWord, operand_[1].value & mask);
			} else {
				CompileOperand(ctx, 1, coAsWord);
				AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
				AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
				AddVMCommand(ctx, cmNor, otNone, osWord, false);
				AddVMCommand(ctx, cmPush, otValue, osWord, ~mask);
				AddVMCommand(ctx, cmNor, otNone, osWord, false);
			}

			CompileOperand(ctx, 0);
			AddVMCommand(ctx, cmShr, otNone, os, false);
		}

		AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
		AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
		AddVMCommand(ctx, cmNor, otNone, osWord, false);

		AddVMCommand(ctx, cmPush, otValue, osWord, ~fl_C);
		AddVMCommand(ctx, cmNor, otNone, osWord, false);

		AddVMCommand(ctx, cmPush, otRegistr, osWord, regEFX);
		AddVMCommand(ctx, cmPush, otRegistr, osWord, regEFX);
		AddVMCommand(ctx, cmNor, otNone, osWord, false);
		AddVMCommand(ctx, cmPush, otValue, osWord, fl_C);
		AddVMCommand(ctx, cmNor, otNone, osWord, false);

		AddVMCommand(ctx, cmAdd, otNone, osWord, false);

		AddVMCommand(ctx, cmPop, otRegistr, osWord, regEFX);

		AddCorrectOperandSizeSection(ctx, os, osWord);

		if (type_ != cmBt) {
			if (operand_[1].type == otValue) {
				if (operand_[0].type & otMemory) {
					AddVMCommand(ctx, cmPush, otValue, os, 1ull << (operand_[1].value & 7));
				} else {
					AddVMCommand(ctx, cmPush, otValue, os, 1ull << operand_[1].value);
				}
			} else {
				CompileOperand(ctx, 1, coAsWord);
				AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
				AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
				AddVMCommand(ctx, cmNor, otNone, osWord, false);
				AddVMCommand(ctx, cmPush, otValue, osWord, ~mask);
				AddVMCommand(ctx, cmNor, otNone, osWord, false);

				AddVMCommand(ctx, cmPush, otValue, os, 1);
				AddVMCommand(ctx, cmShl, otNone, os, false);
			}

			switch (type_) {
			case cmBts:
				if (operand_[0].type & otMemory) {
					AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
					AddVMCommand(ctx, cmPush, otMemory, osByte, operand_[0].effective_base_segment(base_segment_));
				} else {
					CompileOperand(ctx, 0);
				}
				AddVMCommand(ctx, cmNor, otNone, os, false);

				AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
				AddVMCommand(ctx, cmPush, otMemory, os, segSS);
				break;
			case cmBtr:
				if (operand_[0].type & otMemory) {
					AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
					AddVMCommand(ctx, cmPush, otMemory, osByte, operand_[0].effective_base_segment(base_segment_));

					AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
					AddVMCommand(ctx, cmPush, otMemory, osByte, segSS);
					AddVMCommand(ctx, cmNor, otNone, osByte, false);
				} else {
					CompileOperand(ctx, 0, coInverse);
				}
				break;
			case cmBtc:
				if (operand_[0].type & otMemory) {
					AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
					AddVMCommand(ctx, cmPush, otMemory, osByte, operand_[0].effective_base_segment(base_segment_));
					AddVMCommand(ctx, cmNor, otNone, os, false);

					AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
					AddVMCommand(ctx, cmPush, otMemory, osByte, operand_[0].effective_base_segment(base_segment_));
					AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
					AddVMCommand(ctx, cmPush, otMemory, osByte, segSS);
					AddVMCommand(ctx, cmNor, otNone, osByte, false);
				} else {
					CompileOperand(ctx, 0);
					AddVMCommand(ctx, cmNor, otNone, os, false);

					CompileOperand(ctx, 0, coInverse);
				}

				if (operand_[1].type == otValue) {
					if (operand_[0].type & otMemory) {
						AddVMCommand(ctx, cmPush, otValue, os, ~(1 << (operand_[1].value & 7)));
					} else {
						AddVMCommand(ctx, cmPush, otValue, os, ~(1 << operand_[1].value));
					}
				} else {
					CompileOperand(ctx, 1, coAsWord);
					AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
					AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
					AddVMCommand(ctx, cmNor, otNone, osWord, false);
					AddVMCommand(ctx, cmPush, otValue, osWord, ~mask);
					AddVMCommand(ctx, cmNor, otNone, osWord, false);

					AddVMCommand(ctx, cmPush, otValue, os, 1);
					AddVMCommand(ctx, cmShl, otNone, os, false);

					AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
					AddVMCommand(ctx, cmPush, otMemory, os, segSS);

					AddVMCommand(ctx, cmNor, otNone, os, false);
				}
				AddVMCommand(ctx, cmNor, otNone, os, false);
				break;
			}

			AddVMCommand(ctx, cmNor, otNone, os, false);

			if (operand_[0].type & otMemory) {
				AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
				AddVMCommand(ctx, cmPop, otMemory, osByte, operand_[0].effective_base_segment(base_segment_));
			} else {
				CompileOperand(ctx, 0, coSaveResult);
			}
		}
		break;

	case cmPush:
		CompileOperand(ctx, 0);
		AddStoreExtRegistrSection(ctx, regESP);
		break;

	case cmPop:
		CompileOperand(ctx, 0, coSaveResult);
		AddStoreExtRegistrSection(ctx, regESP);
		break;

	case cmMov:
		CompileOperand(ctx, 1);
		CompileOperand(ctx, 0, coSaveResult);
		break;

	case cmLea:
		CompileOperand(ctx, 1, coAsPointer);
		CompileOperand(ctx, 0, coSaveResult);
		AddCorrectOperandSizeSection(ctx, size_, operand_[0].size);
		break;

	case cmNot:
		CompileOperand(ctx, 0, coInverse);
		CompileOperand(ctx, 0, coSaveResult);
		break;

	case cmNeg:
		CompileOperand(ctx, 0);

		os = operand_[0].size;
		AddVMCommand(ctx, cmPush, otValue, os, -1);
		AddVMCommand(ctx, cmAdd, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEFX : regEmpty);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
		AddVMCommand(ctx, cmPush, otMemory, os, segSS);
		AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEIX : regEmpty);

		CompileOperand(ctx, 0, coSaveResult);

		if (save_flags)
			AddCombineFlagsSection(ctx, fl_P | fl_O | fl_A | fl_C);
		break;

	case cmAdd: case cmAdc: case cmXadd:
		if (type_ == cmXadd)
			CompileOperand(ctx, 0);
		CompileOperand(ctx, 1);

		os = operand_[0].size;
		if (type_ == cmAdc) {
			AddCorrectOperandSizeSection(ctx, osWord, os);
			AddRegistrAndValueSection(ctx, regEFX, osWord, fl_C);
			AddVMCommand(ctx, cmAdd, otNone, os, true);
			AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEIX : regEmpty);
		}

		CompileOperand(ctx, 0);
		AddVMCommand(ctx, cmAdd, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEFX : regEmpty);

		CompileOperand(ctx, 0, coSaveResult);

		if (type_ == cmXadd)
			CompileOperand(ctx, 1, coSaveResult);

		if (type_ == cmAdc && save_flags) {
			AddRegistrAndValueSection(ctx, regEIX, size_, fl_C | fl_A | fl_O);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);
			AddVMCommand(ctx, cmNor, otNone, size_, false);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, size_, segSS);
			AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, size_, false);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);
		}
		break;

	case cmSbb:
		CompileOperand(ctx, 1);

		os = operand_[0].size;
		AddCorrectOperandSizeSection(ctx, osWord, os);
		AddRegistrAndValueSection(ctx, regEFX, osWord, fl_C);
		AddVMCommand(ctx, cmAdd, otNone, os, false);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
		AddVMCommand(ctx, cmPush, otMemory, os, segSS);
		AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, os, false);

		AddVMCommand(ctx, cmPush, otValue, os, 1);
		AddVMCommand(ctx, cmAdd, otNone, os, false);

		CompileOperand(ctx, 0);

		AddVMCommand(ctx, cmAdd, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEFX : regEmpty);

		CompileOperand(ctx, 0, coSaveResult);

		if (save_flags)
			AddCorrectFlagSection(ctx, fl_A | fl_C);
		break;

	case cmSub: case cmCmp:
		CompileOperand(ctx, 1);
		CompileOperand(ctx, 0, coInverse);

		os = operand_[0].size;
		AddVMCommand(ctx, cmAdd, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEFX : regEmpty);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
		AddVMCommand(ctx, cmPush, otMemory, os, segSS);

		AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEIX : regEmpty);

		if (type_ == cmCmp) {
			AddVMCommand(ctx, cmPop, otRegistr, os, regEmpty);
		} else {
			CompileOperand(ctx, 0, coSaveResult);
		}

		if (save_flags)
			AddCombineFlagsSection(ctx, fl_P | fl_O | fl_A | fl_C);
		break;

	case cmInc:
		os = operand_[0].size;
		AddVMCommand(ctx, cmPush, otValue, os, 1);
		CompileOperand(ctx, 0);

		AddVMCommand(ctx, cmAdd, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEIX : regEmpty);

		CompileOperand(ctx, 0, coSaveResult);

		if (save_flags)
			AddCombineFlagsSection(ctx, fl_C);
		break;

	case cmDec:
		os = operand_[0].size;
		AddVMCommand(ctx, cmPush, otValue, os, -1);
		CompileOperand(ctx, 0);

		AddVMCommand(ctx, cmAdd, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEIX : regEmpty);

		CompileOperand(ctx, 0, coSaveResult);

		if (save_flags) {
			AddCombineFlagsSection(ctx, fl_C);
			AddCorrectFlagSection(ctx, fl_A);
		}
		break;

	case cmXlat:
		os = operand_[0].size;
		AddCorrectOperandSizeSection(ctx, os, size_);

		AddCorrectOperandSizeSection(ctx, osWord, os);
		AddVMCommand(ctx, cmPush, otRegistr, osByte, regEAX);

		AddVMCommand(ctx, cmPush, otRegistr, os, regEBX);
		AddVMCommand(ctx, cmAdd, otNone, os, false);
		AddVMCommand(ctx, cmPush, otMemory, osByte, (base_segment_ == segDefault) ? segDS : base_segment_);
		AddVMCommand(ctx, cmPop, otRegistr, osByte, regEAX);
		break;

	case cmSetXX:
		AddExtractFlagSection(ctx, flags_,(options() & roInverseFlag) != 0, 1);
		CompileOperand(ctx, 0, coSaveResult);
		AddCorrectOperandSizeSection(ctx, size_, osWord);
		break;

	case cmAnd: case cmTest:
		os = operand_[0].size;
		if (rand() & 1) {
			CompileOperand(ctx, 1, coInverse);
			CompileOperand(ctx, 0, coInverse);
			AddVMCommand(ctx, cmNor, otNone, os, true);
		} else {
			CompileOperand(ctx, 1);
			CompileOperand(ctx, 0);
			AddVMCommand(ctx, cmNand, otNone, os, false);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, os, segSS);
			AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, os, true);
		}
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEFX : regEmpty);

		if (type_ == cmTest) {
			AddVMCommand(ctx, cmPop, otRegistr, os, regEmpty);
		} else {
			CompileOperand(ctx, 0, coSaveResult);
		}
		break;

	case cmXor:
		os = operand_[0].size;
		if (rand() & 1) {
			CompileOperand(ctx, 1, coInverse);
			CompileOperand(ctx, 0, coInverse);
			AddVMCommand(ctx, cmNor, otNone, os, false);

			CompileOperand(ctx, 1);
			CompileOperand(ctx, 0);
			AddVMCommand(ctx, cmNor, otNone, os, false);

			AddVMCommand(ctx, cmNor, otNone, os, true);
		} else {
			CompileOperand(ctx, 1, coInverse);
			CompileOperand(ctx, 0);
			AddVMCommand(ctx, cmNand, otNone, os, false);

			CompileOperand(ctx, 1);
			CompileOperand(ctx, 0, coInverse);
			AddVMCommand(ctx, cmNand, otNone, os, false);

			AddVMCommand(ctx, cmNand, otNone, os, true);
		}
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEFX : regEmpty);

		CompileOperand(ctx, 0, coSaveResult);
		break;

	case cmOr:
		os = operand_[0].size;
		if (rand() & 1) {
			CompileOperand(ctx, 1);
			CompileOperand(ctx, 0);
			AddVMCommand(ctx, cmNor, otNone, os, false);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, os, segSS);
			AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, os, true);
		} else {
			CompileOperand(ctx, 1, coInverse);
			CompileOperand(ctx, 0, coInverse);
			AddVMCommand(ctx, cmNand, otNone, os, true);
		}
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEFX : regEmpty);

		CompileOperand(ctx, 0, coSaveResult);
		break;

	case cmShld: case cmShrd:
		CompileOperand(ctx, 2);
		CompileOperand(ctx, 1);
		CompileOperand(ctx, 0);

		os = operand_[0].size;
		if (os == osWord) {
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, osDWord, segSS);
		}

		AddVMCommand(ctx, type_, otNone, os == osQWord ? osQWord : osDWord, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEFX : regEmpty);

		CompileOperand(ctx, 0, coSaveResult);

		if (os == osWord)
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);
		break;

	case cmRol: case cmRor:
		CompileOperand(ctx, 1);
		CompileOperand(ctx, 0);

		os = operand_[0].size;
		switch (os) {
		case osByte:
			AddVMCommand(ctx, cmPush, otValue, osWord, 8);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otValue, size_, 2);
			AddVMCommand(ctx, cmAdd, otNone, size_, false);
			AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
			AddVMCommand(ctx, cmShl, otNone, osWord, false);
			AddVMCommand(ctx, cmAdd, otNone, osWord, false);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
			break;
		case osWord:
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
			break;
		}

		adr_os = (os == osQWord) ? osQWord : osDWord;
		AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
		AddVMCommand(ctx, cmPush, otMemory, adr_os, segSS);

		AddVMCommand(ctx, type_ == cmRol ? cmShld : cmShrd, otNone, adr_os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEIX : regEmpty);

		CompileOperand(ctx, 0, coSaveResult);

		if (os == osByte || os == osWord)
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);

		if (save_flags)
			AddCombineFlagsSection(ctx, fl_P | fl_A | fl_Z | fl_S);
		break;

	case cmShl: case cmSal: case cmShr:
		CompileOperand(ctx, 1);
		CompileOperand(ctx, 0);

		os = operand_[0].size;
		AddVMCommand(ctx, type_ == cmShr ? cmShr : cmShl, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEFX : regEmpty);

		CompileOperand(ctx, 0, coSaveResult);
		break;

	case cmSar:
		CompileOperand(ctx, 1);

		os = operand_[0].size;
		adr_os = (os == osQWord) ? osQWord : osDWord;
		AddVMCommand(ctx, cmPush, otValue, adr_os, 1);
		AddVMCommand(ctx, cmPush, otValue, osWord, OperandSizeToValue(os) * 8 - 1);
		if (os == osByte || os == osWord)
			AddVMCommand(ctx, cmPush, otValue, osWord, 0);

		CompileOperand(ctx, 0);
		AddVMCommand(ctx, cmShr, otNone, adr_os, false);
		AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
		AddVMCommand(ctx, cmPush, otMemory, adr_os, segSS);
		AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, adr_os, false);
		AddVMCommand(ctx, cmAdd, otNone, adr_os, false);

		switch (os) {
		case osByte:
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);

			AddVMCommand(ctx, cmPush, otValue, osWord, 8);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otValue, size_, 2);
			AddVMCommand(ctx, cmAdd, otNone, size_, false);
			AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
			AddVMCommand(ctx, cmShl, otNone, osWord, false);

			CompileOperand(ctx, 0);

			AddVMCommand(ctx, cmAdd, otNone, osWord, false);
			break;
		case osWord:
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
			CompileOperand(ctx, 0);
			break;
		default:
			CompileOperand(ctx, 0);
			break;
		}

		AddVMCommand(ctx, cmShrd, otNone, adr_os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEFX : regEmpty);

		CompileOperand(ctx, 0, coSaveResult);

		if (os == osByte || os == osWord)
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);
		break;

	case cmRcl: case cmRcr:
		AddVMCommand(ctx, cmPush, otValue, osByte, 8);
		AddRegistrAndValueSection(ctx, regEFX, osWord, fl_C);
		AddVMCommand(ctx, cmShl, otNone, osWord, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty);

		os = operand_[0].size;
		CompileOperand(ctx, 1);
		AddVMCommand(ctx, cmAdd, otNone, osWord, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEmpty);

		CompileOperand(ctx, 0);

		AddVMCommand(ctx, type_, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEIX : regEmpty);
		CompileOperand(ctx, 0, coSaveResult);

		if (save_flags)
			AddCombineFlagsSection(ctx, fl_S | fl_Z | fl_A | fl_P);
		break;

	case cmCbw: case cmCwde: case cmCwd: case cmCdq: case cmCdqe: case cmCqo:
		switch (type_) {
		case cmCbw:
			os = osByte;
			break;
		case cmCwde: case cmCwd:
			os = osWord;
			break;
		case cmCdq: case cmCdqe:
			os = osDWord;
			break;
		default:
			os = osQWord;
			break;
		}
		AddVMCommand(ctx, cmPush, otValue, os, 1);

		AddVMCommand(ctx, cmPush, otValue, osWord, OperandSizeToValue(os) * 8 - 1);
		AddVMCommand(ctx, cmPush, otRegistr, os, regEAX);
		AddVMCommand(ctx, cmShr, otNone, os, false);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
		AddVMCommand(ctx, cmPush, otMemory, os, segSS);
		AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, os, false);

		AddVMCommand(ctx, cmAdd, otNone, os, false);

		switch (type_) {
		case cmCbw:
			AddVMCommand(ctx, cmPop, otHiPartRegistr, osByte, regEAX);
			break;
		case cmCwde:
			AddVMCommand(ctx, cmPush, otRegistr, osWord, regEAX);
			AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEAX);
			if (size_ == osQWord) {
				AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
				AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regEAX);
			}
			break;
		case cmCwd:
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regEDX);
			break;
		case cmCdq:
			AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEDX);
			if (size_ == osQWord) {
				AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
				AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regEDX);
			}
			break;
		case cmCdqe:
			AddVMCommand(ctx, cmPush, otRegistr, osDWord, regEAX);
			AddVMCommand(ctx, cmPop, otRegistr, osQWord, regEAX);
			break;
		default:
			AddVMCommand(ctx, cmPop, otRegistr, osQWord, regEDX);
			break;
		}
		break;

	case cmMovsx:
	case cmMovsxd:
		if (operand_[1].size == operand_[0].size) {
			CompileOperand(ctx, 1);
		} else {
			AddCorrectOperandSizeSection(ctx, operand_[1].size, operand_[0].size);
			CompileOperand(ctx, 1);

			AddVMCommand(ctx, cmPush, otValue, osWord, OperandSizeToValue(operand_[1].size) * 8);
			AddVMCommand(ctx, cmPush, otValue, osWord, OperandSizeToValue(operand_[1].size) * 8 - 1);

			os = operand_[0].size;
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToValue(osWord) * 2);
			AddVMCommand(ctx, cmAdd, otNone, size_, false);
			AddVMCommand(ctx, cmPush, otMemory, os, segSS);

			AddVMCommand(ctx, cmShr, otNone, os, false);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, os, segSS);
			AddVMCommand(ctx, (rand() & 1) ? cmNor : cmNand, otNone, os, false);

			AddVMCommand(ctx, cmPush, otValue, os, 1);
			AddVMCommand(ctx, cmAdd, otNone, os, false);

			AddVMCommand(ctx, cmShl, otNone, os, false);

			AddVMCommand(ctx, cmAdd, otNone, os, false);
		}

		CompileOperand(ctx, 0, coSaveResult);
		break;

	case cmMovzx:
		AddCorrectOperandSizeSection(ctx, operand_[1].size, operand_[0].size);
		CompileOperand(ctx, 1);
		CompileOperand(ctx, 0, coSaveResult);
		break;

	case cmPushf:
		AddVMCommand(ctx, cmPush, otRegistr, operand_[0].size, regEFX);
		AddStoreExtRegistrSection(ctx, regESP);
		break;

	case cmPopf:
		AddVMCommand(ctx, cmPop, otRegistr, operand_[0].size, regEFX);
		AddRegistrAndValueSection(ctx, regEFX, size_, ~0x8ff);
		AddVMCommand(ctx, cmPopf, otNone, size_, 0);
		AddStoreExtRegistrSection(ctx, regESP);
		break;

	case cmPusha:
		os = operand_[0].size;

		AddVMCommand(ctx, cmPush, otRegistr, os, regEAX);
		AddVMCommand(ctx, cmPush, otRegistr, os, regECX);
		AddVMCommand(ctx, cmPush, otRegistr, os, regEDX);
		AddVMCommand(ctx, cmPush, otRegistr, os, regEBX);

		AddVMCommand(ctx, cmPush, otRegistr, os, regESP);
		AddVMCommand(ctx, cmPush, otValue, os, OperandSizeToValue(os) * 4);
		AddVMCommand(ctx, cmAdd, otNone, os, false);

		AddVMCommand(ctx, cmPush, otRegistr, os, regEBP);
		AddVMCommand(ctx, cmPush, otRegistr, os, regESI);
		AddVMCommand(ctx, cmPush, otRegistr, os, regEDI);
		AddStoreExtRegistrSection(ctx, regESP);
		break;

	case cmPopa:
		os = operand_[0].size;

		AddVMCommand(ctx, cmPop, otRegistr, os, regEDI);
		AddVMCommand(ctx, cmPop, otRegistr, os, regESI);
		AddVMCommand(ctx, cmPop, otRegistr, os, regEBP);
		AddVMCommand(ctx, cmPop, otRegistr, os, regEmpty);
		AddVMCommand(ctx, cmPop, otRegistr, os, regEBX);
		AddVMCommand(ctx, cmPop, otRegistr, os, regEDX);
		AddVMCommand(ctx, cmPop, otRegistr, os, regECX);
		AddVMCommand(ctx, cmPop, otRegistr, os, regEAX);
		AddStoreExtRegistrSection(ctx, regESP);
		break;

	case cmLahf:
		AddVMCommand(ctx, cmPush, otRegistr, osWord, regEFX);
		AddVMCommand(ctx, cmPop, otHiPartRegistr, osByte, regEAX);
		break;

	case cmSahf:
		flags = fl_C | fl_P | fl_A | fl_Z | fl_S;

		AddVMCommand(ctx, cmPush, otHiPartRegistr, osByte, regEAX);
		AddVMCommand(ctx, cmPush, otHiPartRegistr, osByte, regEAX);
		AddVMCommand(ctx, cmNor, otNone, osByte, false);
		AddVMCommand(ctx, cmPush, otValue, osByte, ~flags);
		AddVMCommand(ctx, cmNor, otNone, osByte, false);

		AddRegistrAndValueSection(ctx, regEFX, osWord, ~flags);
		AddVMCommand(ctx, cmAdd, otNone, osWord, false);
		AddVMCommand(ctx, cmPop, otRegistr, osWord, regEFX);
		break;

	case cmXchg:
		if ((operand_[0].type | operand_[1].type) & otMemory) {
			i = (operand_[0].type & otMemory) ? 0 : 1;
			CompileOperand(ctx, 1 - i);
			CompileOperand(ctx, i, coAsPointer);
			AddVMCommand(ctx, cmXchg, otMemory, operand_[0].size, operand_[i].effective_base_segment(base_segment_));
			CompileOperand(ctx, 1 - i, coSaveResult);
		}
		else {
			operand = &operand_[1];
			if (operand->type == otRegistr && operand->size > osByte && operand->registr == regESP) {
				CompileOperand(ctx, 0);
				CompileOperand(ctx, 1);
				CompileOperand(ctx, 0, coSaveResult);
				CompileOperand(ctx, 1, coSaveResult);
			}
			else {
				CompileOperand(ctx, 1);
				CompileOperand(ctx, 0);
				CompileOperand(ctx, 1, coSaveResult);
				CompileOperand(ctx, 0, coSaveResult);
			}
		}
		break;

	case cmFnop: case cmNop:
		// do nothing
		break;

	case cmClc:
		AddRegistrAndValueSection(ctx, regEFX, size_, ~fl_C);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);
		break;

	case cmStc:
		AddRegistrOrValueSection(ctx, regEFX, size_, fl_C);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);
		break;

	case cmCmc:
		AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);
		AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);
		AddVMCommand(ctx, cmNor, otNone, size_, false);

		AddVMCommand(ctx, cmPush, otValue, size_, ~fl_C);
		AddVMCommand(ctx, cmNor, otNone, size_, false);

		AddVMCommand(ctx, cmPush, otRegistr, size_, regEFX);
		AddVMCommand(ctx, cmPush, otValue, size_, fl_C);
		AddVMCommand(ctx, cmNor, otNone, size_, false);

		AddVMCommand(ctx, cmNor, otNone, size_, false);

		AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);
		break;

	case cmCld:
		AddRegistrAndValueSection(ctx, regEFX, size_, ~fl_D);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);
		AddRegistrAndValueSection(ctx, regEFX, size_, ~0x8ff);
		AddVMCommand(ctx, cmPopf, otNone, size_, false);
		break;

	case cmStd:
		AddRegistrOrValueSection(ctx, regEFX, size_, fl_D);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);
		AddRegistrAndValueSection(ctx, regEFX, size_, ~0x8ff);
		AddVMCommand(ctx, cmPopf, otNone, size_, false);
		break;

	case cmBswap:
		switch (operand_[0].size) {
		case osWord:
			AddVMCommand(ctx, cmPush, otValue, osWord, 0);
			CompileOperand(ctx, 0, coSaveResult);
			break;
		case osDWord:
			AddVMCommand(ctx, cmPush, otValue, osWord, 8);
			CompileOperand(ctx, 0);
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regETX);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
			AddVMCommand(ctx, cmShl, otNone, osDWord, false);

			AddVMCommand(ctx, cmPush, otValue, osWord, 8);
			AddVMCommand(ctx, cmPush, otRegistr, osWord, regETX);
			AddVMCommand(ctx, cmPush, otRegistr, osWord, regETX);
			AddVMCommand(ctx, cmShl, otNone, osDWord, false);
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otValue, size_, 4);
			AddVMCommand(ctx, cmAdd, otNone, size_, false);
			AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);

			CompileOperand(ctx, 0, coSaveResult);

			AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
			break;
		case osQWord:
			AddVMCommand(ctx, cmPush, otValue, osWord, 8);
			CompileOperand(ctx, 0);
			AddVMCommand(ctx, cmPop, otRegistr, osDWord, regETX);
			AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
			AddVMCommand(ctx, cmPush, otRegistr, osDWord, regETX);
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
			AddVMCommand(ctx, cmShl, otNone, osDWord, false);

			AddVMCommand(ctx, cmPush, otValue, osWord, 8);
			AddVMCommand(ctx, cmPush, otRegistr, osWord, regETX);
			AddVMCommand(ctx, cmPush, otRegistr, osWord, regETX);
			AddVMCommand(ctx, cmShl, otNone, osDWord, false);
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otValue, size_, 4);
			AddVMCommand(ctx, cmAdd, otNone, size_, false);
			AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);

			AddVMCommand(ctx, cmPush, otValue, osWord, 8);
			CompileOperand(ctx, 0);
			AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regETX);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);
			AddVMCommand(ctx, cmShl, otNone, osDWord, false);

			AddVMCommand(ctx, cmPush, otValue, osWord, 8);
			AddVMCommand(ctx, cmPush, otRegistr, osWord, regETX);
			AddVMCommand(ctx, cmPush, otRegistr, osWord, regETX);
			AddVMCommand(ctx, cmShl, otNone, osDWord, false);
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otValue, size_, 4);
			AddVMCommand(ctx, cmAdd, otNone, size_, false);
			AddVMCommand(ctx, cmPush, otMemory, osWord, segSS);

			AddVMCommand(ctx, cmPop, otRegistr, osDWord, regETX);
			AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
			AddVMCommand(ctx, cmPush, otRegistr, osDWord, regETX);
			CompileOperand(ctx, 0, coSaveResult);
			AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
			break;
		}
		break;

	case cmFstsw:
		operand = &operand_[0];
		if (operand->type == (otMemory | otBaseRegistr) && operand->base_registr == regESP) {
			AddVMCommand(ctx, cmFstsw, otNone, osWord, 0);
		} else {
			AddVMCommand(ctx, cmPush, otRegistr, osWord, regEmpty);
			AddVMCommand(ctx, cmFstsw, otNone, osWord, 0);
			CompileOperand(ctx, 0, coSaveResult);
		}
		break;

	case cmFldcw:
		operand = &operand_[0];
		if (operand->type == (otMemory | otBaseRegistr) && operand->base_registr == regESP) {
			AddVMCommand(ctx, cmFldcw, otNone, osWord, 0);
		} else {
			CompileOperand(ctx, 0);
			AddVMCommand(ctx, cmFldcw, otNone, osWord, 0);
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);
		}
		break;

	case cmFstcw:
		operand = &operand_[0];
		if (operand->type == (otMemory | otBaseRegistr) && operand->base_registr == regESP) {
			AddVMCommand(ctx, cmFstcw, otNone, osWord, 0);
		} else {
			AddVMCommand(ctx, cmPush, otRegistr, osWord, regEmpty);
			AddVMCommand(ctx, cmFstcw, otNone, osWord, 0);
			CompileOperand(ctx, 0, coSaveResult);
		}
		break;

	case cmImul: case cmMul:
		os = operand_[0].size;

		if (operand_[2].type != otNone) {
			CompileOperand(ctx, 2);
			CompileOperand(ctx, 1);
		} else if (operand_[1].type != otNone) {
			CompileOperand(ctx, 1);
			CompileOperand(ctx, 0);
		} else {
			CompileOperand(ctx, 0);
			AddVMCommand(ctx, cmPush, otRegistr, os, regEAX);
		}

		AddVMCommand(ctx, type_, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEIX : regEmpty);

		if (operand_[1].type != otNone) {
			if (os > osByte)
				AddVMCommand(ctx, cmPop, otRegistr, os, regEmpty);
			CompileOperand(ctx, 0, coSaveResult);
		} else if (os == osByte) {
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regEAX);
		} else {
			AddVMCommand(ctx, cmPop, otRegistr, os, regEDX);
			AddVMCommand(ctx, cmPop, otRegistr, os, regEAX);
			if (size_ == osQWord && os == osDWord) {
				AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
				AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regEAX);
				AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
				AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regEDX);
			}
		}

		if (save_flags)
			AddCombineFlagsSection(ctx, fl_S | fl_Z | fl_A | fl_P);
		break;

	case cmDiv: case cmIdiv:
		os = operand_[0].size;

		CompileOperand(ctx, 0);
		if (os == osByte) {
			AddVMCommand(ctx, cmPush, otRegistr, osWord, regEAX);
		} else {
			AddVMCommand(ctx, cmPush, otRegistr, os, regEAX);
			AddVMCommand(ctx, cmPush, otRegistr, os, regEDX);
		}

		AddVMCommand(ctx, type_, otNone, os, true);
		AddVMCommand(ctx, cmPop, otRegistr, size_, save_flags ? regEFX : regEmpty);

		if (os == osByte) {
			AddVMCommand(ctx, cmPop, otRegistr, osWord, regEAX);
		} else {
			AddVMCommand(ctx, cmPop, otRegistr, os, regEDX);
			AddVMCommand(ctx, cmPop, otRegistr, os, regEAX);
		}

		if (size_ == osQWord && os == osDWord) {
			AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
			AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regEAX);
			AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
			AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regEDX);
		}
		break;

	case cmJmpWithFlag: case cmJCXZ: case cmLoop: case cmLoope: case cmLoopne:
		AddJmpWithFlagSection(ctx, type_);
		if (section_options_ & rtLinkedNext) {
			AddBeginSection(ctx, voLinkCommand | voUseEndSectionCryptor);
			AddVMCommand(ctx, cmPush, otValue, size_, 0, voLinkCommand | voFixup);
			AddEndSection(ctx, cmJmp, 0, voUseEndSectionCryptor);
		} else {
			AddBeginSection(ctx, voLinkCommand | voUseEndSectionCryptor);
			AddVMCommand(ctx, cmPush, otValue, size_, address() + original_dump_size(), voFixup);
			AddEndSection(ctx, cmRet);
		}
		if (section_options_ & rtLinkedFrom) {
			AddBeginSection(ctx, voLinkCommand | voUseEndSectionCryptor);
			AddVMCommand(ctx, cmPush, otValue, size_, 0, voLinkCommand | voFixup);
			AddEndSection(ctx, cmJmp, 0, voUseEndSectionCryptor);
		} else {
			AddBeginSection(ctx, voLinkCommand | voUseEndSectionCryptor);
			AddCorrectOperandSizeSection(ctx, operand_[0].size, size_);
			CompileOperand(ctx, 0, coFixup);
			AddEndSection(ctx, cmRet);
		}
		break;

	case cmJmp:
		CompileOperand(ctx, 1, coAsPointer);

		operand = &operand_[0];
		if ((options() & roFar) && (operand->type & otMemory)) {
			CompileOperand(ctx, 0, coAsPointer);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);

			AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToValue(size_));
			AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
			AddVMCommand(ctx, cmAdd, otNone, size_, false);
			AddVMCommand(ctx, cmPush, otMemory, size_, operand->effective_base_segment(base_segment_));

			AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
			AddVMCommand(ctx, cmPush, otMemory, size_, operand->effective_base_segment(base_segment_));
		} else {
			AddCorrectOperandSizeSection(ctx, operand->size, size_);
			CompileOperand(ctx, 0, ((options() & roFar) || operand->type != otValue) ? 0 : coFixup);
		}

		if (section_options_ & rtLinkedFrom) {
			AddEndSection(ctx, cmJmp, (options() & roExternal) ? 0xff : 0, voUseEndSectionCryptor);
		} else {
			AddEndSection(ctx, cmRet, (options() & roFar) != 0);
		}
		break;

	case cmCall:
		if ((options() & roInternal) && (section_options_ & rtLinkedFrom) == 0) {
			uint8_t arg_count = static_cast<uint32_t>(operand_[2].value);
			switch (ctx.file->calling_convention()) {
			case ccMSx64:
				if (arg_count > 3)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regR9);
				if (arg_count > 2)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regR8);
				if (arg_count > 1)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regEDX);
				if (arg_count > 0)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regECX);
				break;
			case ccABIx64:
				if (arg_count > 5)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regR9);
				if (arg_count > 4)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regR8);
				if (arg_count > 3)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regECX);
				if (arg_count > 2)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regEDX);
				if (arg_count > 1)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regESI);
				if (arg_count > 0)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regEDI);
				break;
			}
		} else {
			if (options() & roFar) {
				AddCorrectOperandSizeSection(ctx, osWord, size_);
				AddVMCommand(ctx, cmPush, otSegmentRegistr, osWord, segCS);
			}
			AddVMCommand(ctx, cmPush, otValue, size_, 0, voLinkCommand | voFixup);
			CompileOperand(ctx, 1, coAsPointer);
		}

		operand = &operand_[0];
		if ((options() & roFar) && (operand->type & otMemory)) {
			CompileOperand(ctx, 0, coAsPointer);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);

			AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToValue(size_));
			AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
			AddVMCommand(ctx, cmAdd, otNone, size_, false);
			AddVMCommand(ctx, cmPush, otMemory, size_, operand->effective_base_segment(base_segment_));

			AddVMCommand(ctx, cmPush, otRegistr, size_, regETX);
			AddVMCommand(ctx, cmPush, otMemory, size_, operand->effective_base_segment(base_segment_));
		} else {
			AddCorrectOperandSizeSection(ctx, operand->size, size_);
			CompileOperand(ctx, 0, ((options() & roFar) || operand->type != otValue) ? 0 : coFixup);
		}

		if (section_options_ & rtLinkedFrom) {
			AddStoreExtRegistersSection(ctx);
			AddEndSection(ctx, cmJmp, (options() & roExternal) ? 0xff : 0, voUseEndSectionCryptor);
		} else if (options() & roInternal) {
			if (ctx.options.flags & cpCheckDebugger)
				AddCheckBreakpointSection(ctx, size_);
			if (ctx.options.flags & cpMemoryProtection)
				AddCheckCRCSection(ctx, size_);
			AddVMCommand(ctx, cmCall, otNone, size_, operand_[2].value);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regEAX);
		} else {
			AddEndSection(ctx, cmRet, (options() & roFar) != 0);
		}
		break;

	case cmSyscall:
		{
			uint8_t arg_count = static_cast<uint32_t>(operand_[2].value);
			switch (ctx.file->calling_convention()) {
			case ccMSx64:
				if (arg_count > 3)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regR9);
				if (arg_count > 2)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regR8);
				if (arg_count > 1)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regEDX);
				if (arg_count > 0)
					AddVMCommand(ctx, cmPush, otRegistr, size_, regECX);
				break;
			}
		}
		CompileOperand(ctx, 0);
		AddVMCommand(ctx, cmSyscall, otNone, size_, operand_[2].value);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEAX);
		break;

	case cmCmov:
		AddJmpWithFlagSection(ctx, cmJmpWithFlag);
		AddBeginSection(ctx, voLinkCommand | voUseEndSectionCryptor);
		CompileOperand(ctx, 1);
		CompileOperand(ctx, 0, coSaveResult);

		if (section_options_ & rtLinkedNext) {
			AddVMCommand(ctx, cmPush, otValue, size_, 0, voLinkCommand | voFixup);
			AddEndSection(ctx, cmJmp, 0, voUseEndSectionCryptor);

			AddBeginSection(ctx, voLinkCommand | voUseEndSectionCryptor);
			AddVMCommand(ctx, cmPush, otValue, size_, 0, voLinkCommand | voFixup);
			AddEndSection(ctx, cmJmp, 0, voUseEndSectionCryptor);
		} else {
			AddVMCommand(ctx, cmPush, otValue, size_, address() + original_dump_size(), voFixup);
			AddEndSection(ctx, cmRet);

			AddBeginSection(ctx, voLinkCommand | voUseEndSectionCryptor);
			AddVMCommand(ctx, cmPush, otValue, size_, address() + original_dump_size(), voFixup);
			AddEndSection(ctx, cmRet);
		}
		break;

	case cmLods: case cmStos: case cmScas: case cmMovs: case cmCmps: case cmIns: case cmOuts:
		os = operand_[0].size;
		adr_os = operand_[1].size;
		value = OperandSizeToValue(os);

		if (preffix_command_ == cmRep || preffix_command_ == cmRepe || preffix_command_ == cmRepne) {
			if ((section_options_ & rtBeginSection) == 0)
				AddBeginSection(ctx, voUseBeginSectionCryptor);
			AddJmpWithFlagSection(ctx, cmJCXZ);
			AddBeginSection(ctx, voLinkCommand | voUseEndSectionCryptor);
		}

		switch (type_) {
		case cmLods:
			AddCorrectOperandSizeSection(ctx, adr_os, size_);
			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regESI);
			AddVMCommand(ctx, cmPush, otMemory, os, base_segment_ == segDefault ? segDS : base_segment_);

			AddVMCommand(ctx, cmPop, otRegistr, os, regEAX);
			if (size_ == osQWord && os == osDWord) {
				AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
				AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regEAX);
			}
			break;

		case cmStos:
			AddCorrectOperandSizeSection(ctx, adr_os, size_);
			AddVMCommand(ctx, cmPush, otRegistr, os, regEAX);
			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regEDI);
			AddVMCommand(ctx, cmPop, otMemory, os, segES);
			break;
		
		case cmMovs:
			AddCorrectOperandSizeSection(ctx, adr_os, size_);
			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regESI);
			AddVMCommand(ctx, cmPush, otMemory, os, base_segment_ == segDefault ? segDS : base_segment_);

			AddCorrectOperandSizeSection(ctx, adr_os, size_);
			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regEDI);
			AddVMCommand(ctx, cmPop, otMemory, os, segES);
			break;

		case cmScas:
			AddCorrectOperandSizeSection(ctx, adr_os, size_);
			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regEDI);
			AddVMCommand(ctx, cmPush, otMemory, os, segES);

			AddVMCommand(ctx, cmPush, otRegistr, os, regEAX);
			AddVMCommand(ctx, cmPush, otRegistr, os, regEAX);
			AddVMCommand(ctx, cmNor, otNone, os, false);

			AddVMCommand(ctx, cmAdd, otNone, os, true);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, os, segSS);
			AddVMCommand(ctx, cmNor, otNone, os, true);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regEIX);

			AddVMCommand(ctx, cmPop, otRegistr, os, regEmpty);

			AddCombineFlagsSection(ctx, fl_P | fl_O | fl_A | fl_C);
			break;

		case cmCmps:
			AddCorrectOperandSizeSection(ctx, adr_os, size_);
			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regESI);
			AddVMCommand(ctx, cmPush, otMemory, os, base_segment_ == segDefault ? segDS : base_segment_);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, os, segSS);
			AddVMCommand(ctx, cmNor, otNone, os, false);

			AddCorrectOperandSizeSection(ctx, adr_os, size_);
			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regEDI);
			AddVMCommand(ctx, cmPush, otMemory, os, segES);

			AddVMCommand(ctx, cmAdd, otNone, os, true);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regEFX);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, os, segSS);
			AddVMCommand(ctx, cmNor, otNone, os, true);
			AddVMCommand(ctx, cmPop, otRegistr, size_, regEIX);

			AddVMCommand(ctx, cmPop, otRegistr, os, regEmpty);

			AddCombineFlagsSection(ctx, fl_P | fl_O | fl_A | fl_C);
			break;

		case cmIns:
			AddCorrectOperandSizeSection(ctx, adr_os, size_);

			AddVMCommand(ctx, cmPush, otRegistr, osWord, regEDX);
			AddVMCommand(ctx, cmIn, otNone, os, 0);

			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regEDI);
			AddVMCommand(ctx, cmPop, otMemory, os, segES);
			break;

		case cmOuts:
			AddCorrectOperandSizeSection(ctx, adr_os, size_);

			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regESI);
			AddVMCommand(ctx, cmPush, otMemory, os, base_segment_ == segDefault ? segDS : base_segment_);

			AddVMCommand(ctx, cmPush, otRegistr, osWord, regEDX);
			AddVMCommand(ctx, cmOut, otNone, os, 0);
			break;
		}
		
		AddExtractFlagSection(ctx, fl_D, true, (uint8_t)(value << 1));

		if (adr_os != size_) {
			AddVMCommand(ctx, cmPop, otRegistr, size_, regETX);
			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regETX);
		}
		AddVMCommand(ctx, cmPush, otValue, adr_os, 0 - value);
		AddVMCommand(ctx, cmAdd, otNone, adr_os, false);

		switch (type_) {
		case cmLods: case cmOuts:
			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regESI);
			AddVMCommand(ctx, cmAdd, otNone, adr_os, false);
			AddVMCommand(ctx, cmPop, otRegistr, adr_os, regESI);
			break;

		case cmStos: case cmScas: case cmIns:
			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regEDI);
			AddVMCommand(ctx, cmAdd, otNone, adr_os, false);
			AddVMCommand(ctx, cmPop, otRegistr, adr_os, regEDI);
			break;

		case cmMovs: case cmCmps:
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, adr_os, segSS);

			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regESI);
			AddVMCommand(ctx, cmAdd, otNone, adr_os, false);
			AddVMCommand(ctx, cmPop, otRegistr, adr_os, regESI);

			AddVMCommand(ctx, cmPush, otRegistr, adr_os, regEDI);
			AddVMCommand(ctx, cmAdd, otNone, adr_os, false);
			AddVMCommand(ctx, cmPop, otRegistr, adr_os, regEDI);
			break;
		}

		if (preffix_command_ == cmRep || preffix_command_ == cmRepe || preffix_command_ == cmRepne) {
			AddJmpWithFlagSection(ctx, (type_ == cmScas || type_ == cmCmps) ? preffix_command_ : cmRep);
			if ((section_options_ & rtLinkedNext) == 0) {
				AddBeginSection(ctx, voLinkCommand | voUseEndSectionCryptor);
				AddVMCommand(ctx, cmPush, otValue, size_, address() + original_dump_size(), voFixup);
				AddEndSection(ctx, cmRet);
			}
		}
		break;

	case cmRet:
		operand = &operand_[0];
		if (operand->type == otValue) {
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otMemory, size_, segSS);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otValue, size_, operand->value + OperandSizeToStack(size_));
			AddVMCommand(ctx, cmAdd, otNone, size_, false);
			AddVMCommand(ctx, cmPop, otMemory, size_, segSS);

			if (options() & roFar) {
				AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
				AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToStack(size_));
				AddVMCommand(ctx, cmAdd, otNone, size_, false);
				AddVMCommand(ctx, cmPush, otMemory, size_, segSS);

				AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
				AddVMCommand(ctx, cmPush, otValue, size_, operand->value + OperandSizeToStack(size_) * 2);
				AddVMCommand(ctx, cmAdd, otNone, size_, false);
				AddVMCommand(ctx, cmPop, otMemory, size_, segSS);
			}

			switch (operand->value) {
			case 2:
				AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);
				break;
			case 4:
				AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
				break;
			case 8:
				AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
				AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
				break;
			case 10:
				AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);
				AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
				AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
				break;
			case 12:
				AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
				AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
				AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
				break;
			default:
				AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
				AddVMCommand(ctx, cmPush, otValue, size_, operand->value);
				AddVMCommand(ctx, cmAdd, otNone, size_, false);
				AddVMCommand(ctx, cmPop, otRegistr, size_, regESP);
				break;
			}
		}
		if (options() & roInternal) {
			AddEndSection(ctx, cmJmp, 0);
		} else {
			AddEndSection(ctx, cmRet, (options() & roFar) ? 1 : 0);
		}
		break;

	case cmIret:
		AddEndSection(ctx, cmIret);
		break;

	case cmLeave:
		AddVMCommand(ctx, cmPush, otRegistr, size_, regEBP);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regESP);
		AddVMCommand(ctx, cmPop, otRegistr, size_, regEBP);
		break;

	case cmLes: case cmLds: case cmLfs: case cmLgs:
		os = operand_[0].size;
		CompileOperand(ctx, 1, coAsPointer);

		AddVMCommand(ctx, cmPush, otRegistr, osDWord, regESP);
		AddVMCommand(ctx, cmPush, otMemory, osDWord, segSS);
		AddVMCommand(ctx, cmPush, otValue, osDWord, OperandSizeToStack(os));
		AddVMCommand(ctx, cmAdd, otNone, osDWord, false);

		AddVMCommand(ctx, cmPush, otMemory, osWord, operand_[1].effective_base_segment(base_segment_));

		switch (type_) {
		case cmLes:
			AddVMCommand(ctx, cmPop, otSegmentRegistr, osWord, segES);
			break;
		case cmLds:
			AddVMCommand(ctx, cmPop, otSegmentRegistr, osWord, segDS);
			break;
		case cmLfs:
			AddVMCommand(ctx, cmPop, otSegmentRegistr, osWord, segFS);
			break;
		case cmLgs:
			AddVMCommand(ctx, cmPop, otSegmentRegistr, osWord, segGS);
			break;
		}

		AddVMCommand(ctx, cmPush, otMemory, os, operand_[1].effective_base_segment(base_segment_));
		CompileOperand(ctx, 0, coSaveResult);
		break;

	case cmRdtsc:
		AddVMCommand(ctx, cmRdtsc, otNone, size_, 0);
		AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEDX);
		AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEAX);

		if (size_ == osQWord) {
			AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
			AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regEAX);
			AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
			AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regEDX);
		}
		break;

	case cmCpuid:
		AddVMCommand(ctx, cmPush, otRegistr, osDWord, regEAX);
		AddVMCommand(ctx, cmCpuid, otNone, size_, 0);            
		AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEDX);
		AddVMCommand(ctx, cmPop, otRegistr, osDWord, regECX);
		AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEBX);
		AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEAX);

		if (size_ == osQWord) {
			AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
			AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regEAX);
			AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
			AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regEBX);
			AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
			AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regECX);
			AddVMCommand(ctx, cmPush, otValue, osDWord, 0);
			AddVMCommand(ctx, cmPop, otHiPartRegistr, osDWord, regEDX);
		}
		break;

	case cmF2xm1: case cmFabs: case cmFclex: case cmFcos: case cmFdecstp: case cmFincstp:
	case cmFinit: case cmFldln2: case cmFldlg2: case cmFprem: case cmFprem1: case cmFptan:
	case cmFrndint: case cmFsin: case cmFtst: case cmFyl2x: case cmFpatan: case cmFldz: case cmFld1:
	case cmFldpi: case cmWait: case cmFchs: case cmFsqrt:
		AddVMCommand(ctx, type_, otNone, size_, 0);
		break;

	case cmFistp: case cmFist: case cmFstp: case cmFst:
		os = operand_[0].size;
		operand = &operand_[0];

		if (operand->type == (otMemory | otBaseRegistr) && operand->base_registr == regESP) {
			AddVMCommand(ctx, type_, otNone, os, 0);
		} else {
			switch (os) {
			case osWord:
				AddVMCommand(ctx, cmPush, otRegistr, osWord, regEmpty);
				break;
			case osDWord:
				AddVMCommand(ctx, cmPush, otRegistr, osDWord, regEmpty);
				break;
			case osQWord:
				if (size_ == osQWord) {
					AddVMCommand(ctx, cmPush, otRegistr, osQWord, regEmpty);
				} else {
					AddVMCommand(ctx, cmPush, otRegistr, osDWord, regEmpty);
					AddVMCommand(ctx, cmPush, otRegistr, osDWord, regEmpty);
				}
				break;
			case osTByte:
				if (size_ == osQWord) {
					AddVMCommand(ctx, cmPush, otRegistr, osQWord, regEmpty);
				} else {
					AddVMCommand(ctx, cmPush, otRegistr, osDWord, regEmpty);
					AddVMCommand(ctx, cmPush, otRegistr, osDWord, regEmpty);
				}
				AddVMCommand(ctx, cmPush, otRegistr, osWord, regEmpty);
				break;
			}

			AddVMCommand(ctx, type_, otNone, os, 0);
			CompileOperand(ctx, 0, coAsPointer);

			IntelSegment base_segment = operand->effective_base_segment(base_segment_);
			switch (os) {
			case osWord:
				AddVMCommand(ctx, cmPop, otMemory, osWord, base_segment);
				break;
			case osDWord:
				AddVMCommand(ctx, cmPop, otMemory, osDWord, base_segment);
				break;
			case osQWord:
				if (size_ == osQWord) {
					AddVMCommand(ctx, cmPop, otMemory, osQWord, base_segment);
				} else {
					AddVMCommand(ctx, cmPop, otMemory, osDWord, base_segment);
					CompileOperand(ctx, 0, coAsPointer);
					AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToValue(osDWord));
					AddVMCommand(ctx, cmAdd, otNone, size_, false);
					AddVMCommand(ctx, cmPop, otMemory, osDWord, base_segment);
				}
				break;
			case osTByte:
				if (size_ == osQWord) {
					AddVMCommand(ctx, cmPop, otMemory, osQWord, base_segment);
				} else {
					AddVMCommand(ctx, cmPop, otMemory, osDWord, base_segment);
					CompileOperand(ctx, 0, coAsPointer);
					AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToValue(osDWord));
					AddVMCommand(ctx, cmAdd, otNone, size_, false);
					AddVMCommand(ctx, cmPop, otMemory, osDWord, base_segment);
				}
				CompileOperand(ctx, 0, coAsPointer);
				AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToValue(osQWord));
				AddVMCommand(ctx, cmAdd, otNone, size_, false);
				AddVMCommand(ctx, cmPop, otMemory, osWord, base_segment);
				break;
			}
		}
		break;

	case cmFadd: case cmFsub: case cmFisub: case cmFsubr: case cmFdiv: case cmFmul: case cmFcomp:
	case cmFild: case cmFld:
		os = operand_[0].size;
		operand = &operand_[0];

		if (operand->type == (otMemory | otBaseRegistr) && operand->base_registr == regESP) {
			AddVMCommand(ctx, type_, otNone, os, 0);
		} else {
			CompileOperand(ctx, 0, coAsPointer);

			IntelSegment base_segment = operand->effective_base_segment(base_segment_);
			switch (os) {
			case osWord:
				AddVMCommand(ctx, cmPush, otMemory, osWord, base_segment);
				break;
			case osDWord:
				AddVMCommand(ctx, cmPush, otMemory, osDWord, base_segment);
				break;
			case osQWord:
				if (size_ == osQWord) {
					AddVMCommand(ctx, cmPush, otMemory, osQWord, base_segment);
				} else {
					AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToValue(osDWord));
					AddVMCommand(ctx, cmAdd, otNone, size_, false);
					AddVMCommand(ctx, cmPush, otMemory, osDWord, base_segment);
					CompileOperand(ctx, 0, coAsPointer);
					AddVMCommand(ctx, cmPush, otMemory, osDWord, base_segment);
				}
				break;
			case osTByte:
				AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToValue(osQWord));
				AddVMCommand(ctx, cmAdd, otNone, size_, false);
				AddVMCommand(ctx, cmPush, otMemory, osWord, base_segment);
				CompileOperand(ctx, 0, coAsPointer);
				if (size_ == osQWord) {
					AddVMCommand(ctx, cmPush, otMemory, osQWord, base_segment);
				} else {
					AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToValue(osDWord));
					AddVMCommand(ctx, cmAdd, otNone, size_, false);
					AddVMCommand(ctx, cmPush, otMemory, osDWord, base_segment);
					CompileOperand(ctx, 0, coAsPointer);
					AddVMCommand(ctx, cmPush, otMemory, osDWord, base_segment);
				}
				break;
			}

			AddVMCommand(ctx, type_, otNone, os, 0);

			switch (os) {
			case osWord:
				AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);
				break;
			case osDWord:
				AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
				break;
			case osQWord:
				if (size_ == osQWord) {
					AddVMCommand(ctx, cmPop, otRegistr, osQWord, regEmpty);
				} else {
					AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
					AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
				}
				break;
			case osTByte:
				if (size_ == osQWord) {
					AddVMCommand(ctx, cmPop, otRegistr, osQWord, regEmpty);
				} else {
					AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
					AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEmpty);
				}
				AddVMCommand(ctx, cmPop, otRegistr, osWord, regEmpty);
				break;
			}
		}
		break;

	case cmCrc:
		switch (ctx.file->calling_convention()) { //-V719
		case ccStdcall:
			// do nothing
			break;
		case ccCdecl:
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP); //-V760
			AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToStack(size_));
			AddVMCommand(ctx, cmAdd, otNone, size_, false);
			AddVMCommand(ctx, cmPush, otMemory, size_, segSS);

			AddVMCommand(ctx, cmPush, otRegistr, size_, regESP);
			AddVMCommand(ctx, cmPush, otValue, size_, OperandSizeToStack(size_));
			AddVMCommand(ctx, cmAdd, otNone, size_, false);
			AddVMCommand(ctx, cmPush, otMemory, size_, segSS);
			break;
		case ccMSx64:
			AddVMCommand(ctx, cmPush, otRegistr, size_, regEDX);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regECX);
			break;
		case ccABIx64:
			AddVMCommand(ctx, cmPush, otRegistr, size_, regESI);
			AddVMCommand(ctx, cmPush, otRegistr, size_, regEDI);
			break;
		}
		AddVMCommand(ctx, cmCrc, otNone, size_, 0);
		AddVMCommand(ctx, cmPop, otRegistr, osDWord, regEAX);
		break;

	case cmDD: case cmDQ:
		operand = &operand_[0];
		AddVMCommand(ctx, type_, otValue, (type_ == cmDD) ? osDWord : osQWord, operand->value, voLinkCommand | (operand->fixup ? voFixup : voNone), operand->fixup);
		break;

	default:
		throw std::runtime_error("Runtime error at CompileToVM: " + text());
		break;
	}

	GetCommandInfo(*vm_command_info_list_);
	for (i = vm_command_info_list_->count(); i > 0 ; i--) {
		CommandInfo *command_info = vm_command_info_list_->item(i - 1);
		if ((command_info->operand_type() == otRegistr || command_info->operand_type() == otHiPartRegistr) && command_info->value() == regEFX)
			delete command_info;
	}
	for (i = 0; i < count(); i++) {
		IntelVMCommand *command = item(i);
		if (command->options() & voSectionCommand) {
			if (section_options() & rtBeginSection)
				continue;
			if (section_options() & rtEndSection)
				break;
		}

		switch (command->command_type()) {
		case cmPush: case cmPop:
			if ((command->operand_type() == otRegistr || command->operand_type() == otHiPartRegistr) && 
				(command->registr() == regEFX || command->registr() == regETX || command->registr() == regEIX || (command->registr() & regExtended)))
				vm_command_info_list_->Add(command->command_type() == cmPush ? atRead : atWrite, command->registr(), command->operand_type(), command->size());
			break;
		case cmCall:
			vm_command_info_list_->Add(atWrite, regEAX, otRegistr, size());
			break;
		case cmCrc:
			vm_command_info_list_->Add(atRead, regESP, otRegistr, size());
			vm_command_info_list_->Add(atWrite, regESP, otRegistr, size());
			vm_command_info_list_->Add(atWrite, regEAX, otRegistr, size());
			break;
		}
	}
}

void IntelCommand::PrepareLink(const CompileContext &ctx)
{
	bool from_native = block() && (block()->type() & mtExecutable) ? true : owner()->compilation_type() == ctMutation;

	IntelCommand *to_command = reinterpret_cast<IntelCommand *>(link()->to_command());
	if (to_command) {
		if (link()->operand_index() > -1) {
			IntelOperand *operand = &operand_[link()->operand_index()];
			if (size_ == osQWord && link()->sub_value() > ctx.file->image_base()) {
				if (link()->operand_index() == 1 && (operand->type & otMemory) && operand_[0].size == osDWord && type_ != cmMovsxd) {
					if (type_ == cmMov) {
						type_ = cmMovsxd;
						operand_[0].size = osQWord;
						CompileToNative();
					} else {
						throw std::runtime_error("Runtime error at PrepareLink: " + text());
					}
				}
			}
			if (operand->type & otMemory) {
				if ((operand->type & otValue) == 0) {
					operand->type |= otValue;
					operand->value = 0;
					operand->value_size = osDWord;
					CompileToNative();
				} else if (operand->value_size < osDWord) {
					operand->value_size = osDWord;
					CompileToNative();
				}
			}

			if ((operand->type & otValue) == 0)
				throw std::runtime_error("Runtime error at PrepareLink: " + text());
		}

		bool to_native = to_command->block() && (to_command->block()->type() & mtExecutable) ? true : to_command->owner()->compilation_type() == ctMutation;
		if (from_native == to_native) {
			section_options_ |= rtLinkedFrom;
		} else {
			section_options_ |= rtLinkedFromOtherType;
		}

		if ((section_options_ & rtLinkedFromOtherType)
			|| link()->type() == ltSEHBlock
			|| link()->type() == ltFinallyBlock
			|| link()->type() == ltFilterSEHBlock
			|| link()->type() == ltDualSEHBlock
			|| link()->type() == ltGateOffset
			|| link()->type() == ltMemSEHBlock
			|| link()->type() == ltExtSEHHandler
			|| link()->type() == ltVBMemSEHBlock) {
			to_command->include_section_option(rtLinkedToExt);
		} else {
			to_command->include_section_option(rtLinkedToInt);
		}
	}

	if (from_native)
		return;

	size_t j;
	bool need_next_command = false;
	bool need_init_cryptor = false;
	ICommand *next_command;

	switch (link()->type()) {
	case ltCall:
		if ((options() & roUseAsJmp) == 0)
			need_next_command = true;
		need_init_cryptor = true;
		break;
	case ltJmp:
		if (section_options_ & rtLinkedFrom)
			need_init_cryptor = true;
		break;
	case ltSwitch:
		if (section_options_ & rtLinkedFrom) {
			if (!end_section_cryptor_)
				need_init_cryptor = true;
		}
		break;
	case ltCase:
		if (to_command)
			need_init_cryptor = true;
		break;
	case ltNative:
		if ((options() & roBreaked) == 0 && type_ != cmJmp)
			need_next_command = true;
		break;
	case ltJmpWithFlagNSNS:
		need_next_command = true;
		need_init_cryptor = true;
		break;
	case ltJmpWithFlagNSNA:
		need_next_command = true;
		need_init_cryptor = true;
		break;
	case ltJmpWithFlagNSFS:
		include_section_option(rtLinkedToInt);
		to_command = this;
		link()->set_to_command(to_command);
		need_next_command = true;
		need_init_cryptor = true;
		break;
	case ltJmpWithFlag:
		need_next_command = true;
		need_init_cryptor = true;
		break;
	case ltDualSEHBlock:
		if (to_command) {
			j = owner()->IndexOf(to_command) + 1;
			next_command = owner()->item(j);
			link()->set_next_command(next_command);
			next_command->include_section_option(rtLinkedToExt);
		}
		break;
	}

	if (need_next_command) {
		j = owner()->IndexOf(this) + 1;
		if (j < owner()->count()) {
			next_command = owner()->item(j);
			if (owner()->is_breaked_address(next_command->address()))
				next_command = NULL;
			else {
				if (link()->type() == ltCall) {
					if (to_command != next_command) {
						include_section_option(rtLinkedNext);
						link()->set_next_command(next_command);
						next_command->include_section_option(rtLinkedToExt);
					}
				} else {
					include_section_option(rtLinkedNext);
					link()->set_next_command(next_command);
					next_command->include_section_option(link()->type() == ltNative ? rtLinkedToExt : rtLinkedToInt);
				}
			}
		}
	}

	if (need_init_cryptor) {
		SectionCryptorList *section_cryptor_list = reinterpret_cast<IntelFunction*>(owner())->section_cryptor_list();
		SectionCryptor *cur_section_cryptor = NULL;
		IntelCommand *save_cryptor_command = NULL;
		IntelCommand *parent_command = reinterpret_cast<IntelCommand*>(link()->parent_command());

		if (link()->type() == ltCase) {
			cur_section_cryptor = parent_command->end_section_cryptor_;
			if (!cur_section_cryptor) {
				cur_section_cryptor = section_cryptor_list->Add();
				parent_command->end_section_cryptor_ = cur_section_cryptor;
			}
			begin_section_cryptor_ = cur_section_cryptor;
			save_cryptor_command = to_command;
		} else {
			if (to_command) {
				if (section_options_ & rtLinkedFromOtherType) {
					if (link()->type() == ltCall) {
						cur_section_cryptor = section_cryptor_list->Add();
					} else {
						return;
					}
				} else {
					cur_section_cryptor = to_command->begin_section_cryptor_;
					if (!cur_section_cryptor && (options() & roExternal) == 0) {
						cur_section_cryptor = section_cryptor_list->Add();
						to_command->begin_section_cryptor_ = cur_section_cryptor;
					}
				}
			} else {
				cur_section_cryptor = section_cryptor_list->Add();
			}
			end_section_cryptor_ = cur_section_cryptor;

			if (link()->type() == ltSwitch && parent_command)
				parent_command->end_section_cryptor_ = cur_section_cryptor;

			if (link()->type() == ltSwitch && to_command && to_command->link() && to_command->link()->parent_command() != this) {
				save_cryptor_command = reinterpret_cast<IntelCommand*>(to_command->link()->parent_command());
			} else if (link()->type() == ltJmpWithFlag || link()->type() == ltJmpWithFlagNSNA || link()->type() == ltJmpWithFlagNSFS || link()->type() == ltJmpWithFlagNSNS) {
				save_cryptor_command = reinterpret_cast<IntelCommand*>(link()->next_command());
			}
		}

		if (save_cryptor_command) {
			if (link()->type() == ltSwitch) {
				if (save_cryptor_command->end_section_cryptor_ != cur_section_cryptor) {
					if (save_cryptor_command->end_section_cryptor_) {
						cur_section_cryptor->set_end_cryptor(save_cryptor_command->end_section_cryptor_);
					} else {
						save_cryptor_command->end_section_cryptor_ = cur_section_cryptor;
					}
				}
			} else {
				if (save_cryptor_command->begin_section_cryptor_ != cur_section_cryptor) {
					if (save_cryptor_command->begin_section_cryptor_) {
						cur_section_cryptor->set_end_cryptor(save_cryptor_command->begin_section_cryptor_);
					} else {
						save_cryptor_command->begin_section_cryptor_ = cur_section_cryptor;
					}
				}
			}
		}
	}
}

void IntelCommand::CompileLink(const CompileContext &ctx)
{
	size_t k;
	uint64_t value, value1;
	
	if (block()->type() & mtExecutable) {
		// native block
		if (!link() || link()->operand_index() == -1)
			return;

		ICommand *to_command = link()->to_command();
		if (to_command) {
			value = (to_command->block()->type() & mtExecutable) ? to_command->address() : to_command->ext_vm_address();
		} else if (link()->type() == ltDelta) {
			value = link()->to_address();
		} else {
			return;
		}

		if (link()->type() == ltDelta)
			value -= link()->parent_command() ? link()->parent_command()->address() : address();
		set_operand_value(link()->operand_index(), link()->Encrypt(value));
		CompileToNative();
	} else {
		// VM block
		for (size_t i = 0; i < internal_links_.count(); i++) {
			InternalLink *internal_link = internal_links_.item(i);
			IntelVMCommand *vm_command = reinterpret_cast<IntelVMCommand *>(internal_link->from_command());

			switch (internal_link->type()) {
			case vlCRCTableAddress:
				value = reinterpret_cast<IntelFunctionList *>(ctx.file->function_list())->runtime_crc_table()->entry()->address();
				break;
			case vlCRCTableCount:
				value = reinterpret_cast<IntelFunctionList *>(ctx.file->function_list())->runtime_crc_table()->region_count();
				break;
			case vlCRCValue:
				{
					IntelVMCommand *value_command = reinterpret_cast<IntelVMCommand*>(internal_link->to_command());
					uint64_t crc_value = reinterpret_cast<IntelVirtualMachineList *>(ctx.file->virtual_machine_list())->GetCRCValue(value, OperandSizeToValue(value_command->size()));
					value_command->set_sub_value(crc_value);
					value_command->Compile();
				}
				break;
			default:
				{
					IntelCommand *command = reinterpret_cast<IntelCommand*>(internal_link->to_command());
					if (!command)
						continue;

					value = command->is_data() ? command->address() : command->owner()->entry()->address();
				}
				break;
			}
			vm_command->set_value(value);
			vm_command->Compile();
		}

		if (vm_links_.empty())
			return;

		ICommand *to_command = link()->to_command();
		ICommand *next_command = link()->next_command();
		ICommand *ext_command;

		switch (link()->type()) {
		case ltSEHBlock: case ltFinallyBlock: case ltExtSEHBlock:
			if (to_command)
				set_link_value(0, link()->gate_command(0)->address());
			break;

		case ltMemSEHBlock: case ltExtSEHHandler: case ltVBMemSEHBlock:
			// do nothing
			break;

		case ltDualSEHBlock: case ltFilterSEHBlock:
			if (to_command)
				set_link_value(0, link()->gate_command(0)->address());
			break;

		case ltJmpWithFlag:
			k = next_command ? 1 : 0;

			value = vm_links_[2]->address();
			value1 = vm_links_[3 + k]->address();
			set_link_value(0, value1);
			set_link_value(1, value);

			if (next_command) {
				if (next_command->block()->virtual_machine()->id() == block()->virtual_machine()->id())
					set_link_value(1, next_command->vm_address());
				else {
					set_link_value(3, next_command->vm_address());
					set_jmp_value(1, next_command->block()->virtual_machine()->id());
				}
			}
			if (to_command) {
				if (section_options_ & rtLinkedFrom) {
					if (to_command->block()->virtual_machine()->id() == block()->virtual_machine()->id())
						set_link_value(0, to_command->vm_address());
					else {
						set_link_value(4 + k, to_command->vm_address());
						set_jmp_value(1 + k, to_command->block()->virtual_machine()->id());
					}
				}
			}
			break;

		case ltJmpWithFlagNSNS:
			value = vm_links_[2]->address();
			value1 = vm_links_[4]->address();

			set_link_value(0, value);
			set_link_value(1, value1);

			if (next_command) {
				value = next_command->vm_address();
				set_link_value(3, value);
				set_link_value(5, value);
			}
			break;

		case ltJmpWithFlagNSNA:
			value = vm_links_[2]->address();
			if (next_command) {
				value1 = vm_links_[4]->address();
			} else {
				value1 = vm_links_[3]->address();
			}

			set_link_value(0, value);
			set_link_value(1, value1);

			if (next_command) {
				set_link_value(3, next_command->vm_address());
				set_jmp_value(1, next_command->block()->virtual_machine()->id());
				if (next_command->block()->virtual_machine()->id() == block()->virtual_machine()->id()) {
					set_link_value(1, next_command->vm_address());
				} else {
					set_link_value(5, next_command->vm_address());
					set_jmp_value(2, next_command->block()->virtual_machine()->id());
				}
			}
			break;

		case ltJmpWithFlagNSFS:
			value = vm_links_[2]->address();
			if (next_command) {
				value1 = next_command->vm_address();
			} else {
				value1 = vm_links_[5]->address();
			}

			set_link_value(0, value1);
			set_link_value(1, value);
			set_link_value(3, value);
			set_link_value(4, value1);
			break;

		case ltJmp:
			if (to_command) {
				if (section_options_ & rtLinkedFromOtherType) {
					value = to_command->address();
				} else {
					value = to_command->vm_address();
					set_jmp_value(0, to_command->block()->virtual_machine()->id());
				}
				set_link_value(0, link()->Encrypt(value));
			}
			break;

		case ltCall:
			if ((options() & roInternal) && (section_options_ & rtLinkedFrom) == 0) {
				k = 0;
			} else {
				k = 1;
				ext_command = link()->gate_command(0);
				if (ext_command) {
					value = ext_command->address();
				} else if (options() & roInternal) {
					value = next_command->ext_vm_address();
				} else {
					value = address() + original_dump_size();
				}
				set_link_value(0, value);
			}

			if (section_options_ & rtLinkedFrom) {
				set_link_value(k, to_command->vm_address());
				set_jmp_value(0, to_command->block()->virtual_machine()->id());
			} else if (section_options_ & rtLinkedFromOtherType) {
				set_link_value(k, to_command->address());
			}
			break;

		case ltNative:
			set_link_value(0, link()->gate_command(0)->address());
			break;

		case ltOffset:
			if (to_command) {
				if ((section_options_ & rtLinkedFromOtherType) || to_command->is_data()) {
					value = to_command->address();
				} else {
					value = to_command->vm_address();
				}
				set_link_value(0, link()->Encrypt(value));
			}
			break;

		case ltGateOffset:
			if (to_command) {
				value = to_command->address();
				set_link_value(0, link()->Encrypt(value));
			}
			break;

		case ltSwitch:
			if (to_command) {
				if (section_options_ & rtLinkedFromOtherType) {
					value = to_command->address();
				} else {
					value = to_command->vm_address();
				}
				set_link_value(0, link()->Encrypt(value));
			}
			break;

		case ltCase:
			if (to_command) {
				ext_command = link()->gate_command(0);
				if (section_options_ & rtLinkedFromOtherType) {
					ext_command->set_link_value(0, to_command->address());
					value = ext_command->vm_address();
				} else if (ext_command->block()->virtual_machine()->id() != to_command->block()->virtual_machine()->id()) {
					ext_command->set_link_value(0, to_command->vm_address());
					ext_command->set_jmp_value(0, to_command->block()->virtual_machine()->id());
					value = ext_command->vm_address();
				} else {
					value = to_command->vm_address();
				}
				set_link_value(0, link()->Encrypt(value));
			}
			break;
		}
	}
}

bool IntelCommand::GetCommandInfo(IntelCommandInfoList &command_info_list) const
{
	OperandSize os, adr_os;

	command_info_list.clear();
	command_info_list.set_base_segment(base_segment_);

	switch (type_) {
	case cmAaa: case cmAas:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_A);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.Add(atRead, regEAX, otRegistr, osByte);
		command_info_list.Add(atWrite, regEAX, otRegistr, osWord);
		break;

	case cmAad:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.Add(atRead, regEAX, otRegistr, osWord);
		command_info_list.Add(atWrite, regEAX, otRegistr, osWord);
		break;

	case cmAam:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.Add(atRead, regEAX, otRegistr, osByte);
		command_info_list.Add(atWrite, regEAX, otRegistr, osWord);
		break;

	case cmAdc:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_C);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmAdd: case cmAnd:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmBsf: case cmBsr:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmBswap:
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmBt:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		break;

	case cmBtc: case cmBtr: case cmBts:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmCall:
		command_info_list.Add(atRead, regESP, otRegistr, size_);
		command_info_list.Add(atWrite, regESP, otRegistr, size_);
		command_info_list.Add(atWrite, regEIP, otBaseRegistr, size_);

		command_info_list.AddOperand(operand_[0], atRead);
		break;

	case cmSyscall:
		command_info_list.Add(atRead, regESP, otRegistr, size_);
		command_info_list.Add(atWrite, regESP, otRegistr, size_);
		command_info_list.Add(atWrite, regEIP, otBaseRegistr, size_);
		break;

	case cmCbw:
		command_info_list.Add(atRead, regEAX, otRegistr, osByte);
		command_info_list.Add(atWrite, regEAX, otHiPartRegistr, osByte);
		break;

	case cmCwde:
		command_info_list.Add(atRead, regEAX, otRegistr, osWord);
		command_info_list.Add(atWrite, regEAX, otRegistr, osDWord);
		break;

	case cmCdqe:
		command_info_list.Add(atRead, regEAX, otRegistr, osDWord);
		command_info_list.Add(atWrite, regEAX, otRegistr, osQWord);
		break;

	case cmCwd:
		command_info_list.Add(atRead, regEAX, otRegistr, osWord);
		command_info_list.Add(atWrite, regEDX, otRegistr, osWord);
		break;

	case cmCdq:
		command_info_list.Add(atRead, regEAX, otRegistr, osDWord);
		command_info_list.Add(atWrite, regEDX, otRegistr, osDWord);
		break;

	case cmCqo:
		command_info_list.Add(atRead, regEAX, otRegistr, osQWord);
		command_info_list.Add(atWrite, regEDX, otRegistr, osQWord);
		break;

	case cmClc: case cmStc:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_C);
		break;

	case cmCmc:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_C);
		command_info_list.set_change_flags(fl_C);
		break;

	case cmCld: case cmStd:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_D);
		break;

	case cmCli: case cmSti:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_I);
		break;

	case cmCmov:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(flags_);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmCmp:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		break;

	case cmCmps:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_D);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		os = operand_[0].size;
		adr_os = operand_[1].size;
     
		command_info_list.Add(atRead, regESI, otRegistr, adr_os);
		command_info_list.Add(atRead, regEDI, otRegistr, adr_os);
		command_info_list.Add(atWrite, regESI, otRegistr, adr_os);
		command_info_list.Add(atWrite, regEDI, otRegistr, adr_os);

		command_info_list.Add(atRead, segES, otMemory, os);

		if (preffix_command_ == cmRep || preffix_command_ == cmRepe || preffix_command_ == cmRepne) {
			command_info_list.Add(atRead, regECX, otRegistr, adr_os);
			command_info_list.Add(atWrite, regECX, otRegistr, adr_os);
		}
		break;

	case cmCmpxchg:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		os = operand_[0].size;
		command_info_list.Add(atRead, regEAX, otRegistr, os);
		command_info_list.Add(atWrite, regEAX, otRegistr, os);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmCmpxchg8b:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_Z);

		command_info_list.Add(atRead, regEAX, otRegistr, osDWord);
		command_info_list.Add(atRead, regEDX, otRegistr, osDWord);
		command_info_list.Add(atWrite, regEAX, otRegistr, osDWord);
		command_info_list.Add(atWrite, regEDX, otRegistr, osDWord);

		command_info_list.Add(atRead, regEBX, otRegistr, osDWord);
		command_info_list.Add(atRead, regECX, otRegistr, osDWord);

		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmCpuid:
		command_info_list.Add(atRead, regEAX, otRegistr, osDWord);

		command_info_list.Add(atWrite, regEAX, otRegistr, osDWord);
		command_info_list.Add(atWrite, regECX, otRegistr, osDWord);
		command_info_list.Add(atWrite, regEDX, otRegistr, osDWord);
		command_info_list.Add(atWrite, regEBX, otRegistr, osDWord);     
		break;

	case cmDaa:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_A);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.Add(atRead, regEAX, otRegistr, osByte);
		command_info_list.Add(atWrite, regEAX, otRegistr, osByte);
		break;

	case cmDas:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_A | fl_C);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.Add(atRead, regEAX, otRegistr, osByte);
		command_info_list.Add(atWrite, regEAX, otRegistr, osByte);
		break;

	case cmDec: case cmInc:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P);

		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmDiv: case cmIdiv:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[0], atRead);

		os = operand_[0].size;
		if (os == osByte) {
			command_info_list.Add(atRead, regEAX, otRegistr, osWord);
			command_info_list.Add(atWrite, regEAX, otRegistr, osWord);
		} else {
			command_info_list.Add(atRead, regEAX, otRegistr, os);
			command_info_list.Add(atWrite, regEAX, otRegistr, os);
			command_info_list.Add(atRead, regEDX, otRegistr, os);
			command_info_list.Add(atWrite, regEDX, otRegistr, os);
		}
		break;

	case cmMul: case cmImul:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		os = operand_[0].size;
		if (operand_[2].type != otNone) {
			command_info_list.AddOperand(operand_[2], atRead);
			command_info_list.AddOperand(operand_[1], atRead);
			command_info_list.AddOperand(operand_[0], atWrite);
		} else if (operand_[1].type != otNone) {
			command_info_list.AddOperand(operand_[1], atRead);
			command_info_list.AddOperand(operand_[0], atRead);
			command_info_list.AddOperand(operand_[0], atWrite);
		} else {
			command_info_list.AddOperand(operand_[0], atRead);
			command_info_list.Add(atRead, regEAX, otRegistr, os);
		}

		if (operand_[1].type == otNone) {
			if (os == osByte) {
				command_info_list.Add(atWrite, regEAX, otRegistr, osWord);
			} else {
				command_info_list.Add(atWrite, regEAX, otRegistr, os);
				command_info_list.Add(atWrite, regEDX, otRegistr, os);
			}
		}
		break;

	case cmJCXZ:
		os = operand_[1].size;
		command_info_list.Add(atRead, regECX, otRegistr, os);

		command_info_list.Add(atWrite, regEIP, otBaseRegistr, size_);
		break;

	case cmJmpWithFlag:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(flags_);

		command_info_list.Add(atWrite, regEIP, otBaseRegistr, size_);
		break;

	case cmJmp:
		command_info_list.Add(atWrite, regEIP, otBaseRegistr, size_);

		command_info_list.AddOperand(operand_[0], atRead);
		break;

	case cmLahf:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.Add(atWrite, regEAX, otHiPartRegistr, osByte);
		break;

	case cmLds:
		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);

		command_info_list.Add(atWrite, segDS, otSegmentRegistr, osWord);
		break;

	case cmLes:
		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);

		command_info_list.Add(atWrite, segES, otSegmentRegistr, osWord);
		break;

	case cmLfs:
		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);

		command_info_list.Add(atWrite, segFS, otSegmentRegistr, osWord);
		break;

	case cmLgs:
		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);

		command_info_list.Add(atWrite, segGS, otSegmentRegistr, osWord);
		break;

	case cmLss:
		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);

		command_info_list.Add(atWrite, segSS, otSegmentRegistr, osWord);
		break;

	case cmLea:
		{
			IntelOperand operand = operand_[1];
			operand.type &= ~otMemory;
			command_info_list.AddOperand(operand, atRead);
		}
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmLeave:
		command_info_list.Add(atRead, regESP, otRegistr, size_);
		command_info_list.Add(atWrite, regESP, otRegistr, size_);

		command_info_list.Add(atRead, regEBP, otRegistr, size_);
		command_info_list.Add(atWrite, regEBP, otRegistr, size_);
		break;

	case cmLods:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_D);

		os = operand_[0].size;
		adr_os = operand_[1].size;

		command_info_list.Add(atRead, regESI, otRegistr, adr_os);
		command_info_list.Add(atWrite, regESI, otRegistr, adr_os);

		command_info_list.Add(atWrite, regEAX, otRegistr, os);
		command_info_list.Add(atRead, (base_segment_ == segDefault) ? segDS : base_segment_, otMemory, os);

		if (preffix_command_ == cmRep || preffix_command_ == cmRepe || preffix_command_ == cmRepne) {
			command_info_list.Add(atRead, regECX, otRegistr, adr_os);
			command_info_list.Add(atWrite, regECX, otRegistr, adr_os);
		}
		break;

	case cmLoop:
		os = operand_[1].size;
		command_info_list.Add(atRead, regECX, otRegistr, os);
		command_info_list.Add(atWrite, regECX, otRegistr, os);

		command_info_list.Add(atWrite, regEIP, otBaseRegistr, size_);
		break;

	case cmLoope: case cmLoopne:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_Z);

		os = operand_[1].size;
		command_info_list.Add(atRead, regECX, otRegistr, os);
		command_info_list.Add(atWrite, regECX, otRegistr, os);

		command_info_list.Add(atWrite, regEIP, otBaseRegistr, size_);
		break;

	case cmMov: case cmMovsx: case cmMovsxd: case cmMovzx:
		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmMovs:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_D);

		os = operand_[0].size;
		adr_os = operand_[1].size;

		command_info_list.Add(atRead, regESI, otRegistr, adr_os);
		command_info_list.Add(atWrite, regESI, otRegistr, adr_os);
		command_info_list.Add(atRead, regEDI, otRegistr, adr_os);
		command_info_list.Add(atWrite, regEDI, otRegistr, adr_os);

		command_info_list.Add(atRead, (base_segment_ == segDefault) ? segDS : base_segment_, otMemory, os);
		command_info_list.Add(atWrite, segES, otMemory, os);

		if (preffix_command_ == cmRep || preffix_command_ == cmRepe || preffix_command_ == cmRepne) {
			command_info_list.Add(atRead, regECX, otRegistr, adr_os);
			command_info_list.Add(atWrite, regECX, otRegistr, adr_os);
		}
		break;

	case cmNeg:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmNop:
		break;

	case cmNot:
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmOr:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmPop:
		command_info_list.Add(atRead, regESP, otRegistr, size_);
		command_info_list.Add(atWrite, regESP, otRegistr, size_);

		os = operand_[0].size;
		command_info_list.Add(atRead, segSS, otMemory, os);

		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmPopa:
		command_info_list.Add(atRead, regESP, otRegistr, size_);
		command_info_list.Add(atWrite, regESP, otRegistr, size_);

		os = operand_[0].size;
		command_info_list.Add(atRead, segSS, otMemory, os);

		command_info_list.Add(atWrite, regEAX, otRegistr, os);
		command_info_list.Add(atWrite, regECX, otRegistr, os);
		command_info_list.Add(atWrite, regEDX, otRegistr, os);
		command_info_list.Add(atWrite, regEBX, otRegistr, os);
		command_info_list.Add(atWrite, regEBP, otRegistr, os);
		command_info_list.Add(atWrite, regESI, otRegistr, os);
		command_info_list.Add(atWrite, regEDI, otRegistr, os);
		break;

	case cmPopf:
		command_info_list.Add(atRead, regESP, otRegistr, size_);
		command_info_list.Add(atWrite, regESP, otRegistr, size_);

		os = operand_[0].size;
		command_info_list.Add(atRead, segSS, otMemory, os);

		command_info_list.Add(atWrite, regEFX, otRegistr, os);
		command_info_list.set_change_flags(0xFFFF);
		break;

	case cmPush:
		command_info_list.Add(atRead, regESP, otRegistr, size_);
		command_info_list.Add(atWrite, regESP, otRegistr, size_);

		os = operand_[0].size;
		command_info_list.Add(atWrite, segSS, otMemory, os);

		command_info_list.AddOperand(operand_[0], atRead);
		break;

	case cmPusha:
		command_info_list.Add(atRead, regESP, otRegistr, size_);
		command_info_list.Add(atWrite, regESP, otRegistr, size_);

		os = operand_[0].size;
		command_info_list.Add(atWrite, segSS, otMemory, os);

		command_info_list.Add(atRead, regEAX, otRegistr, os);
		command_info_list.Add(atRead, regECX, otRegistr, os);
		command_info_list.Add(atRead, regEDX, otRegistr, os);
		command_info_list.Add(atRead, regEBX, otRegistr, os);
		command_info_list.Add(atRead, regEBP, otRegistr, os);
		command_info_list.Add(atRead, regESI, otRegistr, os);
		command_info_list.Add(atRead, regEDI, otRegistr, os);
		break;

	case cmPushf:
		command_info_list.Add(atRead, regESP, otRegistr, size_);
		command_info_list.Add(atWrite, regESP, otRegistr, size_);

		os = operand_[0].size;
		command_info_list.Add(atWrite, segSS, otMemory, os);

		command_info_list.Add(atRead, regEFX, otRegistr, os);
		command_info_list.set_need_flags(0xFFFF);
		break;

	case cmRet: case cmIret:
		command_info_list.Add(atRead, regESP, otRegistr, size_);
		command_info_list.Add(atWrite, regESP, otRegistr, size_);

		command_info_list.Add(atRead, segSS, otMemory, size_);
		command_info_list.Add(atWrite, regEIP, otBaseRegistr, size_);
		break;

	case cmRcl: case cmRcr:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_C);
		command_info_list.set_change_flags(fl_O | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmRdtsc:
		command_info_list.Add(atWrite, regEAX, otRegistr, osDWord);
		command_info_list.Add(atWrite, regEDX, otRegistr, osDWord);
		break;

	case cmRol: case cmRor:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmSahf:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.Add(atRead, regEAX, otHiPartRegistr, osByte);
		break;

	case cmSal: case cmSar:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmSbb:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_C);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmScas:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_D);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		os = operand_[0].size;
		adr_os = operand_[1].size;

		command_info_list.Add(atRead, regEDI, otRegistr, adr_os);
		command_info_list.Add(atWrite, regEDI, otRegistr, adr_os);

		command_info_list.Add(atRead, regEAX, otRegistr, os);
		command_info_list.Add(atRead, segES, otMemory, os);

		if (preffix_command_ == cmRep || preffix_command_ == cmRepe || preffix_command_ == cmRepne) {
			command_info_list.Add(atRead, regECX, otRegistr, adr_os);
			command_info_list.Add(atWrite, regECX, otRegistr, adr_os);
		}
		break;

	case cmSetXX:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(flags_);

		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmShl: case cmShr:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmShld: case cmShrd:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[2], atRead);
		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmStos:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(fl_D);

		os = operand_[0].size;
		adr_os = operand_[1].size;

		command_info_list.Add(atRead, regEDI, otRegistr, adr_os);
		command_info_list.Add(atWrite, regEDI, otRegistr, adr_os);

		command_info_list.Add(atRead, regEAX, otRegistr, os);
		command_info_list.Add(atWrite, segES, otMemory, os);

		if (preffix_command_ == cmRep || preffix_command_ == cmRepe || preffix_command_ == cmRepne) {
			command_info_list.Add(atRead, regECX, otRegistr, adr_os);
			command_info_list.Add(atWrite, regECX, otRegistr, adr_os);
		}
		break;

	case cmSub:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmTest:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		break;

	case cmXadd:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[1], atWrite);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmXchg:
		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[1], atWrite);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmXlat:
		adr_os = operand_[0].size;
		command_info_list.Add(atRead, regEBX, otRegistr, adr_os);
		command_info_list.Add(atRead, regEAX, otRegistr, osByte);
		command_info_list.Add(atWrite, regEAX, otRegistr, osByte);

		command_info_list.Add(atRead, (base_segment_ == segDefault) ? segDS : base_segment_, otMemory, osByte);
		break;

	case cmXor:
		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	// FPU commands

	case cmWait: case cmFabs: case cmFchs: case cmFclex: case cmFcos: case cmFdecstp:
	case cmFfree: case cmFincstp: case cmFinit: case cmFld1: case cmFldl2t: case cmFldl2e: 
	case cmFldlg2: case cmFldln2: case cmFldpi: case cmFldz:
	case cmFpatan: case cmFprem: case cmFprem1: case cmFptan:
	case cmFrndint: case cmFscale: case cmFsin: case cmFsincos: case cmFsqrt:
	case cmFtst: case cmFxam: case cmFxtract: case cmFyl2x: case cmFyl2xp1:
		command_info_list.Add(atRead, 0, otFPURegistr, size_);
		command_info_list.Add(atWrite, 0, otFPURegistr, size_);
		break;

	case cmFadd: case cmFaddp: case cmFiadd: case cmFcom: case cmFcomp: case cmFcompp: case cmFdiv: case cmFidiv: case cmFdivp:
	case cmFdivr: case cmFidivr: case cmFdivrp: case cmFicom: case cmFicomp: case cmFild: case cmFld: case cmFmul: case cmFimul:
	case cmFmulp: case cmFsub: case cmFisub: case cmFsubp: case cmFsubr: case cmFisubr: case cmFsubrp: case cmFucom: case cmFucomp:
	case cmFucompp: case cmFxch:
		os = operand_[0].size;
		command_info_list.Add(atRead, 0, otFPURegistr, os);
		command_info_list.Add(atWrite, 0, otFPURegistr, os);

		command_info_list.AddOperand(operand_[0], atRead);
		break;

	case cmFcomi: case cmFcomip: case cmFucomi: case cmFucomip:
		os = operand_[0].size;
		command_info_list.Add(atRead, 0, otFPURegistr, os);
		command_info_list.Add(atWrite, 0, otFPURegistr, os);

		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_Z | fl_P | fl_C);

		command_info_list.AddOperand(operand_[0], atRead);
		break;    

		/*
	case cmFcmov:
		command_info_list.Add(atRead, regEFX, otRegistr, size_);
		command_info_list.set_need_flags(flags_);

		OS:=FOperand[0].OperandSize;
		command_info_list.Add(atRead, 0, otFPURegistr, OS);
		command_info_list.Add(atWrite, 0, otFPURegistr, OS);
		break;
		*/

	case cmFist: case cmFistp: case cmFst: case cmFstp: case cmFstsw: case cmFstcw:
		os = operand_[0].size;
		command_info_list.Add(atRead, 0, otFPURegistr, os);
		command_info_list.Add(atWrite, 0, otFPURegistr, os);

		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	case cmFldcw:
		os = operand_[0].size;
		command_info_list.Add(atRead, 0, otFPURegistr, os);
		command_info_list.Add(atWrite, 0, otFPURegistr, os);

		command_info_list.AddOperand(operand_[0], atRead);
		break;

	case cmFnop:
		break;

	case cmRdrand:
	case cmRdseed:
		command_info_list.AddOperand(operand_[0], atWrite);

		command_info_list.Add(atWrite, regEFX, otRegistr, size_);
		command_info_list.set_change_flags(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);
		break;

	case cmMovsd:
	case cmMovss:
	case cmMovupd:
	case cmMovups:
	case cmMovdqu:
	case cmMovq:
	case cmMovlpd:
	case cmMovaps:
		command_info_list.AddOperand(operand_[1], atRead);
		command_info_list.AddOperand(operand_[0], atWrite);
		break;

	default:
		return false;
	}

	return true;
}

bool IntelCommand::Merge(ICommand *command)
{
	if (count() == 0 || command->count() == 0 || command->owner() != owner() || address_range() != command->address_range())
		return false;

	IntelCommand *dest = reinterpret_cast<IntelCommand *>(command);
	size_t i;
	for (i = 0; i < vm_command_info_list_->count(); i++) {
		CommandInfo *command_info = vm_command_info_list_->item(i);
		switch (command_info->operand_type()) {
		case otRegistr:
			if (command_info->value() == regESP || (command_info->value() & regExtended))
				return false;
			break;
		case otControlRegistr:
			if (command_info->type() == atWrite)
				return false;
			break;
		case otMemory:
			if (dest->vm_command_info_list_->GetInfo(atWrite, otRegistr, regESP))
				return false;
			break;
		}
	}

	size_t dest_count = dest->count();
	for (i = 0; i < dest->count(); i++) {
		IntelVMCommand *vm_command = dest->item(i);
		if (vm_command->command_type() == cmJmp || vm_command->command_type() == cmRet || vm_command->command_type() == cmIret) {
			dest_count = i;
			break;
		}
	}

	size_t dest_pos = NOT_ID;
	if (owner()->IndexOf(dest) > owner()->IndexOf(this)) {
		for (i = 0; i < dest_count; i++) {
			if (!dest->item(i)->can_merge(*vm_command_info_list_))
				break;
			dest_pos = i;
		}
		if (dest_pos != NOT_ID)
			dest_pos = rand() % (dest_pos + 1);
	} else {
		for (i = dest_count; i > 0; i--) {
			if (!dest->item(i - 1)->can_merge(*vm_command_info_list_))
				break;
			dest_pos = i - 1;
		}
		if (dest_pos != NOT_ID)
			dest_pos = dest_pos + rand() % (dest_count - dest_pos);
	}

	if (dest_pos == NOT_ID)
		return false;

	for (size_t p = 0; p < count(); ) {
		IntelVMCommand *vm_command = item(p);
		if (vm_command->options() & voSectionCommand) {
			if (section_options() & rtBeginSection) {
				p++;
				continue;
			}
			if (section_options() & rtEndSection)
				break;
		}
		RemoveObject(vm_command);
		vm_command->set_owner(dest);
		dest->InsertObject(dest_pos++, vm_command);
	}

	for (i = 0; i < vm_command_info_list_->count(); i++) {
		CommandInfo *command_info = vm_command_info_list_->item(i);
		dest->vm_command_info_list_->Add(command_info->type(), command_info->value(), command_info->operand_type(), command_info->size());
	}

	return true;
}

/**
 * IntelCommandInfoList
 */

IntelCommandInfoList::IntelCommandInfoList(OperandSize cpu_address_size)
	: CommandInfoList(), cpu_address_size_(cpu_address_size), base_segment_(segDefault)
{

}

void IntelCommandInfoList::Add(AccessType access_type, uint8_t value, OperandType operand_type, OperandSize size)
{
	CommandInfoList::Add(access_type, value, operand_type, (cpu_address_size_ == osQWord && access_type == atWrite && operand_type == otRegistr && size == osDWord) ? osQWord : size);
}

void IntelCommandInfoList::AddOperand(const IntelOperand &operand, AccessType access_type)
{
	static const OperandType operand_types[] = {
		otValue,
		otRegistr,
		otMemory,
		otSegmentRegistr,
		otControlRegistr,
		otDebugRegistr,
		otFPURegistr,
		otHiPartRegistr,
		otBaseRegistr,
		otMMXRegistr,
		otXMMRegistr
	};
	
	for (size_t i = 0; i < _countof(operand_types); i++) {
		OperandType ot = operand_types[i];
		if ((operand.type & ot) == 0)
			continue;

		switch (ot) { //-V719
		case otRegistr:
		case otSegmentRegistr:
		case otControlRegistr:
		case otDebugRegistr:
		case otMMXRegistr:
		case otXMMRegistr:
			if (operand.type & otMemory) {
				Add(atRead, operand.registr, ot, operand.address_size);
			} else {
				Add(access_type, operand.registr, ot, operand.size);
			}
			break;

		case otHiPartRegistr:
			Add(access_type, operand.registr, ot, operand.size);
			break;

		case otBaseRegistr:
			if (operand.type & otMemory) {
				Add(atRead, operand.base_registr, otRegistr, operand.address_size);
			} else {
				Add(access_type, operand.base_registr, otRegistr, operand.size);
			}
			break;

		case otFPURegistr:
			Add(access_type, 0, ot, operand.size);
			break;

		case otMemory:
			Add(access_type, operand.effective_base_segment(base_segment_), ot, operand.size);
			break;
		}
	}
}

#ifdef CHECKED
bool IntelCommand::check_hash() const
{
	return (hash_ == calc_hash());
}

void IntelCommand::update_hash()
{
	hash_ = calc_hash();
}

uint32_t IntelCommand::calc_hash() const
{
	Data data;
	data.PushDWord(type_);
	data.PushDWord(preffix_command_);
	data.PushDWord(size_);
	data.PushDWord(base_segment_);
	for (size_t i = 0; i < 3; i++) {
		const IntelOperand *operand = &operand_[i];
		data.PushWord(operand->type);
		data.PushByte(operand->size);
		data.PushByte(operand->registr);
		data.PushByte(operand->base_registr);
		data.PushByte(operand->scale_registr);
		data.PushByte(operand->address_size);
		data.PushByte(operand->value_size);
		data.PushQWord(operand->value);
	}
	SHA1 sha;
	sha.Input(data.data(), data.size());
	return *reinterpret_cast<const uint32_t *>(sha.Result());
}
#endif

/**
 * IntelFunction
 */

IntelFunction::IntelFunction(IFunctionList *owner, const std::string &name, CompilationType compilation_type, uint32_t compilation_options, bool need_compile, Folder *folder)
	: BaseFunction(owner, name, compilation_type, compilation_options, need_compile, folder)
{
	section_cryptor_list_ = new SectionCryptorList(this);
}

IntelFunction::IntelFunction(IFunctionList *owner)
	: BaseFunction(owner, FunctionName(""), ctVirtualization, 0, true, NULL)
{
	section_cryptor_list_ = new SectionCryptorList(this);
}

IntelFunction::IntelFunction(IFunctionList *owner, OperandSize cpu_address_size, IFunction *parent)
	: BaseFunction(owner, cpu_address_size, parent)
{
	section_cryptor_list_ = new SectionCryptorList(this);
}

IntelFunction::IntelFunction(IFunctionList *owner, const IntelFunction &src)
	: BaseFunction(owner, src)
{
	section_cryptor_list_ = new SectionCryptorList(this);
}

IntelFunction *IntelFunction::Clone(IFunctionList *owner) const
{
	IntelFunction *func = new IntelFunction(owner, *this);
	return func;
}

IntelFunction::~IntelFunction()
{
	delete section_cryptor_list_;
}

void IntelFunction::clear()
{
	break_case_list_.clear();
	BaseFunction::clear();
}

IntelCommand *IntelFunction::GetCommandByAddress(uint64_t address) const
{
	return reinterpret_cast<IntelCommand *>(BaseFunction::GetCommandByAddress(address));
}

IntelCommand *IntelFunction::GetCommandByNearAddress(uint64_t address) const
{
	return reinterpret_cast<IntelCommand *>(BaseFunction::GetCommandByNearAddress(address));
}

IntelCommand *IntelFunction::Add(uint64_t address)
{
	IntelCommand *command = new IntelCommand(this, cpu_address_size(), address);
	AddObject(command);
	return command;
}

IntelCommand *IntelFunction::AddCommand(IntelCommandType type, IntelOperand operand1, IntelOperand operand2, IntelOperand operand3)
{
	IntelCommand *command = new IntelCommand(this, cpu_address_size(), type, operand1, operand2, operand3);
	AddObject(command);
	return command;
}

IntelCommand *IntelFunction::AddCommand(const std::string &value)
{
	IntelCommand *command = new IntelCommand(this, cpu_address_size(), value);
	AddObject(command);
	return command;
}

IntelCommand *IntelFunction::AddCommand(const os::unicode_string &value)
{
	IntelCommand *command = new IntelCommand(this, cpu_address_size(), value);
	AddObject(command);
	return command;
}

IntelCommand *IntelFunction::AddCommand(const Data &value)
{
	IntelCommand *command = new IntelCommand(this, cpu_address_size(), value);
	AddObject(command);
	return command;
}

IntelCommand *IntelFunction::AddCommand(OperandSize value_size, uint64_t value)
{
	IntelCommandType command_type;
	switch (value_size) {
	case osWord:
		command_type = cmDW;
		break;
	case osDWord:
		command_type = cmDD;
		break;
	case osQWord:
		command_type = cmDQ;
		break;
	default:
		return NULL;
	}

	return AddCommand(command_type, IntelOperand(otValue, value_size, 0, value));
}

bool IntelFunction::ParseFilterSEH(IArchitecture &file, uint64_t address)
{
	uint32_t table_count;
	size_t i, j, c;
	uint64_t pos, value;
	IntelCommand *command;

	if (file.cpu_address_size() != osDWord || !file.AddressSeek(address))
		return false;

	pos = file.Tell();
	table_count = file.ReadDWord();
	for (i = 0; i < table_count; i++) {
		for (j = 0; j < 2; j++) {
			value = file.ReadDWord();
			if (value == 0) {
				if (j > 0) 
					return false;
			} else {
				if (file.segment_list()->GetMemoryTypeByAddress(value) == mtNone || 
					(file.fixup_list()->count() != 0 && file.fixup_list()->GetFixupByAddress(address + (1 + i * 2 + j) * sizeof(uint32_t)) == NULL))
					return false;
			}
		}
	}

	file.Seek(pos);

	c = count();

	command = Add(address);
	command->ReadValueFromFile(file, osDWord);
	command->set_comment(CommentInfo(ttComment, "Count"));
	address = command->next_address();

	for (i = 0; i < table_count; i++) {
		command = Add(address);
		command->ReadValueFromFile(file, osDWord);
		command->set_comment(CommentInfo(ttComment, "Class"));
		address = command->next_address();

		command = Add(address);
		value = command->ReadValueFromFile(file, osDWord);
		command->set_comment(CommentInfo(ttComment, "Handler"));
		address = command->next_address();
		command->AddLink(0, ltMemSEHBlock, value);
	}

	for (i = c; i < count(); i++) {
		command = item(i);
		command->exclude_option(roClearOriginalCode);
	}

	return true;
}

bool IntelFunction::ParseSwitch(IArchitecture &file, uint64_t address, OperandSize value_size, uint64_t add_value, IntelCommand *parent_command, size_t mode, size_t max_table_count)
{
	if (value_size < osDWord || value_size > osQWord)
		return false;

	size_t i, table_count, c;
	IntelCommand *command;
	uint64_t pos, value;

	command = GetCommandByAddress(address);
	if (command) {
		// CASEs already parsed by previous switch
		for (table_count = 0; command && (command->type() == cmDD || command->type() == cmDQ) && command->link() && command->link()->type() == ltCase; table_count++) {
			if (command->link()->sub_value() != add_value) {
				if (break_case_list_.find(command->address()) != break_case_list_.end())
					break;
				break_case_list_.insert(command->address());
				ClearItems();
				return false;
			}
			command->link()->set_parent_command(parent_command);
			command = GetCommandByAddress(command->next_address());
		}
		return table_count != 0;
	}

	if (!file.AddressSeek(address))
		return false;

	pos = file.Tell();
	std::vector<uint64_t> value_list;
	for (table_count = 0; table_count <= max_table_count; table_count++) {
		uint64_t case_address = address + table_count * OperandSizeToValue(value_size);
		bool is_ok = true;
		for (i = 0; i < OperandSizeToValue(value_size); i++) {
			uint64_t tmp = case_address + i;
			if (GetCommandByNearAddress(tmp) || link_list()->GetLinkByToAddress(ltNone, tmp)) {
				is_ok = false;
				break;
			}
		}
		if (!is_ok)
			break;
		switch (value_size) {
		case osDWord:
			{
				uint32_t dw = file.ReadDWord();
				value = (mode == 1) ? DWordToInt64(dw) : dw;
			}
			break;
		case osQWord:
			value = file.ReadQWord();
			break;
		}
		if (mode == 2)
			value = add_value - value;
		else
			value = add_value + value;
		if (file.cpu_address_size() == osDWord)
			value = static_cast<uint32_t>(value);
		if ((file.segment_list()->GetMemoryTypeByAddress(value) & mtExecutable) == 0)
			break;
		if (value >= address)
			break;
		if (table_count > 0 && break_case_list_.find(case_address) != break_case_list_.end())
			break;
		value_list.push_back(value);
	}

	if (value_list.empty())
		return false;

	file.Seek(pos);
	c = count();
	for (i = 0; i < value_list.size(); i++) {
		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "Case"));
		command->ReadValueFromFile(file, value_size);
		address = command->next_address();

		CommandLink *link = command->AddLink(0, ltCase, value_list[i]);
		link->set_parent_command(parent_command);
		if (add_value)
			link->set_sub_value(add_value);
		if (mode == 2)
			link->set_is_inverse(true);
	}

	command = item(c);
	command->set_alignment(OperandSizeToValue(value_size));
	command->include_option(roCreateNewBlock);

	return true;
}

bool IntelFunction::ParseSEH3(IArchitecture &file, uint64_t address)
{
	if (!file.AddressSeek(address))
		return false;

	uint32_t state;
	uint64_t pos, value;
	size_t i, c, table_count;
	IntelCommand *command;

	pos = file.Tell();
	for (table_count = 0;; table_count++) {
		state = file.ReadDWord();
		if (state != (uint32_t)-1 && state >= table_count)
			break;

		bool is_ok = true;
		for (i = 0; i < 2; i++) {
			value = file.ReadDWord();
			if (value) {
				if ((file.segment_list()->GetMemoryTypeByAddress(value) & mtExecutable) == 0) {
					is_ok = false;
					break;
				}
			} else if (i == 1) {
				is_ok = false;
				break;
			}
		}
		if (!is_ok)
			break;
	}

	if (!table_count)
		return false;

	file.Seek(pos);
	c = count();
	for (i = 0; i < table_count; i++) {
		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "State"));
		command->ReadValueFromFile(file, osDWord);
		address = command->next_address();

		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "Filter"));
		value = command->ReadValueFromFile(file, osDWord);
		if (value) {
			command->AddLink(0, ltMemSEHBlock, value);
			command->include_option(roExternal);
		}
		address = command->next_address();

		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "Handler"));
		value = command->ReadValueFromFile(file, osDWord);
		if (value)
			command->AddLink(0, ltMemSEHBlock, value);
		address = command->next_address();
	}

	command = item(c);
	command->set_alignment(OperandSizeToValue(osDWord));
	command->include_option(roCreateNewBlock);

	for (i = c; i < count(); i++) {
		command = item(i);
		command->exclude_option(roClearOriginalCode);
	}
	return true;
}

bool IntelFunction::ParseSEH4(IArchitecture &file, uint64_t address)
{
	if (!file.AddressSeek(address))
		return false;

	uint32_t state;
	uint64_t pos, value;
	size_t i, c, table_count;
	IntelCommand *command;

	pos = file.Tell();
	file.ReadDWord();
	file.ReadDWord();
	file.ReadDWord();
	file.ReadDWord();
	for (table_count = 0;; table_count++) {
		state = file.ReadDWord();
		if (state != (uint32_t)-2 && (size_t)state >= table_count)
			break;

		bool is_ok = true;
		for (i = 0; i < 2; i++) {
			value = file.ReadDWord();
			if (value) {
				if ((file.segment_list()->GetMemoryTypeByAddress(value) & mtExecutable) == 0) {
					is_ok = false;
					break;
				}
			} else if (i == 1) {
				is_ok = false;
				break;
			}
		}
		if (!is_ok)
			break;
	}

	if (!table_count)
		return false;

	file.Seek(pos);
	c = count();

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "GSCookieOffset"));
	command->ReadValueFromFile(file, osDWord);
	address = command->next_address();

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "GSCookieXOROffset"));
	command->ReadValueFromFile(file, osDWord);
	address = command->next_address();

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "EHCookieOffset"));
	command->ReadValueFromFile(file, osDWord);
	address = command->next_address();

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "EHCookieXOROffset"));
	command->ReadValueFromFile(file, osDWord);
	address = command->next_address();

	for (i = 0; i < table_count; i++) {
		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "State"));
		command->ReadValueFromFile(file, osDWord);
		address = command->next_address();

		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "Filter"));
		value = command->ReadValueFromFile(file, osDWord);
		if (value) {
			command->AddLink(0, ltMemSEHBlock, value);
			command->include_option(roExternal);
		}
		address = command->next_address();

		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "Handler"));
		value = command->ReadValueFromFile(file, osDWord);
		if (value)
			command->AddLink(0, ltMemSEHBlock, value);
		address = command->next_address();
	}

	command = item(c);
	command->set_alignment(OperandSizeToValue(osDWord));
	command->include_option(roCreateNewBlock);

	for (i = c; i < count(); i++) {
		command = item(i);
		command->exclude_option(roClearOriginalCode);
	}
	return true;
}

bool IntelFunction::ParseCxxSEH(IArchitecture &file, uint64_t address)
{
	if (!file.AddressSeek(address))
		return false;

	uint64_t pos, unwind_map_entry, try_block_entry, catches_entry, value, map_entry, action_entry;
	uint32_t magic, max_state, try_blocks, catches, map_count;
	IntelCommand *command;
	CommandLink *link;
	size_t i, j, c;

	uint64_t add_value = (cpu_address_size() == osDWord) ? 0 : file.image_base();
	pos = file.Tell();
	magic = file.ReadDWord();
	if (magic != 0x19930520 && magic != 0x19930521 && magic != 0x19930522)
		return false;

	if (GetCommandByAddress(address))
		return true;

	file.Seek(pos);

	c = count();

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "Magic"));
	command->ReadValueFromFile(file, osDWord);
	command->set_alignment(OperandSizeToValue(osDWord));
	command->include_option(roCreateNewBlock);
	address = command->next_address();

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "MaxState"));
	max_state = static_cast<uint32_t>(command->ReadValueFromFile(file, osDWord));
	address = command->next_address();

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "UnwindMapEntry"));
	unwind_map_entry = command->ReadValueFromFile(file, osDWord);
	if (unwind_map_entry) {
		unwind_map_entry += add_value;
		link = command->AddLink(0, ltOffset, unwind_map_entry);
		link->set_sub_value(add_value);
	}
	address = command->next_address();

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "TryBlocks"));
	try_blocks = static_cast<uint32_t>(command->ReadValueFromFile(file, osDWord));
	address = command->next_address();

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "TryBlockMapEntry"));
	try_block_entry = command->ReadValueFromFile(file, osDWord);
	if (try_block_entry) {
		try_block_entry += add_value;
		link = command->AddLink(0, ltOffset, try_block_entry);
		link->set_sub_value(add_value);
	}
	address = command->next_address();

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "IPMapEntries"));
	map_count = static_cast<uint32_t>(command->ReadValueFromFile(file, osDWord));
	address = command->next_address();

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "IPtoStateMap"));
	map_entry = command->ReadValueFromFile(file, osDWord);
	if (map_entry) {
		map_entry += add_value;
		link = command->AddLink(0, ltOffset, map_entry);
		link->set_sub_value(add_value);
	}
	address = command->next_address();

	if (file.cpu_address_size() == osQWord) {
		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "UnwindHelp"));
		command->ReadValueFromFile(file, osDWord);
		address = command->next_address();
	}

	if (magic >= 0x19930521) {
		command = Add(address);
		command->ReadValueFromFile(file, osDWord);
		command->set_comment(CommentInfo(ttComment, "ESTypeList"));
		address = command->next_address();

		if (magic == 0x19930522) {
			command = Add(address);
			command->ReadValueFromFile(file, osDWord);
			command->set_comment(CommentInfo(ttComment, "Flags"));
			//address = command->next_address();
		}
	}

	if (max_state && file.AddressSeek(unwind_map_entry)) {
		for (i = 0; i < max_state; i++) {
			command = Add(unwind_map_entry);
			command->set_comment(CommentInfo(ttComment, "ToState"));
			command->ReadValueFromFile(file, osDWord);
			unwind_map_entry = command->next_address();

			command = Add(unwind_map_entry);
			command->set_comment(CommentInfo(ttComment, "Action"));
			action_entry = command->ReadValueFromFile(file, osDWord);
			if (action_entry) {
				action_entry += add_value;
				link = command->AddLink(0, ltMemSEHBlock, action_entry);
				link->set_parsed(true);
				link->set_sub_value(add_value);
			}
			unwind_map_entry = command->next_address();
		}
	}

	if (try_blocks && file.AddressSeek(try_block_entry)) {
		for (i = 0; i < try_blocks; i++) {
			command = Add(try_block_entry);
			command->set_comment(CommentInfo(ttComment, "TryLow"));
			command->ReadValueFromFile(file, osDWord);
			try_block_entry = command->next_address();

			command = Add(try_block_entry);
			command->set_comment(CommentInfo(ttComment, "TryHigh"));
			command->ReadValueFromFile(file, osDWord);
			try_block_entry = command->next_address();

			command = Add(try_block_entry);
			command->set_comment(CommentInfo(ttComment, "CatchHigh"));
			command->ReadValueFromFile(file, osDWord);
			try_block_entry = command->next_address();

			command = Add(try_block_entry);
			command->set_comment(CommentInfo(ttComment, "Catches"));
			catches = static_cast<uint32_t>(command->ReadValueFromFile(file, osDWord));
			try_block_entry = command->next_address();

			command = Add(try_block_entry);
			command->set_comment(CommentInfo(ttComment, "HandlerArray"));
			catches_entry = command->ReadValueFromFile(file, osDWord);
			if (catches_entry) {
				catches_entry += add_value;
				link = command->AddLink(0, ltOffset, catches_entry);
				link->set_sub_value(add_value);
			}
			try_block_entry = command->next_address();

			pos = file.Tell();
			if (catches && file.AddressSeek(catches_entry)) {
				for (j = 0; j < catches; j++) {
					command = Add(catches_entry);
					command->set_comment(CommentInfo(ttComment, "Adjectives"));
					command->ReadValueFromFile(file, osDWord);
					catches_entry = command->next_address();

					command = Add(catches_entry);
					command->set_comment(CommentInfo(ttComment, "Type"));
					command->ReadValueFromFile(file, osDWord);
					catches_entry = command->next_address();

					command = Add(catches_entry);
					command->set_comment(CommentInfo(ttComment, "CatchObj"));
					command->ReadValueFromFile(file, osDWord);
					catches_entry = command->next_address();

					command = Add(catches_entry);
					command->set_comment(CommentInfo(ttComment, "Handler"));
					value = command->ReadValueFromFile(file, osDWord);
					if (value) {
						value += add_value;
						link = command->AddLink(0, ltExtSEHHandler, value);
						link->set_sub_value(add_value);
					}
					catches_entry = command->next_address();

					if (cpu_address_size() == osQWord) {
						command = Add(catches_entry);
						command->set_comment(CommentInfo(ttComment, "Frame"));
						command->ReadValueFromFile(file, osDWord);
						catches_entry = command->next_address();
					}
				}
				file.Seek(pos);
			}
		}
	}

	if (map_count && file.AddressSeek(map_entry)) {
		AddressRange *last_range = NULL;
		for (i = 0; i < map_count; i++) {
			command = Add(map_entry);
			command->set_comment(CommentInfo(ttComment, "Ip"));
			value = command->ReadValueFromFile(file, osDWord) + add_value;
			map_entry = command->next_address();

			if (last_range && last_range->begin() < value)
				last_range->set_end(value);
			last_range = range_list()->Add(value, 0, command, NULL, NULL);

			command = Add(map_entry);
			command->set_comment(CommentInfo(ttComment, "State"));
			command->ReadValueFromFile(file, osDWord);
			map_entry = command->next_address();
		}
	}

	for (i = c; i < count(); i++) {
		command = item(i);
		command->exclude_option(roClearOriginalCode);
	}

	return true;
}

bool IntelFunction::ParseCompressedCxxSEH(IArchitecture &file, uint64_t address, uint64_t begin)
{
	// FIXME
	return false;

	if (file.cpu_address_size() != osQWord || !file.AddressSeek(address))
		return false;

	uint64_t pos, unwind_map_entry, try_block_entry, catches_entry, value, map_entry, action_entry;
	uint32_t max_state, try_blocks, catches, map_count;
	IntelCommand *command;
	CommandLink *link;
	size_t old_count, i, j, k, c;

	uint64_t add_value = (cpu_address_size() == osDWord) ? 0 : file.image_base();

	pos = file.Tell();
	uint8_t header_flags = file.ReadByte();
	if (header_flags & 4) {
		command = Add(address);
		command->ReadCompressedValue(file);
		delete command;
	}

	if (header_flags & 8) {
		value = file.ReadDWord();
		if (value && (file.segment_list()->GetMemoryTypeByAddress(value + add_value) & mtReadable) == 0)
			return false;
	}
	if (header_flags & 0x10) {
		value = file.ReadDWord();
		if (value && (file.segment_list()->GetMemoryTypeByAddress(value + add_value) & mtReadable) == 0)
			return false;
	}
	value = file.ReadDWord();
	if (file.AddressSeek(value + add_value)) {
		map_entry = value + add_value;
		command = Add(map_entry);
		map_count = command->ReadCompressedValue(file);

		value = begin;
		for (i = 0; i < map_count; i++) {
			uint32_t ip = command->ReadCompressedValue(file);
			command->ReadCompressedValue(file);
			value += ip;
			if ((file.segment_list()->GetMemoryTypeByAddress(value) & mtExecutable) == 0) {
				delete command;
				return false;
			}
		}
		delete command;
	} else 
		return false;

	if (GetCommandByAddress(address))
		return true;

	file.Seek(pos);

	old_count = count();

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "Header"));
	command->ReadValueFromFile(file, osByte);
	command->include_option(roCreateNewBlock);
	address = command->next_address();

	if (header_flags & 4) {
		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "Flags"));
		command->ReadCompressedValue(file);
		address = command->next_address();
	}

	unwind_map_entry = 0;
	if (header_flags & 8) {
		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "UnwindMapEntry"));
		unwind_map_entry = command->ReadValueFromFile(file, osDWord);
		if (unwind_map_entry) {
			unwind_map_entry += add_value;
			link = command->AddLink(0, ltOffset, unwind_map_entry);
			link->set_sub_value(add_value);
		}
		address = command->next_address();
	}

	try_block_entry = 0;
	if (header_flags & 0x10) {
		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "TryBlockMapEntry"));
		try_block_entry = command->ReadValueFromFile(file, osDWord);
		if (try_block_entry) {
			try_block_entry += add_value;
			link = command->AddLink(0, ltOffset, try_block_entry);
			link->set_sub_value(add_value);
		}
		address = command->next_address();
	}

	command = Add(address);
	command->set_comment(CommentInfo(ttComment, "IPtoStateMap"));
	map_entry = command->ReadValueFromFile(file, osDWord);
	if (map_entry) {
		map_entry += add_value;
		link = command->AddLink(0, ltOffset, map_entry);
		link->set_sub_value(add_value);
	}
	address = command->next_address();

	if (header_flags & 1) {
		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "Frame"));
		command->ReadCompressedValue(file);
		address = command->next_address();
	}

	if (unwind_map_entry && file.AddressSeek(unwind_map_entry)) {
		command = Add(unwind_map_entry);
		command->set_comment(CommentInfo(ttComment, "MaxState"));
		max_state = command->ReadCompressedValue(file);
		unwind_map_entry = command->next_address();

		for (i = 0; i < max_state; i++) {
			command = Add(unwind_map_entry);
			command->set_comment(CommentInfo(ttComment, "NextOffset"));
			uint32_t offset = command->ReadCompressedValue(file);
			unwind_map_entry = command->next_address();

			uint8_t type = offset & 3;
			if (type) {
				command = Add(unwind_map_entry);
				command->set_comment(CommentInfo(ttComment, "Action"));
				action_entry = command->ReadValueFromFile(file, osDWord);
				if (action_entry) {
					action_entry += add_value;
					link = command->AddLink(0, ltMemSEHBlock, action_entry);
					link->set_parsed(true);
					link->set_sub_value(add_value);
				}
				unwind_map_entry = command->next_address();
			}

			if (type == 1 || type == 2) {
				command = Add(unwind_map_entry);
				command->set_comment(CommentInfo(ttComment, "Object"));
				command->ReadCompressedValue(file);
				unwind_map_entry = command->next_address();
			}
		}
	}

	if (try_block_entry && file.AddressSeek(try_block_entry)) {
		command = Add(try_block_entry);
		command->set_comment(CommentInfo(ttComment, "TryBlocks"));
		try_blocks = command->ReadCompressedValue(file);
		try_block_entry = command->next_address();

		for (i = 0; i < try_blocks; i++) {
			command = Add(try_block_entry);
			command->set_comment(CommentInfo(ttComment, "TryLow"));
			command->ReadCompressedValue(file);
			try_block_entry = command->next_address();

			command = Add(try_block_entry);
			command->set_comment(CommentInfo(ttComment, "TryHigh"));
			command->ReadCompressedValue(file);
			try_block_entry = command->next_address();

			command = Add(try_block_entry);
			command->set_comment(CommentInfo(ttComment, "CatchHigh"));
			command->ReadCompressedValue(file);
			try_block_entry = command->next_address();

			command = Add(try_block_entry);
			command->set_comment(CommentInfo(ttComment, "HandlerArray"));
			catches_entry = command->ReadValueFromFile(file, osDWord) + add_value;
			link = command->AddLink(0, ltOffset, catches_entry);
			link->set_sub_value(add_value);
			try_block_entry = command->next_address();

			pos = file.Tell();
			if (file.AddressSeek(catches_entry)) {
				command = Add(catches_entry);
				command->set_comment(CommentInfo(ttComment, "Catches"));
				catches = command->ReadCompressedValue(file);
				catches_entry = command->next_address();

				for (j = 0; j < catches; j++) {
					command = Add(catches_entry);
					command->set_comment(CommentInfo(ttComment, "Header"));
					uint8_t header = static_cast<uint8_t>(command->ReadValueFromFile(file, osByte));
					catches_entry = command->next_address();

					if (header & 1) {
						command = Add(catches_entry);
						command->set_comment(CommentInfo(ttComment, "Adjectives"));
						command->ReadCompressedValue(file);
						catches_entry = command->next_address();
					}

					if (header & 2) {
						command = Add(catches_entry);
						command->set_comment(CommentInfo(ttComment, "Type"));
						command->ReadValueFromFile(file, osDWord);
						catches_entry = command->next_address();
					}

					if (header & 4) {
						command = Add(catches_entry);
						command->set_comment(CommentInfo(ttComment, "CatchObj"));
						command->ReadCompressedValue(file);
						catches_entry = command->next_address();
					}

					command = Add(catches_entry);
					command->set_comment(CommentInfo(ttComment, "Handler"));
					value = command->ReadValueFromFile(file, osDWord);
					if (value) {
						value += add_value;
						link = command->AddLink(0, ltExtSEHHandler, value);
						link->set_sub_value(add_value);
					}
					catches_entry = command->next_address();

					switch ((header >> 4) & 3) {
					case 1:
						c = 1;
						break;
					case 2:
						c = 2;
						break;
					default:
						c = 0;
						break;
					}
					for (k = 0; k < c; k++) {
						command = Add(catches_entry);
						command->set_comment(CommentInfo(ttComment, "ContinuationAddress"));
						if (header & 8) {
							value = command->ReadValueFromFile(file, osDWord) + add_value;
							link = command->AddLink(0, ltMemSEHBlock, value);
							link->set_sub_value(add_value);
						}
						else {
							command->include_option(roFillNop);
							value = command->ReadCompressedValue(file) + begin;
							link = command->AddLink(0, ltMemSEHBlock, value);
							link->set_base_function_info(function_info_list()->GetItemByAddress(begin));
						}

						catches_entry = command->next_address();
					}
				}
				file.Seek(pos);
			}
		}
	}

	if (file.AddressSeek(map_entry)) {
		command = Add(map_entry);
		command->set_comment(CommentInfo(ttComment, "IPMapEntries"));
		map_count = command->ReadCompressedValue(file);
		map_entry = command->next_address();

		value = begin;
		AddressRange *last_range = NULL;
		for (i = 0; i < map_count; i++) {
			command = Add(map_entry);
			command->set_comment(CommentInfo(ttComment, "Ip"));
			value += command->ReadCompressedValue(file);
			command->include_option(roFillNop);
			map_entry = command->next_address();

			if (last_range)
				last_range->set_end(value);
			last_range = range_list()->Add(value, 0, command, NULL, NULL);

			command = Add(map_entry);
			command->set_comment(CommentInfo(ttComment, "State"));
			command->ReadCompressedValue(file);
			map_entry = command->next_address();
		}
	}

	for (i = old_count; i < count(); i++) {
		command = item(i);
		command->exclude_option(roClearOriginalCode);
	}

	return true;
}

bool IntelFunction::ParseScopeSEH(IArchitecture &file, uint64_t address, uint32_t table_count)
{
	if (!file.AddressSeek(address))
		return false;

	IntelCommand *command;
	CommandLink *link;
	size_t i;
	uint64_t value;
	uint64_t image_base = file.image_base();

	uint64_t pos = file.Tell();

	for (i = 0; i < table_count; i++) { //-V756
		for (size_t j = 0; j < 4; j++) {
			value = file.ReadDWord();
			if ((j == 0 || j == 1) && (file.segment_list()->GetMemoryTypeByAddress(value + image_base) & mtExecutable) == 0)
				return false;
		}
	}

	if (GetCommandByAddress(address))
		return true;

	file.Seek(pos);

	size_t c = count();

	for (i = 0; i < table_count; i++) {
		IntelCommand *begin_entry = command = Add(address);
		begin_entry->set_comment(CommentInfo(ttComment, "Begin"));
		uint64_t begin_address = begin_entry->ReadValueFromFile(file, osDWord) + image_base;
		address = begin_entry->next_address();

		IntelCommand *end_entry = Add(address);
		end_entry->set_comment(CommentInfo(ttComment, "End"));
		uint64_t end_address = end_entry->ReadValueFromFile(file, osDWord) + image_base;
		address = end_entry->next_address();

		range_list()->Add(begin_address, end_address, begin_entry, end_entry, NULL);

		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "Filter"));
		value = command->ReadValueFromFile(file, osDWord);
		if (value > 1) {
			value += image_base;
			pos = file.Tell();
			if (ParseDelphiSEH(file, value)) {
				link = command->AddLink(0, ltOffset, value);
			} else {
				link = command->AddLink(0, ltMemSEHBlock, value);
				command->include_option(roExternal);
			}
			link->set_sub_value(image_base);
			file.Seek(pos);
		}
		address = command->next_address();

		command = Add(address);
		command->set_comment(CommentInfo(ttComment, "Handler"));
		value = command->ReadValueFromFile(file, osDWord);
		if (value) {
			value += image_base;
			link = command->AddLink(0, ltMemSEHBlock, value);
			link->set_sub_value(image_base);
		}
		address = command->next_address();
	};

	for (i = c; i < count(); i++) {
		command = item(i);
		command->exclude_option(roClearOriginalCode);
	}

	return true;
}

bool IntelFunction::ParseNewSEH(IArchitecture &file, uint64_t address)
{
	size_t i;
	IntelCommand *command;

	IntelFunction func(NULL, cpu_address_size(), this);
	func.ReadFromFile(file, address);
	command = func.GetCommandByAddress(address);
	if (command) {
		for (i = func.IndexOf(command) + 1; i < func.count(); i++) {
			command = func.item(i);
			if (command->type() == cmJmp
				&& command->operand(0).type == otValue
				&& (command->operand(0).value < address || func.GetCommandByAddress(command->operand(0).value) == NULL)) {
				command = func.item(i - 1);
				if (command->type() == cmMov
					&& command->operand(0).type == otRegistr
					&& command->operand(0).registr == regEAX
					&& command->operand(1).type == otValue) {
					return ParseCxxSEH(file, command->operand(1).value);
				}
			}
		}
	}

	return false;
}

bool IntelFunction::ParseVB6SEH(IArchitecture &file, uint64_t address)
{
	if (!file.AddressSeek(address))
		return false;

	uint64_t pos = file.Tell();

	size_t i, k, table_count;
	uint32_t flags;
	uint64_t value;
	IntelCommand *command;
	//CommandLink *link;

	flags = file.ReadDWord();
	switch (flags >> 16) {
	case 0x04:
	case 0x08:
	case 0x0c:
	case 0x10:
	case 0x14:
		break;
	default:
		return false;
	}

	k = (flags & 0xffff0007) == 0x80001 ? 1 : 3;
	for (table_count = 0;; table_count++) {
		bool is_ok = true;
		for (i = 0; i < k; i++) {
			value = file.ReadDWord();
			if (value != 0 && (file.segment_list()->GetMemoryTypeByAddress(value) & mtExecutable) == 0) {
				is_ok = false;
				break;
			}
		}
		if (!is_ok)
			break;
	}

	if (!table_count)
		return false;

	file.Seek(pos);

	size_t c = count();

	command = Add(address);
	command->ReadValueFromFile(file, osDWord);
	address = command->next_address();

	for (i = 0; i < k; i++) {
		command = Add(address);
		value = command->ReadValueFromFile(file, osDWord);
		if (value)
			command->AddLink(0, ltVBMemSEHBlock, value);
		address = command->next_address();
	}

	if (flags & 0x30) {
		command = Add(address);
		uint64_t ext_info = command->ReadValueFromFile(file, osDWord);
		address = command->next_address();

		command = Add(address);
		uint64_t address_info = command->ReadValueFromFile(file, osDWord);
		address = command->next_address();

		if (ext_info && file.AddressSeek(ext_info)) {
			address = ext_info;

			command = Add(address);
			command->ReadValueFromFile(file, osDWord);
			address = command->next_address();

			command = Add(address);
			command->ReadValueFromFile(file, osDWord);
			address = command->next_address();

			command = Add(address);
			value = command->ReadValueFromFile(file, osDWord);
			if (value)
				command->AddLink(0, ltVBMemSEHBlock, value);
			address = command->next_address();
		}

		if (address_info && file.AddressSeek(address_info)) {
			address = address_info;

			command = Add(address);
			size_t array_count = static_cast<size_t>(command->ReadValueFromFile(file, osDWord));
			address = command->next_address();

			for (i = 0; i < array_count; i++) {
				command = Add(address);
				value = command->ReadValueFromFile(file, osDWord);
				if (value)
					command->AddLink(0, ltVBMemSEHBlock, value);
				address = command->next_address();
			}
		}
	}

	for (i = c; i < count(); i++) {
		command = item(i);
		command->exclude_option(roClearOriginalCode);
	}

	return true;
}

bool IntelFunction::ParseDelphiSEH(IArchitecture &file, uint64_t address)
{
	if (!file.AddressSeek(address))
		return false;

	IntelCommand *command;
	size_t i, j;
	uint64_t value;

	size_t c = count();
	uint64_t image_base = file.image_base();
	uint64_t pos = file.Tell();

	uint32_t table_count = file.ReadDWord();
	for (i = 0; i < table_count; i++) {
		for (j = 0; j < 2; j++) {
			value = file.ReadDWord();
			if (!value)
				continue;

			value += image_base;
			if ((file.segment_list()->GetMemoryTypeByAddress(value) & (j == 1 ? mtExecutable : mtReadable)) == 0)
				return false;
		}
	}

	file.Seek(pos);

	command = Add(address);
	command->ReadValueFromFile(file, osDWord);
	command->set_comment(CommentInfo(ttComment, "Count"));
	address = command->next_address();

	for (size_t i = 0; i < table_count; i++) {
		command = Add(address);
		command->ReadValueFromFile(file, osDWord);
		command->set_comment(CommentInfo(ttComment, "Type"));
		address = command->next_address();

		command = Add(address);
		value = command->ReadValueFromFile(file, osDWord);
		if (value) {
			value += image_base;
			CommandLink *link = command->AddLink(0, ltMemSEHBlock, value);
			link->set_sub_value(image_base);
		}
		command->set_comment(CommentInfo(ttComment, "Handler"));
		address = command->next_address();
	}

	for (i = c; i < count(); i++) {
		command = item(i);
		command->exclude_option(roClearOriginalCode);
	}

	return true;
}

bool IntelFunction::ParseBCBSEH(IArchitecture &file, uint64_t address, uint64_t next_address, uint8_t version)
{
	if (!file.AddressSeek(address))
		return false;

	uint64_t base_address = address;
	IntelCommand *command;
	size_t c = count();

	if (version == 2) {
		command = Add(address);
		command->ReadValueFromFile(file, osDWord);
		command->set_comment(CommentInfo(ttComment, "ThrowLst"));
		address = command->next_address();
	}

	command = Add(address);
	command->ReadValueFromFile(file, osDWord);
	command->set_comment(CommentInfo(ttComment, "VirtCondOffs"));
	address = command->next_address();

	command = Add(address);
	uint64_t bp_offset = command->ReadValueFromFile(file, osDWord);
	command->set_comment(CommentInfo(ttComment, "BPoffs"));

	//std::vector<uint16_t> ctx_list;
	{
		uint64_t bcb_seh_operand = IntelOperand(otMemory | otRegistr | otValue, osWord, regEBP, bp_offset + 0x10).encode();
		IntelFunction tmp(NULL, file.cpu_address_size(), this);
		address = next_address;
		for (;;) {
			command = NULL;
			if (file.segment_list()->GetMemoryTypeByAddress(address) & mtExecutable) {
				if (file.AddressSeek(address)) {
					command = tmp.ParseCommand(file, address);
					if (command && command->type() == cmMov && command->operand(0).encode() == bcb_seh_operand && command->operand(1).type == otValue) {
						uint16_t bcb_ctx = static_cast<uint16_t>(command->operand(1).value);
						size_t old_count = link_list()->count();
						IntelCommand *orig = command;
						while (bcb_ctx) {
							address = base_address + bcb_ctx;

							if (GetCommandByAddress(address))
								break;

							if (!file.AddressSeek(address))
								break;

							command = Add(address);
							bcb_ctx = static_cast<uint16_t>(command->ReadValueFromFile(file, osWord));
							command->set_comment(CommentInfo(ttComment, "Outer"));
							address = command->next_address();

							command = Add(address);
							uint16_t kind = static_cast<uint16_t>(command->ReadValueFromFile(file, osWord));
							command->set_comment(CommentInfo(ttComment, "Kind"));
							address = command->next_address();

							uint64_t value;
							switch (kind) {
							case 0:
								command = Add(address);
								command->ReadValueFromFile(file, osDWord);
								command->set_comment(CommentInfo(ttComment, "Reserved"));
								address = command->next_address();

								command = Add(address);
								value = command->ReadValueFromFile(file, osDWord);
								if (value)
									command->AddLink(0, ltMemSEHBlock, value);
								command->set_comment(CommentInfo(ttComment, "Handler"));
								break;
							case 1:
							case 2:
								command = Add(address);
								value = command->ReadValueFromFile(file, osDWord);
								if (kind == 1 && value)
									command->AddLink(0, ltMemSEHBlock, value);
								command->set_comment(CommentInfo(ttComment, "Filter"));
								address = command->next_address();

								command = Add(address);
								value = command->ReadValueFromFile(file, osDWord);
								if (value)
									command->AddLink(0, ltMemSEHBlock, value);
								command->set_comment(CommentInfo(ttComment, "Handler"));
								break;
							case 3:
								{
									command = Add(address);
									address = command->ReadValueFromFile(file, osDWord);
									command->set_comment(CommentInfo(ttComment, "Table"));
									command->AddLink(0, ltOffset, address);

									if (file.AddressSeek(address)) {
										command = Add(address);
										command->ReadValueFromFile(file, osDWord);
										command->set_comment(CommentInfo(ttComment, "ArgAddr"));
										address = command->next_address();

										command = Add(address);
										command->ReadValueFromFile(file, osDWord);
										command->set_comment(CommentInfo(ttComment, "ArgSize"));
										address = command->next_address();

										while (true) {
											command = Add(address);
											value = command->ReadValueFromFile(file, osDWord);
											if (value) {
												command->AddLink(0, ltMemSEHBlock, value);
											} else {
												delete command;
												break;
											}
											command->set_comment(CommentInfo(ttComment, "Handler"));
											address = command->next_address();

											command = Add(address);
											command->ReadValueFromFile(file, osDWord);
											command->set_comment(CommentInfo(ttComment, "TypeID"));
											address = command->next_address();

											command = Add(address);
											command->ReadValueFromFile(file, osDWord);
											command->set_comment(CommentInfo(ttComment, "Flags"));
											address = command->next_address();

											command = Add(address);
											command->ReadValueFromFile(file, osDWord);
											command->set_comment(CommentInfo(ttComment, "CctrAddr"));
											address = command->next_address();

											command = Add(address);
											command->ReadValueFromFile(file, osDWord);
											command->set_comment(CommentInfo(ttComment, "CctrMask"));
											address = command->next_address();
										}
									}
								}
								break;
							case 4:
								break;
							case 5:
								command = Add(address);
								command->ReadValueFromFile(file, osDWord);
								command->set_comment(CommentInfo(ttComment, "MinCount"));
								address = command->next_address();

								command = Add(address);
								command->ReadValueFromFile(file, osDWord);
								command->set_comment(CommentInfo(ttComment, "Table"));
								break;
							}
						}
						for (size_t i = old_count; i < link_list()->count(); i++) {
							CommandLink *src_link = link_list()->item(i);
							CommandLink *dst_link = src_link->Clone(tmp.link_list());
							tmp.link_list()->AddObject(dst_link);
							dst_link->set_from_command(tmp.Add(src_link->from_command()->address()));
						}
						command = orig;
					}
				}
			}
			if (!command || command->is_end() || (command->options() & roBreaked) != 0) {
				address = tmp.GetNextAddress(file);
				if (!address)
					break;
			} else {
				address = command->next_address();
			}
		}
	}

	for (size_t i = c; i < count(); i++) {
		command = item(i);
		command->exclude_option(roClearOriginalCode);
	}

	return true;
}

IntelCommand *IntelFunction::ParseString(IArchitecture &file, uint64_t address, size_t len)
{
	if (!file.AddressSeek(address))
		return NULL;

	IntelCommand *command = Add(address);
	command->ReadArray(file, len);
	command->exclude_option(roNeedCompile);
	return command;
}

void IntelFunction::ParseBeginCommands(IArchitecture &file)
{
	if (type() == otMarker || type() == otAPIMarker) {
		CompilerFunction *func = file.compiler_function_list()->GetFunctionByLowerAddress(address());
		if (func && (func->type() == cfCxxSEH || func->type() == cfCxxSEH3 || func->type() == cfCxxSEH4 || func->type() == cfBCBSEH || func->type() == cfVB6SEH)) {
			IntelFunction tmp(NULL, cpu_address_size());
			tmp.ReadFromFile(file, func->address());
			if (tmp.GetCommandByAddress(address())) {
				switch (func->type()) {
				case cfCxxSEH:
					ParseNewSEH(file, func->value(0));
					break;
				case cfCxxSEH3:
					ParseSEH3(file, func->value(0));
					break;
				case cfCxxSEH4:
					ParseSEH4(file, func->value(0));
					break;
				case cfBCBSEH:
					ParseBCBSEH(file, func->value(0), address(), static_cast<uint8_t>(func->value(1)));
					break;
				case cfVB6SEH:
					ParseVB6SEH(file, func->value(0));
					break;
				}
			}
		}
	}
}

void IntelFunction::ParseEndCommands(IArchitecture &file)
{
	if (type() == otMarker) {
		uint64_t len_address = address() + 1;
		if (file.AddressSeek(len_address)) {
			uint8_t len = file.ReadByte();
			ParseString(file, len_address + 1, len);
		}
	}

	if (type() == otMarker || type() == otAPIMarker) {
		std::vector<ICommand *> entry_command_list;
		std::vector<ICommand *> exclude_command_list;
		size_t i, j, k;

		/*
		for (i = 0; i < link_list()->count(); i++) {
			CommandLink *link = link_list()->item(i);
			if (link->type() == ltMemSEHBlock || link->type() == ltExtSEHHandler) {
				IntelCommand *command = GetCommandByAddress(link->to_address());
				if (command && std::find(entry_command_list.begin(), entry_command_list.end(), command) == entry_command_list.end())
					entry_command_list.push_back(command);
			}
		}
		*/

		for (i = 0; i < file.end_marker_list()->count(); i++) {
			MarkerCommand *marker_command = file.end_marker_list()->item(i);
			IntelCommand *command = GetCommandByNearAddress(marker_command->address());
			if (command) {
				if (marker_command->type() == otMarker) {
					uint64_t len_address = command->address() + 1;
					if (file.AddressSeek(len_address)) {
						uint8_t len = file.ReadByte();
						command = ParseString(file, len_address + 1, len);
					}
				} else {
					if (!command->is_end())
						command->include_option(roBreaked);
				}
				command = GetCommandByAddress(command->next_address());
				if (command && std::find(entry_command_list.begin(), entry_command_list.end(), command) == entry_command_list.end())
					entry_command_list.push_back(command);
			} else {
				for (size_t j = 0; j < link_list()->count(); j++) {
					CommandLink *link = link_list()->item(j);
					if ((link->type() == ltJmp || link->type() == ltJmpWithFlag) && link->to_address() && link->to_address() > link->from_command()->address() && marker_command->address() > link->from_command()->next_address() && marker_command->address() < link->to_address()) {
						command = GetCommandByAddress(link->to_address());
						if (command && std::find(entry_command_list.begin(), entry_command_list.end(), command) == entry_command_list.end())
							entry_command_list.push_back(command);
					}
				}
			}
		}

		Sort();
		for (i = 0; i < entry_command_list.size(); i++) {
			ICommand *entry_command = entry_command_list[i];

			size_t n = IndexOf(entry_command);
			if (n > 0) {
				IntelCommand *command = item(n - 1);
				if (!command->is_end())
					command->include_option(roBreaked);
			}
			for (j = n; j < count(); j++) {
				IntelCommand *command = item(j);

				if (std::find(exclude_command_list.begin(), exclude_command_list.end(), command) != exclude_command_list.end())
					break;

				exclude_command_list.push_back(command);

				for (k = 0; k < link_list()->count(); k++) {
					CommandLink *link = link_list()->item(k);
					if (link->parent_command() == command && std::find(entry_command_list.begin(), entry_command_list.end(), link->from_command()) == entry_command_list.end())
						entry_command_list.push_back(link->from_command());
				}

				CommandLink *link = command->link();
				if (link && link->to_address()) {
					IntelCommand *link_command = GetCommandByAddress(link->to_address());
					if (link_command && std::find(entry_command_list.begin(), entry_command_list.end(), link_command) == entry_command_list.end())
						entry_command_list.push_back(link_command);
				}

				if (command->is_end())
					break;
			}
		}
		
		for (i = 0; i < exclude_command_list.size(); i++) {
			ICommand *command = exclude_command_list[i];

			for (j = 0; j < range_list()->count(); j++) {
				AddressRange *range = range_list()->item(j);
				if (range->begin_entry() == command)
					range->set_begin_entry(NULL);
				if (range->end_entry() == command)
					range->set_end_entry(NULL);
				if (range->size_entry() == command)
					range->set_size_entry(NULL);
			}
			for (j = 0; j < function_info_list()->count(); j++) {
				FunctionInfo *info = function_info_list()->item(j);
				if (info->entry() == command)
					info->set_entry(NULL);
				for (k = 0; k < info->count(); k++) {
					AddressRange *range = info->item(k);
					if (range->begin_entry() == command)
						range->set_begin_entry(NULL);
					if (range->end_entry() == command)
						range->set_end_entry(NULL);
					if (range->size_entry() == command)
						range->set_size_entry(NULL);
				}
			}

			if (command->link())
				delete command->link();
			delete command;
		}
	}
}

uint64_t IntelFunction::GetNextAddress(IArchitecture &file)
{
	uint64_t res = BaseFunction::GetNextAddress(file);
	if (res)
		return res;

	size_t c = link_list()->count();
	for (size_t i = 0; i < c; i++) {
		CommandLink *link = link_list()->item(i);
		switch (link->type()) {
		case ltJmp:
			if (type() == otMarker && !link->parsed() && link->to_address() == address() + 0x12) {
				link->set_parsed(true);
				return link->to_address();
			}
			break;
		case ltDualSEHBlock:
			if (!link->next_command()) {
				IntelCommand *command = GetCommandByAddress(link->to_address());
				if (command) {
					IntelCommand *next_command = GetCommandByAddress(command->next_address());
					if (next_command)
						link->set_next_command(next_command);
					else
						return command->next_address();
				}
			}
			break;
		case ltExtSEHHandler:
			if (!link->next_command()) {
				size_t k = IndexOf(GetCommandByAddress(link->to_address()));
				if (k == NOT_ID)
					continue;

				std::set<size_t> stack;
				stack.insert(k);
				while (!stack.empty()) {
					k = *stack.begin();

					for (size_t j = k; j < count(); j++) {
						std::set<size_t>::const_iterator it = stack.find(j);
						if (it != stack.end())
							stack.erase(it);

						IntelCommand *command = item(j);
						if (command->options() & roBreaked)
							break;

						if (command->type() == cmJmpWithFlag && command->operand(0).type == otValue) {
							IntelCommand *to_command = GetCommandByAddress(command->operand(0).value);
							if (to_command) {
								k = IndexOf(to_command);
								if (k != NOT_ID && k > j)
									stack.insert(k);
							}
						}

						if (command->type() != cmRet && command->type() != cmJmp)
							continue;

						if (command->type() == cmJmp && command->operand(0).type == otValue) {
							IntelCommand *tmp = GetCommandByAddress(command->operand(0).value - 8);
							if (tmp && tmp->type() == cmPush && tmp->operand(0).type == otValue) {
								IntelCommand *next = GetCommandByAddress(tmp->next_address());
								if (next && next->type() == cmAdd && next->operand(0).type == (otMemory | otBaseRegistr) && next->operand(0).base_registr == regESP && next->operand(1).type == otRegistr && next->operand(1).registr == regEBX) {
									link->set_next_command(tmp);
									if (!tmp->link())
										tmp->AddLink(0, ltSEHBlock, tmp->operand(0).value);
								}
							}

							IntelCommand *to_command = GetCommandByAddress(command->operand(0).value);
							if (to_command) {
								k = IndexOf(to_command);
								if (k != NOT_ID && k > j) {
									j = k - 1;
									continue;
								}
							}
						}

						for (size_t n = j; n > k; n--) {
							command = item(n - 1);
							if (command->operand(0).type == otRegistr && command->operand(0).registr == regEAX && command->operand(0).size == cpu_address_size() &&
								((command->type() == cmLea && command->operand(1).type == (otMemory | otValue)) || (command->type() == cmMov && command->operand(1).type == otValue))) {
								link->set_next_command(command);
								if (!command->link())
									command->AddLink(1, ltSEHBlock, command->operand(1).value);
								break;
							}
						}
						break;
					}
				}
			}
		}
	}
	if (link_list()->count() > c)
		return GetNextAddress(file);

	return 0;
}

uint64_t IntelFunction::GetRegistrValue(uint8_t reg, size_t end_index)
{
	std::map<uint64_t, IntelCommand *> address_list;
	IntelCommand *mov_command = NULL;
	IntelCommandInfoList command_info_list(cpu_address_size());
	for (size_t i = 0; i <= end_index; i++) {
		IntelCommand *command = item(i);
		if (command->is_data())
			continue;

		std::map<uint64_t, IntelCommand *>::iterator it = address_list.find(command->address());
		if (it != address_list.end()) {
			if (mov_command && it->second) {
				if (mov_command != it->second && !mov_command->is_equal(*it->second))
					mov_command = NULL;
			} else {
				mov_command = it->second;
			}
		}

		if (i == end_index)
			break;

		CommandLink *link = command->link();
		if (link && link->type() != ltOffset && link->to_address()) {
			std::map<uint64_t, IntelCommand *>::iterator it = address_list.find(link->to_address());
			if (it != address_list.end()) {
				if (it->second != mov_command)
					it->second = NULL;
			} else {
				address_list[link->to_address()] = mov_command;
			}
		}

		if (command->is_end() || (command->options() & roBreaked) != 0)
			mov_command = NULL;
		else if (command->GetCommandInfo(command_info_list) && command_info_list.GetInfo(atWrite, otRegistr, reg))
			mov_command = command;
	}

	return (mov_command && mov_command->type() == cmLea && mov_command->operand(1).type == (otValue | otMemory)) ? mov_command->operand(1).value : (uint64_t)-1;
}

uint64_t IntelFunction::GetRegistrMaxValue(uint8_t reg, size_t end_index, IArchitecture &file)
{
	IntelCommandInfoList command_info_list(cpu_address_size());
	IntelCommand *jmp_command = NULL;
	IntelOperand find_operand = IntelOperand(otRegistr, cpu_address_size(), reg);
	for (size_t i = end_index; i > 0; i--) {
		IntelCommand *command = item(i - 1);
		if ((command->options() & roBreaked) || command->is_end()) {
			CommandLink *link = link_list()->GetLinkByToAddress(ltJmpWithFlag, item(i)->address());
			if (!link)
				link = link_list()->GetLinkByToAddress(ltJmp, item(i)->address());
			if (link) {
				command = reinterpret_cast<IntelCommand *>(link->from_command());
				if (link->type() == ltJmpWithFlag && command->flags() == (fl_C | fl_Z) && (command->options() & roInverseFlag) == 0)
					jmp_command = command;
				size_t index = IndexOf(command);
				if (index != NOT_ID) {
					i = index + 1;
					continue;
				}
			}
			break;
		}
		switch (command->type()) {
		case cmJmpWithFlag:
			if (command->flags() == (fl_C | fl_Z) && (command->options() & roInverseFlag))
				jmp_command = command;
			break;
		case cmCmp:
			if (command->operand(0) == find_operand) {
				if (command->operand(1).type == otValue && jmp_command)
					return command->operand(1).value;
			}
			break;
		case cmMovsx: case cmMovsxd:
			if (command->operand(0) == find_operand)
				find_operand = command->operand(1);
			break;
		case cmMov:
		case cmMovzx:
			if (command->operand(0) == find_operand) {
				find_operand = command->operand(1);
				if ((command->operand(1).type & otMemory) && command->operand(1).size == osByte) {
					uint64_t max_count = GetRegistrMaxValue(command->operand(1).registr, i - 1, file);
					if (max_count != (uint64_t)-1) {
						uint64_t base_address = 0;
						if (command->operand(1).type & otBaseRegistr) {
							if (cpu_address_size() == osQWord) {
								base_address = GetRegistrValue(command->operand(1).base_registr, i);
							}
							else {
								base_address = file.compiler_function_list()->GetRegistrValue(command->address(), IntelOperand(otRegistr, cpu_address_size(), command->operand(1).base_registr).encode());
							}
							if (base_address == (uint64_t)-1)
								break;
						}
						if (!file.AddressSeek(base_address + command->operand(1).value))
							break;
						uint8_t res = 0;
						for (uint64_t j = 0; j <= max_count; j++) {
							uint8_t b = file.ReadByte();
							if (b > res)
								res = b;
						}
						return res;
					}
				}
			}
			break;
		case cmCall:
			if (command->operand(0).type != otValue || command->operand(0).value != command->next_address())
				command = NULL;
			break;
		case cmAnd:
			if (command->operand(0).type == otRegistr && command->operand(0).registr == find_operand.registr && static_cast<uint32_t>(command->operand(1).value) == 0xffffffff)
				break;
			// fall-through
		default:
			if (!command->GetCommandInfo(command_info_list))
				command = NULL;
			else if ((find_operand.type & otRegistr) && command_info_list.GetInfo(atWrite, otRegistr, find_operand.registr))
				command = NULL;
			else if ((find_operand.type & otBaseRegistr) && command_info_list.GetInfo(atWrite, otRegistr, find_operand.base_registr))
				command = NULL;
			break;
		}
		if (!command)
			break;
	}
	return (uint64_t)-1;
}

CompilerFunction *IntelFunction::ParseCompilerFunction(IArchitecture &file, uint64_t address)
{
	CompilerFunction *compiler_function = file.compiler_function_list()->GetFunctionByAddress(address);
	if (!compiler_function && (file.segment_list()->GetMemoryTypeByAddress(address) & mtExecutable)) {
		IFunction *tmp_parent = this;
		size_t stack_depth = 0;
		bool in_parent_list = false;
		while (tmp_parent) {
			if (tmp_parent->GetCommandByAddress(address)) {
				in_parent_list = true;
				break;
			}
			tmp_parent = tmp_parent->parent();
			if ((stack_depth++) > 1000)
				return NULL;
		}
		if (in_parent_list)
			return NULL;

		IntelFunction func(NULL, cpu_address_size(), this);
		func.ReadFromFile(file, address);
		IntelCommand *entry = func.GetCommandByAddress(address);
		if (entry) {
			std::set<size_t> entry_stack;
			std::set<IntelCommand *> end_command_list;
			std::set<IntelCommand *> parsed_command_list;

			entry_stack.insert(func.IndexOf(entry));
			while (!entry_stack.empty()) {
				for (size_t i = *entry_stack.begin(); i < func.count(); i++) {
					IntelCommand *command = func.item(i);
					std::set<size_t>::const_iterator it = entry_stack.find(i);
					if (it != entry_stack.end())
						entry_stack.erase(it);

					if (parsed_command_list.find(command) != parsed_command_list.end())
						break;
					parsed_command_list.insert(command);

					switch (command->type()) {
					case cmRet:
					case cmIret:
						if (cpu_address_size() == osQWord && i > 0) {
							IntelCommand *prev = func.item(i - 1);
							if (prev->type() == cmMov && prev->operand(0).type == otRegistr && prev->operand(0).registr == regESP) {
								// mov rsp, xxxx
								command->include_option(roBreaked);
							}
						}
						end_command_list.insert(command);
						break;
					case cmJmpWithFlag:
						{
							IntelCommand *link_command = func.GetCommandByAddress(command->operand(0).value);
							if (link_command)
								entry_stack.insert(func.IndexOf(link_command));
						}
						break;
					case cmJmp:
						{
							bool is_end = true;
							compiler_function = file.compiler_function_list()->GetFunctionByAddress(command->address());
							if (compiler_function && (compiler_function->options() & coNoReturn) != 0)
								command->include_option(roBreaked);

							if (command->operand(0).type == (otValue | otMemory)) {
								if (IRelocation *reloc = file.relocation_list() ? file.relocation_list()->GetRelocationByAddress(command->operand(0).value) : NULL) {
									if (reloc->symbol()) {
										compiler_function = func.ParseCompilerFunction(file, reloc->symbol()->address());
										if (compiler_function && (compiler_function->options() & coNoReturn) != 0)
											command->include_option(roBreaked);
									}
								}
							}
							else if (command->operand(0).type == otValue) {
								IntelCommand *link_command = func.GetCommandByAddress(command->operand(0).value);
								if (link_command) {
									entry_stack.insert(func.IndexOf(link_command));
									is_end = false;
								}
								else {
									compiler_function = func.ParseCompilerFunction(file, command->operand(0).value);
									if (compiler_function && (compiler_function->options() & coNoReturn) != 0)
										command->include_option(roBreaked);
								}
							}
							else if (command->link() && (command->link()->type() == ltSwitch || command->link()->type() == ltOffset)) {
								ICommand *parent_command;
								if (command->link()->type() == ltSwitch)
									parent_command = command;
								else {
									parent_command = func.GetCommandByAddress(command->link()->to_address());
									parent_command = (parent_command && parent_command->link()) ? parent_command->link()->parent_command() : NULL;
								}

								if (parent_command) {
									is_end = false;
									for (size_t j = 0; j < func.link_list()->count(); j++) {
										CommandLink *link = func.link_list()->item(j);
										if (link->parent_command() == parent_command) {
											IntelCommand *link_command = func.GetCommandByAddress(link->to_address());
											if (link_command)
												entry_stack.insert(func.IndexOf(link_command));
										}
									}
								}
							}

							if (is_end)
								end_command_list.insert(command);
						}
						break;
					}

					if (command->options() & roBreaked) {
						end_command_list.insert(command);
						break;
					}

					if (command->is_end())
						break;
				}
			}

			compiler_function = file.compiler_function_list()->Add(cfNone, address);
			if (!end_command_list.empty()) {
				size_t no_return_count = 0;
				for (std::set<IntelCommand *>::const_iterator it = end_command_list.begin(); it != end_command_list.end(); it++) {
					IntelCommand *tmp_command = *it;
					if (tmp_command->options() & roBreaked)
						no_return_count++;
				}

				if (no_return_count == end_command_list.size())
					compiler_function->include_option(coNoReturn);
			}
		}
	}

	return compiler_function;
}

IntelCommand *IntelFunction::ParseCommand(IArchitecture &file, uint64_t address, bool dump_mode)
{
	CommandLink *command_link; 
	IntelCommand *command, *prev;
	size_t i, c;
	CommandLinkList *links;
	IImportFunction *import_function;
	CompilerFunction *compiler_function;
	uint64_t base_address;

	if (dump_mode) {
		command = Add(address);
		if (!file.AddressSeek(address))
			command->InitUnknown();
		else if ((file.selected_segment()->memory_type() & mtExecutable) == 0)
			command->ReadValueFromFile(file, osByte);
		else {
			command->ReadFromFile(file);
			switch (command->type()) {
			case cmJmp:
			case cmCall:
			case cmJmpWithFlag: case cmJCXZ: case cmLoop: case cmLoope: case cmLoopne:
				if ((command->options() & roFar) == 0 && command->operand(0).type == otValue)
					command->AddLink(0, ltNone, command->operand(0).value);
				break;
			}
		}
		return command;
	} else {
		if (!file.AddressSeek(address))
			return NULL;
	}

	command = Add(address);
	command->ReadFromFile(file);

	links = link_list();
	switch (command->type()) {
		case cmDB:
			command->include_option(roInvalidOpcode);
			break;

		case cmAdd:
			if (command->dump_size() == 2 && command->dump(0) == 0 && command->dump(1) == 0) {
				delete command;
				command = NULL;
			}
			break;

		case cmCall:
			if ((command->options() & roFar) == 0) {
				if (command->operand(0).type == otValue && !command->operand(0).relocation)
					command->AddLink(0, ltCall, command->operand(0).value);
				else
					command->AddLink(-1, ltCall);

				if (command->operand(0).type == (otValue | otMemory)) {
					// check import
					import_function = file.import_list()->GetFunctionByAddress(command->operand(0).value);
					if (import_function != NULL && (import_function->options() & ioNoReturn) != 0)
						command->include_option(roBreaked);
				} else if (command->operand(0).type == otValue) {
					// check compiler function
					compiler_function = ParseCompilerFunction(file, command->operand(0).value);
					if (compiler_function) {
						if (compiler_function->options() & coNoReturn)
							command->include_option(roBreaked);

						switch (compiler_function->type()) {
						case cfInitBCBSEH:
							if (compiler_function->value(0)) {
								CompilerFunction *func = file.compiler_function_list()->GetFunctionByLowerAddress(address);
								if (func && func->type() == cfBCBSEH) 
									ParseBCBSEH(file, func->value(0), command->next_address(), static_cast<uint8_t>(func->value(1)));
							}
							break;
						case cfSEH4Prolog:
							if (count() > 1) {
								prev = item(count() - 2);
								if (prev->type() == cmPush && prev->operand(0).type == otValue) {
									if (ParseSEH4(file, prev->operand(0).value))
										prev->AddLink(0, ltOffset, prev->operand(0).value);
								}
							}
						}
					}
				}
			}
			break;

		case cmJmp:
			if ((command->options() & roFar) == 0) {
				if (command->operand(0).type == otValue) { // jmp xxxx
					if (!command->operand(0).relocation)
						command->AddLink(0, ltJmp, command->operand(0).value);

					if (cpu_address_size() == osDWord) {
						if (count() > 1) {
							i = count() - 2;
							prev = item(i);
							if (prev->type() == cmPush && prev->operand(0).type == otValue) {
								command_link = links->GetLinkByToAddress(ltVBMemSEHBlock, command->operand(0).value);
								if (command_link || (file.AddressSeek(command->operand(0).value) && file.ReadByte() == 0xc3))
									prev->AddLink(0, ltFinallyBlock, prev->operand(0).value);
							}
						}

						command_link = links->GetLinkByToAddress(ltSEHBlock, command->address());
						if (command_link) {
							i = count();
							if (ParseFilterSEH(file, command->next_address())) {
								command_link->set_type(ltFilterSEHBlock);
								command_link->set_parent_command(item(i));
							} else {
								command_link->set_type(ltDualSEHBlock);
							}
						}
					}
				} else if (command->operand(0).type == (otValue | otMemory | otRegistr) && command->operand(0).size == cpu_address_size() && command->operand(0).scale_registr == (cpu_address_size() == osDWord ? 2 : 3)) { // jmp dword ptr [reg*4 + xxxx]
					if (ParseSwitch(file, command->operand(0).value, command->operand(0).size, 0, command, 0, static_cast<size_t>(GetRegistrMaxValue(command->operand(0).registr, IndexOf(command), file))))
						command->AddLink(0, ltSwitch, command->operand(0).value);
					else if (count() == 0)
						return ParseCommand(file, this->address(), dump_mode);
				} else if (command->operand(0).type == otRegistr && count() > 1) { // jmp reg
					prev = NULL;
					IntelCommandInfoList command_info(cpu_address_size());
					if (count() > 2) {
						for (i = count() - 2; i > 0; i--) {
							IntelCommand *tmp = item(i);
							if (!tmp->GetCommandInfo(command_info) || command_info.GetInfo(atWrite, otBaseRegistr, regEIP))
								break;
							if (command_info.GetInfo(atWrite, otRegistr, command->operand(0).registr)) {
								prev = tmp;
								break;
							}
						}
					}
					if (prev) {
						if ((prev->type() == cmAdd || prev->type() == cmSub)
							&& prev->operand(0).type == otRegistr
							&& prev->operand(0).size == cpu_address_size()
							&& prev->operand(0).registr == command->operand(0).registr) {
							uint8_t base_registr;
							base_address = 0;
							if (prev->operand(1).type == otRegistr) {
								base_registr = prev->operand(1).registr;
								prev = NULL;
								for (c = i; c > 0; c--) {
									IntelCommand *tmp = item(c - 1);
									if (tmp->type() == cmMov && tmp->operand(0).type == otRegistr && tmp->operand(1).type == otRegistr && tmp->operand(0).registr == base_registr)
										base_registr = tmp->operand(1).registr;
									else if (tmp->type() == cmLea && tmp->operand(0).type == otRegistr && tmp->operand(1).type == (otMemory | otValue) && tmp->operand(0).registr == base_registr)
										base_address = tmp->operand(1).value;
									else if ((tmp->type() == cmMov || tmp->type() == cmMovsxd)
										&& tmp->operand(0).type == otRegistr
										&& tmp->operand(0).registr == command->operand(0).registr) {
										i = c - 1;
										prev = tmp;
										break;
									}
									else {
										if (!tmp->GetCommandInfo(command_info) || command_info.GetInfo(atWrite, otRegistr, command->operand(0).registr))
											break;
									}
								}
							}
							else {
								base_registr = prev->operand(0).registr;
							}
							if (prev) {
								if ((prev->operand(1).type & (otMemory | otBaseRegistr | otRegistr)) == (otMemory | otBaseRegistr | otRegistr)
									&& prev->operand(1).scale_registr == 2
									&& prev->operand(1).size == osDWord) { // add/mov/movsx reg, [reg1 + reg2*4 + xxxx]
									if (!base_address) {
										if (cpu_address_size() == osQWord) {
											base_address = GetRegistrValue(prev->operand(1).base_registr, i);
										}
										else {
											IntelOperand base_operand = IntelOperand(otRegistr, cpu_address_size(), base_registr);
											if (i > 0) {
												IntelCommand *tmp = item(i - 1);
												if (tmp->type() == cmMov
													&& tmp->operand(0).type == otRegistr
													&& tmp->operand(0).registr == base_registr) {
													base_operand = tmp->operand(1);
												}
											}
											base_address = file.compiler_function_list()->GetRegistrValue(command->address(), base_operand.encode());
										}
									}
									if (base_address != (uint64_t)-1) {
										size_t mode;
										switch (prev->type()) {
										case cmMovsxd:
											mode = 1;
											break;
										case cmSub:
											mode = 2;
											break;
										default:
											mode = 0;
											break;
										}
										if (ParseSwitch(file, base_address + prev->operand(1).value, osDWord, base_address, command, mode, static_cast<size_t>(GetRegistrMaxValue(prev->operand(1).registr, IndexOf(prev), file)))) {
											command_link = prev->AddLink(1, ltSwitch, base_address + prev->operand(1).value);
											command_link->set_sub_value(base_address);
											command->AddLink(-1, ltOffset, command_link->to_address());
										}
										else if (count() == 0)
											return ParseCommand(file, this->address(), dump_mode);
									}
								}
								else if (prev->type() == cmAdd
									&& prev->operand(1).type == (otMemory | otRegistr | otValue)
									&& prev->operand(1).scale_registr == 2
									&& prev->operand(1).size == osDWord
									&& prev->operand(0).registr == base_registr) { // add reg, [reg1*4 + xxxx]
									if (cpu_address_size() == osQWord) {
										base_address = GetRegistrValue(base_registr, i);
									}
									else {
										IntelOperand base_operand = IntelOperand(otRegistr, cpu_address_size(), base_registr);
										if (i > 0) {
											IntelCommand *tmp = item(i - 1);
											if (tmp->type() == cmMov
												&& tmp->operand(0).type == otRegistr
												&& tmp->operand(0).registr == base_registr) {
												base_operand = tmp->operand(1);
											}
										}
										base_address = file.compiler_function_list()->GetRegistrValue(command->address(), base_operand.encode());
									}
									if (base_address != (uint64_t)-1) {
										if (ParseSwitch(file, prev->operand(1).value, osDWord, base_address, command, 0, static_cast<size_t>(GetRegistrMaxValue(prev->operand(1).registr, IndexOf(prev), file)))) {
											command_link = prev->AddLink(1, ltSwitch, prev->operand(1).value);
											command->AddLink(-1, ltOffset, command_link->to_address());
										}
										else if (count() == 0)
											return ParseCommand(file, this->address(), dump_mode);
									}
								}
								else if (prev->type() == cmMov
									&& prev->operand(1).type == (otMemory | otRegistr | otValue)
									&& prev->operand(1).scale_registr == 2
									&& prev->operand(1).size == osDWord
									&& prev->operand(0).registr == command->operand(0).registr) { // mov reg, [reg1*4 + xxxx]
									if (cpu_address_size() == osQWord) {
										base_address = GetRegistrValue(base_registr, i + 1);
									}
									else {
										IntelOperand base_operand = IntelOperand(otRegistr, cpu_address_size(), base_registr);
										IntelCommand *tmp = item(i + 1);
										if (tmp->type() == cmMov
											&& tmp->operand(0).type == otRegistr
											&& tmp->operand(0).registr == base_registr) {
											base_operand = tmp->operand(1);
										}
										base_address = file.compiler_function_list()->GetRegistrValue(command->address(), base_operand.encode());
									}
									if (base_address != (uint64_t)-1) {
										if (ParseSwitch(file, prev->operand(1).value, osDWord, base_address, command, 0, static_cast<size_t>(GetRegistrMaxValue(prev->operand(1).registr, IndexOf(prev), file)))) {
											command_link = prev->AddLink(1, ltSwitch, prev->operand(1).value);
											command->AddLink(-1, ltOffset, command_link->to_address());
										}
										else if (count() == 0)
											return ParseCommand(file, this->address(), dump_mode);
									}
								}
							}
						}
						else if (prev->type() == cmMov && prev->operand(1).type == (otValue | otMemory | otRegistr) && prev->operand(1).size == cpu_address_size() && prev->operand(1).scale_registr == (cpu_address_size() == osDWord ? 2 : 3)) { // mov reg1, dword ptr [reg*4 + xxxx]
							if (ParseSwitch(file, prev->operand(1).value, prev->operand(1).size, 0, command, 0, static_cast<size_t>(GetRegistrMaxValue(prev->operand(1).registr, IndexOf(prev), file)))) {
								command_link = prev->AddLink(1, ltSwitch, prev->operand(1).value);
								command->AddLink(-1, ltOffset, command_link->to_address());
							}
							else if (count() == 0)
								return ParseCommand(file, this->address(), dump_mode);
						}
					}
				}
			}
			break;

		case cmPush:
			if (cpu_address_size() == osDWord) {
				if (command->operand(0).type == otValue) { // push xxxx
					if (count() > 1) {
						i = count() - 2;
						prev = item(i);
						if (prev->type() == cmMov 
							&& prev->operand(0).type == (otMemory | otRegistr) 
							&& prev->base_segment() == segFS
							&& prev->operand(1).type == otRegistr 
							&& prev->operand(1).registr != regESP) // mov fs:[reg], reg1
								command->AddLink(0, ltFinallyBlock, command->operand(0).value);
					}
				} else if ((command->operand(0).type & otMemory) != 0 && command->base_segment() == segFS) { // push fs:[xxxx]
					if (count() >= 2) {
						i = count() - 2;
						prev = item(i);
						if (prev->type() == cmPush && prev->operand(0).type == otValue) // push xxxx
							prev->AddLink(0, ltSEHBlock, prev->operand(0).value);
					}
				}
			}
			break;

		case cmMov:
			if (cpu_address_size() == osDWord) {
				if (command->base_segment() == segFS) {
					if (command->operand(0).type == otRegistr 
						&& command->operand(1).type == (otMemory | otValue)
						&& command->operand(1).value == 0) { // mov reg, fs:[00000000]

						uint64_t mem_offset = 0;
						uint8_t mem_registr = 0;
						{
							IntelCommand tmp(NULL, cpu_address_size());
							uint64_t pos = file.Tell();
							for (i = 0; i < 10; i++) {
								tmp.ReadFromFile(file);
								if (tmp.type() == cmPush
									|| tmp.type() == cmDB
									|| tmp.type() == cmJmp
									|| tmp.type() == cmJmpWithFlag
									|| tmp.type() == cmRet
									|| tmp.type() == cmIret
									|| tmp.type() == cmCall)
									break;
								if (tmp.type() == cmMov) {
									if (tmp.operand(1).type == otRegistr && tmp.operand(1).registr == command->operand(0).registr && tmp.operand(0).type == (otMemory | otRegistr | otValue)) {
										mem_offset = tmp.operand(0).value;
										mem_registr = tmp.operand(0).registr;
									}
									break;
								}
							}
							file.Seek(pos);
						}

						c = 0;
						for (i = count(); i > 0; i--) {
							prev = item(i - 1);
							if (prev->type() == cmJmp 
								|| prev->type() == cmJmpWithFlag 
								|| prev->type() == cmRet 
								|| prev->type() == cmIret 
								|| prev->type() == cmCall)
								break;

							if (prev->type() == cmPush ||
								(mem_offset && prev->type() == cmMov && prev->operand(0).type == (otMemory | otRegistr | otValue) && prev->operand(0).value == mem_offset + 4 && prev->operand(0).registr == mem_registr && prev->operand(1).type == otValue)) {
								c++;
								if (mem_offset)
									mem_offset += 4;
								size_t k = (prev->type() == cmPush) ? 0 : 1;
								if (c == 1) {
									if (ParseNewSEH(file, prev->operand(k).value)) {
										prev->AddLink((int)k, ltOffset, prev->operand(k).value);
										break;
									}
								} else if (c == 2) {
									uint64_t version = 0;
									if (i > 1) {
										IntelCommand *tmp = item(i - 2);
										if (tmp->type() == cmPush && tmp->operand(0).type == otValue)
											version = tmp->operand(0).value;
									}

									if (version == (uint64_t)-2 && ParseSEH4(file, prev->operand(k).value))
										prev->AddLink((int)k, ltOffset, prev->operand(k).value);
									else if (version == (uint64_t)-1 && ParseSEH3(file, prev->operand(k).value))
										prev->AddLink((int)k, ltOffset, prev->operand(k).value);
									break;
								}
							}
						}
					}
				} else if (command->operand(0).type == (otMemory | otRegistr | otValue) 
							&& command->operand(0).registr == regEBP 
							&& command->operand(0).size == osDWord
							&& command->operand(1).type == otValue) { // mov [ebp + xxxx], xxxx
					CompilerFunction *func =  file.compiler_function_list()->GetFunctionByAddress(address);
					if (func && func->type() == cfVB6SEH) {
						if (ParseVB6SEH(file, func->value(0)))
							command->AddLink(1, ltOffset, func->value(0));
					}
				}
			}
			break;

		case cmInt:
			if (command->operand(0).value == 3)
				command->include_option(roBreaked);
			else if (file.owner()->format_name() == "PE") {
				if (command->operand(0).value == 0x29) // __failfast
					command->include_option(roBreaked);
			}
			break;

		case cmHlt:
		case cmUd2:
			command->include_option(roBreaked);
			break;

		case cmJmpWithFlag: case cmJCXZ: case cmLoop: case cmLoope: case cmLoopne:
			command->AddLink(0, ltJmpWithFlag, command->operand(0).value);
			break;
	}

	return command;
}

IntelCommand *IntelFunction::ReadValidCommand(IArchitecture &file, uint64_t address)
{
	size_t i, f, d;
	IntelCommand *command;
	IFixupList *fixup_list; 
	ISectionList *segment_list; 
	const IFixup *fixup; 
	bool invalid_fixup;
	IntelOperand operand;

	command = ParseCommand(file, address, true);
	if (!command)
		return NULL;

	fixup_list = file.fixup_list();
	segment_list = file.segment_list();

	if (fixup_list->count() > 0) {
		// need to check fixups for all value operands
		d = 0;
		while (d < command->dump_size()) {
			fixup = fixup_list->GetFixupByNearAddress(address + d);
			if (fixup) {
				invalid_fixup = true;
				f = static_cast<size_t>(fixup->address() - address);
				for (i = 0; i < 3; i++) {
					operand = command->operand(i);
					if (operand.type & otValue) {
						if (command->type() == cmCall || command->type() == cmJmp || command->type() == cmJmpWithFlag) {
							if ((operand.type & otMemory) == 0)
								break;
						}
						if (f == operand.value_pos) {
							invalid_fixup = false;
							break;
						}
					}
				}
				if (invalid_fixup)
					return NULL;
				d += OperandSizeToValue(fixup->size());
			} else {
				d++;
			}
		}
	}

	/*
	for (i = 0; i < 3; i++) {
		operand = command->operand(i);
		if (operand.type == (otMemory | otValue)) {
			// check fixup
			if (fixup_list->count() > 0 && operand.fixup == NULL && !operand.is_large_value)
				return NULL;
			// check segment type
			if ((segment_list->GetMemoryTypeByAddress(operand.value) & mtReadable) == 0)
				return NULL;
		}
	}
	*/

	if (command->type() == cmCall || command->type() == cmJmp || command->type() == cmJmpWithFlag) {
		operand = command->operand(0);
		// check segment type for value operand
		if (operand.type == otValue && (segment_list->GetMemoryTypeByAddress(command->operand(0).value) & mtExecutable) == 0)
			return NULL;
	}

	if (cpu_address_size() == osQWord) {
		// calc REX preffixes count
		f = 0;
		for (i = 0; i < command->command_pos(); i++) {
			if ((command->dump(i) & 0xF0) == 0x40) {
				f++;
			} else {
				if (f)
					break;
			}
		}
		if (f > 1)
			return NULL;
	}

	return command;
}

uint64_t IntelFunction::ParseParam(IArchitecture &file, size_t index, uint64_t &param_reference)
{
	size_t i;
	IntelCommand *command;
	bool need_push_value;
	uint8_t registr;
	IntelOperand operand;
	IntelCommandInfoList command_info(cpu_address_size());

	CallingConvention calling_convention = file.calling_convention();
	bool use_stack = false;
	switch (calling_convention) {
	case ccMSx64:
		registr = regECX;
		break;
	case ccABIx64:
		registr = regEDI;
		break;
	default:
		registr = 0xFF;
		use_stack = true;
	}

	need_push_value = true;
	for (i = index; i > 0; i--) {
		command = item(i - 1);

		// unknown command
		if (!command->GetCommandInfo(command_info))
			return 0;

		// commands change EIP can no be found between API`s param and API`s call
		if (command_info.GetInfo(atWrite, otBaseRegistr, regEIP))
			return 0;

		param_reference = command->address();
		if (!use_stack) {
			if (command->type() == cmLea && command->operand(0).size == cpu_address_size() && command->operand(0).type == otRegistr && command->operand(0).registr == registr) {
				// lea reg, [xxxx]
				operand = command->operand(1);
				if (operand.type == (otMemory | otValue) && operand.is_large_value)
					return operand.value;
				return 0;
			} else if (command->type() == cmMov && (command->operand(0).size == cpu_address_size() || (command->operand(0).size == osDWord && cpu_address_size() == osQWord)) && command->operand(0).type == otRegistr && command->operand(0).registr == registr) {
				// mov reg, xxxx
				operand = command->operand(1);
				if (operand.type == otValue) {
					return operand.value;
				} else if (operand.type == otRegistr) {
					registr = operand.registr;
				} else {
					return 0;
				}
			} else if (command_info.GetInfo(atWrite, otRegistr, registr)) {
				return 0;
			}
	
		} else {
			if ((command->type() == cmPush && need_push_value) || // push xxxx
				(command->type() == cmMov && command->operand(0).size == cpu_address_size() && 
					// mov [esp], xxxx
					((command->operand(0).type == (otMemory | otBaseRegistr) && command->operand(0).base_registr == regESP && need_push_value) ||
					// mov reg, xxxx
					(command->operand(0).type == otRegistr && command->operand(0).registr == registr && !need_push_value))
					)) {
				operand = command->operand(command->type() == cmMov);
				if (operand.type == otValue) {
					return operand.value;
				} else if (operand.type == otRegistr) {
					need_push_value = false;
					registr = operand.registr;
				} else {
					return 0;
				}
			} else if (!need_push_value && command->type() == cmLea && command->operand(0).size == cpu_address_size() && command->operand(0).type == otRegistr && command->operand(0).registr == registr && command->operand(1).type == (otValue | otRegistr | otMemory)) {
				// lea reg, [reg + xxxx]
				IntelOperand base_operand = IntelOperand(otRegistr, cpu_address_size(), command->operand(1).registr);
				if (i > 1) {
					IntelCommand *tmp = item(i - 2);
					if (tmp->type() == cmMov
						&& tmp->operand(0).type == otRegistr 
						&& tmp->operand(0).registr == base_operand.registr) {
						base_operand = tmp->operand(1);
					}
				}
				uint64_t base_address = file.compiler_function_list()->GetRegistrValue(command->address(), base_operand.encode());
				if (base_address != (uint64_t)-1)
					return base_address + command->operand(1).value;
			} else if (!need_push_value && command_info.GetInfo(atWrite, otRegistr, registr)) {
				return 0;
			}
		}
	}

	return 0;
}

void IntelFunction::ReadMarkerCommands(IArchitecture &file, MarkerCommandList &command_list, uint64_t address, uint32_t options)
{
	uint64_t param_address, param_reference, call_start, call_end, tmp_address;
	IntelCommand *command;
	ICommand *link_command;
	uint8_t api_reg;
	std::vector<size_t> stack;
	size_t i, j, cur_index;
	bool need_parse_backward, first_call;

	command_list.clear();
	call_start = address;
	call_end = address + 1;

	if (options & moForward) {
		// forward searching
		if (count() == 0)
			return;

		command = item(0);
		if (command->operand(0).type != otRegistr)
			return;

		api_reg = command->operand(0).registr;
		ReadFromFile(file, address);

		command = GetCommandByAddress(address);
		if (!command)
			return;

		cur_index = IndexOf(command) + 1;
		need_parse_backward = false;
		first_call = true;
		IntelCommandInfoList command_info_list(cpu_address_size());
		while (cur_index < count()) {
			command = item(cur_index);
			bool is_end = command->is_end();
			if ((command->options() & roBreaked) == 0) {
				if (command->type() == cmCall && command->operand(0).type == otRegistr && command->operand(0).registr == api_reg) {
					// call reg
					if (options & moNeedParam) {
						param_address = ParseParam(file, cur_index, param_reference);
						if (!param_address && first_call) {
							need_parse_backward = true;
							call_start = command->address();
							call_end = command->next_address();
						} else {
							command_list.Add(command->address(), command->next_address(), param_reference, param_address);
						}
						first_call = false;
					} else {
						command_list.Add(command->address(), command->next_address(), 0, 0);
					}
				} else if ((command->type() == cmJmp || command->type() == cmJmpWithFlag || command->type() == cmLoop) && command->link()) {
					// add link to stack
					link_command = GetCommandByAddress(command->link()->to_address());
					if (link_command) {
						i = IndexOf(link_command);
						if (i != NOT_ID)
							stack.push_back(i);
					}
				} else if (command->GetCommandInfo(command_info_list)) {
					if (command_info_list.GetInfo(atWrite, otRegistr, api_reg)) {
						std::vector<IntelCommand *> exclude_command_list;
						exclude_command_list.push_back(command);
						for (i = 0; i < exclude_command_list.size(); i++) {
							for (j = IndexOf(exclude_command_list[i]); j < count(); j++) {
								command = item(j);

								if (std::find(exclude_command_list.begin(), exclude_command_list.end(), command) == exclude_command_list.end())
									exclude_command_list.push_back(command);

								for (size_t k = 0; k < link_list()->count(); k++) {
									CommandLink *link = link_list()->item(k);
									if (link->parent_command() == command && std::find(exclude_command_list.begin(), exclude_command_list.end(), link->from_command()) == exclude_command_list.end())
										exclude_command_list.push_back(reinterpret_cast<IntelCommand *>(link->from_command()));
								}

								CommandLink *link = command->link();
								if (link && link->to_address()) {
									IntelCommand *link_command = GetCommandByAddress(link->to_address());
									if (link_command && std::find(exclude_command_list.begin(), exclude_command_list.end(), link_command) == exclude_command_list.end())
										exclude_command_list.push_back(link_command);
								}

								if (command->is_end())
									break;
							}
						}
						for (i = 0; i < exclude_command_list.size(); i++) {
							exclude_command_list[i]->include_option(roBreaked);
						}
						is_end = true;
					}
				} else {
					is_end = true;
				}
			} else {
				is_end = true;
			}

			// the end of branch
			if (is_end) {
				// delete processed indexes
				for (i = stack.size(); i > 0; i--) {
					if (stack[i - 1] <= cur_index)
						stack.erase(stack.begin() + i - 1);
				}
				if (stack.empty())
					break;

				// calc minimum index from stack
				cur_index = stack[0];
				for (i = 0; i < stack.size(); i++) {
					if (cur_index > stack[i])
						cur_index = stack[i];
				}
			} else {
				cur_index++;
			}
		}

		if (!need_parse_backward)
			return;
	}

	if ((options & moNeedParam) == 0)
		return;

	// backward searching
	SignatureList param_signatures;
	if (cpu_address_size() == osDWord) {
		for (i = 0; i < file.compiler_function_list()->count(); i++) {
			if (file.compiler_function_list()->item(i)->type() == cfBaseRegistr) {
				param_signatures.Add("8B");    // mov reg, [reg + xxxx]
				break;
			}
		}
		param_signatures.Add("68");    // push xxxx
		param_signatures.Add("B?");    // mov reg, xxxx
		param_signatures.Add("8D8?");    // lea reg, [xxxx]
		param_signatures.Add("C70424");    // mov [esp], xxxx
	} else {
		param_signatures.Add("4?8D");    // lea reg, [xxxx]
		param_signatures.Add("B?");    // mov reg, xxxx
	}

	for (i = 0; i < param_signatures.count(); i++) {
		Signature *sign = param_signatures.item(i);
		for (j = 0x100; j > 0; j--) {
			if (!file.AddressSeek(address - j))
				continue;
			uint8_t b;
			file.Read(&b, sizeof(b));
			if (!sign->SearchByte(b))
				continue;
			
			clear();
			tmp_address = address - j - sign->size() + 1;
			while (tmp_address < address) {
				command = ReadValidCommand(file, tmp_address);
				// these commands can no be found between API`s param and API`s call
				if (command == NULL 
					|| command->type() == cmDB 
					|| command->type() == cmRet
					|| command->type() == cmIret
					|| command->type() == cmJmp
					|| command->type() == cmEnter) {
						tmp_address = 0;
						break;
				}
				tmp_address = command->next_address();
			}

			if (tmp_address != address)
				continue;

			size_t index = count();
			if (options & moSkipLastCall) {
				if (count() > 1) {
					command = item(count() - 1);
					if (command->type() == cmPush && command->operand(0).type == otRegistr && command->operand(0).registr == regEAX) {
						command = item(count() - 2);
						if (command->type() == cmCall)
							index -= 2;
					}
				}
			}

			param_address = ParseParam(file, index, param_reference);
			if (param_address && (file.segment_list()->GetMemoryTypeByAddress(param_address) & mtReadable)) {
				command_list.Add(call_start, call_end, param_reference, param_address);
				return;
			}
		}
	}
}

IntelCommand *IntelFunction::CreateCommand()
{
	return new IntelCommand(this, cpu_address_size());
}

void IntelFunction::CreateBlocks()
{
	CommandBlock *cur_block = NULL;
	for (size_t i = 0; i < count(); i++) {
		IntelCommand *command = item(i);
		if (command->block() || (command->options() & roNeedCompile) == 0) {
			cur_block = NULL;
			continue;
		}

		if ((!cur_block || (command->options() & roCreateNewBlock) || item(cur_block->end_index())->is_data() != command->is_data()))
			cur_block = AddBlock(i, true);

		cur_block->set_end_index(i);

		command->set_block(cur_block);
		if (command->type() == cmJmp || command->type() == cmRet || command->type() == cmIret)
			cur_block = NULL;
	}
}

bool IntelFunction::Init(const CompileContext &ctx)
{
	if (need_compile()) {
		ICommand *command;
		CommandLink *link;
		size_t i, j, k;
		std::vector<ICommand *> entry_command_list;
		std::vector<ICommand *> exclude_command_list;

		// exclude duplicates of exception handlers
		for (i = 0; i < link_list()->count(); i++) {
			link = link_list()->item(i);
			if (link->type() == ltExtSEHHandler || link->type() == ltMemSEHBlock) {
				command = GetCommandByAddress(link->to_address());
				if (command && std::find(entry_command_list.begin(), entry_command_list.end(), command) == entry_command_list.end()) {
					ICommand *tmp = ctx.file->function_list()->GetCommandByAddress(command->address(), true);
					if (tmp && tmp != command)
						entry_command_list.push_back(command);
				}
			}
		}

		for (i = 0; i < entry_command_list.size(); i++) {
			ICommand *entry_command = entry_command_list[i];
			if (!entry_command)
				continue;

			for (j = IndexOf(entry_command); j < count(); j++) {
				command = item(j);

				if (std::find(exclude_command_list.begin(), exclude_command_list.end(), command) != exclude_command_list.end())
					break;

				std::vector<ICommand *>::iterator it = std::find(entry_command_list.begin(), entry_command_list.end(), command);
				if (it != entry_command_list.end())
					*it = NULL;

				exclude_command_list.push_back(command);

				for (k = 0; k < link_list()->count(); k++) {
					link = link_list()->item(k);
					if (link->parent_command() == command && std::find(entry_command_list.begin(), entry_command_list.end(), link->from_command()) == entry_command_list.end())
						entry_command_list.push_back(link->from_command());
				}

				link = command->link();
				if (link && link->to_address()) {
					ICommand *link_command = GetCommandByAddress(link->to_address());
					if (link_command && std::find(entry_command_list.begin(), entry_command_list.end(), link_command) == entry_command_list.end())
						entry_command_list.push_back(link_command);
				}

				if (command->is_data() || command->is_end() || (command->options() & roBreaked) != 0)
					break;
			}
		}

		for (i = 1; i < count(); i++) {
			command = item(i - 1);
			if (!command->is_end() && std::find(exclude_command_list.begin(), exclude_command_list.end(), item(i)) != exclude_command_list.end())
				command->include_option(roBreaked);
		}

		for (i = 0; i < exclude_command_list.size(); i++) {
			command = exclude_command_list[i];
			if (command->link())
				delete command->link();
			delete command;
			if (entry() == command)
				set_entry(NULL);
		}

		for (i = 0; i < function_info_list()->count(); i++) {
			FunctionInfo *info = function_info_list()->item(i);
			if (!info->entry())
				continue;

			if (info->entry()->comment().value == "LPStart Encoding") {
				size_t c = IndexOf(info->entry());
				for (j = c + 1; j < count(); j++) {
					IntelCommand *command = item(j);
					if (!command->is_data() || (command->options() & roCreateNewBlock))
						break;

					if (command->comment().value == "TTable Offset") {
						command->CompileToNative();
						if (command->link())
							command->link()->set_sub_value(command->link()->sub_value() + command->dump_size() - command->original_dump_size());
					} else if (command->comment().value == "Call Site Encoding" && command->dump_size() == 1 && command->dump(0) == DW_EH_PE_uleb128) {
						uint8_t call_size_encoding = DW_EH_PE_udata4;
						command->set_dump(&call_size_encoding, sizeof(call_size_encoding));

						IntelCommand *call_site_entry = item(j + 1);
						size_t call_site_length = static_cast<uint32_t>(call_site_entry->operand(0).value);
						size_t new_call_site_length = 0;
						for (k = j + 2; k < count(); k++) {
							command = item(k);
							call_site_length -= command->dump_size();
							if (command->comment().value != "Action") {
								command->Init(cmDD, IntelOperand(command->operand(0)));
								command->CompileToNative();
							}
							new_call_site_length += command->dump_size();
							if (!call_site_length)
								break;
						}
						call_site_entry->set_operand_value(0, new_call_site_length);
						call_site_entry->CompileToNative();
						break;
					}
				}
			}
		}
	}

	return BaseFunction::Init(ctx);
}

bool IntelFunction::Prepare(const CompileContext &ctx)
{
	IArchitecture *file = from_runtime() ? ctx.runtime : ctx.file;
	if (type() == otString) {
		MapFunction *map_function = file->map_function_list()->GetFunctionByAddress(address());
		if (map_function) {
			for (size_t i = 0; i < count(); i++) {
				IntelCommand *command = item(i);
				command->exclude_option(roClearOriginalCode);

				if (command->address()) {
					uint64_t end_address = command->address() + command->original_dump_size();
					for (size_t j = 0; j < map_function->reference_list()->count(); j++) {
						Reference *reference = map_function->reference_list()->item(j);
						if (reference->tag() != 1)
							continue;

						if (command->address() <= reference->operand_address() && end_address > reference->operand_address())
							end_address = reference->operand_address();
					}
					if (end_address > command->address())
						ctx.manager->Add(command->address(), static_cast<size_t>(end_address - command->address()), file->segment_list()->GetMemoryTypeByAddress(command->address()));
				}
			}
		}
	} else if (address() && count() > 0) {
		for (size_t i = 0; i < count(); i++) {
			IntelCommand *command = item(i);
			if (command->options() & roInvalidOpcode) {
				ctx.file->Notify(mtError, command, string_format(language[lsCommandNotSupported].c_str(), command->text().c_str()));
				return false;
			}

			uint64_t next_address = command->address() + command->original_dump_size();
			if (command->type() == cmCall && (command->options() & roFar) == 0 && command->operand(0).type == otValue && command->operand(0).value != next_address) {
				CompilerFunction *compiler_function = file->compiler_function_list()->GetFunctionByAddress(next_address);
				if (compiler_function && compiler_function->type() == cfBaseRegistr) {
					delete command->link();
					IntelOperand operand;
					operand.decode(compiler_function->value(0));
					command->Init(cmLea, operand, IntelOperand(otMemory | otValue, operand.size, 0, next_address, (cpu_address_size() == osDWord) ? NEED_FIXUP : LARGE_VALUE));
					command->CompileToNative();
				}
			}
			if (!command->is_data() && ((command->options() & roBreaked) || is_breaked_address(next_address))) {
				// need add JMP after breaked commands
				IntelCommand *jmp_command = new IntelCommand(this, cpu_address_size(), cmJmp, IntelOperand(otValue, cpu_address_size(), 0, next_address));
				jmp_command->AddLink(0, ltJmp, next_address);
				jmp_command->set_address_range(function_info_list()->GetRangeByAddress(next_address));
				jmp_command->CompileToNative();
				InsertObject(i + 1, jmp_command);
			}
			if (is_breaked_address(next_address))
				break;
		}

		if (ctx.runtime && compilation_type() != ctMutation && address() && entry_type() != etNone) {
			size_t i, c;
			IntelCommand *command, *jmp_command, *loop_command, *antitrace_command;
			ICommand *loader_data_command = NULL;
			uint64_t loader_data_address = 0;

			IntelLoaderData *loader_data = reinterpret_cast<IntelFunctionList*>(ctx.file->function_list())->loader_data();
			if (loader_data) {
				loader_data_command = loader_data->entry();
			} else {
				loader_data_address = ctx.runtime->export_list()->GetAddressByType(atLoaderData);
				if (!loader_data_address)
					return false;
			}

			c = count();
			AddCommand(cmPushf);
			AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEAX));
			AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regECX));
			AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEBX));
			AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEDX));

			// anti trace
			antitrace_command = NULL;
			if (ctx.runtime && (ctx.options.flags & cpCheckDebugger)) {
				Data data;
				data.PushByte(0xf3); // rep
				data.PushByte(0xf3); // rep
				data.PushByte(0xf3); // rep
				data.PushByte(0xf3); // rep
				data.PushByte(0xf3); // rep
				data.PushByte(0x9c); // pushf
				command = AddCommand(data);
				command->AddLink(-1, ltNative);
				AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEAX));
				AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, fl_T));
				antitrace_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
				antitrace_command->set_flags(fl_Z);
				antitrace_command->include_option(roInverseFlag);
				antitrace_command->AddLink(0, ltJmpWithFlag);
			}

			// add CPU hash check
			AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, 1));
			command = AddCommand(cmCpuid);
			command->include_option(roNoNative);

			// Athlon bug
			AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regEAX));
			AddCommand(cmAnd, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otValue, osDWord, 0, 0xff0));
			AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otValue, osDWord, 0, 0xfe0));
			jmp_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
			jmp_command->set_flags(fl_Z);
			jmp_command->include_option(roInverseFlag);
			jmp_command->AddLink(0, ltJmpWithFlag);
			AddCommand(cmXor, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, 0x20));
			command = AddCommand(cmNop);
			jmp_command->link()->set_to_command(command);

			AddCommand(cmAnd, IntelOperand(otRegistr, osDWord, regEBX), IntelOperand(otValue, osDWord, 0, 0x00ffffff));
			AddCommand(cmAdd, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otRegistr, osDWord, regEBX));
			if (ctx.file->owner()->format_name() == "PE") {
				PEArchitecture *pe = reinterpret_cast<PEArchitecture *>(ctx.file);
				if (pe->image_type() != itDriver) {
					size_t osbuild_offset;
					if (cpu_address_size() == osDWord) {
						command = AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEBX), IntelOperand(otMemory | otValue, cpu_address_size(), 0, 0x30));
						command->set_base_segment(segFS);
						osbuild_offset = offsetof(PEB32, OSBuildNumber);
					} else {
						command = AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEBX), IntelOperand(otMemory | otValue, cpu_address_size(), 0, 0x60));
						command->set_base_segment(segGS);
						osbuild_offset = offsetof(PEB64, OSBuildNumber);
					}
					AddCommand(cmMovzx, IntelOperand(otRegistr, osDWord, regEBX), IntelOperand(otMemory | otRegistr | otValue, osWord, regEBX, osbuild_offset));
					AddCommand(cmShl, IntelOperand(otRegistr, osDWord, regEBX), IntelOperand(otValue, osWord, 0, 7));
					AddCommand(cmAdd, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otRegistr, osDWord, regEBX));
				}
			}
			command = AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEDX), IntelOperand(otMemory | otValue, cpu_address_size(), 0, loader_data_address, NEED_FIXUP));
			command->AddLink(1, ltOffset, loader_data_command);
			AddCommand(cmXor, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otRegistr, osDWord, regEDX));
			AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otRegistr | otValue, osDWord, regEDX, ctx.runtime_var_index[VAR_CPU_COUNT] * OperandSizeToValue(cpu_address_size())));
			AddCommand(cmXor, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otValue, osDWord, 0, ctx.runtime_var_salt[VAR_CPU_COUNT]));
			AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size(), regEDX), IntelOperand(otValue, cpu_address_size(), 0, ctx.runtime_var_index[VAR_CPU_HASH] * OperandSizeToValue(cpu_address_size())));

			command = AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regEBX), IntelOperand(otMemory | otRegistr, osDWord, regEDX, 0));
			AddCommand(cmXor, IntelOperand(otRegistr, osDWord, regEBX), IntelOperand(otValue, osDWord, 0, ctx.runtime_var_salt[VAR_CPU_HASH]));
			AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otRegistr, osDWord, regEBX));

			jmp_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
			jmp_command->set_flags(fl_Z);
			jmp_command->AddLink(0, ltJmpWithFlag);

			AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size(), regEDX), IntelOperand(otValue, cpu_address_size(), 0, OperandSizeToValue(cpu_address_size())));
			AddCommand(cmDec, IntelOperand(otRegistr, osDWord, regECX));
			loop_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
			loop_command->set_flags(fl_Z);
			loop_command->include_option(roInverseFlag);
			loop_command->AddLink(0, ltJmpWithFlag, command);

			command = AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEDX));
			if (antitrace_command)
				antitrace_command->link()->set_to_command(command);
			AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEBX));
			AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regECX));
			AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEAX));
			AddCommand(cmPopf);
			AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, 0xdeadc0de));
			AddCommand(cmPush, IntelOperand(otValue, cpu_address_size(), 0, 0));
			AddCommand(cmRet);

			command = AddCommand(cmNop);
			jmp_command->link()->set_to_command(command);
			AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEDX));
			AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEBX));
			AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regECX));
			AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEAX));
			AddCommand(cmPopf);
			command = AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size(), 0, address()));
			command->AddLink(0, ltJmp, address());

			for (i = c; i < count(); i++) {
				command = item(i);
				command->CompileToNative();
			}

			set_entry(item(c));
		}
	}

	return BaseFunction::Prepare(ctx);
}

bool IntelFunction::PrepareExtCommands(const CompileContext &ctx)
{
	size_t i;
	MemoryManager &manager = *ctx.manager;

	ExtCommandList *ext_list = ext_command_list();
	if (type() != otString) {
		if (address() && !entry()) {
			ctx.file->Notify(mtError, (count()) ? item(0) : NULL, "There are no data for compilation");
			return false;
		}
		if (entry() && entry_type() != etNone)
			ext_list->Add((entry_type() == etDefault) ? address() : 0, entry());
	}

	ext_list->Sort();
	for (i = ext_list->count(); i > 0; i--) {
		ExtCommand *ext_command = ext_list->item(i - 1);
		if (!ext_command->command() || is_breaked_address(ext_command->address()))
			continue;

		if (ext_command->address()) {
			if (!manager.Alloc(5, mtNone, ext_command->address())) {
				ctx.file->Notify(mtError, ext_command->command(), ext_command->address() == address() ? language[lsMinimalFunctionSize] : language[lsNotEnoughPlace]);
				return false;
			}
		}
		ext_command->command()->include_section_option(rtLinkedToExt);
	}

	return true;
}

void IntelFunction::GetFreeRegisters(size_t index, CommandInfoList &free_registr_list) const
{
	CommandInfoList used_registr_list;
	IntelCommandInfoList command_info_list(cpu_address_size());

	uint16_t free_flags = 0;
	bool free_flags_extracted = false;
	free_registr_list.clear();
	for (size_t i = index; i < count(); i++) {
		IntelCommand *command = item(i);

		bool is_end;
		if (command->GetCommandInfo(command_info_list)) {
			if (!free_flags_extracted) {
				if (command_info_list.change_flags()) {
					free_flags = command_info_list.change_flags();
					free_flags_extracted = true;
				}
				if (command_info_list.need_flags()) {
					free_flags &= ~command_info_list.need_flags();
					free_flags_extracted = true;
				}
			}

			for (size_t j = 0; j < command_info_list.count(); j++) {
				CommandInfo *command_info = command_info_list.item(j);
				if ((command_info->operand_type() == otRegistr || command_info->operand_type() == otHiPartRegistr) && command_info->value() != regESP && command_info->value() != regEIP) {
					OperandSize reg_size = command_info->size();
					if (command_info->operand_type() == otHiPartRegistr)
						reg_size = (reg_size == osByte) ? osWord : osQWord;
					uint8_t reg = command_info->value();

					if (command_info->type() == atRead) {
						used_registr_list.Add(atRead, reg, otRegistr, reg_size);
					} else if (!used_registr_list.GetInfo(atRead, otRegistr, reg) && (command_info->operand_type() != otHiPartRegistr || free_registr_list.GetInfo(atWrite, otRegistr, reg))) {
						free_registr_list.Add(atWrite, reg, otRegistr, reg_size);
					}
				}
			}
			is_end = command_info_list.GetInfo(atWrite, otBaseRegistr, regEIP) != NULL;
		} else {
			is_end = true;
		}

		if (is_end)
			break;
	}
	free_registr_list.set_change_flags(free_flags);
}

void IntelFunction::Mutate(const CompileContext &ctx, bool for_virtualization)
{
	#define osRandom (OperandSize)0x80
	#define osRandomStartWord (OperandSize)0x81

	enum {
		regFree = 0xf,
		flRandom = 0xff
	};

	size_t i, j, insert_count;
	IntelCommand *command, *new_command;

	std::vector<IntelCommand *> template_command_list;
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmMov, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmMov, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmMovsx, IntelOperand(otRegistr, osWord, regFree), IntelOperand(otRegistr, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmMovsx, IntelOperand(otRegistr, osDWord, regFree), IntelOperand(otRegistr, osWord)));
	if (cpu_address_size() == osQWord) {
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmMovsx, IntelOperand(otRegistr, osQWord, regFree), IntelOperand(otRegistr, osWord)));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmMovsxd, IntelOperand(otRegistr, osQWord, regFree), IntelOperand(otRegistr, osDWord)));
	}
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmMovzx, IntelOperand(otRegistr, osWord, regFree), IntelOperand(otRegistr, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmMovzx, IntelOperand(otRegistr, osDWord, regFree), IntelOperand(otRegistr, osWord)));
	if (cpu_address_size() == osQWord)
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmMovzx, IntelOperand(otRegistr, osQWord, regFree), IntelOperand(otRegistr, osWord)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmNot, IntelOperand(otRegistr, osRandom, regFree)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmNeg, IntelOperand(otRegistr, osRandom, regFree)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmInc, IntelOperand(otRegistr, osRandom, regFree)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmDec, IntelOperand(otRegistr, osRandom, regFree)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmCmp, IntelOperand(otRegistr, osRandom), IntelOperand(otRegistr, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmCmp, IntelOperand(otRegistr, osRandom), IntelOperand(otValue, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmTest, IntelOperand(otRegistr, osRandom), IntelOperand(otRegistr, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmTest, IntelOperand(otRegistr, osRandom), IntelOperand(otValue, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmAnd, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmAnd, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmOr, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmOr, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmXor, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmXor, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmAdd, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmAdd, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmAdc, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmAdc, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmSub, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmSub, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osRandom)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmShl, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osByte, regECX)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmShl, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmShr, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osByte, regECX)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmShr, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmSal, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osByte, regECX)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmSal, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmSar, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osByte, regECX)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmSar, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmRol, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osByte, regECX)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmRol, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmRor, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osByte, regECX)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmRor, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmShrd, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otRegistr, osRandomStartWord), IntelOperand(otRegistr, osByte, regECX)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmShrd, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otRegistr, osRandomStartWord), IntelOperand(otValue, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmShld, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otRegistr, osRandomStartWord), IntelOperand(otRegistr, osByte, regECX)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmShld, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otRegistr, osRandomStartWord), IntelOperand(otValue, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmBt, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otRegistr, osRandomStartWord)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmBt, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otValue, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmBtc, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otRegistr, osRandomStartWord)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmBtc, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otValue, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmBtr, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otRegistr, osRandomStartWord)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmBtr, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otValue, osByte)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmBts, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otRegistr, osRandomStartWord)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmBts, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otRegistr, osRandomStartWord)));

	command = new IntelCommand(this, cpu_address_size(), cmSetXX, IntelOperand(otRegistr, osByte, regFree));
	command->set_flags(flRandom);
	template_command_list.push_back(command);

	command = new IntelCommand(this, cpu_address_size(), cmCmov, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otRegistr, osRandomStartWord));
	command->set_flags(flRandom);
	template_command_list.push_back(command);

	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmClc));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmStc));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmCmc));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmCbw));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmCwde));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmCwd));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmCdq));
	if (cpu_address_size() == osQWord) {
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmCdqe));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmCqo));
	}
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmLahf));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmBswap, IntelOperand(otRegistr, osRandomStartWord, regFree)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmXchg, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osRandom, regFree)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmXadd, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osRandom, regFree)));
	template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmJmp, IntelOperand(otValue, cpu_address_size())));

	// FIXME
	/*
	command = new IntelCommand(this, cpu_address_size(), cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
	command->set_flags(flRandom);
	template_command_list.push_back(command);
	*/

	if (for_virtualization) {
		/*
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmJCXZ, IntelOperand(otValue, cpu_address_size())));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmLoop, IntelOperand(otValue, cpu_address_size())));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmLoope, IntelOperand(otValue, cpu_address_size())));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmLoopne, IntelOperand(otValue, cpu_address_size())));
		*/
	} else {
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmSbb, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osRandom)));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmSbb, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osRandom)));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmRcl, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osByte, regECX)));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmRcl, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osByte)));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmRcr, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otRegistr, osByte, regECX)));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmRcr, IntelOperand(otRegistr, osRandom, regFree), IntelOperand(otValue, osByte)));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmBsr, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otRegistr, osRandomStartWord)));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmBsf, IntelOperand(otRegistr, osRandomStartWord, regFree), IntelOperand(otRegistr, osRandomStartWord)));
		template_command_list.push_back(new IntelCommand(this, cpu_address_size(), cmRdtsc));
	}

	size_t link_count = link_list()->count();

	for (i = 0; i < count(); i++) {
		command = item(i);

		switch (command->type()) {
		case cmJmp:
		case cmJmpWithFlag:
			if (command->dump_size() < 5)
				command->CompileToNative();
			break;
		case cmJCXZ:
		case cmLoop:
		case cmLoope:
		case cmLoopne:
			if (!for_virtualization) {
				uint64_t next_address = command->next_address();
				uint64_t to_address = command->link()->to_address();
				AddressRange *address_range = command->address_range();

				new_command = new IntelCommand(this, cpu_address_size(), cmJmp, IntelOperand(otValue, cpu_address_size(), 0, 0));
				new_command->include_option(roNoProgress);
				new_command->AddLink(0, ltJmp, command);
				new_command->CompileToNative();
				new_command->set_address_range(address_range);
				InsertObject(i++, new_command);

				CommandBlock *block = AddBlock(i++, true);
				block->set_end_index(block->start_index() + 2);
				command->set_block(block);

				new_command = new IntelCommand(this, cpu_address_size(), cmJmp, IntelOperand(otValue, cpu_address_size(), 0, next_address));
				new_command->include_option(roNoProgress);
				new_command->AddLink(0, ltJmp, item(i));
				new_command->CompileToNative();
				new_command->set_address_range(address_range);
				new_command->set_block(block);
				InsertObject(i++, new_command);

				new_command = new IntelCommand(this, cpu_address_size(), cmJmp, IntelOperand(otValue, cpu_address_size(), 0, to_address));
				new_command->include_option(roNoProgress);
				new_command->AddLink(0, ltJmp, to_address);
				new_command->CompileToNative();
				new_command->set_address_range(address_range);
				new_command->set_block(block);
				InsertObject(i++, new_command);
				if (command->link()) {
					if (command->link()->to_command()) {
						new_command->link()->set_to_command(command->link()->to_command());
						command->link()->set_to_command(new_command);
					}
				}
			}
			break;
		case cmCall:
			if ((command->options() & roFar) == 0 && command->operand(0).type == otValue && command->operand(0).value == command->next_address()) {
				if (cpu_address_size() == osDWord) {
					command->Init(cmPush, IntelOperand(otValue, cpu_address_size(), 0, command->next_address(), NEED_FIXUP));
					command->CompileToNative();
					if (command->link()) {
						delete command->link();
						link_count--;
					}
				} else {
					uint64_t next_address = command->next_address();
					AddressRange *address_range = command->address_range();

					command->Init(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEAX));
					command->CompileToNative();
					if (command->link()) {
						delete command->link();
						link_count--;
					}

					command = new IntelCommand(this, cpu_address_size(), cmLea, IntelOperand(otRegistr, cpu_address_size(), regEAX), IntelOperand(otMemory | otValue, cpu_address_size(), 0, next_address, LARGE_VALUE));
					command->include_option(roNoProgress);
					command->CompileToNative();
					command->set_address_range(address_range);
					InsertObject(i++, command);

					command = new IntelCommand(this, cpu_address_size(), cmXchg, IntelOperand(otMemory | otRegistr, cpu_address_size(), regESP), IntelOperand(otRegistr, cpu_address_size(), regEAX));
					command->include_option(roNoProgress);
					command->CompileToNative();
					command->set_address_range(address_range);
					InsertObject(i++, command);
				}
			}
			break;
		case cmDC:
			command->CompileToNative();
			break;
		}
	}

	IntelCommandInfoList command_info_list(cpu_address_size());
	CommandInfoList free_registr_list;
	std::vector<IntelCommand *> garbage_command_list;
	insert_count = 0;

	std::list<ICommand *> new_command_list;
	for (i = 0; i < count(); i++) {
		command = item(i);
		new_command_list.push_back(command);

		if ((command->options() & roNoProgress) == 0)
			ctx.file->StepProgress();

		if (is_breaked_address(command->address()))
			continue;

		AddressRange *address_range = command->address_range();
		uint32_t src_options = command->options();

		if (command->block()) {
			CommandBlock *block = command->block();
			for (j = block->start_index() + 1; j <= block->end_index(); j++) {
				new_command_list.push_back(item(j));
			}
			i = block->end_index();
			if (insert_count) {
				block->set_start_index(block->start_index() + insert_count);
				block->set_end_index(block->end_index() + insert_count);
			}
			ctx.file->StepProgress(block->end_index() - block->start_index());
			continue;
		} else if ((command->options() & roNeedCompile) == 0)
			continue;

		bool is_end;
		if (command->GetCommandInfo(command_info_list)) {
			GetFreeRegisters(i + 1, free_registr_list);
			// mutate command
			switch (command->type()) {
			case cmXor:
				if (command->operand(0).type == otRegistr && command->operand(1).type == otRegistr && command->operand(0).registr == command->operand(1).registr && (rand() & 1)) {
					// xor reg, reg -> sub reg, reg
					command->Init(cmSub, command->operand(0), command->operand(1));
					command->CompileToNative();
				}
				break;

			case cmCall:
				if ((command->options() & roFar) == 0 && (rand() & 1)) {
				}
				break;

			case cmAdd:
				if (command->operand(0).type == otRegistr && command->operand(0).size == cpu_address_size() 
					&& ((command->operand(1).type == otRegistr && command->operand(1).registr != regESP) || (command->operand(1).type == otValue && cpu_address_size() != osQWord)) 
					&& (rand() & 1)) {
					if ((command_info_list.change_flags() & free_registr_list.change_flags()) == command_info_list.change_flags()) {
						// add reg, xxxx -> lea reg, [reg + xxxx]
						IntelOperand second_operand = command->operand(1);
						second_operand.type |= otMemory;
						if ((second_operand.type & otValue) && (command->operand(0).registr != regESP)) {
							second_operand.type |= otRegistr;
							second_operand.registr = command->operand(0).registr;
						} else {
							second_operand.type |= otBaseRegistr;
							second_operand.base_registr = command->operand(0).registr;
							if ((second_operand.base_registr & 7) == regEBP) {
								second_operand.type |= otValue;
								second_operand.value_size = osByte;
								second_operand.value = 0;
							}
						}

						command->Init(cmLea, command->operand(0), second_operand);
						command->CompileToNative();
					}
				}
				break;

			case cmSub:
				if (command->operand(0).type == otRegistr && command->operand(0).size == cpu_address_size() 
					&& (command->operand(1).type == otValue && cpu_address_size() != osQWord)
					&& (rand() & 1)) {
					if ((command_info_list.change_flags() & free_registr_list.change_flags()) == command_info_list.change_flags()) {
						// sub reg, xxxx -> lea reg, [reg - xxxx]
						IntelOperand second_operand = command->operand(1);
						second_operand.type |= otMemory;
						if (command->operand(0).registr != regESP) {
							second_operand.type |= otRegistr;
							second_operand.registr = command->operand(0).registr;
						} else {
							second_operand.type |= otBaseRegistr;
							second_operand.base_registr = command->operand(0).registr;
						}
						second_operand.value = 0 - second_operand.value;

						command->Init(cmLea, command->operand(0), second_operand);
						command->CompileToNative();
					}
				}
				break;

			case cmJmp:
				if (!for_virtualization && (command->options() & roFar) == 0 && command->operand(0).type != otValue && (rand() & 1)) {
					// jmp xxxx -> push xxxx, ret
					command->Init(cmPush, command->operand(0));
					command->CompileToNative();

					command = new IntelCommand(this, cpu_address_size(), cmRet);
					command->include_option(roNoProgress);
					command->CompileToNative();
					command->set_address_range(address_range);

					new_command_list.push_back(command);
					insert_count++;
				}
				break;
			}
			is_end = command_info_list.GetInfo(atWrite, otBaseRegistr, regEIP) != NULL;
		} else {
			is_end = true;
		}

		if (!is_end) {
			// add garbage code
			garbage_command_list.clear();
			for (j = 0; j < template_command_list.size(); j++) {
				command = template_command_list[j];
				if (!command->GetCommandInfo(command_info_list))
					continue;

				bool is_ok = true;
				for (size_t k = 0; k < command_info_list.count() && is_ok; k++) {
					CommandInfo *command_info = command_info_list.item(k);
					if (command_info->type() == atWrite && (command_info->operand_type() == otRegistr || command_info->operand_type() == otHiPartRegistr)) {
						if (command_info->value() == regFree) {
							if (!free_registr_list.count())
								is_ok = false;
						} else if (command_info->value() == regEFX) {
							if ((command_info_list.change_flags() & free_registr_list.change_flags()) != command_info_list.change_flags())
								is_ok = false;
						} else {
							OperandSize registr_size;
							if (command_info->operand_type() == otHiPartRegistr) {
								switch (command_info->size()) {
								case osByte:
									registr_size = osWord;
									break;
								case osWord:
									registr_size = osDWord;
									break;
								default:
									registr_size = osQWord;
									break;
								}
							} else {
								registr_size = command_info->size();
							}

							CommandInfo *free_registr = free_registr_list.GetInfo(atWrite, otRegistr, command_info->value());
							if (!free_registr || free_registr->size() < registr_size)
								is_ok = false;
						}
					}
				}
				if (is_ok)
					garbage_command_list.push_back(command);
			}

			size_t c = rand() % 4;
			for (size_t m = 0; m < c && !garbage_command_list.empty(); m++) {
				j = rand() % garbage_command_list.size();
				command = garbage_command_list[j];
				garbage_command_list.erase(garbage_command_list.begin() + j);

				IntelOperand operand[3];
				uint8_t registr[3];
				OperandSize min_size = osByte;
				OperandSize max_size = cpu_address_size();
				bool is_ok = true;
				uint8_t max_registr = 0;
				for (size_t k = 0; k < _countof(operand) && is_ok; k++) {
					IntelOperand tmp = command->operand(k);
					if (tmp.type == otNone)
						continue;

					if (tmp.size == osRandomStartWord && min_size < osWord)
						min_size = osWord;

					if (tmp.type == otRegistr) {
						if (tmp.registr == regFree) {
							if (free_registr_list.count()) {
								CommandInfo *free_registr = free_registr_list.item(rand() % free_registr_list.count());
								registr[k] = free_registr->value();
								if (max_size > free_registr->size())
									max_size = free_registr->size();
							} else {
								is_ok = false;
								break;
							}
						} else if (tmp.registr == 0) {
							registr[k] = rand() % ((cpu_address_size() == osDWord) ? 8 : 16);
						} else {
							registr[k] = tmp.registr;
						}
						if (max_registr < registr[k])
							max_registr = registr[k];
						if (cpu_address_size() == osDWord && registr[k] > 3 && min_size < osWord)
							min_size = osWord;
						if (tmp.size & osRandom) {
							if (min_size > max_size)
								is_ok = false;
						} else if (tmp.size < min_size || tmp.size > max_size)
							is_ok = false;
					}
				}

				if (is_ok) {
					OperandSize random_size = min_size;
					for (int size = min_size; size <= max_size; size++) {
						random_size = static_cast<OperandSize>(size);
						if (rand() & 1)
							break;
					}

					for (size_t k = 0; k < _countof(operand) && is_ok; k++) {
						IntelOperand tmp = command->operand(k);
						if (tmp.size & osRandom)
							tmp.size = random_size;
						if (tmp.type == otRegistr) {
							if (tmp.size == osByte && (tmp.registr == regFree || tmp.registr == 0) && max_size > osByte && max_registr < 4 && (rand() & 1))
								tmp.type = otHiPartRegistr;
							tmp.registr = registr[k];
						} else if (tmp.type == otValue) {
							switch (tmp.size) {
							case osByte:
								tmp.value = ByteToInt64(rand32() & 0xff);
								tmp.value_size = osByte;
								break;
							case osWord:
								tmp.value = WordToInt64(rand32() & 0xffff);
								tmp.value_size = osWord;
								break;
							default:
								tmp.value = DWordToInt64(rand32());
								tmp.value_size = osDWord;
								break;
							}
						}
						operand[k] = tmp;
					}
					uint16_t flags = command->flags();
					uint32_t options = command->options();
					command = new IntelCommand(this, cpu_address_size(), static_cast<IntelCommandType>(command->type()), operand[0], operand[1], operand[2]);
					if (flags) {
						if (flags == flRandom) {
							switch (rand() % 8) {
							case 0: flags = fl_O; break;
							case 1: flags = fl_C; break;
							case 2: flags = fl_Z; break;
							case 3: flags = fl_C | fl_Z; break;
							case 4: flags = fl_S; break;
							case 5: flags = fl_P; break;
							case 6: flags = fl_S | fl_O; break;
							default: flags = fl_Z | fl_S | fl_O; break;
							}
							if (rand() & 1)
								options |= roInverseFlag;
						}
						command->set_flags(flags);
						if (options & roInverseFlag)
							command->include_option(roInverseFlag);
					}
					command->include_option(roNoProgress);
					if (src_options & roNeedCRC)
						command->include_option(roNeedCRC);
					command->CompileToNative();
					command->set_address_range(address_range);
					new_command_list.push_back(command);
					insert_count++;

					switch (command->type()) {
					case cmJmpWithFlag:
						// FIXME
						/*
						command->AddLink(0, ltJmpWithFlag, item(i + 1));
						*/
						break;
					case cmJmp:
						command->AddLink(0, ltJmp, item(i + 1));
						break;
					}
				}
			}
		}
	}

	for (i = link_count; i < link_list()->count(); i++) {
		link_list()->item(i)->from_command()->PrepareLink(ctx);
	}

	for (i = 0; i < template_command_list.size(); i++) {
		delete template_command_list[i];
	}

	assign(new_command_list);
}

void IntelFunction::CompileToNative(const CompileContext &ctx)
{
	size_t i, j;
	size_t c = link_list()->count();
	for (i = 0; i < c; i++) {
		CommandLink *link = link_list()->item(i);
		IntelCommand *to_command = reinterpret_cast<IntelCommand *>(link->to_command());
		if (!to_command)
			continue;

		switch (link->type()) {
		case ltDualSEHBlock:
			{
				CommandBlock *block = AddBlock(count(), true);
				size_t k = IndexOf(to_command);
				IntelCommand *next_command = item(k + 1);
				IntelCommand *src_command = to_command;
				IntelCommand *dst_command = src_command->Clone(this);
				AddObject(dst_command);
				CommandLink *src_link = src_command->link();
				if (src_link) {
					CommandLink *dst_link = src_link->Clone(link_list());
					dst_link->set_from_command(dst_command);
					dst_link->set_to_command(src_link->to_command());
					link_list()->AddObject(dst_link);
				}
				IntelCommand *command = new IntelCommand(this, cpu_address_size(), cmJmp, IntelOperand(otValue, cpu_address_size(), 0, to_command->next_address()));
				AddObject(command);
				command->AddLink(0, ltJmp, next_command);

				for (size_t j = block->start_index(); j < count(); j++) {
					IntelCommand *command = item(j);
					command->set_block(block);
					command->CompileToNative();
				}
				block->set_end_index(count() - 1);

				link->set_to_command(item(block->start_index()));
			}
			break;
		case ltFilterSEHBlock:
			{
				CommandBlock *block = AddBlock(count(), true);
				size_t k = IndexOf(to_command);
				IntelCommand *next_command = item(k + 1);
				size_t n = static_cast<size_t>(next_command->operand(0).value * 2 + 2);
				for (j = 0; j < n; j++) {
					IntelCommand *src_command = item(k + j);
					IntelCommand *dst_command = src_command->Clone(this);
					AddObject(dst_command);
					CommandLink *src_link = src_command->link();
					if (src_link) {
						CommandLink *dst_link = src_link->Clone(link_list());
						dst_link->set_from_command(dst_command);
						dst_link->set_to_command(src_link->to_command());
						link_list()->AddObject(dst_link);
					}
				}

				for (size_t j = block->start_index(); j < count(); j++) {
					IntelCommand *command = item(j);
					command->set_block(block);
					command->CompileToNative();
				}
				block->set_end_index(count() - 1);

				link->set_to_command(item(block->start_index()));
			}
			break;
		}
	}

	Mutate(ctx, false);

	CreateBlocks();
	for (i = 0; i < ext_command_list()->count(); i++) {
		ExtCommand *ext_command = ext_command_list()->item(i);
		if (!ext_command->command() || is_breaked_address(ext_command->address()))
			continue;

		CommandBlock *block = AddBlock(count(), true);
		block->set_address(ext_command->address());

		IntelCommand *command = AddCommand(ext_command->use_call() ? cmCall : cmJmp, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltJmp, ext_command->command());
		command->CompileToNative();
		command->set_block(block);
	}
}

/**
* IntelStackValue
*/

IntelStackValue::IntelStackValue(IntelStack *owner, ValueType type, uint64_t value)
	: IObject(), owner_(owner), type_(type), value_(value), is_modified_(false)
{

}

IntelStackValue::~IntelStackValue()
{
	if (owner_)
		owner_->RemoveObject(this);
}

void IntelStackValue::Calc(IntelCommandType command_type, uint16_t command_flags, bool inverse_flags, OperandSize size, uint64_t op2, IntelFlagsValue *flags)
{
	if (type_ != vtValue)
		throw std::runtime_error("Runtime error at Calc");

	uint64_t op1 = value_;
	uint64_t result;
	switch (command_type) {
	case cmAdd:
		result = op1 + op2;
		break;
	case cmAdc:
		result = op1 + op2 + ((flags->value() & fl_C) ? 1 : 0);
		break;
	case cmCmp:
	case cmSub:
		result = op1 - op2;
		break;
	case cmSbb:
		result = op1 - op2 - ((flags->value() & fl_C) ? 1 : 0);
		break;
	case cmTest:
	case cmAnd:
		result = op1 & op2;
		break;
	case cmOr:
		result = op1 | op2;
		break;
	case cmXor:
		result = op1 ^ op2;
		break;
	case cmSetXX:
		result = flags->Check(command_flags) ? 1 : 0;
		if (inverse_flags)
			result = result ? 0 : 1;
		break;
	case cmCmov:
		if (flags->Check(command_flags) != (inverse_flags == false))
			return;

		result = op2;
		break;
	case cmShr:
		op2 &= (size == osQWord) ? 0x3f : 0x1f;
		if (!op2)
			return;

		switch (size) {
		case osByte:
			result = static_cast<uint8_t>(op1) >> op2;
			break;
		case osWord:
			result = static_cast<uint16_t>(op1) >> op2;
			break;
		case osDWord:
			result = static_cast<uint32_t>(op1) >> op2;
			break;
		default:
			result = op1 >> op2;
			break;
		}
		break;
	case cmSar:
		op2 &= (size == osQWord) ? 0x3f : 0x1f;
		if (!op2)
			return;

		switch (size) {
		case osByte:
			result = static_cast<int8_t>(op1) >> op2;
			break;
		case osWord:
			result = static_cast<int16_t>(op1) >> op2;
			break;
		case osDWord:
			result = static_cast<int32_t>(op1) >> op2;
			break;
		default:
			result = static_cast<int64_t>(op1) >> op2;
			break;
		}
		break;
	case cmShl:
	case cmSal:
		op2 &= (size == osQWord) ? 0x3f : 0x1f;
		if (!op2)
			return;

		switch (size) {
		case osByte:
			result = static_cast<uint8_t>(op1) << op2;
			break;
		case osWord:
			result = static_cast<uint16_t>(op1) << op2;
			break;
		case osDWord:
			result = static_cast<uint32_t>(op1) << op2;
			break;
		default:
			result = op1 << op2;
			break;
		}
		break;
	case cmRol:
		op2 &= (size == osQWord) ? 0x3f : 0x1f;
		if (!op2)
			return;

		switch (size) {
		case osByte:
			result = _rotl8(static_cast<uint8_t>(op1), static_cast<uint8_t>(op2));
			break;
		case osWord:
			result = _rotl16(static_cast<uint16_t>(op1), static_cast<uint8_t>(op2));
			break;
		case osDWord:
			result = _rotl32(static_cast<uint32_t>(op1), static_cast<uint8_t>(op2));
			break;
		default:
			result = _rotl64(op1, static_cast<uint8_t>(op2));
			break;
		}
		break;
	case cmRor:
		op2 &= (size == osQWord) ? 0x3f : 0x1f;
		if (!op2)
			return;

		switch (size) {
		case osByte:
			result = _rotr8(static_cast<uint8_t>(op1), static_cast<uint8_t>(op2));
			break;
		case osWord:
			result = _rotr16(static_cast<uint16_t>(op1), static_cast<uint8_t>(op2));
			break;
		case osDWord:
			result = _rotr32(static_cast<uint32_t>(op1), static_cast<uint8_t>(op2));
			break;
		default:
			result = _rotr64(op1, static_cast<uint8_t>(op2));
			break;
		}
		break;
	case cmMov:
	case cmLea:
	case cmMovsx:
	case cmMovsxd:
	case cmMovzx:
		result = op2;
		break;
	case cmCbw:
		result = static_cast<int64_t>(static_cast<int8_t>(op2));
		break;
	case cmCwde:
		result = static_cast<int64_t>(static_cast<int16_t>(op2));
		break;
	case cmCdqe:
		result = static_cast<int64_t>(static_cast<int32_t>(op2));
		break;
	case cmCwd:
		result = (static_cast<int16_t>(op2) < 0) ? (uint64_t)-1 : 0;
		break;
	case cmCdq:
		result = (static_cast<int32_t>(op2) < 0) ? (uint64_t)-1 : 0;
		break;
	case cmCqo:
		result = (static_cast<int64_t>(op2) < 0) ? (uint64_t)-1 : 0;
		break;
	case cmNot:
		result = ~op1;
		break;
	case cmNeg:
		result = 0 - op1;
		break;
	case cmBt:
		op2 &= (OperandSizeToValue(size) * 8 - 1);
		result = op1;
		break;
	case cmBtr:
		op2 &= (OperandSizeToValue(size) * 8 - 1);
		result = op1 & ~((uint64_t)1 << op2);
		break;
	case cmBtc:
		op2 &= (OperandSizeToValue(size) * 8 - 1);
		result = op1 ^ ((uint64_t)1 << op2);
		break;
	case cmBts:
		op2 &= (OperandSizeToValue(size) * 8 - 1);
		result = op1 | ((uint64_t)1 << op2);
		break;
	case cmBswap:
		switch (size) {
		case osDWord:
			result = __builtin_bswap32(static_cast<uint32_t>(op1));
			break;
		case osQWord:
			result = __builtin_bswap64(op1);
			break;
		default:
			throw std::runtime_error("Runtime error at Calc");
		}
		break;
	default:
		throw std::runtime_error("Runtime error at Calc");
	}

	if (flags)
		flags->Calc(command_type, size, op1, op2, result);

	if (command_type == cmCmp || command_type == cmTest || command_type == cmBt)
		return;

	memcpy(&value_, &result, OperandSizeToValue(size));
}

/**
* IntelFlagsValue
*/

IntelFlagsValue::IntelFlagsValue()
	: IObject(), mask_(0), value_(0)
{

}

uint16_t IntelFlagsValue::GetRandom() const
{
	std::vector<uint16_t> list;

	if (mask_ & fl_Z)
		list.push_back(fl_Z);
	if (mask_ & fl_S)
		list.push_back(fl_S);
	if (mask_ & fl_C)
		list.push_back(fl_C);
	if (mask_ & fl_O)
		list.push_back(fl_O);
	if ((mask_ & (fl_C | fl_Z)) == (fl_C | fl_Z))
		list.push_back(fl_C | fl_Z);
	if ((mask_ & (fl_S | fl_O)) == (fl_S | fl_O))
		list.push_back(fl_S | fl_O);
	if ((mask_ & (fl_Z | fl_S | fl_O)) == (fl_Z | fl_S | fl_O))
		list.push_back(fl_Z | fl_S | fl_O);

	return list.empty() ? 0 : list[rand() % list.size()];
}

bool IntelFlagsValue::Check(uint16_t flags) const
{
	bool s, z, o;

	switch (flags) {
	case (fl_S | fl_O):
		s = (value_ & fl_S) != 0;
		o = (value_ & fl_O) != 0;
		return s != o;
	case (fl_Z | fl_S | fl_O):
		z = (value_ & fl_Z) != 0;
		s = (value_ & fl_S) != 0;
		o = (value_ & fl_O) != 0;
		return z || (s != o);
	default:
		return (value_ & flags) != 0;
	}
}

void IntelFlagsValue::exclude(uint16_t mask)
{
	mask_ &= ~mask;
	value_ &= ~mask;
}

void IntelFlagsValue::Calc(IntelCommandType command_type, OperandSize size, uint64_t op1, uint64_t op2, uint64_t result)
{
	uint64_t tmp;
	uint64_t sign_mask = (uint64_t)1 << (OperandSizeToValue(size) * 8 - 1);
	uint64_t value_mask = sign_mask | (sign_mask - 1);
	uint16_t prev_value = value_;

	switch (command_type) {
	case cmAdd:
	case cmAdc:
		exclude(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		mask_ |= fl_C;
		if (command_type == cmAdc && (prev_value & fl_C)) {
			if ((result & value_mask) <= (op1 & value_mask))
				value_ |= fl_C;
		}
		else {
			if ((result & value_mask) < (op1 & value_mask))
				value_ |= fl_C;
		}

		mask_ |= fl_O;
		if ((~(op1 ^ op2) & (op2 ^ result)) & sign_mask)
			value_ |= fl_O;
		break;
	case cmCmp:
	case cmSub:
	case cmSbb:
		exclude(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		mask_ |= fl_C;
		if (command_type == cmSbb && (prev_value & fl_C)) {
			if ((op1 & value_mask) <= (result & value_mask))
				value_ |= fl_C;
		}
		else {
			if ((op1 & value_mask) < (op2 & value_mask))
				value_ |= fl_C;
		}

		mask_ |= fl_O;
		if (((op1 ^ op2) & (op1 ^ result)) & sign_mask)
			value_ |= fl_O;
		break;
	case cmNeg:
		exclude(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		mask_ |= fl_C;
		if (result & value_mask)
			value_ |= fl_C;

		mask_ |= fl_O;
		if ((result & value_mask) == sign_mask)
			value_ |= fl_O;
		break;
	case cmOr:
	case cmXor:
	case cmAnd:
	case cmTest:
		exclude(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		mask_ |= fl_C;
		mask_ |= fl_O;
		break;
	case cmShr:
		exclude(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		switch (size) {
		case osByte:
			tmp = static_cast<uint8_t>(op1) >> (op2 - 1);
			break;
		case osWord:
			tmp = static_cast<uint16_t>(op1) >> (op2 - 1);
			break;
		case osDWord:
			tmp = static_cast<uint32_t>(op1) >> (op2 - 1);
			break;
		default:
			tmp = op1 >> (op2 - 1);
			break;
		}
		mask_ |= fl_C;
		if (tmp & 1)
			value_ |= fl_C;

		if (op2 == 1) {
			mask_ |= fl_O;
			if (op1 & sign_mask)
				value_ |= fl_O;
		}
		break;

	case cmSar:
		exclude(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		switch (size) {
		case osByte:
			tmp = static_cast<int8_t>(op1) >> (op2 - 1);
			break;
		case osWord:
			tmp = static_cast<int16_t>(op1) >> (op2 - 1);
			break;
		case osDWord:
			tmp = static_cast<int32_t>(op1) >> (op2 - 1);
			break;
		default:
			tmp = op1 >> (op2 - 1);
			break;
		}
		mask_ |= fl_C;
		if (tmp & 1)
			value_ |= fl_C;

		if (op2 == 1)
			mask_ |= fl_O;
		break;

	case cmShl:
	case cmSal:
		exclude(fl_O | fl_S | fl_Z | fl_A | fl_P | fl_C);

		switch (size) {
		case osByte:
			tmp = static_cast<uint8_t>(op1) << (op2 - 1);
			break;
		case osWord:
			tmp = static_cast<uint16_t>(op1) << (op2 - 1);
			break;
		case osDWord:
			tmp = static_cast<uint32_t>(op1) << (op2 - 1);
			break;
		default:
			tmp = op1 << (op2 - 1);
			break;
		}
		mask_ |= fl_C;
		if (tmp & sign_mask)
			value_ |= fl_C;

		if (op2 == 1) {
			mask_ |= fl_O;
			if (((result & sign_mask) != 0) != ((value_ & fl_C) != 0))
				value_ |= fl_O;
		}
		break;


	case cmRcl:
	case cmRcr:
		exclude(fl_O | fl_C);

		// TODO
		return;
	case cmRol:
		exclude(fl_O | fl_C);

		mask_ |= fl_C;
		if (result & 1)
			value_ |= fl_C;

		if (op2 == 1) {
			mask_ |= fl_O;
			if (((result & sign_mask) != 0) != ((value_ & fl_C) != 0))
				value_ |= fl_O;
		}
		return;
	case cmRor:
		exclude(fl_O | fl_C);

		mask_ |= fl_C;
		if (result & sign_mask)
			value_ |= fl_C;

		if (op2 == 1) {
			mask_ |= fl_O;
			if (((result & sign_mask) != 0) != (((result << 1) & sign_mask) != 0))
				value_ |= fl_O;
		}
		return;
	case cmStc:
		mask_ |= fl_C;
		value_ |= fl_C;
		return;
	case cmClc:
		mask_ |= fl_C;
		value_ &= ~fl_C;
		return;
	case cmCmc:
		if (mask_ & fl_C)
			value_ ^= fl_C;
		return;
	case cmBt:
	case cmBtr:
	case cmBtc:
	case cmBts:
		exclude(fl_O | fl_S | fl_A | fl_P | fl_C); // fl_Z is unaffected

		mask_ |= fl_C;
		if ((op1 >> op2) & 1)
			value_ |= fl_C;
		return;
	default:
		return;
	}

	mask_ |= fl_Z;
	if ((result & value_mask) == 0)
		value_ |= fl_Z;

	mask_ |= fl_S;
	if (result & sign_mask)
		value_ |= fl_S;
}

/**
* IntelStack
*/

IntelStack::IntelStack()
	: ObjectList<IntelStackValue>()
{

}

IntelStackValue *IntelStack::Add(ValueType type, uint64_t value)
{
	IntelStackValue *res = new IntelStackValue(this, type, value);
	AddObject(res);
	return res;
};

IntelStackValue *IntelStack::Insert(size_t index, ValueType type, uint64_t value)
{
	IntelStackValue *res = new IntelStackValue(this, type, value);
	InsertObject(index, res);
	return res;
}

IntelStackValue *IntelStack::GetRegistr(uint8_t reg) const
{
	for (size_t i = 0; i < count(); i++) {
		IntelStackValue *res = item(i);
		if (res->type() == vtRegistr && res->value() == reg)
			return res;
	}
	return NULL;
}

IntelStackValue *IntelStack::GetRandom(uint32_t types)
{
	std::vector<IntelStackValue *> list;
	for (size_t i = 0; i < count(); i++) {
		IntelStackValue *stack_item = item(i);
		if (stack_item->type() & types) {
			if (stack_item->type() == vtRegistr && (stack_item->value() == regEFX || stack_item->value() == regEmpty))
				continue;

			list.push_back(stack_item);
		}
	}
	return list.empty() ? NULL : list[rand() % list.size()];
}

/**
* IntelRegistrStorage
*/

IntelRegistrStorage::IntelRegistrStorage()
	: IntelStack()
{

}

IntelRegistrValue *IntelRegistrStorage::item(size_t index) const
{
	return reinterpret_cast<IntelRegistrValue *>(IntelStack::item(index));
}

IntelRegistrValue *IntelRegistrStorage::GetRegistr(uint8_t reg) const
{
	for (size_t i = 0; i < count(); i++) {
		IntelRegistrValue *res = item(i);
		if (res->registr() == reg)
			return res;
	}
	return NULL;
};

IntelRegistrValue *IntelRegistrStorage::Add(uint8_t reg, uint64_t value)
{
	IntelRegistrValue *res = GetRegistr(reg);
	if (res)
		res->set_value(value);
	else {
		res = new IntelRegistrValue(this, reg, value);
		AddObject(res);
	}
	return res;
}

/**
* IntelObfuscation
*/

IntelObfuscation::IntelObfuscation()
	: IObject(), func_(NULL)
{

}

IntelCommand *IntelObfuscation::AddCommand(IntelCommandType command_type, IntelOperand operand1, IntelOperand operand2, IntelOperand operand3)
{
	if (command_type != cmLea && registr_values_.count()) {
		for (size_t i = 0; i < 2; i++) {
			IntelOperand *operand = (i == 0) ? &operand1 : &operand2;
			uint16_t type = operand->type & (otMemory | otBaseRegistr | otRegistr);
			if (type == (otMemory | otBaseRegistr) || type == (otMemory | otRegistr)) {
				IntelRegistrValue *reg_value = registr_values_.item(rand() % registr_values_.count());
				if ((operand->type & otRegistr) && !operand->scale_registr) {
					operand->base_registr = operand->registr;
					operand->type -= otRegistr;
					operand->type |= otBaseRegistr;
				}
				if (operand->type & otBaseRegistr) {
					operand->scale_registr = rand() & 3;
					uint64_t tmp = operand->value - (reg_value->value() << operand->scale_registr);
					if (DWordToInt64(static_cast<uint32_t>(tmp)) == tmp) {
						operand->type |= (otRegistr | otValue);
						operand->registr = reg_value->registr();
						operand->value = tmp;
						operand->value_size = osDWord;
					}
				}
			}
		}
	}

	IntelCommand *command = new IntelCommand(func_, func_->cpu_address_size(), command_type, operand1, operand2, operand3);
	command_list_.push_back(command);
	return command;
}

void IntelObfuscation::AddRestoreStackItem(IntelStackValue *stack_item)
{
	if (stack_item && stack_item->type() == vtRegistr && stack_item->value() != regEmpty) {
		if (stack_item->is_modified()) {
			uint8_t reg = static_cast<uint8_t>(stack_item->value());
			OperandSize cpu_address_size = func_->cpu_address_size();
			uint64_t value = (stack_.count() - 1 - stack_.IndexOf(stack_item)) * OperandSizeToStack(cpu_address_size);

			if (reg == regEFX) {
				AddCommand(cmPush, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, value));
				AddCommand(cmPopf, IntelOperand(otNone, cpu_address_size, 0));

				flags_.clear();
			}
			else {
				AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, value));

				IntelRegistrValue *reg_value = registr_values_.GetRegistr(reg);
				if (reg_value)
					delete reg_value;
			}
		}
		stack_item->set_value(regEmpty);
		stack_item->set_is_modified(false);
	}
}

void IntelObfuscation::AddRestoreRegistr(uint8_t reg)
{
	if (IntelStackValue *stack_item = stack_.GetRegistr(reg))
		AddRestoreStackItem(stack_item);
}

void IntelObfuscation::AddRestoreStack(size_t to_index)
{
	size_t i;
	for (i = stack_.count(); i > to_index; i--) {
		IntelStackValue *stack_item = stack_.item(i - 1);
		AddRestoreStackItem(stack_item);
	}
	size_t value = 0;
	OperandSize cpu_address_size = func_->cpu_address_size();
	for (i = stack_.count(); i > to_index; i--) {
		delete stack_.item(i - 1);
		value += OperandSizeToStack(cpu_address_size);
	}
	if (value)
		AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, value));
}

void IntelObfuscation::Compile(IntelFunction *func, size_t index)
{
	func_ = func;
	flags_.clear();
	stack_.clear();
	registr_values_.clear();

	size_t i, j, old_count;
	IntelCommand *command;
	IntelStackValue *stack_item;
	IntelRegistrValue *reg_value;
	uint8_t reg;
	OperandSize cpu_address_size = func_->cpu_address_size();
	bool need_update;
	IntelOperand new_operand[3];

	while (index < func_->count()) {
		command = func_->item(index);
		func_->erase(index);

		if (command->section_options() & (rtLinkedToInt | rtLinkedToExt))
			AddRestoreStack(0);

		old_count = command_list_.size();

		AddRandomCommands();

		if (stack_.count()) {
			switch (command->type()) {
			case cmPop:
				reg = command->operand(0).registr;

				command->Init(cmMov, IntelOperand(otRegistr, cpu_address_size, reg), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, stack_.count() * OperandSizeToStack(cpu_address_size)));

				stack_item = stack_.GetRegistr(reg);
				if (stack_item)
					stack_item->set_value(regEmpty);

				reg_value = registr_values_.GetRegistr(reg);
				if (reg_value)
					delete reg_value;

				stack_.Insert(0, vtRegistr, regEmpty);
				break;

			case cmPush:
			case cmPushf:
				stack_item = stack_.item(0);
				AddRestoreStackItem(stack_item);
				delete stack_item;

				if (command->type() == cmPushf) {
					AddCommand(cmPushf, IntelOperand(otNone, cpu_address_size, 0));
					command->Init(cmPop, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, stack_.count() * OperandSizeToStack(cpu_address_size)));
				}
				else {
					IntelOperand first_operand = command->operand(0);
					if (first_operand.type == otValue) {
						if (first_operand.value_size == osQWord)
							first_operand.value_size = osDWord;
					}
					else if (first_operand.type == otRegistr)
						AddRestoreRegistr(first_operand.registr);

					command->Init(cmMov, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, stack_.count() * OperandSizeToStack(cpu_address_size)), first_operand);
					if (command->link() && command->link()->operand_index() == 0)
						command->link()->set_operand_index(1);
				}
				break;

			case cmCall:
				if ((command->options() & roUseAsJmp) && command->link()) {
					size_t ret_pos = rand() % stack_.count();

					for (j = stack_.count(); j > 0; j--) {
						IntelStackValue *stack_item = stack_.item(j - 1);
						AddRestoreStackItem(stack_item);
					}
					uint64_t value = (stack_.count() - ret_pos - 1) * OperandSizeToStack(cpu_address_size);
					if (value)
						AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, value));

					stack_.clear();

					command_list_.push_back(command);

					j = command_list_.size();
					AddRandomCommands();

					stack_item = stack_.GetRegistr(regEFX);
					if (!stack_item) {
						AddCommand(cmPushf, IntelOperand(otNone, func_->cpu_address_size(), 0));
						stack_item = stack_.Add(vtRegistr, regEFX);
					}
					stack_item->set_is_modified(true);

					IntelCommand *add_command = AddCommand(cmAdd, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, stack_.count() * OperandSizeToStack(cpu_address_size)),
						IntelOperand(otValue, cpu_address_size, 0, 0));

					flags_.clear();

					CommandLink *link = add_command->AddLink(1, ltDelta, command->link()->to_command());
					link->set_parent_command(command);
					link->set_sub_value(5);

					command->link()->set_to_command(command_list_[j]);

					AddRandomCommands();

					command = new IntelCommand(func_, cpu_address_size, cmRet, ret_pos ? IntelOperand(otValue, osWord, 0, ret_pos * OperandSizeToStack(cpu_address_size)) : IntelOperand());
				}
				AddRestoreStack(0);
				break;
			case cmRet:
			case cmJmp:
			case cmJmpWithFlag:
				AddRestoreStack(0);
				break;
			}
		}

		if (command_list_.size() > old_count && command->section_options() & (rtLinkedToInt | rtLinkedToExt)) {
			IntelCommand *dst_command = command_list_[old_count];
			IntelCommandType dst_type = (IntelCommandType)dst_command->type();
			IntelOperand dst_operand[3];
			for (i = 0; i < _countof(dst_operand); i++) {
				dst_operand[i] = dst_command->operand(i);
			}
			uint16_t dst_flags = dst_command->flags();
			uint32_t dst_options = dst_command->options();
			CommandLink *dst_link = dst_command->link();
			if (dst_link)
				dst_link->set_from_command(NULL);

			dst_command->Init(static_cast<IntelCommandType>(command->type()), command->operand(0), command->operand(1), command->operand(2));
			dst_command->set_flags(command->flags());
			dst_command->exclude_option((CommandOption)UINT32_MAX);
			dst_command->include_option((CommandOption)command->options());
			if (command->link())
				command->link()->set_from_command(dst_command);

			command->Init(dst_type, dst_operand[0], dst_operand[1], dst_operand[2]);
			command->set_flags(dst_flags);
			command->exclude_option((CommandOption)UINT32_MAX);
			command->include_option((CommandOption)dst_options);
			if (dst_link)
				dst_link->set_from_command(command);

			command_list_[old_count] = command;
			command = dst_command;
		}

		command_list_.push_back(command);
	}

	for (i = 0; i < command_list_.size(); i++) {
		command = command_list_[i];

		// optimize operands
		need_update = false;
		for (j = 0; j < _countof(new_operand); j++) {
			IntelOperand *operand = &new_operand[j];
			*operand = command->operand(j);

			if ((operand->type & (otMemory | otValue)) == (otMemory | otValue) && (operand->type & (otBaseRegistr | otRegistr))) {
				if (operand->fixup || operand->is_large_value)
					continue;

				if (command->link() && command->link()->operand_index() == (int)j)
					continue;

				if (operand->value_size != osByte && ByteToInt64(static_cast<uint8_t>(operand->value)) == operand->value) {
					operand->value_size = osByte;
					need_update = true;
				}
			}
		}
		if (need_update)
			command->Init(static_cast<IntelCommandType>(command->type()), new_operand[0], new_operand[1], new_operand[2]);

		command->CompileToNative();
		if (command->link() && !command->link()->to_command()) {
			std::map<IntelCommand *, size_t>::const_iterator it = jmp_command_list_.find(command);
			if (it != jmp_command_list_.end()) {
				IntelCommand *to_command;
				if (command->type() == cmJmpWithFlag && (command->options() & roUseAsJmp) == 0) {
					while (true) {
						j = rand() % command_list_.size();
						if (j == it->second || j == it->second + 1)
							continue;
						to_command = command_list_[j];
						break;
					}
				}
				else
					to_command = command_list_[it->second];
				command->link()->set_to_command(to_command);
			}
		}

		func_->AddObject(command);
	}
}

#define NEED_STORE_FLAGS reinterpret_cast<IntelStackValue *>(-1)

void IntelObfuscation::AddRandomCommands()
{
	size_t i, j, c;
	IntelCommand *new_command, *last_command;
	std::vector<IntelCommandType> template_command_list;
	IntelCommandType command_type;
	uint8_t reg;
	OperandSize cpu_address_size = func_->cpu_address_size();
	uint8_t registr_count = (cpu_address_size == osDWord) ? 8 : 16;
	IntelStackValue *stack_item;
	IntelRegistrValue *reg_value;
	uint16_t command_flags;
	uint64_t source_value;
	OperandSize size;

	c = 30 + (rand() % 10);
	for (i = 0; i < c; i++) {

		last_command = command_list_.empty() ? NULL : command_list_.back();

		template_command_list.clear();
		template_command_list.push_back(cmPush);
		if (stack_.count()) {
			template_command_list.push_back(cmPop);
			if (stack_.count() < 20) {
				template_command_list.push_back(cmPush);
				if (last_command && last_command->type() != cmCall) {
					template_command_list.push_back(cmCall);
					template_command_list.push_back(cmCall);
					template_command_list.push_back(cmCall);
					template_command_list.push_back(cmCall);

					template_command_list.push_back(cmRet);
					template_command_list.push_back(cmRet);
					template_command_list.push_back(cmRet);
					template_command_list.push_back(cmRet);
					template_command_list.push_back(cmRet);
				}
			}
			template_command_list.push_back(cmLea);
			template_command_list.push_back(cmMov);
			template_command_list.push_back(cmMovsx);
			template_command_list.push_back(cmMovzx);

			template_command_list.push_back(cmCbw);
			template_command_list.push_back(cmCwde);
			template_command_list.push_back(cmCwd);
			template_command_list.push_back(cmCdq);
			if (cpu_address_size == osQWord) {
				template_command_list.push_back(cmCdqe);
				template_command_list.push_back(cmCqo);
			}
			template_command_list.push_back(cmBswap);

			if (last_command && (last_command->type() != cmCmp || flags_.mask() == 0)) {
				template_command_list.push_back(cmAdd);
				template_command_list.push_back(cmSub);
				template_command_list.push_back(cmNeg);
				template_command_list.push_back(cmCmp);

				template_command_list.push_back(cmAnd);
				template_command_list.push_back(cmTest);
				template_command_list.push_back(cmXor);
				template_command_list.push_back(cmOr);
				template_command_list.push_back(cmNot);

				template_command_list.push_back(cmShr);
				template_command_list.push_back(cmShl);
				template_command_list.push_back(cmSal);
				template_command_list.push_back(cmSar);
				template_command_list.push_back(cmRol);
				template_command_list.push_back(cmRor);
			}

			template_command_list.push_back(cmBt);
			template_command_list.push_back(cmBtr);
			template_command_list.push_back(cmBtc);
			template_command_list.push_back(cmBts);

			if (flags_.mask()) {
				template_command_list.push_back(cmJmpWithFlag);
				template_command_list.push_back(cmJmpWithFlag);
				template_command_list.push_back(cmJmpWithFlag);
				template_command_list.push_back(cmJmpWithFlag);
				template_command_list.push_back(cmJmpWithFlag);

				template_command_list.push_back(cmSetXX);
				template_command_list.push_back(cmCmov);
				if (flags_.mask() & fl_C) {
					if (last_command && last_command->type() != cmCmc && last_command->type() != cmClc && last_command->type() != cmStc) {
						template_command_list.push_back((flags_.value() & fl_C) ? cmClc : cmStc);
						template_command_list.push_back(cmCmc);
					}
					template_command_list.push_back(cmAdc);
					template_command_list.push_back(cmSbb);
				}
			}
		}

		command_type = template_command_list[rand() % template_command_list.size()];
		switch (command_type) {
		case cmPush:
			if (rand() & 1) {
				reg = rand() % registr_count;
				if (reg == regESP)
					reg = regEFX;

				if (!registr_values_.GetRegistr(reg)) {
					if (stack_.GetRegistr(reg))
						break;
				}

				if (reg == regEFX)
					AddCommand(cmPushf, IntelOperand(otNone, func_->cpu_address_size(), 0));
				else
					AddCommand(cmPush, IntelOperand(otRegistr, func_->cpu_address_size(), reg));

				reg_value = registr_values_.GetRegistr(reg);
				if (reg_value)
					stack_.Add(reg_value->type(), reg_value->value());
				else
					stack_.Add(vtRegistr, reg);
			}
			else {
				uint64_t value = DWordToInt64(rand32());
				AddCommand(cmPush, IntelOperand(otValue, cpu_address_size, 0, value));
				stack_.Add(vtValue, value);
			}
			break;

		case cmPop:
			AddRestoreStack(stack_.count() - 1);
			break;

		case cmCall:
			stack_.Add(vtReturnAddress, command_list_.size());

			new_command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size, 0));
			new_command->AddLink(0, ltCall);
			new_command->include_option(roUseAsJmp);

			jmp_command_list_[new_command] = command_list_.size();
			break;

		case cmRet:
			if (IntelStackValue *ret_item = stack_.GetRandom(vtReturnAddress)) {
				size_t ret_pos = stack_.IndexOf(ret_item);
				IntelCommand *call_command = command_list_[static_cast<size_t>(ret_item->value())];
				j = static_cast<size_t>(call_command->operand(2).value);
				if (j == 0) {
					stack_item = stack_.GetRegistr(regEFX);
					if (!stack_item) {
						AddCommand(cmPushf, IntelOperand(otNone, func_->cpu_address_size(), 0));
						stack_item = stack_.Add(vtRegistr, regEFX);
					}
					stack_item->set_is_modified(true);

					call_command->set_operand_value(2, command_list_.size());

					AddCommand(cmAdd, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, (stack_.count() - 1 - ret_pos) * OperandSizeToStack(cpu_address_size)),
						IntelOperand(otValue, cpu_address_size, 0, DWordToInt64(rand32())));

					flags_.clear();
				}
				else {
					IntelCommand *add_command = command_list_[j];
					CommandLink *link = add_command->AddLink(1, ltDelta);
					link->set_parent_command(call_command);
					link->set_sub_value(5);

					AddRestoreStack(ret_pos + 1);
					delete ret_item;

					source_value = 0;
					for (j = stack_.count(); j > 0; j--) {
						stack_item = stack_.item(j - 1);
						if (stack_item->type() == vtValue || stack_item->type() == vtReturnAddress || (stack_item->type() == vtRegistr && stack_item->value() == regEmpty)) {
							if (rand() & 1)
								break;

							delete stack_item;
							source_value += OperandSizeToStack(cpu_address_size);
						} else 
							break;
					}
					if (source_value)
						AddCommand(cmRet, IntelOperand(otValue, osWord, 0, source_value));
					else
						AddCommand(cmRet);

					jmp_command_list_[add_command] = command_list_.size();
				}
			}
			break;

		case cmJmpWithFlag:
			command_flags = flags_.GetRandom();
			if (!command_flags)
				break;

			new_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size, 0));
			new_command->AddLink(0, ltJmpWithFlag);
			new_command->set_flags(command_flags);
			if (rand() & 1)
				new_command->include_option(roInverseFlag);

			if (flags_.Check(new_command->flags()) == ((new_command->options() & roInverseFlag) == 0))
				new_command->include_option(roUseAsJmp);

			jmp_command_list_[new_command] = command_list_.size();
			break;

		case cmCbw:
		case cmCwde:
		case cmCdqe:
			reg_value = registr_values_.GetRegistr(regEAX);
			if (!reg_value)
				break;

			AddCommand(command_type);

			switch (command_type) {
			case cmCbw:
				size = osWord;
				break;
			case cmCwde:
				size = osDWord;
				break;
			default:
				size = osQWord;
				break;
			}

			reg_value->Calc(command_type, 0, false, size, reg_value->value(), &flags_);
			if (cpu_address_size == osQWord && size == osDWord)
				reg_value->set_value(static_cast<uint32_t>(reg_value->value()));
			break;

		case cmCwd:
		case cmCdq:
		case cmCqo:
			reg_value = registr_values_.GetRegistr(regEAX);
			if (!reg_value)
				break;

			source_value = reg_value->value();

			switch (command_type) {
			case cmCwd:
				size = osWord;
				break;
			case cmCdq:
				size = osDWord;
				break;
			default:
				size = osQWord;
				break;
			}

			reg_value = registr_values_.GetRegistr(regEDX);
			if (!reg_value) {
				if (size != cpu_address_size)
					break;

				stack_item = stack_.GetRegistr(regEDX);
				if (!stack_item) {
					AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, regEDX));
					stack_item = stack_.Add(vtRegistr, regEDX);
				}
				stack_item->set_is_modified(true);

				reg_value = registr_values_.Add(regEDX, 0);
			}

			AddCommand(command_type);

			reg_value->Calc(command_type, 0, false, size, source_value, &flags_);
			if (cpu_address_size == osQWord && size == osDWord)
				reg_value->set_value(static_cast<uint32_t>(reg_value->value()));
			break;

		case cmStc:
		case cmCmc:
		case cmClc:
			if (flags_.mask() & fl_C) {
				stack_item = stack_.GetRegistr(regEFX);
				if (!stack_item)
					break;
				stack_item->set_is_modified(true);

				flags_.Calc(command_type, cpu_address_size, 0, 0, 0);
				AddCommand(command_type);
			}
			break;

		default:
			if (IntelStackValue *first_item = stack_.GetRandom(vtRegistr | vtValue)) {
				source_value = 0;

				command_flags = 0;
				bool inverse_flags = false;
				IntelStackValue *flags_item = NULL;

				if (command_type == cmSetXX || command_type == cmCmov) {
					command_flags = flags_.GetRandom();
					if (!command_flags)
						break;

					if (rand() & 1)
						inverse_flags = true;
				} 
				else switch (command_type) {
				case cmXor:
				case cmAnd:
				case cmTest:
				case cmOr:
				case cmNeg:
				case cmAdd:
				case cmAdc:
				case cmSub:
				case cmSbb:
				case cmCmp:
				case cmRor:
				case cmRol:
				case cmShr:
				case cmShl:
				case cmSar:
				case cmSal:
				case cmDec:
				case cmInc:
				case cmBt:
				case cmBtr:
				case cmBtc:
				case cmBts:
					flags_item = stack_.GetRegistr(regEFX);
					if (!flags_item)
						flags_item = NEED_STORE_FLAGS;
					break;
				}

				IntelOperand first_operand, second_operand;

				switch (rand() % 4) {
				case 0:
					first_operand.size = osByte;
					break;
				case 1:
					first_operand.size = osWord;
					break;
				case 2:
					first_operand.size = osDWord;
					break;
				default:
					first_operand.size = cpu_address_size;
					break;
				}

				if (first_item->type() == vtRegistr) {
					first_operand.type = otRegistr;
					first_operand.registr = static_cast<uint8_t>(first_item->value());

					if (!registr_values_.GetRegistr(first_operand.registr)) {
						command_type = cmMov;
						first_operand.size = cpu_address_size;
					}
				}
				else {
					first_operand.type = otMemory | otBaseRegistr | otValue;
					first_operand.base_registr = regESP;
					first_operand.value = (stack_.count() - 1 - stack_.IndexOf(first_item)) * OperandSizeToStack(cpu_address_size);
					if (flags_item == NEED_STORE_FLAGS)
						first_operand.value += OperandSizeToStack(cpu_address_size);
				}

				if (command_type == cmLea) {
					if (first_operand.type != otRegistr || !registr_values_.count())
						break;

					first_operand.size = cpu_address_size;
					second_operand.size = first_operand.size;

					reg_value = registr_values_.item(rand() % registr_values_.count());

					second_operand.type = otMemory | otRegistr | otValue;
					second_operand.registr = reg_value->registr();
					second_operand.scale_registr = rand() & 3;

					source_value = reg_value->value();
					if (second_operand.scale_registr)
						source_value = source_value << second_operand.scale_registr;

					if (rand() & 1) {
						reg_value = registr_values_.item(rand() % registr_values_.count());
						second_operand.type |= otBaseRegistr;
						second_operand.base_registr = reg_value->registr();
						source_value = source_value + reg_value->value();
					}

					second_operand.value_size = second_operand.size;
					switch (second_operand.size) {
					case osByte:
						second_operand.value = ByteToInt64(rand32());
						break;
					case osWord:
						second_operand.value = WordToInt64(rand32());
						break;
					default:
						second_operand.value = DWordToInt64(rand32());
						second_operand.value_size = osDWord;
						break;
					}
					source_value = source_value + second_operand.value;
				}
				else if (command_type == cmSetXX) {
					first_operand.size = osByte;
				}
				else if (command_type == cmShr || command_type == cmShl || command_type == cmSal || command_type == cmSar || command_type == cmRol || command_type == cmRor) {
					second_operand.size = osByte;
					switch (rand() % 2) {
					case 0:
						reg_value = registr_values_.GetRegistr(regECX);
						if (reg_value) {
							second_operand.type = otRegistr;
							second_operand.registr = reg_value->registr();

							source_value = reg_value->value();
							break;
						}
					default:
						second_operand.type = otValue;
						second_operand.value = static_cast<uint8_t>(rand());
						if (!second_operand.value)
							second_operand.value = 1;
						second_operand.value_size = second_operand.size;

						source_value = second_operand.value;
						break;
					}
				}
				else if (command_type != cmNot && command_type != cmNeg && command_type != cmBswap) {
					second_operand.size = first_operand.size;
					switch (rand() % 3) {
					case 0:
						if (registr_values_.count()) {
							reg_value = registr_values_.item(rand() % registr_values_.count());
							source_value = reg_value->value();

							second_operand.type = otRegistr;
							second_operand.registr = reg_value->registr();
							break;
						}
					case 1:
						if (first_operand.type == otRegistr) {
							stack_item = stack_.GetRandom(otValue);
							if (stack_item) {
								source_value = stack_item->value();

								second_operand.type = otMemory | otBaseRegistr | otValue;
								second_operand.base_registr = regESP;
								second_operand.value = (stack_.count() - 1 - stack_.IndexOf(stack_item)) * OperandSizeToStack(cpu_address_size);
								if (flags_item == NEED_STORE_FLAGS)
									second_operand.value += OperandSizeToStack(cpu_address_size);
								break;
							}
						}
					default:
						second_operand.type = otValue;
						second_operand.value_size = second_operand.size;
						switch (second_operand.size) {
						case osByte:
							second_operand.value = ByteToInt64(rand32());
							break;
						case osWord:
							second_operand.value = WordToInt64(rand32());
							break;
						case osQWord:
							if (command_type == cmMov && first_operand.type == otRegistr) {
								second_operand.value = rand64();
								break;
							}
						default:
							second_operand.value = DWordToInt64(rand32());
							second_operand.value_size = osDWord;
							break;
						}

						source_value = second_operand.value;
					}
				}

				if (command_type == cmCmov) {
					if (first_operand.type != otRegistr || first_operand.size == osByte || second_operand.type == otValue)
						break;
				}
				else if (command_type == cmMovsx || command_type == cmMovzx) {
					if (first_operand.type != otRegistr || first_operand.size == osByte || second_operand.type == otValue)
						break;

					second_operand.size = rand() & 1 ? osByte : osWord;
					if (first_operand.size == osQWord && command_type == cmMovsx && (rand() & 1)) {
						command_type = cmMovsxd;
						second_operand.size = osDWord;
					}

					if (command_type == cmMovzx) {
						switch (second_operand.size) {
						case osByte:
							source_value = static_cast<uint8_t>(source_value);
							break;
						case osWord:
							source_value = static_cast<uint16_t>(source_value);
							break;
						case osDWord:
							source_value = static_cast<uint32_t>(source_value);
							break;
						}
					}
					else {
						switch (second_operand.size) {
						case osByte:
							source_value = ByteToInt64(static_cast<uint8_t>(source_value));
							break;
						case osWord:
							source_value = WordToInt64(static_cast<uint16_t>(source_value));
							break;
						case osDWord:
							source_value = DWordToInt64(static_cast<uint32_t>(source_value));
							break;
						}
					}
				}
				else if (command_type == cmBt || command_type == cmBtr || command_type == cmBtc || command_type == cmBts) {
					if (first_operand.size == osByte || first_operand.type != otRegistr || (second_operand.type & otMemory))
						break;

					if (second_operand.type == otValue) {
						second_operand.size = osByte;
						second_operand.value_size = osByte;
						second_operand.value = static_cast<uint8_t>(second_operand.value);
						source_value = second_operand.value;
					}
				}
				else if (command_type == cmBswap) {
					if (first_operand.size == osByte || first_operand.size == osWord || first_operand.type != otRegistr)
						break;
				}

				if (cpu_address_size == osDWord) {
					if (first_operand.type == otRegistr && first_operand.size == osByte && first_operand.registr >= 4)
						break;
					if (second_operand.type == otRegistr && second_operand.size == osByte && second_operand.registr >= 4)
						break;
				}

				if (flags_item == NEED_STORE_FLAGS) {
					AddCommand(cmPushf, IntelOperand(otNone, func_->cpu_address_size(), 0));
					flags_item = stack_.Add(vtRegistr, regEFX);
				}
				if (flags_item)
					flags_item->set_is_modified(true);

				new_command = AddCommand(command_type, first_operand, second_operand);
				if (command_flags) {
					new_command->set_flags(command_flags);
					if (inverse_flags)
						new_command->include_option(roInverseFlag);
				}

				if (first_operand.type == otRegistr) {
					bool is_modified = (command_type != cmCmp && command_type != cmTest && command_type != cmBt);
					if (is_modified)
						first_item->set_is_modified(true);
					reg_value = registr_values_.GetRegistr(first_operand.registr);
					if (reg_value) {
						reg_value->Calc(command_type, command_flags, inverse_flags, first_operand.size, source_value, &flags_);
						if (is_modified) {
							if (cpu_address_size == osQWord && first_operand.size == osDWord)
								reg_value->set_value(static_cast<uint32_t>(reg_value->value()));
						}
					}
					else
						registr_values_.Add(first_operand.registr, source_value);
				}
				else {
					first_item->Calc(command_type, command_flags, inverse_flags, first_operand.size, source_value, &flags_);
				}
			}
			break;
		}
	}
}

IntelCommand *IntelFunction::AddGate(ICommand *to_command, AddressRange *address_range)
{
	size_t i;

	IntelVirtualMachine *virtual_machine = reinterpret_cast<IntelVirtualMachine *>(to_command->block()->virtual_machine());
	size_t old_count = count();

	IntelCommand *command = AddCommand(cmPush, IntelOperand(otValue, cpu_address_size()));
	CommandLink *link = command->AddLink(0, ltJmp, to_command);
	link->set_cryptor(virtual_machine->entry_cryptor());
	if (to_command && to_command->seh_handler())
		command->set_seh_handler(NEED_SEH_HANDLER);

	command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
	command->include_option(roUseAsJmp);
	command->AddLink(0, ltCall, virtual_machine->entry_command());
#ifndef DEMO
	if (false)
	if (virtual_machine->processor()->cpu_address_size() == cpu_address_size()) {
		IntelObfuscation engine;
		engine.Compile(this, old_count);
	}
#endif

	CommandBlock *cur_block = NULL;
	for (i = old_count; i < count(); i++) {
		if (!cur_block)
			cur_block = AddBlock(i, true);

		command = item(i);
		command->CompileToNative();
		command->set_block(cur_block);

		cur_block->set_end_index(i);
		if (command->is_end())
			cur_block = NULL;
	}

	IntelCommand *res = item(old_count);
	if (address_range) {
		cur_block = res->block();
		for (i = cur_block->start_index(); i <= cur_block->start_index(); i++) {
			command = item(i);
			command->set_address_range(address_range);
		}
	}

	return res;
}

IntelCommand *IntelFunction::AddShortGate(ICommand *to_command, AddressRange *address_range)
{
	CommandBlock *cur_block = AddBlock(count(), true);

	IntelCommand *res = AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size()));
	res->AddLink(0, ltJmp, to_command);
	if (to_command && to_command->seh_handler())
		res->set_seh_handler(NEED_SEH_HANDLER);

	cur_block->set_end_index(count() - 1);

	for (size_t i = cur_block->start_index(); i <= cur_block->end_index(); i++) {
		IntelCommand *command = item(i);
		command->CompileToNative();
		command->set_block(cur_block);
		if (address_range)
			command->set_address_range(address_range);
	}

	return res;
}

void IntelFunction::CompileToVM(const CompileContext &ctx)
{
	size_t i, j, c;
	IntelCommand *command;

	// create internal links
	c = link_list()->count();
	for (i = 0; i < count(); i++) {
		command = item(i);
		if (command->block() || (command->options() & roNeedCompile) == 0)
			continue;

		if (command->is_data()) {
			if (command->link() && command->link()->type() == ltCase) {
				// create blocks for CASEs
				CommandBlock *cur_block = NULL;
				for (j = i; j < count(); j++) {
					command = item(j);
					if (command->link() && command->link()->type() == ltCase) {
						if (command->block() || (command->options() & roNeedCompile) == 0 || is_breaked_address(command->address())) {
							cur_block = NULL;
							continue;
						}

						if (!cur_block || (command->options() & roCreateNewBlock)) {
							cur_block = AddBlock(j);
							cur_block->set_virtual_machine(virtual_machine(ctx.file->virtual_machine_list(), command));
						}
						cur_block->set_end_index(j);

						command->set_block(cur_block);

						command->CompileToVM(ctx);
					} else {
						break;
					}
				}
			} 
			continue;
		}

		if ((command->options() & roLockPrefix) && (command->options() & roNoNative) == 0) {
			command->AddLink(-1, ltNative);
			continue;
		} else {
			bool relocation_found = false;
			for (j = 0; j < 3; j++) {
				IntelOperand operand = command->operand(j) ;
				if (operand.type == otNone)
					break;

				if (operand.relocation) {
					relocation_found = true;
					break;
				}
			}
			if (relocation_found) {
				command->AddLink(-1, ltNative);
				continue;
			}
		}

		switch (command->type()) {
		case cmJmp: case cmCall: 
			if (command->options() & roFar)
				command->AddLink(-1, ltNative);
			break;
		case cmLods: case cmMovs: case cmScas: case cmCmps: case cmStos:
			if (command->preffix_command() == cmRep || command->preffix_command() == cmRepe || command->preffix_command() == cmRepne)
				command->AddLink(-1, ltNative);
			break;
		case cmCmov:
			command->AddLink(-1, ltJmpWithFlagNSNA);
			break;
		case cmXchg:
			if (((command->operand(0).type | command->operand(1).type) & otMemory) && (command->options() & roNoNative) == 0)
				command->AddLink(-1, ltNative);
			break;
		case cmFadd: case cmFsub: case cmFisub: case cmFsubr: case cmFdiv: case cmFmul: 
		case cmFcomp: case cmFild: case cmFld: case cmFstp: case cmFst:
			if (command->operand(0).type == otFPURegistr)
				command->AddLink(-1, ltNative);
			break;
		case cmPush: case cmPop: case cmMov: case cmMovsx: case cmMovsxd: case cmMovzx:
		case cmJmpWithFlag: case cmJCXZ: case cmLoop: case cmLoope: case cmLoopne:
		case cmRet: case cmIret: 
		case cmLea: case cmNop: case cmFnop:
		case cmNot: case cmNeg: case cmAdd: case cmAdc: case cmXadd:
		case cmSub: case cmCmp: case cmInc: case cmDec: case cmXlat: case cmSetXX:
		case cmAnd: case cmXor: case cmTest: case cmOr:
		case cmShld: case cmShrd:
		case cmRol: case cmRor: case cmRcl: case cmRcr:
		case cmShl: case cmSal: case cmShr: case cmSar:
		case cmCbw: case cmCwde: case cmCwd: case cmCdq: case cmCdqe: case cmCqo:
		case cmPushf: case cmPopf: case cmPusha: case cmPopa:
		case cmLahf: case cmSahf:
		case cmBt: case cmBtr: case cmBts: case cmBtc:
		case cmClc: case cmStc: case cmCmc: case cmCld: case cmStd:
		case cmBswap: case cmLeave:
		case cmImul: case cmMul: case cmDiv: case cmIdiv:
		case cmLes: case cmLds: case cmLfs: case cmLgs:
		case cmFstsw: case cmFldcw: case cmFstcw:
		case cmF2xm1: case cmFabs: case cmFclex: case cmFcos: case cmFdecstp: case cmFincstp:
		case cmFinit: case cmFldln2: case cmFldlg2: case cmFprem: case cmFprem1: case cmFptan:
		case cmFrndint: case cmFsin: case cmFtst: case cmFyl2x: case cmFpatan: case cmFldz: case cmFld1: case cmFldpi:
		case cmWait: case cmFchs: case cmFsqrt:
		case cmFistp: case cmFist: case cmRdtsc:
		case cmCrc:
			// do nothing
			break;

		default:
			if ((command->options() & roNoNative) == 0)
				command->AddLink(-1, ltNative);
			break;
		}
	}
	for (i = c; i < link_list()->count(); i++) {
		link_list()->item(i)->from_command()->PrepareLink(ctx);
	}

	// optimize flags 
	IntelCommand *flag_command = NULL;
	uint64_t flags = 0;
	IntelCommandInfoList command_info(cpu_address_size());
	for (i = 0; i < count(); i++) {
		command = item(i);

		if ((command->link() && command->link()->type() == ltNative) || !command->GetCommandInfo(command_info) || command_info.GetInfo(atWrite, otBaseRegistr, regEIP)) {
			flag_command = NULL;
			continue;
		}

		if (!flag_command) {
			if (command_info.change_flags()) {
				flag_command = command;
				flags = command_info.change_flags();
			}
		} else {
			if (command_info.need_flags()) {
				if ((command_info.need_flags() & flags) != 0) {
					flag_command = NULL;
					continue;
				}
			}
			if (command_info.change_flags()) {
				if ((command_info.change_flags() & flags) == flags) {
					flag_command->include_option(roNoSaveFlags);
					flag_command = command;
					flags = command_info.change_flags();
				}
			}
		}
	}

	// create VM blocks
	CommandBlock *cur_block = NULL;
	uint64_t cur_eip = (uint64_t)-1;
	for (i = 0; i < count(); i++) {
		command = item(i);
		if ((command->options() & roNoProgress) == 0)
			ctx.file->StepProgress();

		if (command->block() || (command->options() & roNeedCompile) == 0 || is_breaked_address(command->address())) {
			cur_block = NULL;
			continue;
		}

		bool is_data = command->is_data() && (!command->link() || command->link()->type() != ltNative);
		bool new_block = (!cur_block || (command->options() & roCreateNewBlock) || item(cur_block->end_index())->is_data() != is_data);
		if (new_block) {
			cur_block = AddBlock(i, is_data);
			if (!is_data)
				cur_block->set_virtual_machine(virtual_machine(ctx.file->virtual_machine_list(), command));
		}

		cur_block->set_end_index(i);

		command->set_block(cur_block);
		if (command->seh_handler())
			command->seh_handler()->set_deleted(true);
		if (is_data) {
			cur_eip = (uint64_t)-1;
		} else {
			if (command->block()->virtual_machine()->backward_direction())
				command->include_section_option(rtBackwardDirection);
			if (new_block || (command->section_options() & (rtLinkedToInt | rtLinkedToExt))) {
				command->AddExtSection(ctx, NULL);
				cur_eip = (uint64_t)-1;
			}
			cur_eip = command->AddStoreEIPSection(ctx, cur_eip);
			if (command->section_options() & rtLinkedToExt)
				command->AddStoreExtRegistersSection(ctx);
		}
		if (command->options() & roNeedCompile) {
			if (is_data) {
				command->CompileToNative();
			} else {
				command->CompileToVM(ctx);
			}
		}

		if (!is_data) {
			if ((command->section_options() & rtEndSection) == 0 && i < count() - 1 && (item(i + 1)->section_options() & (rtLinkedToInt | rtLinkedToExt))) 
				command->AddExtSection(ctx, item(i + 1));
		}

		if (command->section_options() & rtCloseSection)
			cur_block = NULL;
	}

	// create gates for external commands
	ExtCommandList *ext_list = ext_command_list();
	for (i = 0; i < ext_list->count(); i++) {
		ExtCommand *ext_command = ext_list->item(i);
		if (!ext_command->command() || is_breaked_address(ext_command->address()))
			continue;

		command = AddGate(ext_command->command(), ext_command->command()->address_range());
		
		if (ext_command->address()) {
			command = AddShortGate(command, NULL);
			command->block()->set_address(ext_command->address());
		}

		if (entry() == ext_command->command())
			set_entry(command);
	}
}

bool IntelFunction::Compile(const CompileContext &ctx)
{
	switch (compilation_type()) {
	case ctMutation: //bian yi
		CompileToNative(ctx);
		break;
	case ctVirtualization: //xu ni hua
		CompileToVM(ctx);
		break;
	case ctUltra://xu ni hua + bian yi
		Mutate(ctx, true);
		CompileToVM(ctx);
		break;
	default:
		return false;
	}

	return BaseFunction::Compile(ctx);
}

void IntelFunction::AfterCompile(const CompileContext &ctx)
{
	size_t i, j, c;
	IntelCommand *command, *from_command, *gate_command, *native_command;
	CommandBlock *block;
	CommandLink *link;

	if (compilation_type() == ctMutation) {
		for (i = 0; i < link_list()->count(); i++) {
			link = link_list()->item(i);
			if (!link->to_command())
				continue;

			from_command = reinterpret_cast<IntelCommand *>(link->from_command());
			if ((from_command->section_options() & rtLinkedFromOtherType) && !link->to_command()->is_data())
				link->set_to_command(AddGate(link->to_command(), NULL));

			switch (link->type()) {
			case ltMemSEHBlock: case ltExtSEHHandler: case ltVBMemSEHBlock:
				if (from_command->address()) {
					block = AddBlock(count(), true);
					command = from_command->Clone(this);
					AddObject(command);
					command->set_block(block);
					block->set_address(command->address());

					CommandLink *dst_link = command->AddLink(0, ltOffset, link->to_command());
					dst_link->set_sub_value(link->sub_value());
				}
				break;
			}
		}
	} else {
		// create native gates for links
		c = count();
		for (i = 0; i < c; i++) {
			from_command = item(i);
			link = from_command->link();
			if (!link)
				continue;

			IntelCommand *to_command = reinterpret_cast<IntelCommand *>(link->to_command());
			ICommand *next_command = link->next_command();
			IntelCommand *parent_command = reinterpret_cast<IntelCommand *>(link->parent_command());

			if (to_command && to_command->block() && (to_command->block()->type() & mtExecutable) == 0) {
				// to VM block
				switch (link->type()) {
				case ltGateOffset:
					link->set_to_command(AddGate(to_command, to_command->address_range()));
					break;
				case ltMemSEHBlock: case ltExtSEHHandler: case ltVBMemSEHBlock:
					if (to_command) {
						if (from_command->address()) {
							block = AddBlock(count(), true);
							native_command = from_command->Clone(this);
							AddObject(native_command);
							native_command->set_block(block);
							block->set_address(native_command->address());
						}
						else {
							native_command = NULL;
						}

						gate_command = AddGate(to_command, to_command->address_range());

						if (native_command) {
							CommandLink *dst_link = native_command->AddLink(0, ltOffset, gate_command);
							dst_link->set_sub_value(link->sub_value());
						}

						link->set_to_command(gate_command);
					}
					break;
				}
			}

			if (from_command->block() && (from_command->block()->type() & mtExecutable) == 0) {
				// from VM block
				switch (link->type()) {
				case ltSEHBlock: case ltFinallyBlock: case ltExtSEHBlock:
					if (to_command)
						link->AddGateCommand(AddGate(to_command, to_command->address_range()));
					break;

				case ltCall:
					if (next_command && (from_command->options() & roInternal) == 0) {
						if (from_command->address_range()) {
							Data data;
							data.PushByte(rand());
							command = AddCommand(data);
							command->set_address_range(from_command->address_range());
							gate_command = AddGate(next_command, next_command->address_range());
							command->set_block(gate_command->block());
							command->block()->set_start_index(command->block()->start_index() - 1);
						}
						else {
							gate_command = AddGate(next_command, next_command->address_range());
						}
					}
					else {
						gate_command = NULL;
					}

					link->AddGateCommand(gate_command);
					break;

				case ltNative:
					native_command = from_command->Clone(this);
					AddObject(native_command);

					if (next_command) {
						gate_command = AddGate(next_command, native_command->address_range());
					}
					else {
						gate_command = AddShortGate(NULL, native_command->address_range());
						gate_command->set_operand_value(0, from_command->address() + from_command->original_dump_size());
						gate_command->CompileToNative();
					}
					block = gate_command->block();
					block->set_start_index(block->start_index() - 1);
					native_command->set_block(block);

					link->AddGateCommand(native_command);
					break;

				case ltDualSEHBlock:
					if (to_command) {
						block = AddBlock(count(), true);
						gate_command = reinterpret_cast<IntelCommand *>(to_command->Clone(this));
						AddObject(gate_command);
						CommandLink *src_link = to_command->link();
						if (src_link) {
							CommandLink *dst_link = src_link->Clone(link_list());
							dst_link->set_from_command(gate_command);
							dst_link->set_to_command(src_link->to_command());
							link_list()->AddObject(dst_link);
						}
						command = new IntelCommand(this, cpu_address_size(), cmJmp, IntelOperand(otValue, cpu_address_size(), 0, link->to_address() + 5));
						AddObject(command);
						command->AddLink(0, ltJmp, next_command);
						block->set_end_index(count() - 1);

						if (gate_command->link()->to_command())
							gate_command->link()->set_to_command(AddGate(gate_command->link()->to_command(), gate_command->address_range()));

						if (command->link()->to_command())
							command->link()->set_to_command(AddGate(command->link()->to_command(), command->address_range()));

						for (j = block->start_index(); j <= block->end_index(); j++) {
							command = item(j);
							command->set_block(block);
							command->CompileToNative();
						}

						link->AddGateCommand(gate_command);
					}
					break;

				case ltFilterSEHBlock:
					if (to_command) {
						block = AddBlock(count(), true);
						size_t index = IndexOf(to_command);
						size_t n = 2 + static_cast<uint32_t>(reinterpret_cast<IntelCommand *>(link->parent_command())->operand(0).value) * 2;
						for (j = 0; j < n; j++) {
							native_command = item(index + j);
							command = native_command->Clone(this);
							AddObject(command);
							CommandLink *src_link = native_command->link();
							if (src_link) {
								CommandLink *dst_link = src_link->Clone(link_list());
								dst_link->set_from_command(command);
								dst_link->set_to_command(src_link->to_command());
								link_list()->AddObject(dst_link);
							}
							command->set_block(block);
						}
						block->set_end_index(count() - 1);
						for (j = block->start_index(); j <= block->end_index(); j++) {
							CommandLink *src_link = item(j)->link();
							if (!src_link || !src_link->to_command())
								continue;

							src_link->set_to_command(AddGate(src_link->to_command(), src_link->from_command()->address_range()));
						}
						gate_command = item(block->start_index());
						link->AddGateCommand(gate_command);
					}
					break;

				case ltCase:
					if (to_command) {
						block = AddBlock(count());
						block->set_virtual_machine(parent_command->block()->virtual_machine());

						command = AddCommand(cmJmp);
						command->AddLink(-1, ltNone);
						command->include_section_option(rtLinkedToInt);
						command->set_block(block);
						if (command->block()->virtual_machine()->backward_direction())
							command->include_section_option(rtBackwardDirection);

						command->AddBeginSection(ctx);
						if (from_command->section_options() & rtLinkedFrom) {
							command->AddVMCommand(ctx, cmPush, otValue, cpu_address_size(), 0, voLinkCommand | voFixup);
							command->AddEndSection(ctx, cmJmp, 0);
						}
						else {
							command->AddVMCommand(ctx, cmPush, otValue, cpu_address_size(), 0, voLinkCommand | voFixup);
							command->AddEndSection(ctx, cmRet);
						}
						link->AddGateCommand(command);
					}
					break;
				}
			}
		}
	}

	for (i = 0; i < count(); i++) {
		command = item(i);
		if (!command->block())
			continue;

		for (j = 0; j < 3; j++) {
			IntelOperand operand = command->operand(j);
			if (operand.type == otNone)
				break;

			IFixup *fixup = operand.fixup;
			if (fixup && fixup != NEED_FIXUP) {
				if (command->options() & roClearOriginalCode)
					fixup->set_deleted(true);
				if (command->block()->type() & mtExecutable) {
					if (command->block()->address()) {
						fixup->set_deleted(false);
					}
					else {
						fixup = fixup->Clone(ctx.file->fixup_list());
						ctx.file->fixup_list()->AddObject(fixup);
						fixup->set_deleted(false);
						command->set_operand_fixup(j, fixup);
					}
				}
				else {
					for (size_t k = 0; k < command->count(); k++) {
						IntelVMCommand *vm_command = command->item(k);
						if (vm_command->fixup()) {
							fixup = fixup->Clone(ctx.file->fixup_list());
							ctx.file->fixup_list()->AddObject(fixup);
							fixup->set_deleted(false);
							vm_command->set_fixup(fixup);
						}
					}
				}
			}
		}
	}

	if (function_info_list()->count()) {
		std::set<AddressRange *> range_list;

		for (i = 0; i < block_list()->count(); i++) {
			CommandBlock *block = block_list()->item(i);
			if ((block->type() & mtExecutable) == 0)
				continue;

			AddressRange *block_range = item(block->start_index())->address_range();
			if (block_range)
				range_list.insert(block_range);

			for (j = block->start_index(); j <= block->end_index(); j++) {
				AddressRange *range = item(j)->address_range();
				if (range && range != block_range)
					range_list.insert(range);
			}
		}

		for (i = 0; i < function_info_list()->count(); i++) {
			FunctionInfo *info = function_info_list()->item(i);
			for (size_t j = 0; j < info->count(); j++) {
				AddressRange *range = info->item(j);
				if (range_list.find(range) == range_list.end()) {
					Data data;
					data.PushByte(rand());

					CommandBlock *block = AddBlock(count(), true);
					ICommand *command = AddCommand(data);
					command->set_block(block);
					command->set_address_range(range);
				}
			}
		}
	}
}

void IntelFunction::CompileInfo(const CompileContext &ctx)
{
	BaseFunction::CompileInfo(ctx);

	size_t i;
	FunctionInfo *info;
	AddressRange *range;
	uint64_t base_value;
	IntelCommand *command;

	for (i = 0; i < range_list()->count(); i++) {
		range = range_list()->item(i);
		info = range->link_info();
		if (!info)
			continue;

		switch (info->base_type()) {
		case btImageBase:
			base_value = ctx.file->image_base();
			break;
		case btFunctionBegin:
			base_value = info->begin();
			break;
		default:
			base_value = info->base_value();
			break;
		}

		if (range->begin_entry()) {
			command = reinterpret_cast<IntelCommand *>(range->begin_entry());
			if (command->type() == cmDC) {
				AddressRange *prev = NULL;
				for (size_t j = 0; j < i; j++) {
					AddressRange *tmp = range_list()->item(j);
					if (tmp->link_info() == info && tmp->original_end() == range->original_begin() && tmp->begin_entry()) {
						prev = tmp;
						break;
					}
				}
				base_value = prev ? prev->begin() : info->begin();
			}
			command->set_operand_value(0, range->begin() - base_value);
			command->CompileToNative();
		}
		if (range->end_entry()) {
			command = reinterpret_cast<IntelCommand *>(range->end_entry());
			command->set_operand_value(0, range->end() - base_value);
			command->CompileToNative();
		}
		if (range->size_entry()) {
			command = reinterpret_cast<IntelCommand *>(range->size_entry());
			command->set_operand_value(0, range->end() - range->begin());
			if (command->type() == cmDB) {
				uint32_t size = static_cast<uint32_t>(command->operand(0).value);
				Data data;
				if (command->comment().value == "UWOP_EPILOG") {
					uint32_t offset = static_cast<uint8_t>(info->end() - range->begin());
					UNWIND_CODE unwind_code;
					unwind_code.FrameOffset = static_cast<uint16_t>(command->dump_value(0, osWord));
					if (unwind_code.OpInfo & 1) {
						unwind_code.CodeOffset = static_cast<uint8_t>(offset);
						data.PushWord(unwind_code.FrameOffset);
					} else {
						unwind_code.CodeOffset = static_cast<uint8_t>(size);
						data.PushWord(unwind_code.FrameOffset);
						unwind_code.CodeOffset = static_cast<uint8_t>(offset);
						unwind_code.OpInfo = static_cast<uint8_t>(offset >> 8);
						data.PushWord(unwind_code.FrameOffset);
					}
					command->set_dump(data.data(), data.size());
				} else if (command->comment().value.substr(0, 18) == "DW_CFA_advance_loc") {
					if (size <= 0x3f) {
						data.PushByte(DW_CFA_advance_loc | (size & 0x3f));
					}
					else if (size <= 0xff) {
						data.PushByte(DW_CFA_advance_loc1);
						data.PushByte(static_cast<uint8_t>(size));
					}
					else if (size <= 0xffff) {
						data.PushByte(DW_CFA_advance_loc2);
						data.PushWord(static_cast<uint16_t>(size));
					}
					else {
						data.PushByte(DW_CFA_advance_loc4);
						data.PushDWord(size);
					}
					command->set_dump(data.data(), data.size());
				}
			} else 
				command->CompileToNative();
		}
	}
}

void IntelFunction::CompileLinks(const CompileContext &ctx)
{
	BaseFunction::CompileLinks(ctx);

	bool need_encrypt = (ctx.options.flags & cpEncryptBytecode) != 0;
	for (size_t i = 0; i < block_list()->count(); i++) {
		CommandBlock *block = block_list()->item(i);

		// skip native blocks
		if (block->type() & mtExecutable)
			continue;

		IntelVirtualMachine *virtual_machine = reinterpret_cast<IntelVirtualMachine *>(block->virtual_machine());
		virtual_machine->CompileBlock(*block, need_encrypt);
	}
}

void IntelFunction::AddWatermarkReference(uint64_t address, const std::string &value)
{
	IntelCommand *ref_command = GetCommandByAddress(address);
	if (!ref_command || value.empty())
		return;

	uint32_t key = rand32();
	uint16_t len = static_cast<uint16_t>(value.size());
	Data data;
	data.PushDWord(key);
	data.PushWord(len);
	for (size_t i = 0; i < value.size(); i++) {
		data.PushByte(value[i] ^ static_cast<uint8_t>(_rotl32(key, (int)i) + i));
	}
	IntelCommand *data_command = AddCommand(data);

	switch (ref_command->type()) {
	case cmLea:
		{
			IntelCommand *mem_command = AddCommand(cpu_address_size() == osDWord ? cmDD : cmDQ, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
			mem_command->AddLink(0, ltOffset, data_command);
			mem_command->CompileToNative();

			ref_command->AddLink(1, ltOffset, mem_command);
		}
		break;
	case cmMov:
		ref_command->Init(cmLea, ref_command->operand(0), ref_command->operand(1));
		ref_command->AddLink(1, ltOffset, data_command);
		break;
	default:
		throw std::runtime_error("Unknown reference command");
	}
}

void IntelFunction::ReadFromBuffer(Buffer &buffer, IArchitecture &file)
{
	BaseFunction::ReadFromBuffer(buffer, file);

	size_t i, j, k;
	IntelCommand *command;
	bool syscall_found = false;

	for (i = 0; i < count(); i++) {
		command = item(i);
		if (command->type() == cmCpuid || command->type() == cmSbb)
			command->include_option(roNoNative);
		else if (command->type() == cmPopf) {
			Data data;
			command->CompileToNative();
			for (k = 0; k < command->dump_size(); k++) {
				data.PushByte(command->dump(k));
			}
			command->Init(cmNop);

			for (j = i; j < count(); j++) {
				command = item(j);
				if (command->type() == cmCpuid || command->type() == cmRdtsc) {
					command->CompileToNative();
					for (k = 0; k < command->dump_size(); k++) {
						data.PushByte(command->dump(k));
					}
					data.PushByte(0x90);
					command->Init(data);
					command->AddLink(-1, ltNative);
					break;
				}
			}
		} else if (command->operand(1).type == otValue && static_cast<uint32_t>(command->operand(1).value) == FACE_SYSCALL) {
			command->set_operand_value(1, 0);
			command->CompileToNative();
			IntelOperand operand = command->operand(0);
			IntelCommandInfoList command_info_list(cpu_address_size());
			size_t cur_index = i + 1;
			std::vector<size_t> stack;

			while (cur_index < count()) {
				command = item(cur_index);
				bool is_end = command->is_end();
				if (command->type() == cmMov) {
					if (operand.type == otRegistr && command->operand(1) == operand) {
						operand = command->operand(0);
						cur_index++;
						continue;
					}
				} else if (command->type() == cmCall) {
					if (command->operand(0) == operand) {
						command->Init(cmSyscall, command->operand(0));
						command->CompileToNative();
						command->include_option(roNoNative);
						syscall_found = true;
					}
					if (operand.type != otRegistr || operand.registr == regEAX)
						is_end = true;
				} else if ((command->type() == cmJmp || command->type() == cmJmpWithFlag) && command->link()) {
					IntelCommand *link_command = GetCommandByAddress(command->link()->to_address());
					if (link_command) {
						k = IndexOf(link_command);
						if (k != NOT_ID)
							stack.push_back(k);
					}
				}
				if (command->GetCommandInfo(command_info_list)) {
					if (operand.type == otRegistr && command_info_list.GetInfo(atWrite, otRegistr, operand.registr))
						is_end = true;
				} else {
					is_end = true;
				}

				if (is_end) {
					for (k = stack.size(); k > 0; k--) {
						if (stack[k - 1] <= cur_index)
							stack.erase(stack.begin() + k - 1);
					}
					if (stack.empty())
						break;

					cur_index = stack[0];
					for (k = 0; k < stack.size(); k++) {
						if (cur_index > stack[k])
							cur_index = stack[k];
					}
				} else {
					cur_index++;
				}
			}
		}
	}

	if (syscall_found) {
		CallingConvention calling_convention = file.calling_convention();
		for (i = 0; i < count(); i++) {
			command = item(i);
			if (command->type() != cmSyscall)
				continue;

			IntelCommand *next_command = item(i + 1);
			if (next_command->type() == cmAdd && next_command->operand(0).type == otRegistr && next_command->operand(0).registr == regESP)
				continue;

			k = 0;
			for (j = i; j > 0; j--) {
				IntelCommand *param_command = item(j - 1);

				switch (param_command->type()) {
				case cmPush:
					if (calling_convention == ccStdcall) {
						k++;
					}
					else {
						param_command = NULL;
					}
					break;
				case cmMov: case cmLea: case cmXor: case cmMovsxd:
					if (calling_convention == ccMSx64) {
						if (param_command->operand(0).type == otRegistr) {
							switch (param_command->operand(0).registr) {
							case regECX:
								k = std::max<size_t>(k, 1);
								break;
							case regEDX:
								k = std::max<size_t>(k, 2);
								break;
							case regR8:
								k = std::max<size_t>(k, 3);
								break;
							case regR9:
								k = std::max<size_t>(k, 4);
								break;
							}
						}
						else if (param_command->operand(0).type == (otMemory | otBaseRegistr | otValue) && param_command->operand(0).base_registr == regESP) {
							switch (param_command->operand(0).value) {
							case 0x20:
								k = std::max<size_t>(k, 5);
								break;
							case 0x28:
								k = std::max<size_t>(k, 6);
								break;
							case 0x30:
								k = std::max<size_t>(k, 7);
								break;
							case 0x38:
								k = std::max<size_t>(k, 8);
								break;
							case 0x40:
								k = std::max<size_t>(k, 9);
								break;
							case 0x48:
								k = std::max<size_t>(k, 10);
								break;
							default:
								if (param_command->operand(0).value >= 0x50)
									k = NOT_ID;
								break;
							}
						}
					}
					break;
				case cmCall: case cmJmp: case cmJmpWithFlag: case cmRet:
					param_command = NULL;
					break;
				}
				if (!param_command || link_list()->GetLinkByToAddress(ltNone, param_command->address()))
					break;
			}
			if (k == NOT_ID)
				continue;

			command->include_option(roInternal);
			command->set_operand_value(2, k);
		}
	}

	if (file.owner()->format_name() != "PE" && compilation_type() != ctMutation && cpu_address_size() == osQWord) {
		// clang can use stack less than RSP
		bool is_use_rbp = false;
		uint64_t delta_rsp = 0;
		uint64_t sub_rsp_value = 0;
		for (j = 0; j < count(); j++) {
			command = item(j);
			switch (command->type()) {
			case cmMov:
				if (command->operand(0).type == otRegistr && command->operand(0).registr == regEBP && command->operand(1).type == otRegistr && command->operand(1).registr == regESP) {
					is_use_rbp = true;
				} else if (is_use_rbp && ((command->operand(0).type == (otMemory | otRegistr | otValue) && command->operand(0).registr == regEBP) 
										|| ((command->operand(0).type & (otMemory | otBaseRegistr | otValue)) == (otMemory | otBaseRegistr | otValue) && command->operand(0).base_registr == regEBP))) {
					uint64_t value = command->operand(0).value;
					if (static_cast<int64_t>(value) < 0 && 0 - value > delta_rsp) {
						sub_rsp_value = std::max((0 - value) - delta_rsp, sub_rsp_value);
					}
				} else if (((command->operand(0).type == (otMemory | otRegistr | otValue) && command->operand(0).registr == regESP) 
										|| ((command->operand(0).type & (otMemory | otBaseRegistr | otValue)) == (otMemory | otBaseRegistr | otValue) && command->operand(0).base_registr == regESP))) {
					uint64_t value = command->operand(0).value;
					if (static_cast<int64_t>(value) < 0)
						sub_rsp_value = std::max((0 - value), sub_rsp_value);
				}
				break;
			case cmPush:
				if (is_use_rbp)
					delta_rsp += OperandSizeToValue(cpu_address_size());
				break;
			case cmSub:
				if (is_use_rbp && command->operand(0).type == otRegistr && command->operand(0).registr == regESP && command->operand(1).type == otValue) {
					delta_rsp += command->operand(1).value;
				}
				break;
			}
		}
		if (sub_rsp_value) {
			size_t push_index = 0;
			size_t pop_index = 0;
			for (j = 0; j < count(); j++) {
				IntelCommand *command = item(j);

				for (i = 0; i < 3; i++) {
					IntelOperand operand = command->operand(i);
					if (operand.type == otNone)
						break;

					if (((operand.type & (otMemory | otRegistr)) == (otMemory | otRegistr) && operand.registr == regESP)
						|| ((operand.type & (otMemory | otBaseRegistr)) == (otMemory | otBaseRegistr) && operand.base_registr == regESP)) {
						command->set_operand_value(i, operand.value + sub_rsp_value);
						command->CompileToNative();
					}
				}

				switch (command->type()) {
				case cmPush:
					push_index = j;
					break;
				case cmMov:
					if (command->operand(0).type == otRegistr && command->operand(0).registr == regEBP && command->operand(1).type == otRegistr && command->operand(1).registr == regESP)
						push_index = j;
					break;
				case cmPop:
				case cmRet:
					if (!pop_index)
						pop_index = j;
					break;
				}
			}

			command = new IntelCommand(this, cpu_address_size(), cmSub, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, sub_rsp_value));
			command->CompileToNative();
			InsertObject(push_index + 1, command);

			if (pop_index > push_index)
				pop_index++;

			IntelCommand *pop_command = item(pop_index);

			command = new IntelCommand(this, cpu_address_size(), static_cast<IntelCommandType>(pop_command->type()), pop_command->operand(0), pop_command->operand(1));
			command->CompileToNative();
			InsertObject(pop_index + 1, command);

			pop_command->Init(cmAdd, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, sub_rsp_value));
			pop_command->CompileToNative();
		}
	}

#ifdef CHECKED
	for (i = 0; i < count(); i++) {
		item(i)->update_hash();
	}
#endif
}

/**
 * SectionCryptor
 */

SectionCryptor::SectionCryptor(SectionCryptorList *owner, OperandSize cpu_address_size)
	: owner_(owner), parent_cryptor_(NULL)
{
	size_t i;

	registr_order_.push_back(regEFX);
	registr_order_.push_back(regEAX);
	registr_order_.push_back(regECX);
	registr_order_.push_back(regEDX);
	registr_order_.push_back(regEBX);
	registr_order_.push_back(regEBP);
	registr_order_.push_back(regESI);
	registr_order_.push_back(regEDI);
	if (cpu_address_size == osQWord) {
		for (i = 8; i < 16; i++) {
			registr_order_.push_back((uint8_t)i);
		}
	}
	for (i = 0; i < registr_order_.size(); i++) {
		std::swap(registr_order_[i], registr_order_[rand() % registr_order_.size()]);
	}
}

SectionCryptor::~SectionCryptor()
{
	if (owner_)
		owner_->RemoveObject(this);
}

void SectionCryptor::set_end_cryptor(SectionCryptor *cryptor) 
{ 
	if (cryptor == this || cryptor->end_cryptor() == this)
		return;

	if (parent_cryptor_)
		parent_cryptor_->set_end_cryptor(cryptor);
	else
		parent_cryptor_ = cryptor;
}

SectionCryptor *SectionCryptor::end_cryptor()
{ 
	SectionCryptor *cur_cryptor = this;
	while (cur_cryptor->parent_cryptor_) {
		cur_cryptor = cur_cryptor->parent_cryptor_;
	}
	return cur_cryptor;
}

/**
 * SectionCryptorList
 */

SectionCryptorList::SectionCryptorList(IFunction *owner)
	: ObjectList<SectionCryptor>(), owner_(owner)
{

}

SectionCryptor *SectionCryptorList::Add()
{
	SectionCryptor *section_cryptor = new SectionCryptor(this, owner_->cpu_address_size());
	AddObject(section_cryptor);
	return section_cryptor;
}

/**
 * IntelFileHelper
 */

IntelFileHelper::IntelFileHelper()
	: IObject(), marker_index_(0)
{
	marker_name_list_ = new MapFunctionList(NULL);
}

IntelFileHelper::~IntelFileHelper()
{
	delete marker_name_list_;
}

void IntelFileHelper::AddMarker(IArchitecture &file, uint64_t address, uint64_t name_reference, uint64_t name_address, ObjectType type, uint8_t tag, bool is_unicode)
{
	if (type == otUnknown)
		return;

	std::string marker_name;
	MapFunction *map_function;
	size_t name_length = 0;
	if (name_address) {
		// read marker name
		if (file.AddressSeek(name_address)) {
			if (is_unicode) {
				os::unicode_string wname;
				for (;;) {
					os::unicode_char w = file.ReadWord();
					if (w == 0)
						break;
					wname.push_back(w);
				}
				name_length = (wname.size() + 1) * sizeof(os::unicode_char);
				marker_name = os::ToUTF8(wname);
			} else {
				for (;;) {
					char c = file.ReadByte();
					if (c == 0)
						break;
					marker_name.push_back(c);
				}
				name_length = marker_name.size() + 1;
				marker_name = file.ANSIToUTF8(marker_name);
			}
		}

		map_function = marker_name_list_->GetFunctionByAddress(name_address);
		if (!map_function) {
			map_function = marker_name_list_->Add(name_address, name_address + name_length, otString, marker_name);
			// need add marker name to string_list for string references searching
			string_list_.push_back(map_function);
		}
		map_function->reference_list()->Add(name_reference, 0);
	}

	std::string name = marker_name.empty() ? string_format("VMProtectMarker%d", ++marker_index_) : string_format("VMProtectMarker \"%s\"", marker_name.c_str());

	map_function = file.map_function_list()->GetFunctionByAddress(address);
	if (!map_function) {
		map_function = file.map_function_list()->Add(address, 0, type, name);
	} else {
		map_function->set_type(type);
		map_function->set_name(name);
	}
	map_function->set_name_address(name_address);
	map_function->set_name_length(name_length);
	switch (tag & 0x7f) {
	case 1:
		map_function->set_compilation_type(ctVirtualization);
		break;
	case 2:
		map_function->set_compilation_type(ctMutation);
		break;
	case 3:
		map_function->set_compilation_type(ctUltra);
		break;
	}
	if (tag & 0x80)
		map_function->set_lock_to_key(true);
}

void IntelFileHelper::AddString(IArchitecture &file, uint64_t address, uint64_t reference, bool is_unicode)
{
	uint64_t end_address;
	std::string name;
	os::unicode_string wname;
	char c;
	os::unicode_char w;
	MapFunction *map_function;

	if (!file.AddressSeek(address))
		return;

	// read string from file
	if (is_unicode) {
		for (;;) {
			w = file.ReadWord();
			if (w == 0)
				break;
			wname.push_back(w);
		}
		end_address = address + (wname.size() + 1) * sizeof(w);
		name = os::ToUTF8(wname);
	} else {
		for (;;) {
			c = file.ReadByte();
			if (c == 0)
				break;
			name.push_back(c);
		}
		end_address = address + name.size() + 1;
		name = file.ANSIToUTF8(name);
	}
	name = "string \"" + name + "\"";

	map_function = file.map_function_list()->Add(address, end_address, otString, name);
	map_function->reference_list()->Add(reference, address);

	if (std::find(string_list_.begin(), string_list_.end(), map_function) == string_list_.end())
		string_list_.push_back(map_function);
}

void IntelFileHelper::AddEndMarker(IArchitecture &file, uint64_t address, uint64_t next_address, ObjectType type)
{
	file.end_marker_list()->Add(address, next_address, 0, 0, type);
}

void IntelFileHelper::Parse(IArchitecture &file)
{
	SignatureList asm_signatures, import_signatures, string_signatures, compiler_function_signatures;
	ISectionList *segment_list;
	size_t i, k, j, r, n, pointer_size, c;
	ISection *segment;
	uint64_t read_size, address, buf_address, operand_address, tmp_address, pointer_value, last_operand_address;
	uint8_t buf[4096], b, registr;
	Signature *sign;
	IntelFunctionList function_list(NULL);
	IntelFunction command_list(NULL, file.cpu_address_size());
	IntelCommand *command, *tmp_command;
	IImportFunction *import_function;
	IntelOperand operand, tmp_operand;
	IFixupList *fixup_list;
	IImportList *import_list;
	std::map<uint64_t, IImportFunction *> jmp_references;
	MarkerCommandList marker_command_list;
	MarkerCommand *marker_command;
	MapFunction *map_function;
	MapFunctionList *map_function_list;
	CompilerFunctionList *compiler_function_list;
	bool is_data_reference;
	std::map<uint64_t, IImportFunction *> call_import_function_map;

	asm_signatures.Add("EB10564D50726F7465637420626567696E0?");	// "VMProtect begin"
	asm_signatures.Add("EB0E564D50726F7465637420656E6400");	// "VMProtect end"

	import_signatures.Add("FF15");  // call dword ptr [xxxx]
	import_signatures.Add("FF25");  // jmp dword ptr [xxxx]
	import_signatures.Add("FF2425");// jmp dword ptr [xxxx]
	import_signatures.Add("E8");    // call xxxx
	import_signatures.Add("A1");    // mov eax, [xxxx]
	import_signatures.Add((file.cpu_address_size() == osQWord) ? "4?8B" : "8B");  // mov reg, [xxxx]
	import_signatures.Add((file.cpu_address_size() == osQWord) ? "4?8D" : "8D");  // lea reg, [xxxx]
	uint64_t plt_got_address = 0;

	if (file.cpu_address_size() == osDWord) {
		// patch TlsAlloc in Delphi6
		compiler_function_signatures.Add("5352BA????????89C38B5203B8????????8B12B905000000", cfPatchImport);

		// base registr
		compiler_function_signatures.Add("E8000000005?", cfBaseRegistr);

		// get base registr
		compiler_function_signatures.Add("8B1C24C3", cfGetBaseRegistr);
		compiler_function_signatures.Add("8B3424C3", cfGetBaseRegistr);
		compiler_function_signatures.Add("8B0424C3", cfGetBaseRegistr);
		compiler_function_signatures.Add("8B0C24C3", cfGetBaseRegistr);
		compiler_function_signatures.Add("8B1424C3", cfGetBaseRegistr);

		// DllFunctionCall in VB6
		compiler_function_signatures.Add("A1????????0BC07402FFE068????????B8????????FFD0FFE0", cfDllFunctionCall);

		// CxxSEH
		compiler_function_signatures.Add("6AFF68????????64A100000000", cfCxxSEH);
		compiler_function_signatures.Add("6AFF68????????68????????64A100000000", cfCxxSEH3);
		compiler_function_signatures.Add("6AFE68????????68????????64A100000000", cfCxxSEH4);
		compiler_function_signatures.Add("68????????64FF3500000000", cfSEH4Prolog);

		// VB6SEH
		compiler_function_signatures.Add("83EC??68????????64A1000000005064892500000000", cfVB6SEH);
		compiler_function_signatures.Add("81EC??????68????????64A1000000005064892500000000", cfVB6SEH);

		// __InitExceptBlockLDTC in BCB
		compiler_function_signatures.Add("538BDD03580?8943088D44240889430CC74304????????66C74310000066C743120000C7431C000000006467A1000089036467891E00005BC3", cfInitBCBSEH);

		// _pei386_runtime_relocator in MinGW
		compiler_function_signatures.Add("C705????????01000000B8????????2D????????83F8077EDDBB????????83F80B7E618B3D????????85FF750B8B35????????85F6743D", cfRelocatorMinGW);
		compiler_function_signatures.Add("C705????????01000000E8????????8D04408D04851E00000083E0F0E8????????C705????????0000000029C48D44241F83E0F0A3????????B8????????2D????????83F8070F8E??00000083F80B0F8E??010000A1????????85C00F85??000000A1????????85C00F85??000000", cfRelocatorMinGW);
		compiler_function_signatures.Add("C705????????01000000E8????????8D04408D04851E000000C1E804C1E004E8????????C705????????0000000029C48D44241F83E0F0A3????????B8????????2D????????83F807", cfRelocatorMinGW);

		if (file.owner()->format_name() == "ELF") {
			import_signatures.Add("E9");    // jmp xxxx
			if (ELFDirectory *plt_got = reinterpret_cast<ELFArchitecture &>(file).command_list()->GetCommandByType(DT_PLTGOT)) {
				plt_got_address = plt_got->value();
				import_signatures.Add("FFA3");  // jmp dword ptr [ebx + xxxx]
			}
		}
	}
	else {
		compiler_function_signatures.Add("554889E55DE9????????", cfJmpFunction);
	}

	segment_list = file.segment_list();
	fixup_list = file.fixup_list();
	import_list = file.import_list();
	map_function_list = file.map_function_list();
	compiler_function_list = file.compiler_function_list();

	for (i = 0; i < import_list->count(); i++) {
		IImport *import = import_list->item(i);
		for (j = 0; j < import->count(); j++) {
			import_function = import->item(j);
			if (import_function->options() & ioIsRelative) {
				import_function->map_function()->reference_list()->Add(import_function->address(), import_function->address() + 1);
				jmp_references[import_function->address()] = import_function;
			}
		}
	}

	j = 0; 
	for (i = 0; i < segment_list->count(); i++) {
		segment = segment_list->item(i);
		if (!segment->need_parse())
			continue;

		j += static_cast<size_t>(segment->physical_size());
		if (compiler_function_signatures.count() && (segment->memory_type() & mtExecutable))
			j += static_cast<size_t>(segment->physical_size());
	}
	std::string arch_name = (file.owner()->visible_count() > 1) ? string_format(" (%s)", file.name().c_str()) : "";
	file.StartProgress(string_format("%s %s%s...", language[lsLoading].c_str(), os::ExtractFileName(file.owner()->file_name().c_str()).c_str(), arch_name.c_str()), j);

	if (compiler_function_signatures.count()) {
		// search compiler functions
		for (i = 0; i < segment_list->count(); i++) {
			segment = segment_list->item(i);
			if (!segment->need_parse() || (segment->memory_type() & mtExecutable) == 0)
				continue;

			compiler_function_signatures.InitSearch();
			read_size = 0;
			while (read_size < segment->physical_size()) {
				file.Seek(segment->physical_offset() + read_size);
				n = file.Read(buf, std::min(static_cast<size_t>(segment->physical_size() - read_size), sizeof(buf)));
				file.StepProgress(n);
				for (k = 0; k < n; k++) {
					b = buf[k];
					buf_address = segment->address() + read_size + k + 1;

					for (j = 0; j < compiler_function_signatures.count(); j++) {
						sign = compiler_function_signatures.item(j);
						if (sign->SearchByte(b)) {
							address = buf_address - sign->size();
							CompilerFunctionType func_type = static_cast<CompilerFunctionType>(sign->tag());
							switch (func_type) {
							case cfBaseRegistr:
								{
									IntelOperand base_operand = IntelOperand(otRegistr, command_list.cpu_address_size(), b & 7);
									uint64_t value = 0;
									command = command_list.ReadValidCommand(file, address + sign->size());
									if (command) {
										if (command->type() == cmMov && command->operand(1).type == otRegistr && command->operand(1).registr == base_operand.registr && (command->operand(0).type & otMemory))
											base_operand = command->operand(0); // mov [xxxx], reg
										else {
											if (command->type() == cmAdd && command->operand(0).type == otRegistr && command->operand(0).registr == base_operand.registr && command->operand(1).type == otValue)
												value = command->operand(1).value; // add reg, xxxx

											IntelCommandInfoList command_info_list(file.cpu_address_size());
											std::set<uint64_t> address_list;
											address_list.insert(command->next_address());
											while (!address_list.empty()) {
												tmp_address = *address_list.begin();
												for (;;) {
													std::set<uint64_t>::const_iterator it = address_list.find(tmp_address);
													if (it != address_list.end())
														address_list.erase(it);

													command = command_list.ReadValidCommand(file, tmp_address);
													if (!command || (command->options() & roBreaked) || command->is_data())
														break;

													if ((command->type() == cmJmp && command->operand(0).type == otValue) || command->type() == cmJmpWithFlag) {
														if (command->operand(0).value > tmp_address)
															address_list.insert(command->operand(0).value);
													}

													if (command->type() == cmJmp || command->type() == cmRet || command->type() == cmIret || command->type() == cmCall)
														break;

													if (!command->GetCommandInfo(command_info_list) || command_info_list.GetInfo(atWrite, otRegistr, base_operand.registr))
														break;

													if (command->type() == cmMov && command->operand(1).type == otRegistr && command->operand(1).registr == base_operand.registr && (command->operand(0).type & otMemory)) {
														base_operand = command->operand(0); // mov [xxxx], reg
														address_list.clear();
														break;
													}

													tmp_address = command->next_address();
												}
											}
										}
									}
									address += 5;
									CompilerFunction *compiler_function = compiler_function_list->Add(func_type, address);
									compiler_function->add_value(base_operand.encode());
									if (value)
										compiler_function->add_value(value);
								}
								break;

							case cfDllFunctionCall:
								command_list.ReadFromFile(file, address);
								if (command_list.count() == 8) {
									if (file.AddressSeek(command_list.item(4)->operand(0).value)) {
										std::string dll_name;
										std::string func_name;
										uint32_t dll_name_address = file.ReadDWord();
										uint32_t func_name_address = file.ReadDWord();
										if (file.AddressSeek(dll_name_address))
											dll_name = file.ReadString();
										if (file.AddressSeek(func_name_address))
											func_name = file.ReadString();
										std::transform(dll_name.begin(), dll_name.end(), dll_name.begin(), tolower);
										if (dll_name.find('.') == NOT_ID)
											dll_name += ".dll";
										if (dll_name == "vmprotectsdk32.dll") {
											const ImportInfo *import_info = file.import_list()->GetSDKInfo(func_name);
											if (import_info) {
												CompilerFunction *compiler_function = compiler_function_list->Add(func_type, address);
												compiler_function->add_value(import_info->encode());
												compiler_function->add_value(dll_name_address);
												compiler_function->add_value(dll_name.size() + 1);
												compiler_function->add_value(func_name_address);
												compiler_function->add_value(func_name.size() + 1);
											}
										}
									}
								}
								break;

							case cfCxxSEH:
							case cfCxxSEH3:
							case cfCxxSEH4:
								command = command_list.ReadValidCommand(file, address + 2);
								if (command) {
									CompilerFunction *compiler_function = compiler_function_list->Add(func_type, address);
									compiler_function->add_value(command->operand(0).value);
								}
								break;

							case cfVB6SEH:
								{
									command = command_list.ReadValidCommand(file, address);
									uint64_t offset = 4 - command->operand(1).value;
									for (;;) {
										command = command_list.ReadValidCommand(file, address);
										if (!command || command->is_end())
											break;

										if (command->operand(0).type == (otMemory | otRegistr | otValue) 
											&& command->operand(0).registr == regEBP 
											&& command->operand(0).size == osDWord
											&& command->operand(0).value == offset
											&& command->operand(1).type == otValue) { // mov [ebp + xxxx], xxxx
											CompilerFunction *compiler_function = compiler_function_list->Add(cfVB6SEH, command->address());
											compiler_function->add_value(command->operand(1).value);
											break;
										}
										address = command->next_address();
									}
								}
								break;

							case cfInitBCBSEH:
								{
									CompilerFunction *compiler_function = compiler_function_list->Add(cfInitBCBSEH, address);
									if (file.AddressSeek(address + 5)) {
										b = file.ReadByte();
										if (b == 8)
											compiler_function->add_value(2);
										else if (b == 4)
											compiler_function->add_value(1);
									}
								}
								break;

							case cfRelocatorMinGW:
								{
									command_list.clear();
									size_t d;
									switch (sign->size()) {
									case 73:
										d = 11;
										break;
									case 111:
										d = 10;
										break;
									default:
										d = 0;
										break;
									}

									while (command_list.count() < 13 + d) {
										command = command_list.ReadValidCommand(file, address);
										if (!command)
											break;

										address = command->next_address();
									}

									if (command_list.count() == 13 + d) {
										CompilerFunction *compiler_function = compiler_function_list->Add(cfRelocatorMinGW, address);
										compiler_function->add_value(command_list.item(0)->operand(0).value);
										compiler_function->add_value(command_list.item(d + 2)->operand(1).value);
										compiler_function->add_value(command_list.item(d + 1)->operand(1).value);
									}
								}
								break;

							case cfPatchImport:
								command = command_list.ReadValidCommand(file, address + 2);
								if (command && file.AddressSeek(command->operand(1).value + 3)) {
									import_function = import_list->GetFunctionByAddress(file.ReadDWord());
									if (import_function)
										import_function->include_option(ioHasDataReference);
								}
								break;

							case cfJmpFunction:
								command = command_list.ReadValidCommand(file, address + 5);
								if (command && file.segment_list()->GetMemoryTypeByAddress(command->operand(0).value) & mtExecutable) {
									CompilerFunction *compiler_function = compiler_function_list->Add(cfJmpFunction, address);
									compiler_function->add_value(command->operand(0).value);
								}
								break;

							case cfGetBaseRegistr:
								command = command_list.ReadValidCommand(file, address);
								if (command) {
									CompilerFunction *compiler_function = compiler_function_list->Add(cfGetBaseRegistr, address);
									compiler_function->add_value(command->operand(0).registr);
								}
								break;

							default:
								compiler_function_list->Add(func_type, address);
								break;
							}
						}
					}
				}
				read_size += n;
			}
		}
	}

	pointer_size = OperandSizeToValue(file.cpu_address_size());
	for (i = 0; i < segment_list->count(); i++) {
		segment = segment_list->item(i);
		if (!segment->need_parse())
			continue;

		asm_signatures.InitSearch();
		import_signatures.InitSearch();
		read_size = 0;
		pointer_value = 0;
		last_operand_address = 0;
		while (read_size < segment->physical_size()) {
			file.Seek(segment->physical_offset() + read_size);
			n = file.Read(buf, std::min(static_cast<size_t>(segment->physical_size() - read_size), sizeof(buf)));
			file.StepProgress(n);
			for (k = 0; k < n; k++) {
				b = buf[k];
				buf_address = segment->address() + read_size + k + 1;

				if (segment->memory_type() & mtExecutable) {
					// search asm markers
					for (j = 0; j < asm_signatures.count(); j++) {
						sign = asm_signatures.item(j);
						if (sign->SearchByte(b)) {
							address = buf_address - sign->size();
							switch (j) {
							case 0:
								AddMarker(file, address, 0, 0, otMarker, b, false);
								break;
							case 1:
								AddEndMarker(file, address, address + sign->size(), otMarker);
								break;
							}
						}
					}

					// search references to import
					for (j = 0; j < import_signatures.count(); j++) {
						sign = import_signatures.item(j);
						if (sign->SearchByte(b)) {
							address = buf_address - sign->size();
							command_list.clear();
							command = command_list.ReadValidCommand(file, address);
							if (!command)
								continue;

							IntelCommandType ref_command = static_cast<IntelCommandType>(command->type());
							operand = command->operand((ref_command == cmJmp || ref_command == cmCall) ? 0 : 1);
							if ((operand.type & otValue) == 0)
								continue;

							operand_address = address + operand.value_pos;
							uint64_t next_address = command->next_address();

							import_function = NULL;
							if (j == 3 && !operand.relocation) {
								// check compiler function
								CompilerFunction *compiler_function = compiler_function_list->GetFunctionByAddress(operand.value);
								if (compiler_function) {
									switch (compiler_function->type()) {
									case cfGetBaseRegistr:
										registr = static_cast<uint8_t>(compiler_function->value(0));
										compiler_function = compiler_function_list->Add(cfBaseRegistr, next_address);
										compiler_function->add_value(IntelOperand(otRegistr, command_list.cpu_address_size(), registr).encode());
										tmp_address = command->next_address();
										for (;;) {
											tmp_command = command_list.ReadValidCommand(file, tmp_address);
											if (tmp_command && tmp_command->type() == cmAdd && tmp_command->operand(0).type == otRegistr) {
												if (tmp_command->operand(0).registr == registr) {
													compiler_function->add_value(tmp_command->operand(1).value);
													break;
												}
												tmp_address = tmp_command->next_address();
											} else {
												break;
											}
										}
										break;

									case cfDllFunctionCall:
										compiler_function->include_option(coUsed);
										ImportInfo sdk_info;
										sdk_info.decode(compiler_function->value(0));
										switch (sdk_info.type) {
										case atBegin:
											{
												b = 0;
												if (sdk_info.options & ioHasCompilationType)
													b = 1 + sdk_info.compilation_type;
												if (sdk_info.options & ioLockToKey)
													b |= 0x80;

												command_list.ReadMarkerCommands(file, marker_command_list, address, moNeedParam | moSkipLastCall);
												if (marker_command_list.count() == 0) {
													AddMarker(file, address, 0, 0, otAPIMarker, b, true);
												} else {
													marker_command_list.Sort();
													for (r = 0; r < marker_command_list.count(); r++) {
														marker_command = marker_command_list.item(r);
														AddMarker(file, marker_command->address(),
																	marker_command->name_reference(),
																	marker_command->name_address(),
																	otAPIMarker, b, true);
													}
												}
											}
											break;

										case atEnd:
											AddEndMarker(file, address, next_address, otAPIMarker);
											break;
										case atDecryptStringW:
											command_list.ReadMarkerCommands(file, marker_command_list, address, moNeedParam | moSkipLastCall);
											for (r = 0; r < marker_command_list.count(); r++) {
												marker_command = marker_command_list.item(r);
												AddString(file, marker_command->name_address(), marker_command->name_reference(), true);
											}
											break;
										}
										break;

									case cfInitBCBSEH:
										{
											uint8_t version = static_cast<uint8_t>(compiler_function->value(0));
											if (version) {
												for (size_t d = 0x30; d > 0; d--) {
													if (!file.AddressSeek(address - d))
														continue;
			
													command_list.clear();
													tmp_address = address - d;
													while (tmp_address < address) {
														command = command_list.ReadValidCommand(file, tmp_address);
														// these commands can no be found between API`s param and API`s call
														if (command == NULL 
															|| command->type() == cmDB 
															|| command->type() == cmRet
															|| command->type() == cmIret
															|| command->type() == cmJmp
															|| command->type() == cmEnter) {
																tmp_address = 0;
																break;
														}
														tmp_address = command->next_address();
														if (command->type() == cmCall)
															command_list.clear();
													}

													if (tmp_address != address)
														continue;

													for (size_t c = command_list.count(); c > 0; c--) {
														command = command_list.item(i);
														if (command->type() == cmMov && command->operand(0).type == otRegistr && command->operand(0).registr == regEAX) {
															if (command->operand(1).type == otValue) {
																compiler_function = compiler_function_list->Add(cfBCBSEH, address);
																compiler_function->add_value(command->operand(1).value);
																compiler_function->add_value(version);
															}
															d = 1;
														}
													}
												}
											}
										}
										break;

									case cfJmpFunction:
										operand.value = compiler_function->value(0);
										break;
									}
								}

								// try to search import_function by jmp references
								std::map<uint64_t, IImportFunction *>::const_iterator it = jmp_references.find(operand.value);
								if (it != jmp_references.end())
									import_function = it->second;

								if (!import_function) {
									tmp_address = operand.value;
									for (;;) {
										// try parse jmp branches
										tmp_command = command_list.ReadValidCommand(file, tmp_address);
										if (tmp_command) {
											if (tmp_command->type() == cmJmp && (tmp_command->options() & roFar) == 0) {
												// jmp xxxx
												tmp_operand = tmp_command->operand(0);
												if (tmp_operand.type == otValue) {
													if (command_list.GetCommandByNearAddress(tmp_operand.value) == NULL) {
														tmp_address = tmp_operand.value;
														continue;
													}
												}
												else if (tmp_operand.type == (otMemory | otValue)) {
													import_function = import_list->GetFunctionByAddress(tmp_operand.value);
												}
											}
											else if (tmp_command->type() == cmNop) {
												// rep nop xxxx
												tmp_address = tmp_command->next_address();
												continue;
											}
										}
										break;
									}
								}
							} else if (j == 8)
								import_function = import_list->GetFunctionByAddress(plt_got_address + operand.value);
							else
								import_function = import_list->GetFunctionByAddress(operand.relocation ? operand_address : operand.value);

							if (import_function) {
								if ((ref_command == cmJmp || j == 3) && (import_function->options() & ioNoReturn)) {
									tmp_address = (j == 3) ? command->operand(0).value : address;
									CompilerFunction *compiler_function = compiler_function_list->GetFunctionByAddress(tmp_address);
									if (!compiler_function)
										compiler_function = compiler_function_list->Add(cfNone, tmp_address);
									compiler_function->include_option(coNoReturn);
								}

								// check data reference to import function
								if (ref_command == cmMov) {
									is_data_reference = true;
									registr = command->operand(0).registr;
									tmp_address = command->next_address();
									while (segment_list->GetMemoryTypeByAddress(tmp_address) & mtExecutable) {
										command = command_list.ReadValidCommand(file, tmp_address);
										if (!command)
											break;

										tmp_address = command->next_address();
										if (command->operand(0).type == otRegistr && command->operand(0).registr == registr) {
											if (command->type() == cmJmp || command->type() == cmCall)
												is_data_reference = false;
											break;
										} else if (command->type() == cmJmp && command->operand(0).type == otValue && command->operand(0).value >= tmp_address) {
											tmp_address = command->operand(0).value;
										} else if (command->type() == cmDB
													|| command->type() == cmJmp
													|| command->type() == cmCall
													|| command->type() == cmRet
													|| command->type() == cmIret)
											break;
									}
									if (is_data_reference)
										import_function->include_option(ioHasDataReference);
								}

								switch (import_function->type()) {
								case atBegin:
									if (ref_command != cmJmp) {
										command_list.ReadMarkerCommands(file, marker_command_list, address, moNeedParam | (ref_command == cmMov ? moForward : 0));

										b = 0;
										if ((import_function->options() & ioHasCompilationType) != 0)
											b = 1 + import_function->compilation_type();
										if ((import_function->options() & ioLockToKey) != 0)
											b |= 0x80;

										if (marker_command_list.count() == 0) {
											AddMarker(file, address, 0, 0, otAPIMarker, b, false);
										} else {
											marker_command_list.Sort();
											for (r = 0; r < marker_command_list.count(); r++) {
												marker_command = marker_command_list.item(r);
												AddMarker(file, marker_command->address(),
															marker_command->name_reference(),
															marker_command->name_address(),
															otAPIMarker, b, false);
											}
										}
									}
									break;

								case atEnd:
									if (ref_command == cmMov) {
										command_list.ReadMarkerCommands(file, marker_command_list, address, (ref_command == cmMov ? moForward : 0)); //-V547
										if (marker_command_list.count()) {
											marker_command_list.Sort();
											for (r = 0; r < marker_command_list.count(); r++) {
												marker_command = marker_command_list.item(r);
												AddEndMarker(file, marker_command->address(),
															marker_command->operand_address(),
															otAPIMarker);
											}
										}
									} else if (ref_command != cmJmp)
										AddEndMarker(file, address, next_address, otAPIMarker);
									break;

								case atDecryptStringA: case atDecryptStringW:
									command_list.ReadMarkerCommands(file, marker_command_list, address, moNeedParam | (ref_command == cmMov ? moForward : 0));
									for (r = 0; r < marker_command_list.count(); r++) {
										marker_command = marker_command_list.item(r);
										AddString(file, marker_command->name_address(), marker_command->name_reference(), import_function->type() == atDecryptStringW);
										call_import_function_map[marker_command->address()] = import_function;
									}										
									break;
								}
								if (j == 3 || j == 7) {
									if (import_function->address() == operand_address)
										import_function->map_function()->reference_list()->Add(address, operand_address);
								} else {
									last_operand_address = operand_address;
									import_function->map_function()->reference_list()->Add(address, operand_address);
									// add jmp_reference for next searching
									if (ref_command == cmJmp)
										jmp_references[address] = import_function;
								}
							}
						}
					}
				}

				// check data reference
				pointer_value >>= 8;
				pointer_value |= static_cast<uint64_t>(b) << ((pointer_size - 1) * 8);
				if (buf_address >= segment->address() + pointer_size - 1) {
					tmp_address = buf_address - pointer_size;
					if ((segment_list->GetMemoryTypeByAddress(pointer_value) & mtReadable) && (fixup_list->count() == 0 || fixup_list->GetFixupByAddress(tmp_address))) {
						import_function = import_list->GetFunctionByAddress(pointer_value);
						if (import_function && last_operand_address != tmp_address)
							import_function->include_option(ioHasDataReference);
					}
				}
			}
			read_size += n;
		}
	}

	// search references to strings
	if (string_list_.size() > 0) {
		if (file.cpu_address_size() == osQWord) {
			string_signatures.Add("4?8D"); // lea reg, [xxxxxxxx]
			string_signatures.Add("48B?"); // mov reg, xxxxxxxx
		} else {
			string_signatures.Add("B?");  // mov reg, xxxxxxxx
			string_signatures.Add("C7");  // mov [xxxxxxxx], xxxxxxxx
			string_signatures.Add("8D");  // lea reg, [xxxxxxxx]
			string_signatures.Add("68");  // push xxxxxxxx
		}

		for (i = 0; i < segment_list->count(); i++) {
			segment = segment_list->item(i);
			if (!segment->need_parse() || (segment->memory_type() & mtExecutable) == 0)
				continue;

			string_signatures.InitSearch();
			read_size = 0;
			while (read_size < segment->physical_size()) {
				file.Seek(segment->physical_offset() + read_size);
				n = file.Read(buf, std::min(static_cast<size_t>(segment->physical_size() - read_size), sizeof(buf)));
				for (k = 0; k < n; k++) {
					b = buf[k];
					buf_address = segment->address() + read_size + k + 1;

					for (j = 0; j < string_signatures.count(); j++) {
						sign = string_signatures.item(j);
						if (sign->SearchByte(b)) {
							address = buf_address - sign->size();
							command_list.clear();
							command = command_list.ReadValidCommand(file, address);
							if (!command)
								continue;

							uint64_t delta_offset = (uint64_t)-1;
							if (command->operand(0).type == otRegistr) {
								tmp_command = command_list.ReadValidCommand(file, command->next_address());
								if (tmp_command && tmp_command->type() == cmLea && tmp_command->operand(1).type == (otMemory | otRegistr | otValue) && tmp_command->operand(1).registr == command->operand(0).registr)
									delta_offset = tmp_command->operand(1).value;
							}

							operand = command->operand(command->type() != cmPush);
							if ((operand.type & otValue) == 0)
								continue;

							tmp_command = command_list.ReadValidCommand(file, command->next_address());
							if (tmp_command && tmp_command->type() == cmJmp && tmp_command->operand(0).type == otValue) {
								tmp_command = command_list.ReadValidCommand(file, tmp_command->operand(0).value);
								if (tmp_command && tmp_command->type() == cmCall) {
									std::map<uint64_t, IImportFunction *>::const_iterator it = call_import_function_map.find(tmp_command->address());
									if (it != call_import_function_map.end()) {
										import_function = it->second;
										if (import_function->type() == atDecryptStringA || import_function->type() == atDecryptStringW) {
											uint64_t param_reference;
											if (command_list.ParseParam(file, 1, param_reference))
												AddString(file, operand.value, command->address(), import_function->type() == atDecryptStringW);
										}
									}
								}
							}

							for (r = 0; r < string_list_.size(); r++) {
								map_function = string_list_[r];
								bool is_match = false;
								if (map_function->address() <= operand.value && map_function->end_address() > operand.value)
									is_match = true;
								else for (c = 0; c < map_function->equal_address_list()->count(); c++) {
									Reference *reference = map_function->equal_address_list()->item(c);
									if (reference->address() <= operand.value && reference->operand_address() > operand.value) {
										is_match = true;
										break;
									}
								}

								if (is_match) {
									if (map_function->reference_list()->GetReferenceByAddress(address) == NULL && (delta_offset == (uint64_t)-1 || delta_offset < map_function->end_address() - map_function->address()))
										map_function->reference_list()->Add(address, operand.value, 1);
									break;
								}
							}
						}
					}
				}
				read_size += n; 
			}
		}

		// check references to marker_names
		for (i = 0; i < map_function_list->count(); i++) {
			map_function = map_function_list->item(i);
			if (map_function->type() == otAPIMarker) {
				MapFunction *name_function = NULL;
				for (j = 0; j < string_list_.size(); j++) {
					if (string_list_[j]->address() == map_function->name_address() || string_list_[j]->equal_address_list()->GetReferenceByAddress(map_function->name_address())) {
						name_function = string_list_[j];
						break;
					}
				}
				if (name_function && name_function->reference_list()->count() > 1) {
					uint64_t end_name_address = map_function->name_address() + map_function->name_length();
					for (j = 0; j < name_function->reference_list()->count(); j++) {
						Reference *reference = name_function->reference_list()->item(j);
						if (reference->tag() != 1)
							continue;

						if (map_function->name_address() <= reference->operand_address() && end_name_address > reference->operand_address())
							end_name_address = reference->operand_address();
					}
					if (end_name_address > map_function->name_address())
						map_function->set_name_length(static_cast<size_t>(end_name_address - map_function->name_address()));
					else
						map_function->set_name_address(0);
				}
			}
		}
	}

	// check import functions without references
	for (i = 0; i < import_list->count(); i++) {
		IImport *import = import_list->item(i);
		for (j = 0; j < import->count(); j++) {
			import_function = import->item(j);
			if ((import_function->options() & ioHasDataReference) == 0 && import_function->map_function()->reference_list()->count() == 0)
				import_function->include_option(ioNoReferences);
		}
	}

	file.EndProgress();
};

/**
 * IntelFunctionList
 */

IntelFunctionList::IntelFunctionList(IArchitecture *owner)
	: BaseFunctionList(owner), import_(NULL), crc_table_(NULL), loader_data_(NULL), runtime_crc_table_(NULL)
{
	crc_cryptor_ = new ValueCryptor();
}

IntelFunctionList::IntelFunctionList(IArchitecture *owner, const IntelFunctionList &src)
	: BaseFunctionList(owner, src), import_(NULL), crc_table_(NULL), loader_data_(NULL), runtime_crc_table_(NULL)
{
	crc_cryptor_ = new ValueCryptor();
}

IntelFunctionList::~IntelFunctionList()
{
	delete crc_cryptor_;
}

IntelFunctionList *IntelFunctionList::Clone(IArchitecture *owner) const
{
	IntelFunctionList *list = new IntelFunctionList(owner, *this);
	return list;
}

IntelFunction *IntelFunctionList::Add(const std::string &name, CompilationType compilation_type, uint32_t compilation_options, bool need_compile, Folder *folder)
{
	IntelFunction *func = new IntelFunction(this, name, compilation_type, compilation_options, need_compile, folder);
	AddObject(func);
	return func;
}

IntelFunction *IntelFunctionList::CreateFunction(OperandSize cpu_address_size)
{
	return new IntelFunction(this, cpu_address_size);
}

IntelFunction *IntelFunctionList::item(size_t index) const
{ 
	return reinterpret_cast<IntelFunction *>(BaseFunctionList::item(index));
}

IntelFunction *IntelFunctionList::GetFunctionByAddress(uint64_t address) const
{ 
	return reinterpret_cast<IntelFunction *>(BaseFunctionList::GetFunctionByAddress(address));
}

IntelSDK *IntelFunctionList::AddSDK(OperandSize cpu_address_size)
{
	IntelSDK *func = new IntelSDK(this, cpu_address_size);
	AddObject(func);
	return func;
}

IntelImport *IntelFunctionList::AddImport(OperandSize cpu_address_size)
{
	IntelImport *func = new IntelImport(this, cpu_address_size);
	AddObject(func);
	return func;
}

IntelRuntimeData *IntelFunctionList::AddRuntimeData(OperandSize cpu_address_size)
{
	IntelRuntimeData *func = new IntelRuntimeData(this, cpu_address_size);
	AddObject(func);
	return func;
}

IntelCRCTable *IntelFunctionList::AddCRCTable(OperandSize cpu_address_size)
{
	IntelCRCTable *func = new IntelCRCTable(this, cpu_address_size);
	AddObject(func);
	return func;
}

IntelLoaderData *IntelFunctionList::AddLoaderData(OperandSize cpu_address_size)
{
	IntelLoaderData *func = new IntelLoaderData(this, cpu_address_size);
	AddObject(func);
	return func;
}

IntelFunction *IntelFunctionList::AddWatermark(OperandSize cpu_address_size, Watermark *watermark, int copy_count)
{
	IntelFunction *func = new IntelFunction(this, cpu_address_size);
	func->set_compilation_type(ctMutation);
	func->set_memory_type(mtNone);
	func->AddWatermark(watermark, copy_count);
	AddObject(func);
	return func;
}

IntelRuntimeCRCTable *IntelFunctionList::AddRuntimeCRCTable(OperandSize cpu_address_size)
{
	IntelRuntimeCRCTable *func = new IntelRuntimeCRCTable(this, cpu_address_size);
	AddObject(func);
	return func;
}

IntelVirtualMachineProcessor *IntelFunctionList::AddProcessor(OperandSize cpu_address_size)
{
	IntelVirtualMachineProcessor *func = new IntelVirtualMachineProcessor(this, cpu_address_size);
	AddObject(func);
	return func;
}

void IntelFunctionList::ReadFromBuffer(Buffer &buffer, IArchitecture &file)
{
	BaseFunctionList::ReadFromBuffer(buffer, file);

	// add loader stubs
	size_t c = count();
	for (size_t i = 0; i < c; i++) {
		IntelFunction *func = item(i);
		if (func->tag() != ftLoader)
			continue;

		for (size_t j = 0; j < func->count(); j++) {
			IntelCommand *command = func->item(j);
			if (command->type() == cmCall && command->operand(0).type == otValue) {
				uint64_t address = command->operand(0).value;
				if (address == command->next_address() || GetFunctionByAddress(address))
					continue;

				IntelFunction *new_func = reinterpret_cast<IntelFunction *>(AddByAddress(address, ctMutation, 0, false, NULL));
				if (new_func) {
					new_func->set_tag(ftLoader);
					for (size_t k = 0; k < new_func->count(); k++) {
						IntelCommand *command = new_func->item(k);
						command->exclude_option(roClearOriginalCode);
#ifdef CHECKED
						command->update_hash();
#endif
					}
				}
			}
		}
	}
}

bool IntelFunctionList::Prepare(const CompileContext &ctx)
{
	IntelFunction *func;
	IntelCommand *command;
	size_t i, j;
	OperandSize cpu_address_size = ctx.file->cpu_address_size();

	crc_cryptor_->clear();
	crc_cryptor_->set_size(osDWord);
	crc_cryptor_->Add(ccXor, rand32());
	
	if ((ctx.options.flags | ctx.options.sdk_flags) & cpMemoryProtection) {
		crc_table_ = AddCRCTable(cpu_address_size);
	} else {
		crc_table_ = NULL;
	}

	if (ctx.runtime) {
		// remove CalcCRC function
		IntelFunctionList *function_list = reinterpret_cast<IntelFunctionList *>(ctx.runtime->function_list());
		uint64_t calc_crc_address = ctx.runtime->export_list()->GetAddressByType(atCalcCRC);
		if (!calc_crc_address)
			return false;
		func = function_list->GetFunctionByAddress(calc_crc_address);
		if (!func)
			return false;
		func->set_need_compile(false);
		for (i = 0; i < function_list->count(); i++) {
			func = function_list->item(i);
			for (j = 0; j < func->count(); j++) {
				command = func->item(j);
				if (command->type()== cmCall && command->operand(0).type == otValue && command->operand(0).value == calc_crc_address) {
					delete command->link();
					command->Init(cmCrc);
#ifdef CHECKED
					command->update_hash();
#endif
				}
			}
		}

		if (ctx.runtime->segment_list()->count() > 0) {
			// add runtime functions
			for (i = 0; i < function_list->count(); i++) {
				func = function_list->item(i);

				if (func->need_compile()) {
					func = func->Clone(this);
					AddObject(func);

					if (func->type() == otString) {
						for (j = 0; j < func->count(); j++) {
							command = func->item(j);
							for (size_t k = 0; k < MESSAGE_COUNT; k++) {
								os::unicode_string unicode_message = 
#ifdef VMP_GNU
									os::FromUTF8(default_message[k]);
#else
									default_message[k];
#endif
								if (command->CompareDump(reinterpret_cast<const uint8_t*>(unicode_message.c_str()), (unicode_message.size() + 1) * sizeof(os::unicode_char))) {
									os::unicode_string str = os::FromUTF8(ctx.options.messages[k]);
									command->set_dump(reinterpret_cast<const uint8_t*>(str.c_str()), (str.size() + 1) * sizeof(os::unicode_char));
								} else {
									std::string message = 
#ifdef VMP_GNU								
										default_message[k];
#else									
										os::ToUTF8(default_message[k]);
#endif
									if (command->CompareDump(reinterpret_cast<const uint8_t*>(message.c_str()), message.size() + 1)) {
										std::string str = ctx.options.messages[k];
										command->set_dump(reinterpret_cast<const uint8_t*>(str.c_str()), str.size() + 1);
									}
								}
							}
						}
					}

					for (j = 0; j < func->count(); j++) {
						func->item(j)->CompileToNative();
					}
				} else {
					// need delete import references
					for (j = 0; j < ctx.runtime->map_function_list()->count(); j++) {
						ReferenceList *reference_list = ctx.runtime->map_function_list()->item(j)->reference_list();
						for (size_t k = reference_list->count(); k > 0; k--) {
							Reference *reference = reference_list->item(k - 1);
							command = func->GetCommandByNearAddress(reference->address());
							if (command && (command->options() & roClearOriginalCode))
								delete reference;
						}
					}
					if (!func->FreeByManager(ctx))
						return false;
				}
			}

			AddRuntimeData(cpu_address_size);
		}
	}

	if (ctx.options.flags & cpImportProtection) {
		import_ = AddImport(cpu_address_size);
	} else {
		import_ = NULL;
	}

	AddSDK(cpu_address_size);

	if (ctx.runtime && ctx.runtime->segment_list()->count() == 0) {
		loader_data_ = AddLoaderData(cpu_address_size);
	} else {
		loader_data_ = NULL;
	}

	AddWatermark(cpu_address_size, ctx.options.watermark, ctx.runtime ? 8 : 10);

	return BaseFunctionList::Prepare(ctx);
}

void IntelFunctionList::CompileLinks(const CompileContext &ctx)
{
	if (ctx.options.flags & cpMemoryProtection) {
		runtime_crc_table_ = AddRuntimeCRCTable(ctx.file->cpu_address_size());
		runtime_crc_table_->Compile(ctx);
	} else {
		runtime_crc_table_ = NULL;
	}

	BaseFunctionList::CompileLinks(ctx);
}

bool IntelFunctionList::GetRuntimeOptions() const
{
	for (size_t i = 0; i < count(); i++) {
		IntelFunction *func = item(i);
		if (func->tag() != ftLoader)
			continue;

		for (size_t j = 0; j < func->count(); j++) {
			IntelCommand *command = func->item(j);

			if (command->link() && command->link()->to_address()) {
				if (!GetCommandByAddress(command->link()->to_address(), false))
					return true;
			} else {
				for (size_t k = 0; k < 3; k++) {
					IntelOperand operand = command->operand(k);
					if (operand.type == otNone)
						break;

					if ((operand.type & otValue) && (operand.fixup || operand.is_large_value)) {
						if (owner()->image_base() == operand.value || owner()->import_list()->GetFunctionByAddress(operand.value))
							continue;

						if (!GetCommandByAddress(operand.value, false))
							return true;
					}
				}
			}
		}
	}
	return false;
}

/**
 * PEIntelFunctionList
 */

PEIntelFunctionList::PEIntelFunctionList(IArchitecture *owner)
	: IntelFunctionList(owner)
{

}

PEIntelFunctionList::PEIntelFunctionList(IArchitecture *owner, const PEIntelFunctionList &src)
	: IntelFunctionList(owner, src)
{

}

PEIntelFunctionList *PEIntelFunctionList::Clone(IArchitecture *owner) const
{
	PEIntelFunctionList *list = new PEIntelFunctionList(owner, *this);
	return list;
}

IntelSDK *PEIntelFunctionList::AddSDK(OperandSize cpu_address_size)
{
	IntelSDK *func = new PEIntelSDK(this, cpu_address_size);
	AddObject(func);
	return func;
}

PEIntelExport *PEIntelFunctionList::AddExport(OperandSize cpu_address_size)
{
	PEIntelExport *func = new PEIntelExport(this, cpu_address_size);
	AddObject(func);
	return func;
}

void PEIntelFunctionList::ReadFromBuffer(Buffer &buffer, IArchitecture &file)
{
	IntelFunctionList::ReadFromBuffer(buffer, file);

	if (file.cpu_address_size() == osDWord && reinterpret_cast<PEArchitecture&>(file).image_type() == itDriver) {
		// add exception handler
		IntelFunction *except_handler = NULL;
		for (size_t i = 0; i < count(); i++) {
			IntelFunction *func = item(i);
			if (func->tag() != ftLoader)
				continue;

			for (size_t j = 0; j < func->count(); j++) {
				IntelCommand *command = func->item(j);
				if (command->base_segment() == segFS && command->operand(0).type == otRegistr && command->operand(1).type == (otMemory | otValue) && command->operand(1).value == 0) {
					// mov reg, fs:[00000000]
					command = func->item(j - 1);
					uint64_t address = command->operand(0).value;
					command->AddLink(0, ltOffset, address);
					if (!GetFunctionByAddress(address)) {
						IntelFunction *new_func = reinterpret_cast<IntelFunction *>(AddByAddress(address, ctMutation, 0, false, NULL));
						if (new_func) {
							new_func->set_tag(ftLoader);
							for (size_t k = 0; k < new_func->count(); k++) {
								IntelCommand *command = new_func->item(k);
								command->exclude_option(roClearOriginalCode);
								if (command->seh_handler())
									command->set_seh_handler(NEED_SEH_HANDLER);
#ifdef CHECKED
								command->update_hash();
#endif
							}
						}
					}
				}
			}
		}
	}
}

bool PEIntelFunctionList::Prepare(const CompileContext &ctx)
{
	if (ctx.runtime) {
		PEArchitecture *file = reinterpret_cast<PEArchitecture *>(ctx.file);
		if (file->image_type() == itDriver) {
			IntelFunctionList *function_list = reinterpret_cast<IntelFunctionList *>(ctx.runtime->function_list());
			for (size_t i = 0; i < function_list->count(); i++) {
				IntelFunction *func = function_list->item(i);
				for (size_t j = 0; j < func->count(); j++) {
					IntelCommand *command = func->item(j);
					for (size_t k = 0; k < 3; k++) {
						IntelOperand operand = command->operand(k);
						if (operand.type == otNone)
							break;

						if ((operand.type & otValue) == 0)
							continue;

						uint32_t value = static_cast<uint32_t>(operand.value);
						if ((value & 0xFFFF0000) == 0xFACE0000) {
							switch (value) {
							case FACE_NON_PAGED_POOL_NX:
								// NonPagedPoolNx
								command->set_operand_value(k, file->operating_system_version() >= 0x060002 ? 512 : 0);
								command->CompileToNative();
								break;
							case FACE_DEFAULT_MDL_PRIORITY:
								// MdlMappingNoExecute | HighPagePriority
								command->set_operand_value(k, file->operating_system_version() >= 0x060002 ? 0x40000020 : 0x20); 
								command->CompileToNative();
								break;
							}
						}
					}
				}
			}
		}

		if (file->entry_point()) {
			IntelFunction *entry_point_func = GetFunctionByAddress(file->entry_point());
			if (entry_point_func) {
				entry_point_func->set_entry_type(etNone);
				entry_point_func->entry()->include_section_option(rtLinkedToInt);
			}
		}
	}

	return IntelFunctionList::Prepare(ctx);
}

/**
 * IntelSDK
 */

IntelSDK::IntelSDK(IFunctionList *owner, OperandSize cpu_address_size)
	: IntelFunction(owner, cpu_address_size)
{
	set_compilation_type(ctMutation);
}

bool IntelSDK::Init(const CompileContext &ctx)
{
	MapFunctionList *map_function_list;
	MapFunction *map_function;
	IFunctionList *function_list;
	size_t i, c, j, k, /*old_count,*/ n, f;
	uint64_t address;
	IArchitecture *file;
	IImportList *import_list;
	IImport *import;
	IImportFunction *import_function;
	IntelCommand *command, *ret_command, *mem_command, *api_entry;
	CommandBlock *block;
	uint64_t api_address;
	std::map<APIType, IntelCommand*> map_api_entry;

	CallingConvention calling_convention = ctx.file->calling_convention();

	f = (ctx.runtime && ctx.runtime->segment_list()->count() > 0) ? 2 : 1;
	for (n = 0; n < f; n++) {
		file = (n == 0) ? ctx.file : ctx.runtime;
		map_function_list = file->map_function_list();
		function_list = file->function_list();
		for (i = 0; i < map_function_list->count(); i++) {
			map_function = map_function_list->item(i);
			switch (map_function->type()) {
			case otAPIMarker:
				// need clear marker name
				if (map_function->name_address())
					ctx.manager->Add(map_function->name_address(), map_function->name_length(), file->segment_list()->GetMemoryTypeByAddress(map_function->name_address()));
				break;
			case otMarker:
				// need clear "VMProtect begin" from asm markers
				ICommand *command = function_list->GetCommandByAddress(map_function->address() + 2, true);
				if (!command)
					ctx.manager->Add(map_function->address() + 2, 0x10, file->segment_list()->GetMemoryTypeByAddress(map_function->name_address()));
				break;
			}
		}

		// need clear "VMProtect end" from asm markers
		for (i = 0; i < file->end_marker_list()->count(); i++) {
			MarkerCommand *marker_command = file->end_marker_list()->item(i);
			if (marker_command->type() != otMarker)
				continue;

			ICommand *command = function_list->GetCommandByAddress(marker_command->address() + 2, true);
			if (!command)
				ctx.manager->Add(marker_command->address() + 2, 0x0e, file->segment_list()->GetMemoryTypeByAddress(map_function->name_address()));
		}

		for (i = 0; i < file->compiler_function_list()->count(); i++) {
			CompilerFunction *compiler_function = file->compiler_function_list()->item(i);
			if (compiler_function->type() == cfDllFunctionCall) {
				// clear names
				ctx.manager->Add(compiler_function->value(1), static_cast<size_t>(compiler_function->value(2)));
				ctx.manager->Add(compiler_function->value(3), static_cast<size_t>(compiler_function->value(4)));

				if ((compiler_function->options() & coUsed) == 0)
					continue;

				address = compiler_function->address();
				command = reinterpret_cast<IntelCommand *>(ctx.file->function_list()->GetCommandByNearAddress(address, true));
				if (command) {
					delete command->link();
				} else {
					if (!file->AddressSeek(address))
						return false;

					block = AddBlock(count(), true);
					block->set_address(address);

					command = Add(address);
					command->ReadFromFile(*file);
					command->set_block(block);
					command->include_option(roFillNop);
					command->exclude_option(roClearOriginalCode);
				}

				// need delete fixups
				for (k = 0; k < 3; k++) {
					IntelOperand operand = command->operand(k);
					if (operand.type == otNone)
						break;

					IFixup *fixup = operand.fixup;
					if (fixup && fixup != NEED_FIXUP)
						fixup->set_deleted(true);
				}
				// need clear operands
				command->Init(static_cast<IntelCommandType>(command->type()));

				APIType function_type = static_cast<APIType>(compiler_function->value(0) & 0xff);
				switch (function_type) {
				case atBegin:
					command->Init(cmRet, IntelOperand(otValue, osWord, 0, OperandSizeToValue(cpu_address_size())));
					break;
				case atEnd:
					command->Init(cmRet);
					break;
				default:
					if (!ctx.runtime)
						return false;
					api_address = ctx.runtime->export_list()->GetAddressByType(function_type);
					if (!api_address)
						return false;

					command->Init(cmJmp, IntelOperand(otValue, cpu_address_size(), 0, api_address));
					command->AddLink(0, ltJmp, api_address);
					break;
				}

				command->CompileToNative();
			}
		}

		import_list = file->import_list();
		for (i = 0; i < import_list->count(); i++) {
			import = import_list->item(i);
			if (!import->is_sdk())
				continue;

			for (j = 0; j < import->count(); j++) {
				import_function = import->item(j);

				map_function = import_function->map_function();
				for (c = 0; c < map_function->reference_list()->count(); c++) {
					address = map_function->reference_list()->item(c)->address();

					command = reinterpret_cast<IntelCommand *>(ctx.file->function_list()->GetCommandByNearAddress(address, true));
					if (command) {
						delete command->link();
					} else {
						if (!file->AddressSeek(address))
							return false;

						block = AddBlock(count(), true);
						block->set_address(address);

						command = Add(address);
						command->ReadFromFile(*file);
						command->set_block(block);
						command->include_option(roFillNop);
						command->exclude_option(roClearOriginalCode);
					}

					if (command->type() != cmMov) {
						// need delete fixups
						for (k = 0; k < 3; k++) {
							IntelOperand operand = command->operand(k);
							if (operand.type == otNone)
								break;

							IFixup *fixup = operand.fixup;
							if (fixup && fixup != NEED_FIXUP)
								fixup->set_deleted(true);
						}
						// need clear operands
						command->Init(static_cast<IntelCommandType>(command->type()));
					}

					switch (import_function->type()) {
						case atBegin:
							switch (command->type()) {
							case cmCall:
								if (calling_convention == ccStdcall) {
									command->Init(cmLea, IntelOperand(otRegistr, cpu_address_size(), regESP), 
														IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regESP, OperandSizeToValue(cpu_address_size())));
								} else {
									command->Init(cmNop);
								}
								break;
							case cmMov:
								if (calling_convention == ccStdcall) {
									ret_command = AddCommand(cmRet, IntelOperand(otValue, osWord, 0, OperandSizeToValue(cpu_address_size())));
								} else {
									ret_command = AddCommand(cmRet);
								}

								mem_command = AddCommand((cpu_address_size() == osDWord) ? cmDD : cmDQ, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
								mem_command->AddLink(0, ltOffset, ret_command);

								command->AddLink(1, ltOffset, mem_command);
								break;
							default:
								if (calling_convention == ccStdcall) {
									command->Init(cmRet, IntelOperand(otValue, osWord, 0, OperandSizeToValue(cpu_address_size())));
								} else {
									command->Init(cmRet);
								}
								break;
							}
							break;

						case atEnd:
							switch (command->type()) {
							case cmCall:
								command->Init(cmNop);
								break;
							case cmMov:
								ret_command = AddCommand(cmRet);

								mem_command = AddCommand((cpu_address_size() == osDWord) ? cmDD : cmDQ, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
								mem_command->AddLink(0, ltOffset, ret_command);

								command->AddLink(1, ltOffset, mem_command);
								break;
							default:
								command->Init(cmRet);
								break;
							}
							break;

						case atDecryptStringA:
						case atDecryptStringW:
						case atFreeString:
						case atIsDebuggerPresent:
						case atIsVirtualMachinePresent:
						case atIsValidImageCRC:
						case atActivateLicense:
						case atDeactivateLicense:
						case atGetOfflineActivationString:
						case atGetOfflineDeactivationString:
						case atSetSerialNumber:
						case atGetSerialNumberState:
						case atGetSerialNumberData:
						case atGetCurrentHWID:
						case atIsProtected:
							api_entry = NULL;
							api_address = 0;
							if (!ctx.runtime || ctx.runtime->segment_list()->count() == 0) {
								std::map<APIType, IntelCommand*>::const_iterator it = map_api_entry.find(import_function->type());
								if (it != map_api_entry.end())
									api_entry = it->second;
								else { 
									switch (import_function->type()) {
									case atDecryptStringA:
									case atDecryptStringW:
										if (calling_convention == ccMSx64)
											api_entry = AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEAX), IntelOperand(otRegistr, cpu_address_size(), regECX));
										else if (calling_convention == ccABIx64)
											api_entry = AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEAX), IntelOperand(otRegistr, cpu_address_size(), regEDI));
										else
											api_entry = AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEAX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regESP, OperandSizeToValue(cpu_address_size())));
										if (calling_convention == ccStdcall)
											AddCommand(cmRet, IntelOperand(otValue, osWord, 0, OperandSizeToValue(cpu_address_size())));
										else
											AddCommand(cmRet);
										break;
									case atFreeString:
										api_entry = AddCommand(cmXor, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otRegistr, osDWord, regEAX));
										if (calling_convention == ccStdcall)
											AddCommand(cmRet, IntelOperand(otValue, osWord, 0, OperandSizeToValue(cpu_address_size())));
										 else
											AddCommand(cmRet);
										break;
									case atIsProtected:
										api_entry = AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, 1));
										AddCommand(cmRet);
										break;
									default:
										// other APIs can not work without runtime
										return false;
									}
									map_api_entry[import_function->type()] = api_entry;
								}
							} else {
								api_address = ctx.runtime->export_list()->GetAddressByType(import_function->type());
								if (!api_address)
									return false;
							}

							switch (command->type()) {
							case cmCall:
								command->Init(cmCall, IntelOperand(otValue, cpu_address_size(), 0, api_address));
								if (api_entry)
									command->AddLink(0, ltCall, api_entry);
								else
									command->AddLink(0, ltCall, api_address);
								break;
							case cmMov:
								mem_command = AddCommand((cpu_address_size() == osDWord) ? cmDD : cmDQ, IntelOperand(otValue, cpu_address_size(), 0, api_address, NEED_FIXUP));
								if (api_entry)
									mem_command->AddLink(0, ltOffset, api_entry);
								else
									mem_command->AddLink(0, ltOffset, api_address);
								command->AddLink(1, ltOffset, mem_command);
								break;
							default:
								command->Init(cmJmp, IntelOperand(otValue, cpu_address_size(), 0, api_address));
								if (api_entry)
									command->AddLink(0, ltJmp, api_entry);
								else
									command->AddLink(0, ltJmp, api_address);
								break;
							}
							break;

						default:
							throw std::runtime_error("Unknown API from SDK: " + import_function->name());
					}

					command->CompileToNative();
				}
			}
		}
	}

	for (i = 0; i < count(); i++) {
		item(i)->CompileToNative();
	}

	return IntelFunction::Init(ctx);
}

/**
 * PEIntelSDK
 */

PEIntelSDK::PEIntelSDK(IFunctionList *parent, OperandSize cpu_address_size)
	: IntelSDK(parent, cpu_address_size)
{

}

bool PEIntelSDK::Init(const CompileContext &ctx)
{
	if (!IntelSDK::Init(ctx))
		return false;

	PEArchitecture *file = reinterpret_cast<PEArchitecture *>(ctx.file);
	if (file->import_list()->has_sdk() && ctx.runtime == NULL) {
		// remove SDK from import
		PEDirectory *dir = file->command_list()->GetCommandByType(IMAGE_DIRECTORY_ENTRY_IMPORT);
		if (!dir)
			return false;

		size_t i, j;
		IntelCommand *command;
		uint64_t address = dir->address();

		CommandBlock *block = AddBlock(count(), true);
		block->set_address(address);

		for (i = 0; i < file->import_list()->count(); i++) {
			PEImport *import = file->import_list()->item(i);
			if (import->is_sdk()) {
				import->FreeByManager(*ctx.manager, true);
			} else {
				if (!file->AddressSeek(address))
					return false;

				for (j = 0; j < 5; j++) {
					command = Add(0);
					command->ReadValueFromFile(*file, osDWord);
					command->include_option(roWritable);
				}
			}
			address += 5 * sizeof(uint32_t);
		}
		for (j = 0; j < 5; j++) {
			command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
			command->CompileToNative();
		}
		block->set_end_index(count() - 1);

		for (i = block->start_index(); i <= block->end_index(); i++) {
			item(i)->set_block(block);
		}
	}

	return true;
}

/**
 * PEIntelExport
 */

PEIntelExport::PEIntelExport(IFunctionList *owner, OperandSize cpu_address_size)
	: IntelFunction(owner, cpu_address_size), size_(0)
{
	set_compilation_type(ctMutation);
}

bool PEIntelExport::Init(const CompileContext &ctx)
{
	PEArchitecture *file = reinterpret_cast<PEArchitecture *>(ctx.file);
	size_ = file->export_list()->WriteToData(*this, file->image_base());
	if (count())
		set_entry(item(0));

	return IntelFunction::Init(ctx);
}

bool PEIntelExport::Compile(const CompileContext &ctx)
{
	CreateBlocks();
	block_list()->CompileBlocks(*ctx.manager);
	CompileLinks(ctx);
	return true;
}

/**
 * IntelImport
 */

IntelImport::IntelImport(IFunctionList *owner, OperandSize cpu_address_size)
	: IntelFunction(owner, cpu_address_size)
{
	set_compilation_type(ctMutation);
}

IntelCommand *IntelImport::GetIATCommand(PEImportFunction *import_function) const
{
	size_t i;

	for (i = 0; i < iat_info_list_.size(); i++) {
		if (iat_info_list_[i].import_function->address() == import_function->address()) {
			return iat_info_list_[i].command;
		}
	}

	return NULL;
}

bool IntelImport::Init(const CompileContext &ctx)
{
	IntelCommandType value_type, rand_type, ref_type;
	size_t i, j, n, k, c, index, r;
	PEImportList *import_list;
	PEImport *import;
	PEImportFunction *import_function;
	IATInfo iat_info;
	IntelCommand *command, *src_command, *iat_command, *ref_command;
	ReferenceList call_references;
	MapFunction *map_function;
	uint64_t address, rand_value;
	PEArchitecture *file;
	uint8_t mov_registr, rand_registr;
	bool is_mov_command;
	CommandLink *link;

	value_type = (cpu_address_size() == osDWord) ? cmDD : cmDQ;
	k = (ctx.runtime && ctx.runtime->segment_list()->count() > 0) ? 2 : 1;
	for (n = 0; n < k; n++) {
		file = reinterpret_cast<PEArchitecture *>((n == 0) ? ctx.file : ctx.runtime);
		import_list = file->import_list();
		for (i = 0; i < import_list->count(); i++) {
			import = import_list->item(i);

			// APIs processed by IntelSDK
			if (import->is_sdk()) 
				continue;

			if (import->excluded_from_import_protection())
				continue;

			for (j = 0; j < import->count(); j++) {
				import_function = import->item(j);

				if (import_function->options() & (ioHasDataReference | ioNoReferences))
					continue;

				iat_info.import_function = import_function;
				iat_info.command = NULL;
				iat_info.from_runtime = (n > 0);
				iat_info_list_.push_back(iat_info);
			}
		}
	}

	index = count();
	for (i = 0; i < iat_info_list_.size(); i++) {
		import_function = iat_info_list_[i].import_function;

		command = AddCommand(value_type, IntelOperand(otValue, cpu_address_size(), 0, (value_type == cmDD) ? rand32() : rand64()));
		// second operand is a key for decrypt IAT value
		command->set_operand_value(1, (import_function->options() & ioNative) ? 0 : DWordToInt64(rand32()));
		command->include_option(roCreateNewBlock);
		command->include_option(roWritable);

		iat_info_list_[i].command = command;

		map_function = import_function->map_function();

		call_references.clear();
		for (r = 0; r < 2; r++) {
			ReferenceList *reference_list = (r == 0) ? map_function->reference_list() : &call_references;

			for (n = 0; n < reference_list->count(); n++) {
				address = reference_list->item(n)->address();

				src_command = reinterpret_cast<IntelCommand *>(ctx.file->function_list()->GetCommandByNearAddress(address, true));
				iat_command = iat_info_list_[i].command;

				file = reinterpret_cast<PEArchitecture *>((iat_info_list_[i].from_runtime) ? ctx.runtime : ctx.file);

				if (file == NULL || !file->AddressSeek(address))
					return false;

				ref_command = Add(address);
				ref_command->ReadFromFile(*file);
				if (ref_command->type() == cmInt) {
					// reference command from runtime
					if (!src_command)
						throw std::runtime_error("Runtime error at Init");

					delete ref_command;
					ref_command = src_command->Clone(this);
					AddObject(ref_command);
				}

				// delete fixups
				for (k = 0; k < 3; k++) {
					IntelOperand operand = ref_command->operand(k);
					if (operand.type == otNone)
						break;

					IFixup *fixup = operand.fixup;
					if (fixup && fixup != NEED_FIXUP)
						fixup->set_deleted(true);
				}

				is_mov_command = (ref_command->type() == cmMov && ref_command->operand(0).type == otRegistr && ref_command->operand(0).size == cpu_address_size());
				ref_type = static_cast<IntelCommandType>(ref_command->type());
				mov_registr = ref_command->operand(0).registr;
				rand_registr = rand() % 8;
				if (rand_registr == regESP)
					rand_registr = regEAX;

				c = ref_command->original_dump_size();
				if (src_command == NULL && c > 5) {
					IntelCommand *push_command;
					switch (rand() % (is_mov_command ? 3 : 2)) {
					case 2:
						rand_type = cmPop;
						AddCommand(cmXchg, IntelOperand(otMemory | otRegistr, cpu_address_size(), regESP), IntelOperand(otRegistr, cpu_address_size(), mov_registr));
						push_command = AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), mov_registr));
						break;
					case 1:
						rand_type = cmPush;
						push_command = AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), rand_registr));
						AddCommand(cmXchg, IntelOperand(otMemory | otRegistr, cpu_address_size(), regESP), IntelOperand(otRegistr, cpu_address_size(), rand_registr));
						break;
					default:
						rand_type = cmNop;
						push_command = NULL;
						break;
					}
					if (push_command) {
						push_command->CompileToNative();
						c -= push_command->dump_size();
					}
				} else {
					rand_type = cmUnknown;
					c = 0;
				}

				if (is_mov_command && mov_registr == rand_registr) {
					if (c > 5) {
						AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), rand_registr));
						AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size(), rand_registr), 
							IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), rand_registr, c - 5));
						AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), rand_registr));
					}
				} else {
					AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), rand_registr));
					if (c > 5 && ref_type != cmJmp) {
						AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), rand_registr), 
							IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regESP, OperandSizeToValue(cpu_address_size())));
						AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size(), rand_registr), 
							IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), rand_registr, c - 5));
						AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regESP, OperandSizeToValue(cpu_address_size())),
							IntelOperand(otRegistr, cpu_address_size(), rand_registr));
					}
				}

				rand_value = file->segment_list()->item(0)->address() + rand32() % file->segment_list()->item(0)->size();
				if (cpu_address_size() == osDWord) {
					AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), rand_registr), 
						IntelOperand(otValue, cpu_address_size(), 0, rand_value, NEED_FIXUP));
				} else {
					AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size(), rand_registr), 
						IntelOperand(otMemory | otValue, cpu_address_size(), 0, rand_value, LARGE_VALUE));
				}

				// read random registr from IAT
				command = AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), rand_registr), 
					IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), rand_registr, 0x80000000));
				link = command->AddLink(1, ltOffset, iat_command);
				link->set_sub_value(rand_value);

				// decrypt API`s address in random registr
				AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size(), rand_registr), 
					IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), rand_registr, iat_command->operand(1).value));

				// restore random registr
				if (ref_type == cmJmp || ref_type == cmCall) {
					AddCommand(cmXchg, IntelOperand(otMemory | otRegistr, cpu_address_size(), regESP), IntelOperand(otRegistr, cpu_address_size(), rand_registr));
				} else if (is_mov_command && mov_registr != rand_registr){
					IntelOperand ref_operand = ref_command->operand(0);
					if ((ref_operand.type & otBaseRegistr) && ref_operand.base_registr == regESP) {
						ref_operand.type |= otValue;
						ref_operand.value += OperandSizeToValue(cpu_address_size());
					}

					AddCommand(cmMov, ref_operand, IntelOperand(otRegistr, ref_operand.size, rand_registr));
					AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), rand_registr));
				}

				if (ref_type == cmJmp) {
					AddCommand(cmRet, IntelOperand(otValue, osWord, 0, OperandSizeToValue(cpu_address_size())));
				} else {
					AddCommand(cmRet);
				}

				// clear operands
				ref_command->Init(cmNop);
				ref_command->set_address(0);
				ref_command->set_address_range(NULL);

				if (src_command) {
					delete src_command->link();
					src_command->Init(cmCall, IntelOperand(otValue, cpu_address_size()));
					if (ref_type == cmJmp)
						src_command->include_option(roUseAsJmp);
					src_command->AddLink(0, ltCall, ref_command);
				} else {
					c = ref_command->original_dump_size();
					if (rand_type == cmPush || rand_type == cmPop) {
						CommandBlock *block = AddBlock(index, true);
						block->set_address(address);

						command = new IntelCommand(this, cpu_address_size(), rand_type, IntelOperand(otRegistr, cpu_address_size(), (rand_type == cmPop) ? mov_registr : rand_registr));
						command->CompileToNative();
						command->set_block(block);
						InsertObject(index++, command);

						address += command->dump_size();
						c -= command->dump_size();
					}

					ctx.manager->Add(address, c, file->segment_list()->GetMemoryTypeByAddress(address), this);

					ext_command_list()->Add(address, ref_command, true);
				}

				if (ref_type == cmJmp) {
					address = reference_list->item(n)->address();

					for (j = 0; j < ctx.file->function_list()->count(); j++) {
						IntelFunction *func = reinterpret_cast<IntelFunction *>(ctx.file->function_list()->item(j));
						if (!func->need_compile())
							continue;

						for (k = 0; k < func->link_list()->count(); k++) {
							CommandLink *link = func->link_list()->item(k);
							if (link->type() != ltCall)
								continue;

							 command = reinterpret_cast<IntelCommand *>(link->from_command());
							 if (command->type() == cmCall && command->operand(0).type == otValue && command->operand(0).value == address)
								 call_references.Add(command->address(), 0);
						}
					}
				}
			}
		}
	}

	for (i = 0; i < count(); i++) {
		item(i)->CompileToNative();
	}

	return IntelFunction::Init(ctx);
}

/**
 * IntelCRCTable
 */

IntelCRCTable::IntelCRCTable(IFunctionList *owner, OperandSize cpu_address_size)
	: IntelFunction(owner, cpu_address_size)
{
	set_compilation_type(ctMutation);
}

bool IntelCRCTable::Init(const CompileContext &ctx)
{
	size_t i, c, n, f;

	c = 10;
	f = (ctx.runtime && ctx.runtime->segment_list()->count() > 0) ? 2 : 1;
	for (n = 0; n < f; n++) {
		IArchitecture *file = (n == 0) ? ctx.file : ctx.runtime;
		c += ctx.file->segment_list()->count();
		if ((ctx.options.flags & cpStripFixups) == 0)
			c += file->fixup_list()->count();
		if (ctx.options.flags & cpImportProtection) {
			IImportList *import_list = file->import_list();
			for (i = 0; i < import_list->count(); i++) {
				c += import_list->item(i)->count();
			}
		} else {
			c += file->import_list()->count();
		}
	}

	for (i = 0; i < c; i++) {
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
	}

	size_entry_ = AddCommand(cmDD, IntelOperand(otValue, osDWord));
	size_entry_->include_option(roCreateNewBlock);

	hash_entry_ = AddCommand(cmDD, IntelOperand(otValue, osDWord));
	hash_entry_->include_option(roCreateNewBlock);

	for (i = 0; i < count(); i++) {
		IntelCommand *command = item(i);
		command->CompileToNative();
		command->include_option(roWritable);
	}

	return IntelFunction::Init(ctx);
}

/**
 * IntelRuntimeCRCTable
 */

IntelRuntimeCRCTable::IntelRuntimeCRCTable(IFunctionList *owner, OperandSize cpu_address_size)
	: IntelFunction(owner, cpu_address_size), cryptor_(NULL)
{
	set_compilation_type(ctMutation);
}

void IntelRuntimeCRCTable::clear()
{
	region_info_list_.clear();
	IntelFunction::clear();
}

bool IntelRuntimeCRCTable::Compile(const CompileContext &ctx)
{
	IntelFunctionList *function_list = reinterpret_cast<IntelFunctionList *>(ctx.file->function_list());
	cryptor_ = function_list->crc_cryptor();

	size_t block_size, i, j, k, end_operand_index;
	uint64_t block_address;
	bool check_fixups = (ctx.options.flags & cpStripFixups) == 0;
	MemoryManager manager(ctx.file);

	for (i = 0; i < function_list->count(); i++) {
		IntelFunction *func = function_list->item(i);
		if (!func->need_compile())
			continue;

		for (j = 0; j < func->block_list()->count(); j++) {
			CommandBlock *block = func->block_list()->item(j);
			if (block->type() & mtExecutable) {
				// native block
				block_size = 0;
				block_address = 0;
				for (k = block->start_index(); k <= block->end_index(); k++) {
					IntelCommand *command = func->item(k);
					if (command->options() & roWritable)
						continue;

					if (block_address && (block_address + block_size) != command->address()) {
						if (block_size)
							manager.Add(block_address, block_size, mtReadable);
						block_address = 0;
						block_size = 0;
					}
					if (!block_address)
						block_address = command->address();

					end_operand_index = NOT_ID;
					for (size_t n = 0; n < 3; n++) {
						IntelOperand operand = command->operand(n);
						if (operand.type == otNone)
							break;

						if ((operand.type & otValue) && ((check_fixups && operand.fixup) || operand.relocation)) {
							end_operand_index = n;
							break;
						}
					}
					block_size += (end_operand_index == NOT_ID) ? command->dump_size() : command->operand(end_operand_index).value_pos;
				}
				if (block_size)
					manager.Add(block_address, block_size, mtReadable);
			} else {
				// VM block
				IntelCommand *command = func->item(block->end_index());
				block_size = 0;
				if (command->section_options() & rtBackwardDirection) {
					block_address = command->vm_address() - command->vm_dump_size();
					for (k = command->count(); k > 0; k--) {
						IntelVMCommand *vm_command = command->item(k - 1);
						if (check_fixups && vm_command->fixup())
							break;
						block_size += vm_command->dump_size();
					}
				} else {
					block_address = command->vm_address();
					for (k = 0; k < command->count(); k++) {
						IntelVMCommand *vm_command = command->item(k);
						if (check_fixups && vm_command->fixup())
							break;
						block_size += vm_command->dump_size();
					}
				}
				if (block_size)
					manager.Add(block_address, block_size, mtReadable);
			}
		}
	}
	if (manager.count() == 0)
		return true;

	manager.Pack();

	for (i = 0; i < manager.count(); i++) {
		MemoryRegion *region = manager.item(i);
		uint64_t block_address = region->address();

		size_t region_size, block_size;
		for (region_size = region->size(); region_size != 0; region_size -= block_size, block_address += block_size) {
			block_size = 0x1000 - (rand() & 0xff);
			if (block_size > region_size)
				block_size = region_size;

			region_info_list_.push_back(RegionInfo(block_address, static_cast<uint32_t>(block_size), false));
		}
	}

	for (i = 0; i < region_info_list_.size(); i++) {
		std::swap(region_info_list_[i], region_info_list_[rand() % region_info_list_.size()]);
	}

	size_t self_crc_offset = 0;
	size_t self_crc_size = 0;
	for (i = 0; i < region_info_list_.size(); i++) {
		self_crc_size += sizeof(CRCInfo::POD);
		if (self_crc_size > 0x1000 && (rand() & 1)) {
			region_info_list_.insert(region_info_list_.begin() + i + 1, RegionInfo(self_crc_offset, (uint32_t)self_crc_size, true));
			self_crc_offset += self_crc_size;
			self_crc_size = 0;
		}
	}
	if (self_crc_size)
		region_info_list_.push_back(RegionInfo(self_crc_offset, (uint32_t)self_crc_size, true));

	for (i = 0; i < region_info_list_.size(); i++) {
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
	}
	set_entry(item(0));
	for (i = 0; i < count(); i++) {
		item(i)->CompileToNative();
	}

	CreateBlocks();

	for (i = 0; i < block_list()->count(); i++) {
		block_list()->item(i)->Compile(*ctx.manager);
	}

	return true;
}

size_t IntelRuntimeCRCTable::WriteToFile(IArchitecture &file)
{
	size_t res = IntelFunction::WriteToFile(file);

	if (entry()) {
		uint64_t address = entry()->address();
		std::vector<CRCInfo> crc_info_list;
		std::vector<uint8_t> dump;
		for (size_t i = 0; i < region_info_list_.size(); i++) {
			RegionInfo region_info = region_info_list_[i];

			dump.resize(region_info.size);
			if (region_info.is_self_crc) {
				memcpy(&dump[0], reinterpret_cast<uint8_t *>(&crc_info_list[0]) + region_info.address, dump.size());
				region_info.address += address;
			} else {
				file.AddressSeek(region_info.address);
				file.Read(&dump[0], dump.size());
			}

			CRCInfo crc_info(static_cast<uint32_t>(region_info.address - file.image_base()), dump);
			if (cryptor_) {
				crc_info.pod.address = static_cast<uint32_t>(cryptor_->Encrypt(crc_info.pod.address));
				crc_info.pod.size = static_cast<uint32_t>(cryptor_->Encrypt(crc_info.pod.size));
			}
			crc_info.pod.hash = 0 - crc_info.pod.hash;
			crc_info_list.push_back(crc_info);
		}

		file.AddressSeek(address);
		file.Write(&crc_info_list[0], crc_info_list.size() * sizeof(CRCInfo::POD));
	}

	return res;
}

/**
 * IntelLoaderData
 */

IntelLoaderData::IntelLoaderData(IFunctionList *owner, OperandSize cpu_address_size)
	: IntelFunction(owner, cpu_address_size)
{
	set_compilation_type(ctMutation);
}

bool IntelLoaderData::Init(const CompileContext &ctx)
{
	IntelCommand *command = AddCommand(cpu_address_size(), 0);
	if (!command)
		return false;

	command->CompileToNative();
	command->include_option(roWritable);
	set_entry(command);
	set_entry_type(etNone);

	return IntelFunction::Init(ctx);
}

/**
 * IntelRuntimeData
 */

IntelRuntimeData::IntelRuntimeData(IFunctionList *owner, OperandSize cpu_address_size)
	: IntelFunction(owner, cpu_address_size), strings_entry_(NULL), strings_size_(0), resources_entry_(NULL), resources_size_(0),
	trial_hwid_entry_(NULL), trial_hwid_size_(0), data_key_(0)
#ifdef ULTIMATE
	, license_data_entry_(NULL), license_data_size_(0), files_entry_(NULL), files_size_(0),
	registry_entry_(NULL), registry_size_(0)
#endif	
{
	set_compilation_type(ctMutation);
	rc5_key_.Create();
}

bool IntelRuntimeData::CommandCompareHelper::operator()(const IntelCommand *left, IntelCommand *right) const
{
	return (left->address() < right->address());
}

bool IntelRuntimeData::Init(const CompileContext &ctx)
{
	IntelFunctionList *function_list;
	size_t i, j, index, k;
	std::vector<IntelCommand *> string_command_list;
	IntelCommand *command, *string_command;
	CommandLink *link;
	IntelCommand *key_entry;
	Data key;
	uint64_t image_base = ctx.file->image_base();

	key.PushBuff(rc5_key_.Value, sizeof(rc5_key_.Value));
	data_key_ = key.ReadDWord(0);

	resources_entry_ = NULL;
	resources_size_ = 0;
	if ((ctx.options.flags & cpResourceProtection) && ctx.file->resource_list() && ctx.file->resource_list()->count()) {
		PEArchitecture *file = reinterpret_cast<PEArchitecture *>(ctx.file);
		PEResourceList resource_list(NULL);
		for (i = 0; i < file->resource_list()->count(); i++) {
			PEResource *resource = file->resource_list()->item(i);
			if (resource->need_store())
				continue;

			resource_list.AddObject(resource->Clone(&resource_list));
		}

		if (resource_list.count()) {
			index = count();

			std::vector<PEResource *> list;
			PEResource *resource;

			// create resource list
			for (i = 0; i < resource_list.count(); i++) {
				list.push_back(resource_list.item(i));
			}

			for (i = 0; i < list.size(); i++) {
				resource = list[i];
				for (j = 0; j < resource->count(); j++) {
					list.push_back(resource->item(j));
				}
			}

			// create root directory
			uint32_t number_of_id_entries = 0;
			uint32_t number_of_named_entries = 0;
			for (i = 0; i < resource_list.count(); i++) {
				if (resource_list.item(i)->has_name()) {
					number_of_named_entries++;
				} else {
					number_of_id_entries++;
				}
			}
			AddCommand(osDWord, number_of_named_entries);
			AddCommand(osDWord, number_of_id_entries);

			for (i = 0; i < resource_list.count(); i++) {
				resource_list.item(i)->WriteEntry(*this);
			}

			for (i = 0; i < list.size(); i++) {
				list[i]->WriteHeader(*this);
			}

			resources_entry_ = item(index);
			resources_entry_->include_option(roCreateNewBlock);
			resources_size_ = static_cast<uint32_t>((count() - index) * OperandSizeToValue(osDWord));

			for (i = 0; i < list.size(); i++) {
				list[i]->WriteName(*this, index, data_key_);
			}

			for (i = 0; i < list.size(); i++) {
				list[i]->WriteData(*this, *file, data_key_);
			}
		}
	}

#ifdef ULTIMATE
	files_entry_ = NULL;
	files_size_ = 0;
	if (ctx.options.file_manager) {
		FileManager *file_manager = ctx.options.file_manager;
		if (!file_manager->OpenFiles())
			return false;

		std::vector<FileFolder *> folder_list;
		for (i = 0; i < file_manager->folder_list()->count(); i++) {
			folder_list.push_back(file_manager->folder_list()->item(i));
		}
		for (i = 0; i < folder_list.size(); i++) {
			FileFolder *file_folder = folder_list[i];
			for (j = 0; j < file_folder->count(); j++) {
				folder_list.push_back(file_folder->item(j));
			}
		}

		// create root directory
		index = count();
		AddCommand(osDWord, file_manager->count() + folder_list.size());

		for (i = 0; i < file_manager->count(); i++) {
			file_manager->item(i)->WriteEntry(*this);
		}
		for (i = 0; i < folder_list.size(); i++) {
			folder_list[i]->WriteEntry(*this);
		}

		files_entry_ = item(index);
		files_entry_->include_option(roCreateNewBlock);
		files_size_ = static_cast<uint32_t>((count() - index) * OperandSizeToValue(osDWord));

		for (i = 0; i < file_manager->count(); i++) {
			file_manager->item(i)->WriteName(*this, image_base, data_key_);
		}
		for (i = 0; i < folder_list.size(); i++) {
			folder_list[i]->WriteName(*this, image_base, data_key_);
		}

		for (i = 0; i < file_manager->count(); i++) {
			InternalFile *internal_file = file_manager->item(i);
			Notify(mtInformation, NULL, string_format("%s %s", language[lsLoading].c_str(), os::ExtractFileName(internal_file->absolute_file_name().c_str()).c_str()));
			internal_file->WriteData(*this, image_base, data_key_);
		}

		file_manager->CloseFiles();
	}

	registry_entry_ = NULL;
	registry_size_ = 0;
	if (ctx.options.file_manager && ctx.options.file_manager->server_count()) {
		index = count();

		// create root directory
		AddCommand(osDWord, 0);
		AddCommand(osDWord, 0);

		registry_entry_ = item(index);
		registry_entry_->include_option(roCreateNewBlock);
		for (i = index; i < count(); i++) {
			command = item(i);
			registry_size_ += (command->type() == cmDB) ? (uint32_t)command->dump_size() : OperandSizeToValue(command->operand(0).size);
		}

		i = AlignValue(registry_size_, 8);
		if (i > registry_size_) {
			Data tmp;
			tmp.resize(i - registry_size_, 0);
			AddCommand(tmp);
			registry_size_ = (uint32_t)i;
		}
	}
#endif

	function_list = reinterpret_cast<IntelFunctionList *>(ctx.file->function_list());
	for (i = 0; i < function_list->count(); i++) {
		IntelFunction *func = function_list->item(i);
		if (func->need_compile() && func->type() == otString) {
			for (j = 0; j < func->count(); j++) {
				string_command_list.push_back(func->item(j));
			}
		}
	}

	key_entry = AddCommand(key);
	key_entry->include_option(roCreateNewBlock);

	strings_entry_ = NULL;
	strings_size_ = 0;
	if (string_command_list.size()) {
		std::sort(string_command_list.begin(), string_command_list.end(), CommandCompareHelper());
		index = count();

		// create directory
		AddCommand(osDWord, string_command_list.size());

		for (i = 0; i < string_command_list.size(); i++) {
			string_command = string_command_list[i];

			// create string entry
			AddCommand(osDWord, string_command->address() - ctx.file->image_base());
			command = AddCommand(osDWord, 0);
			link = command->AddLink(0, ltOffset);
			link->set_sub_value(ctx.file->image_base());
			AddCommand(osDWord, string_command->dump_size());
		}
		strings_entry_ = item(index);
		strings_entry_->include_option(roCreateNewBlock);
		strings_size_ = static_cast<uint32_t>((count() - index) * OperandSizeToValue(osDWord));

		// create string values
		Data data;
		for (i = 0; i < string_command_list.size(); i++) {
			string_command = string_command_list[i];

			data.clear();
			for (j = 0; j < string_command->dump_size(); j++) {
				data.PushByte(string_command->dump(j) ^ static_cast<uint8_t>(_rotl32(data_key_, static_cast<int>(j)) + j));
			}

			command = AddCommand(data);
			command->include_option(roCreateNewBlock);

			item(index + 1 + i * 3 + 1)->link()->set_to_command(command);
		}
	}

#ifdef ULTIMATE
	license_data_entry_ = NULL;
	license_data_size_ = 0;
	if (ctx.options.licensing_manager) {
		Data license_data;
		if (ctx.options.licensing_manager->GetLicenseData(license_data)) {
			license_data_entry_ = AddCommand(license_data);
			license_data_entry_->include_option(roCreateNewBlock);
			license_data_size_ = static_cast<uint32_t>(license_data.size());
		}
	}
#endif

	VMProtectBeginVirtualization("Trial HWID");
	trial_hwid_entry_ = NULL;
	trial_hwid_size_ = 0;
#ifdef DEMO
	if (true)
#else
	if (ctx.options.flags & cpUnregisteredVersion)
#endif
	{
		size_t size = VMProtectGetCurrentHWID(NULL, 0);
		std::vector<char> hwid;
		hwid.resize(size);
		VMProtectGetCurrentHWID(hwid.data(), (int)hwid.size());

		std::vector<uint8_t> binary;
		binary.resize(size);
		Base64Decode(hwid.data(), hwid.size(), binary.data(), size);

		Data data;
		data.PushBuff(binary.data(), binary.size());
		data.resize(64);

		trial_hwid_size_ = static_cast<uint32_t>(std::min(size, data.size()));
		trial_hwid_entry_ = AddCommand(data);
		trial_hwid_entry_->include_option(roCreateNewBlock);
	}
#ifdef ULTIMATE
	else if (!ctx.options.hwid.empty()) {
		std::string hwid = ctx.options.hwid;
		size_t size = hwid.size();

		std::vector<uint8_t> binary;
		binary.resize(size);
		Base64Decode(hwid.data(), hwid.size(), binary.data(), size);
		if (size & 3) {
			Notify(mtError, NULL, "Invalid HWID");
			return false;
		}

		Data data;
		data.PushBuff(binary.data(), binary.size());
		data.resize(64);

		trial_hwid_size_ = static_cast<uint32_t>(std::min(size, data.size()));
		trial_hwid_entry_ = AddCommand(data);
		trial_hwid_entry_->include_option(roCreateNewBlock);
	}
#endif
	VMProtectEnd();

	for (i = 0; i < count(); i++) {
		item(i)->CompileToNative();
	}

	// setup faces for common runtime functions
	IntelCRCTable *intel_crc = reinterpret_cast<IntelFunctionList *>(ctx.file->function_list())->crc_table();
	for (k = 0; k < function_list->count(); k++) {
		IntelFunction *func = function_list->item(k);
		if (!func->from_runtime() || func->tag() == ftLoader)
			continue;

		for (i = 0; i < func->count(); i++) {
			IntelCommand *command = func->item(i);
			for (j = 0; j < 3; j++) {
				IntelOperand operand = command->operand(j);
				if (operand.type == otNone)
					break;

				if ((operand.type & otValue) == 0)
					continue;

				if (operand.size == osQWord && ((operand.value >> 32) & 0xFFFF0000) == 0xFACE0000) {
					command->Init(static_cast<IntelCommandType>(command->type()), command->operand(0), IntelOperand(otValue, operand.size, 0, operand.value >> 32));
					func->InsertObject(i + 1, new IntelCommand(func, func->cpu_address_size(), cmShl, command->operand(0), IntelOperand(otValue, osWord, 0, 32)));
					func->InsertObject(i + 2, new IntelCommand(func, func->cpu_address_size(), cmAdd, command->operand(0), IntelOperand(otValue, operand.size, 0, static_cast<uint32_t>(operand.value))));
					operand = command->operand(1);
				}

				uint32_t value = static_cast<uint32_t>(operand.value);
				// clang optimization
				if (value == FACE_RC5_P + FACE_RC5_Q) {
					command->set_operand_value(j, rc5_key_.P + rc5_key_.Q);
					command->CompileToNative();
					continue;
				}
				if (value == FACE_RC5_P + FACE_RC5_Q + FACE_RC5_Q) {
					command->set_operand_value(j, rc5_key_.P + rc5_key_.Q + rc5_key_.Q);
					command->CompileToNative();
					continue;
				}

				bool is_neg = false;
				if ((value & 0xFFFF0000) != 0xFACE0000) {
					value = 0 - value;
					is_neg = true;
				}

				if ((value & 0xFFFF0000) == 0xFACE0000) {
					switch (value) {
					case FACE_STRING_INFO:
						if (strings_entry_) {
							link = command->AddLink((int)j, ltOffset, strings_entry_);
							link->set_sub_value(image_base);
						} else {
							command->set_operand_value(j, 0);
							command->CompileToNative();
						}
						break;
					case FACE_RESOURCE_INFO:
						if (resources_entry_) {
							link = command->AddLink((int)j, ltOffset, resources_entry_);
							link->set_sub_value(image_base);
						} else {
							command->set_operand_value(j, 0);
							command->CompileToNative();
						}
						break;
					case FACE_KEY_INFO:
						if (key_entry) {
							link = command->AddLink((int)j, ltOffset, key_entry);
							link->set_sub_value(image_base);
						} else {
							command->set_operand_value(j, 0);
							command->CompileToNative();
						}
						break;
#ifdef ULTIMATE
					case FACE_STORAGE_INFO:
						if (files_entry_) {
							link = command->AddLink((int)j, ltOffset, files_entry_);
							link->set_sub_value(image_base);
						} else {
							command->set_operand_value(j, 0);
							command->CompileToNative();
						}
						break;
					case FACE_REGISTRY_INFO:
						if (registry_entry_) {
							link = command->AddLink((int)j, ltOffset, registry_entry_);
							link->set_sub_value(image_base);
						} else {
							command->set_operand_value(j, 0);
							command->CompileToNative();
						}
						break;
					case FACE_LICENSE_INFO:
						if (license_data_entry_) {
							link = command->AddLink((int)j, ltOffset, license_data_entry_);
							link->set_sub_value(image_base);
						} else {
							command->set_operand_value(j, 0);
							command->CompileToNative();
						}
						break;
					case FACE_LICENSE_INFO_SIZE:
						command->set_operand_value(j, license_data_size_);
						command->CompileToNative();
						break;
#else
					case FACE_STORAGE_INFO:
					case FACE_REGISTRY_INFO:
					case FACE_LICENSE_INFO:
					case FACE_LICENSE_INFO_SIZE:
						command->set_operand_value(j, 0);
						command->CompileToNative();
						break;
#endif
					case FACE_TRIAL_HWID:
						if (trial_hwid_entry_) {
							link = command->AddLink((int)j, ltOffset, trial_hwid_entry_);
							link->set_sub_value(image_base);
						} else {
							command->set_operand_value(j, 0);
							command->CompileToNative();
						}
						break;
					case FACE_TRIAL_HWID_SIZE:
						command->set_operand_value(j, trial_hwid_size_);
						command->CompileToNative();
						break;
					case FACE_RC5_P:
						command->set_operand_value(j, is_neg ? 0 - rc5_key_.P : rc5_key_.P);
						command->CompileToNative();
						break;
					case FACE_RC5_Q:
						command->set_operand_value(j, is_neg ? 0 - rc5_key_.Q : rc5_key_.Q);
						command->CompileToNative();
						break;
					case FACE_CRC_INFO_SALT:
						command->set_operand_value(j, function_list->crc_cryptor()->item(0)->value());
						command->CompileToNative();
						break;
					case FACE_IMAGE_BASE:
						if (command->operand(0).size != cpu_address_size()) {
							IntelOperand first = command->operand(0);
							IntelOperand second = command->operand(1);
							first.size = cpu_address_size();
							second.size = cpu_address_size();
							command->Init(static_cast<IntelCommandType>(command->type()), first, second);
						}
						command->set_operand_value(j, image_base);
						command->set_operand_fixup(j, NEED_FIXUP);
						command->CompileToNative();
						break;
					case FACE_CRC_TABLE_ENTRY:
						if (intel_crc) {
							link = command->AddLink((int)j, ltOffset, intel_crc->table_entry());
							link->set_sub_value(image_base);
						} else {
							command->set_operand_value(j, 0);
							command->CompileToNative();
						}
						break;
					case FACE_CRC_TABLE_SIZE:
						if (intel_crc) {
							link = command->AddLink((int)j, ltOffset, intel_crc->size_entry());
							link->set_sub_value(image_base);
						} else {
							command->set_operand_value(j, 0);
							command->CompileToNative();
						}
						break;
					case FACE_CRC_TABLE_HASH:
						if (intel_crc) {
							link = command->AddLink((int)j, ltOffset, intel_crc->hash_entry());
							link->set_sub_value(image_base);
						} else {
							command->set_operand_value(j, 0);
							command->CompileToNative();
						}
						break;
					case FACE_CORE_OPTIONS:
						{
							uint32_t options = 0;
							if (ctx.options.flags & cpInternalMemoryProtection)
								options |= CORE_OPTION_MEMORY_PROTECTION;
							if (ctx.options.flags & cpCheckDebugger)
								options |= CORE_OPTION_CHECK_DEBUGGER;
							command->set_operand_value(j, options);
						}
						command->CompileToNative();
						break;
					case FACE_VAR_IS_PATCH_DETECTED:
					case FACE_VAR_IS_DEBUGGER_DETECTED:
					case FACE_VAR_LOADER_CRC_INFO:
					case FACE_VAR_LOADER_CRC_INFO_SIZE:
					case FACE_VAR_LOADER_CRC_INFO_HASH:
					case FACE_VAR_CPU_HASH:
					case FACE_VAR_SESSION_KEY:
					case FACE_VAR_DRIVER_UNLOAD:
					case FACE_VAR_CRC_IMAGE_SIZE:
					case FACE_VAR_LOADER_STATUS:
					case FACE_VAR_SERVER_DATE:
					case FACE_VAR_OS_BUILD_NUMBER:
						command->set_operand_value(j, ctx.runtime_var_index[(value & 0xff) >> 4] * OperandSizeToValue(cpu_address_size()));
						command->CompileToNative();
						break;
					case FACE_VAR_IS_PATCH_DETECTED_SALT:
					case FACE_VAR_IS_DEBUGGER_DETECTED_SALT:
					case FACE_VAR_LOADER_CRC_INFO_SALT:
					case FACE_VAR_LOADER_CRC_INFO_SIZE_SALT:
					case FACE_VAR_LOADER_CRC_INFO_HASH_SALT:
					case FACE_VAR_CPU_HASH_SALT:
					case FACE_VAR_DRIVER_UNLOAD_SALT:
					case FACE_VAR_CRC_IMAGE_SIZE_SALT:
					case FACE_VAR_SERVER_DATE_SALT:
					case FACE_VAR_OS_BUILD_NUMBER_SALT:
						command->set_operand_value(j, ctx.runtime_var_salt[value & 0xff]);
						command->CompileToNative();
						break;
					}
				}
			}
		}
	}

	return IntelFunction::Init(ctx);
}

size_t IntelRuntimeData::WriteToFile(IArchitecture &file)
{
	size_t res = IntelFunction::WriteToFile(file);

	CipherRC5 cipher(rc5_key_);
	for (size_t i = 0; i < 6; i++) {
		IntelCommand *command;
		size_t size;

		switch (i) {
		case 0:
			command = resources_entry_;
			size = resources_size_;
			break;
		case 1:
			command = strings_entry_;
			size = strings_size_;
			break;
		case 2:
			command = trial_hwid_entry_;
			size = AlignValue(trial_hwid_size_, 8);
			break;
#ifdef ULTIMATE
		case 3:
			command = license_data_entry_;
			size = license_data_size_;
			break;
		case 4:
			command = files_entry_;
			size = files_size_;
			break;
		case 5:
			command = registry_entry_;
			size = registry_size_;
			break;
#endif
		default:
			command = NULL;
			size = 0;
		}

		if (size) {
			std::vector<uint8_t> buff;
			buff.resize(size);
			file.AddressSeek(command->address());
			uint64_t pos = file.Tell();
			file.Read(&buff[0], buff.size());
#ifdef ULTIMATE
			if (command == trial_hwid_entry_) {
				cipher.Encrypt(buff.data(), buff.size());
			} else if (command == license_data_entry_) {
				size_t crc_pos = buff.size() - 16;
				cipher.Encrypt(buff.data(), crc_pos);
				SHA1 sha1;
				sha1.Input(buff.data(), crc_pos);
				const uint8_t *p = sha1.Result();
				for (size_t j = crc_pos; j < buff.size(); j++) {
					buff[j] = p[j - crc_pos];
				}
				cipher.Encrypt(buff.data() + crc_pos, 16);
			} else
#endif
			{
				uint32_t *p = reinterpret_cast<uint32_t*>(buff.data());
				for (size_t j = 0; j < size / sizeof(uint32_t); j++) {
					p[j] ^= data_key_;
				}
			}
			file.Seek(pos);
			file.Write(buff.data(), buff.size());
		}
	}

	return res;
}

/**
 * BaseIntelLoader
 */

BaseIntelLoader::BaseIntelLoader(IntelFunctionList *owner, OperandSize cpu_address_size)
	: IntelFunction(owner, cpu_address_size), data_segment_address_(0), import_segment_address_(0)
{
	set_tag(ftLoader);
}

void BaseIntelLoader::AddAVBuffer(const CompileContext &ctx)
{
	IntelCommand *command;
	uint32_t sum = 0;
	CommandBlock *block = AddBlock(count(), true);
	for (size_t i = 0; i < 64; i++) {
		uint32_t value = (i == 0) ? 0 : rand32();
		sum += value;
		command = AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, value));
		command->CompileToNative();
		command->set_block(block);
	}
	block->set_end_index(count() - 1);
	command = item(block->start_index());
	command->set_operand_value(0, 0xB7896EB5 - sum);
	command->CompileToNative();
	uint64_t address = ctx.manager->Alloc((block->end_index() - block->start_index() + 1) * sizeof(uint32_t), mtReadable);
	block->set_address(address);
}

bool BaseIntelLoader::Prepare(const CompileContext &ctx)
{
	size_t i, j;

	if (ctx.file->virtual_machine_list()->count() > 1) {
		std::set<ICommand *> call_list;

		for (i = 0; i < count(); i++) {
			IntelCommand *command = item(i);
			if (command->type() == cmCall && (command->options() & roInternal)) {
				ICommand *to_command = command->link()->to_command();
				if (!to_command)
					continue;

				call_list.insert(to_command);
				command_group_.insert(item(i + 1));
			}
		}
		if (!call_list.empty()) {
			for (i = 0; i < count(); i++) {
				IntelCommand *command = item(i);
				if (command->type() == cmRet && (command->options() & roInternal)) {
					IntelCommand *block_command = NULL;
					for (j = i; j > 0; j--) {
						command = item(j - 1);
						if (!block_command) {
							if ((command->type() == cmCall && ((command->section_options() & rtLinkedFrom) || (command->options() & roInternal) == 0))
								|| command->type() == cmJmp || command->type() == cmJmpWithFlag || command->type() == cmCmov || command->type() == cmRet || command->is_data())
								block_command = item(j);
						}
						if (call_list.find(command) != call_list.end()) {
							command_group_.insert(block_command ? block_command : command);
							break;
						}
					}
				}
			}
		}
	}

	// prepare loader's VM
	std::vector<IFunction *> function_list = ctx.file->function_list()->processor_list();
	for (size_t k = 0; k < function_list.size(); k++) {
		IntelFunction *func = reinterpret_cast<IntelFunction*>(function_list[k]);
		for (i = 0; i < func->count(); i++) {
			IntelCommand *command = func->item(i);
			for (j = 0; j < 3; j++) {
				IntelOperand operand = command->operand(j);
				if (operand.type == otNone)
					break;

				if (operand.fixup)
					command->set_operand_fixup(j, NEED_FIXUP);
			}
		}
		for (i = 0; i < func->function_info_list()->count(); i++) {
			FunctionInfo *info = func->function_info_list()->item(i);
			for (size_t j = 0; j < info->count(); j++) {
				AddressRange *address_range = info->item(j);
				address_range->set_begin(0);
				address_range->set_end(0);
			}
		}
	}

	// prepare ranges
	function_list.push_back(this);
	for (i = 0; i < function_list.size(); i++) {
		IntelFunction *func = reinterpret_cast<IntelFunction*>(function_list[i]);
		func->range_list()->Prepare();
		func->function_info_list()->Prepare();
	}

	return PrepareExtCommands(ctx);
}

IVirtualMachine *BaseIntelLoader::virtual_machine(IVirtualMachineList *virtual_machine_list, ICommand *command) const
{
	if (command_group_.find(command) != command_group_.end()) {
		for (std::set<ICommand *>::const_iterator it = command_group_.begin(); it != command_group_.end(); it++) {
			command = *it;
			if (command->block())
				return command->block()->virtual_machine();
		}
	}

	return IntelFunction::virtual_machine(virtual_machine_list, command);
}

bool BaseIntelLoader::Compile(const CompileContext &ctx)
{
	size_t i, j;

	if (ctx.options.flags & cpMemoryProtection) {
		IntelVirtualMachineList *virtual_machine_list = reinterpret_cast<IntelVirtualMachineList*>(ctx.file->virtual_machine_list());
		virtual_machine_list->ClearCRCMap();
	}

	if (!IntelFunction::Compile(ctx))
		return false;
	IntelFunction::AfterCompile(ctx);

	std::vector<IFunction *> function_list = ctx.file->function_list()->processor_list();
	function_list.push_back(this);
	std::vector<CommandBlock*> data_block_list[2], block_list;
	for (i = 0; i < function_list.size(); i++) {
		IFunction *func = function_list[i];
		for (j = 0; j < func->block_list()->count(); j++) {
			CommandBlock *block = func->block_list()->item(j);
			uint32_t command_options = block->function()->item(block->start_index())->options();
			if (command_options & roImportSegment)
				data_block_list[0].push_back(block);
			else if (command_options & roDataSegment)
				data_block_list[1].push_back(block);
			else 
				block_list.push_back(block);
		}
	}

	for (i = 0; i < block_list.size(); i++) {
		std::swap(block_list[i], block_list[rand() % block_list.size()]);
	}

	if (ctx.file->runtime_function_list() && ctx.file->runtime_function_list()->count()) {
		// sort blocks by address range
		for (i = 0; i < block_list.size(); i++) {
			block_list[i]->set_sort_index(i);
		}
		std::sort(block_list.begin(), block_list.end(), CommandBlockListCompareHelper());
	}

	for (i = 0; i < block_list.size(); i++) {
		block_list[i]->Compile(*ctx.manager);
	}

	for (j = 0; j < 2; j++) {
		std::vector<CommandBlock*> *list = &data_block_list[j];
		if (list->empty())
			continue;

		MemoryRegion *last_region = ctx.manager->item(ctx.manager->count() - 1);
		uint64_t address = last_region->address();
		uint64_t segment_address = AlignValue(address, ctx.file->segment_alignment());
		if (j == 0)
			import_segment_address_ = segment_address;
		else 
			data_segment_address_ = segment_address;
		if (segment_address > address)
			last_region->Alloc(segment_address - address, mtNone);
		for (i = 0; i < ctx.manager->count(); i++) {
			MemoryRegion *region = ctx.manager->item(i);
			if (region->address() < segment_address)
				region->exclude_type(mtReadable);
		}
		for (i = 0; i < list->size(); i++) {
			list->at(i)->Compile(*ctx.manager);
		}
	}

	for (i = 0; i < function_list.size(); i++) {
		function_list[i]->CompileInfo(ctx);
	}

	if (ctx.options.flags & cpMemoryProtection) {
		IntelFunctionList *function_list = reinterpret_cast<IntelFunctionList *>(ctx.file->function_list());
		IntelRuntimeCRCTable *runtime_crc_table = function_list->runtime_crc_table();
		for (i = 0; i < function_list->count(); i++) {
			IntelFunction *func = function_list->item(i);
			if (func == runtime_crc_table || func->tag() == ftProcessor || func == this)
				continue;

			func->set_need_compile(false);
		}
		runtime_crc_table->clear();
		runtime_crc_table->Compile(ctx);
	}

	for (i = 0; i < function_list.size(); i++) {
		IFunction *func = function_list[i];
		if (func->compilation_type() != ctMutation)
			continue;

		func->CompileLinks(ctx);
	}

	for (i = 0; i < function_list.size(); i++) {
		IFunction *func = function_list[i];
		if (func->compilation_type() == ctMutation)
			continue;

		func->CompileLinks(ctx);
	}

	return true;
}

/**
 * PEIntelLoader
 */

PEIntelLoader::PEIntelLoader(IntelFunctionList *owner, OperandSize cpu_address_size)
	: BaseIntelLoader(owner, cpu_address_size), import_entry_(NULL), import_size_(0), iat_entry_(NULL), iat_size_(0), 
	name_entry_(NULL), resource_section_info_(NULL), resource_packer_info_(NULL), export_entry_(NULL), export_size_(0),
	tls_entry_(NULL), tls_size_(0), file_crc_entry_(NULL), file_crc_size_(0), loader_crc_entry_(NULL), loader_crc_size_(0), 
	delay_import_entry_(NULL), delay_import_size_(0), tls_call_back_entry_(NULL), iat_address_(0),
	loader_crc_size_entry_(NULL), loader_crc_hash_entry_(NULL), file_crc_size_entry_(NULL), security_cookie_(0), cfg_check_function_entry_(NULL)
{

}

Data EncryptString(const char *str, uint32_t key)
{
	Data data;
	for (size_t i = 0; ; i++) {
		data.PushByte(str[i] ^ static_cast<uint8_t>(_rotl32(key, (int)i) + i));
		if (!str[i])
			break;
	}
	return data;
}

Data EncryptString(const os::unicode_char *str, uint32_t key)
{
	Data data;
	for (size_t i = 0; ; i++) {
		data.PushWord(str[i] ^ static_cast<uint16_t>(_rotl32(key, (int)i) + i));
		if (!str[i])
			break;
	}
	return data;
}

bool PEIntelLoader::Prepare(const CompileContext &ctx)
{
	size_t i, j, k, index, old_count, import_index, orig_dll_count, file_dll_count, start_index;
	PEImportList new_import_list(NULL);
	PEImport *import;
	PEImportFunction *import_function;
	IntelCommandType value_command_type;
	IntelCommand *command, *iat_command, *src_command, *dst_command, *setup_image_entry, *free_image_entry;
	ImportInfo import_info;
	std::vector<ImportInfo> import_info_list;
	std::vector<ImportFunctionInfo> import_function_info_list;
	PEArchitecture *file, *runtime;
	CommandLink *link;
	IntelFunctionList *runtime_function_list;
	IntelFunction *func;
	std::map<uint64_t, PEImportFunction *> runtime_info_list;
	CommandLink *src_link, *dst_link;
	std::string dll_name;
	IntelImport *intel_import;
	IntelCRCTable *intel_crc;
	uint64_t loader_data_address, tls_index_address;

	file = reinterpret_cast<PEArchitecture *>(ctx.file);
	runtime = reinterpret_cast<PEArchitecture *>(ctx.runtime);
	intel_import = reinterpret_cast<IntelFunctionList *>(file->function_list())->import();
	intel_crc = reinterpret_cast<IntelFunctionList *>(file->function_list())->crc_table();
	IntelLoaderData *loader_data = reinterpret_cast<IntelFunctionList*>(file->function_list())->loader_data();
	loader_data_address = (loader_data) ? loader_data->entry()->address() : runtime->export_list()->GetAddressByType(atLoaderData);
	if (!loader_data_address)
		return false;

	// create AV signature buffer
	AddAVBuffer(ctx);
	start_index = count();

	ICommand *entry_point_command = NULL;
	if (file->entry_point()) {
		IFunction *entry_point_func = ctx.file->function_list()->GetFunctionByAddress(file->entry_point());
		if (entry_point_func)
			entry_point_command = entry_point_func->entry();
	}
	import_index = 0;
	file_dll_count = 0;
	k = (runtime->segment_list()->count() > 0) ? 2 : 1;
	for (j = 0; j < k; j++) {
		PEArchitecture *source_file = (j == 0) ? file : runtime;
		for (i = 0; i < source_file->import_list()->count(); i++) {
			import = source_file->import_list()->item(i);
			if (import->is_sdk())
				continue;

			new_import_list.AddObject(import->Clone(&new_import_list));
			import_index += import->count();
		}

		if (j == 0)
			file_dll_count = new_import_list.count();
	}

	// need move native APIs to the top of vector
	if (ctx.options.flags & cpImportProtection) {
		for (i = 0; i < new_import_list.count(); i++) {
			import = new_import_list.item(i);

			k = NOT_ID;
			for (j = 0; j < import->count(); j++) {
				import_function = import->item(j);
				if (import_function->options() & ioNative) {
					if (k == NOT_ID)
						continue;
					import->SwapObjects(k, j);
					k++;
				} else {
					if (k == NOT_ID)
						k = j;
				}
			}
		}
	}

	// add loader import
	std::map<uint64_t, PEImportFunction *> import_map;
	orig_dll_count = new_import_list.count();
	runtime_function_list = reinterpret_cast<IntelFunctionList *>(runtime->function_list());
	for (i = 0; i < runtime_function_list->count(); i++) {
		func = runtime_function_list->item(i);
		if (func->tag() != ftLoader)
			continue;

		for (j = 0; j < func->count(); j++) {
			command = func->item(j);
			import_function = NULL;
			switch (command->type()) {
			case cmCall:
			case cmJmp:
			case cmMov:
				k = (command->type() == cmMov) ? 1 : 0;
				if (command->operand(k).type == (otMemory | otValue))
					import_function = runtime->import_list()->GetFunctionByAddress(command->operand(k).value);
				break;
			}
			if (!import_function)
				continue;

			std::map<uint64_t, PEImportFunction *>::const_iterator it = import_map.find(import_function->address());
			PEImportFunction *new_import_function = (it != import_map.end()) ? it->second : NULL;
			if (!new_import_function) {
				dll_name = import_function->owner()->name();
				import = NULL;
				for (k = orig_dll_count; k < new_import_list.count(); k++) {
					if (new_import_list.item(k)->CompareName(dll_name)) {
						import = new_import_list.item(k);
						break;
					}
				}
				if (!import) {
					import = new PEImport(&new_import_list, dll_name);
					new_import_list.AddObject(import);
				}
				new_import_function = import_function->Clone(import);
				import->AddObject(new_import_function);
				import_map[import_function->address()] = new_import_function;
			}
			runtime_info_list[command->address()] = new_import_function;
		}
	}

	// create import directory
	for (i = 0; i < new_import_list.count(); i++) {
		import = new_import_list.item(i);

#ifdef ULTIMATE
		if (ctx.options.file_manager && i < file_dll_count) {
			bool is_delay_import = false;
			for (j = 0; j < ctx.options.file_manager->count(); j++) {
				if (import->CompareName(ctx.options.file_manager->item(j)->name())) {
					is_delay_import = true;
					break;
				}
			}

			if (is_delay_import) {
				import_info.original_first_thunk = NULL;
				import_info.name = NULL;
				import_info.first_thunk = NULL;

				import_info_list.push_back(import_info);
				continue;
			}
		}
#endif

		// IMAGE_IMPORT_DESCRIPTOR.OriginalFirstThunk
		command = AddCommand(cmDD, IntelOperand(otValue, osDWord)); 
		command->AddLink(0, ltOffset);
		import_info.original_first_thunk = command;

		// IMAGE_IMPORT_DESCRIPTOR.TimeDateStamp
		AddCommand(cmDD, IntelOperand(otValue, osDWord)); 

		// IMAGE_IMPORT_DESCRIPTOR.ForwarderChain
		AddCommand(cmDD, IntelOperand(otValue, osDWord)); 

		// IMAGE_IMPORT_DESCRIPTOR.Name
		command = AddCommand(cmDD, IntelOperand(otValue, osDWord)); 
		command->AddLink(0, ltOffset);
		import_info.name = command;

		// IMAGE_IMPORT_DESCRIPTOR.FirstThunk
		command = AddCommand(cmDD, IntelOperand(otValue, osDWord)); 
		command->AddLink(0, ltOffset);
		import_info.first_thunk = command;

		import_info_list.push_back(import_info);
	}

	// end of import directory
	for (j = 0; j < 5; j++) {
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
	}

	import_size_ = static_cast<uint32_t>((count() - start_index) * sizeof(uint32_t));
	import_entry_ = item(start_index);
	import_entry_->set_alignment(OperandSizeToValue(cpu_address_size()));

	// create IAT
	value_command_type = (cpu_address_size() == osDWord) ? cmDD : cmDQ;
	uint64_t ordinal_mask = (cpu_address_size() == osDWord) ? IMAGE_ORDINAL_FLAG32 : IMAGE_ORDINAL_FLAG64;
	size_t name_index = count();
	for (i = 0; i < new_import_list.count(); i++) {
		import = new_import_list.item(i);

		bool is_delay_import = (import_info_list[i].name == NULL);

		index = count();
		for (j = 0; j < import->count(); j++) {
			import_function = import->item(j);

			if (is_delay_import) {
				command = NULL;
			} else
			// for import protection need only one API for each DLL
			if ((ctx.options.flags & cpImportProtection) && i < orig_dll_count && (import_function->options() & ioNative) == 0 && j > 0) {
				command = NULL;
			} else if (import_function->is_ordinal()) {
				command = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, ordinal_mask | import_function->ordinal()));
			} else {
				command = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size()));
				command->AddLink(0, ltOffset);
			}
			ImportFunctionInfo import_function_info(import_function);
			import_function_info.name = command;

			import_function_info_list.push_back(import_function_info);
		}

		if (is_delay_import)
			continue;

		AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size()));

		import_info_list[i].original_first_thunk->link()->set_to_command(item(index));
	}
	name_entry_ = item(name_index);
	name_entry_->set_alignment(OperandSizeToValue(cpu_address_size()));

	size_t iat_index = count();
	for (i = 0, import_index = 0; i < new_import_list.count(); i++) {
		import = new_import_list.item(i);

		bool is_delay_import = (import_info_list[i].name == NULL);

		index = count();
		for (j = 0; j < import->count(); j++, import_index++) {
			import_function = import->item(j);

			if (is_delay_import) {
				command = NULL;
			} else
			// for import protection need only one API for each DLL
			if ((ctx.options.flags & cpImportProtection) && i < orig_dll_count && (import_function->options() & ioNative) == 0 && j > 0) {
				command = NULL;
			} else if (import_function->is_ordinal()) {
				command = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, ordinal_mask | import_function->ordinal()));
			} else {
				command = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size()));
				command->AddLink(0, ltOffset);
			}

			import_function_info_list[import_index].thunk = command;
		}

		if (is_delay_import)
			continue;

		AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size()));

		import_info_list[i].first_thunk->link()->set_to_command(item(index));
	}

	iat_entry_ = item(iat_index);
	iat_size_ = static_cast<uint32_t>((count() - iat_index) * OperandSizeToValue(cpu_address_size()));
	iat_entry_->set_alignment(file->segment_alignment());
	iat_entry_->include_option(roCreateNewBlock);

	if (iat_address_) {
		CommandBlock *block = AddBlock(iat_index, true);
		block->set_address(iat_address_);
		for (i = iat_index; i < count(); i++) {
			block->set_end_index(i);
			item(i)->set_block(block);
		}
	}
	else {
		// IAT size must be aligned by page size
		j = AlignValue(iat_size_, file->segment_alignment());
		if (j > iat_size_) {
			std::string buffer;
			buffer.resize(j - iat_size_, 0);
			AddCommand(buffer);
		}
	}

	// create import DLL names
	uint32_t string_key = rand32();
	for (i = 0; i < new_import_list.count(); i++) {
		import = new_import_list.item(i);

		bool is_delay_import = (import_info_list[i].name == NULL);

		if (is_delay_import) {
			command = AddCommand(EncryptString(import->name().c_str(), string_key));
			command->include_option(roCreateNewBlock);

			import_info_list[i].loader_name = command;
			continue;
		}

		if ((ctx.options.flags & cpImportProtection) && i < orig_dll_count) {
			command = AddCommand(EncryptString(import->name().c_str(), string_key));
			command->include_option(roCreateNewBlock);

			import_info_list[i].loader_name = command;
		}

		command = NULL;
		for (j = 0; j < i; j++) {
			if (new_import_list.item(j)->CompareName(import->name())) {
				command = reinterpret_cast<IntelCommand *>(import_info_list[j].name->link()->to_command());
				break;
			}
		}
		if (command == NULL) {
			command = AddCommand(import->name());
			command->include_option(roCreateNewBlock);
			command->set_alignment(sizeof(uint16_t));
		}

		import_info_list[i].name->link()->set_to_command(command);
	}

	// create import function names
	for (i = 0, import_index = 0; i < new_import_list.count(); i++) {
		import = new_import_list.item(i);

		bool is_delay_import = (import_info_list[i].name == NULL);

		for (j = 0; j < import->count(); j++, import_index++) {
			import_function = import->item(j);
			if (import_function->is_ordinal())
				continue;

			if (is_delay_import) {
				command = AddCommand(EncryptString(import_function->name().c_str(), string_key));
				command->include_option(roCreateNewBlock);

				import_function_info_list[import_index].loader_name = command;
				continue;
			}

			// for import protection need only one API for each DLL
			if ((ctx.options.flags & cpImportProtection) && i < orig_dll_count && (import_function->options() & ioNative) == 0) {
				command = AddCommand(EncryptString(import_function->name().c_str(), string_key));
				command->include_option(roCreateNewBlock);

				import_function_info_list[import_index].loader_name = command;

				if (j > 0)
					continue;
			}
			
			command = AddCommand(cmDW, IntelOperand(otValue, osWord));
			command->include_option(roCreateNewBlock);
			command->set_alignment(sizeof(uint16_t));

			AddCommand(import_function->name());

			import_function_info_list[import_index].name->link()->set_to_command(command);
			import_function_info_list[import_index].thunk->link()->set_to_command(command);
		}
	}

	// update links for PE structures
	for (i = 0; i < count(); i++) {
		link = item(i)->link();
		if (!link)
			continue;

		link->set_sub_value(file->image_base());
	}

	// create export
	export_entry_ = NULL;
	export_size_ = 0;
	if (ctx.options.flags & cpPack) {
		index = count();
		export_size_ = file->export_list()->WriteToData(*this, file->image_base());
		export_entry_ = (count() == index) ? AddCommand(osDWord, 0) : item(index);
	}

	// create delay import
	delay_import_entry_ = NULL;
	delay_import_size_ = 0;
	if (file->delay_import_list()->count()) {
		std::vector<ImportInfo> delay_import_info;
		PEDelayImport *delay_import;
		PEDelayImportFunction *delay_import_function;

		size_t delay_index = count();
		for (i = 0; i < file->delay_import_list()->count(); i++) {
			delay_import = file->delay_import_list()->item(i);

			index = count();
			AddCommand(osDWord, delay_import->flags());

			import_info.name = AddCommand(osDWord, 0);
			import_info.name->AddLink(0, ltOffset);

			AddCommand(osDWord, delay_import->module());
			AddCommand(osDWord, delay_import->iat());

			import_info.first_thunk = AddCommand(osDWord, 0);
			import_info.first_thunk->AddLink(0, ltOffset);

			AddCommand(osDWord, delay_import->bound_iat());
			AddCommand(osDWord, delay_import->unload_iat());
			AddCommand(osDWord, delay_import->time_stamp());

			for (j = index + 1; j < count() - 1; j++) {
				command = item(j);
				if (delay_import->flags() & 1) {
					if (command->link())
						command->link()->set_sub_value(file->image_base());
					else if (command->operand(0).value)
						command->set_operand_value(0, command->operand(0).value - file->image_base());
				} else {
					if (command->link() || command->operand(0).value)
						command->set_operand_fixup(0, NEED_FIXUP);
				}
			}

			delay_import_info.push_back(import_info);
		}

		// end of delay import
		for (j = 0; j < 8; j++) {
			AddCommand(osDWord, 0);
		}

		delay_import_entry_ = item(delay_index);
		delay_import_entry_->include_option(roCreateNewBlock);
		delay_import_entry_->set_alignment(OperandSizeToValue(osDWord));
		delay_import_size_ = static_cast<uint32_t>((count() - delay_index) * sizeof(uint32_t));

		for (i = 0; i < file->delay_import_list()->count(); i++) {
			delay_import = file->delay_import_list()->item(i);

			index = count();
			for (j = 0; j < delay_import->count(); j++) {
				delay_import_function = delay_import->item(j);
				if (delay_import_function->is_ordinal()) {
					command = AddCommand(cpu_address_size(), ordinal_mask | delay_import_function->ordinal());
				} else {
					command = AddCommand(cpu_address_size(), 0);
					link = command->AddLink(0, ltOffset);
					if (delay_import->flags() & 1)
						link->set_sub_value(file->image_base());
					else
						command->set_operand_fixup(0, NEED_FIXUP);
				}
			}
			AddCommand(cpu_address_size(), 0);

			command = item(index);
			delay_import_info[i].first_thunk->link()->set_to_command(command);
			delay_import_info[i].original_first_thunk = command;
		}

		for (i = 0; i < file->delay_import_list()->count(); i++) {
			delay_import = file->delay_import_list()->item(i);
			import_info = delay_import_info[i];

			command = AddCommand(delay_import->name());
			command->include_option(roCreateNewBlock);
			import_info.name->link()->set_to_command(command);

			index = IndexOf(import_info.original_first_thunk);
			for (j = 0; j < delay_import->count(); j++) {
				delay_import_function = delay_import->item(j);
				if (delay_import_function->is_ordinal())
					continue;

				command = AddCommand(osWord, 0);
				command->include_option(roCreateNewBlock);
				command->set_alignment(sizeof(uint16_t));
				AddCommand(delay_import_function->name());

				item(index + j)->link()->set_to_command(command);
			}
		}
	}

	// create tls structure
	tls_entry_ = NULL;
	tls_size_ = 0;
	tls_call_back_entry_ = NULL;
	tls_index_address = 0;
	if (file->tls_directory()->address() && (file->tls_directory()->count() || (ctx.options.flags & cpPack))) {
		size_t tls_index = count();

		PETLSDirectory *tls_directory = file->tls_directory();
		if (ctx.options.flags & cpPack) {
			if (file->AddressSeek(tls_directory->address_of_index()) && !file->selected_segment()->excluded_from_packing())
				tls_index_address = tls_directory->address_of_index();
		}

		AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, tls_directory->start_address_of_raw_data(), NEED_FIXUP));
		AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, tls_directory->end_address_of_raw_data(), NEED_FIXUP));
		AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, tls_directory->address_of_index(), NEED_FIXUP));
		IntelCommand *call_back_entry = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, 0));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, tls_directory->size_of_zero_fill()));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, tls_directory->characteristics()));

		tls_entry_ = item(tls_index);
		tls_entry_->include_option(roCreateNewBlock);
		tls_entry_->set_alignment(OperandSizeToValue(cpu_address_size()));
		for (i = tls_index; i < count(); i++) {
			command = item(i);
			tls_size_ += (command->type() == cmDB) ? (uint32_t)command->dump_size() : OperandSizeToValue(command->operand(0).size);
		}

		index = count();
		if (file->tls_directory()->count()) {
			tls_call_back_entry_ = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
			tls_call_back_entry_->AddLink(0, ltGateOffset);
		}
		for (i = 0; i < tls_directory->count(); i++) {
			AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, tls_directory->item(i)->address(), NEED_FIXUP));
		}
		if (count() > index) {
			AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, 0));
			call_back_entry->AddLink(0, ltOffset, item(index));
			call_back_entry->set_operand_fixup(0, NEED_FIXUP);
		}
	}

	// create watermarks
	AddWatermark(ctx.options.watermark, 2);

	// create section list for setting WRITABLE flag
	PESegment *section;
	std::vector<PESegment *> writable_section_list;
	uint64_t address;
	section = file->segment_list()->GetSectionByAddress(loader_data_address);
	if (section)
		writable_section_list.push_back(section);
	for (i = 0; i < orig_dll_count; i++) {
		import = new_import_list.item(i);
		for (j = 0; j < import->count(); j++) {
			import_function = import->item(j);
			address = import_function->address();
			if (ctx.options.flags & cpImportProtection) {
				iat_command = intel_import->GetIATCommand(import_function);
				if (iat_command)
					address = iat_command->address();
			}
			section = file->segment_list()->GetSectionByAddress(address);
			if (!section)
				continue;

			if (std::find(writable_section_list.begin(), writable_section_list.end(), section) == writable_section_list.end())
				writable_section_list.push_back(section);
		}
	}

	for (i = 0; i < file->relocation_list()->count(); i++) {
		PERelocation *relocation = file->relocation_list()->item(i);

		section = file->segment_list()->GetSectionByAddress(relocation->address());
		if (!section)
			continue;

		if (std::find(writable_section_list.begin(), writable_section_list.end(), section) == writable_section_list.end())
			writable_section_list.push_back(section);
	}
	
	std::vector<PackerInfo> packer_info_list;
	PEFixupList loader_fixup_list;
	bool pack_resources = false;
	IntelCommand *packer_props = NULL;
	if (ctx.options.flags & cpPack) {
		PackerInfo packer_info;
		for (i = 0; i < file->segment_list()->count(); i++) {
			section = file->segment_list()->item(i);
			if (section->excluded_from_packing())
				continue;

			bool can_be_packed = true;
			if ((section->memory_type() & (mtWritable | mtShared)) == (mtWritable | mtShared)) {
				can_be_packed = false;
			}

			if (!can_be_packed) {
				//file->Notify(mtWarning, NULL, string_format(language[lsSegmentCanNotBePacked].c_str(), section->name().c_str()));
				continue;
			}

			if (section->physical_size()) {
				packer_info.section = section;
				packer_info.address = section->address();
				packer_info.size = static_cast<size_t>(section->physical_size());
				packer_info.data = NULL;
				packer_info_list.push_back(packer_info);

				// need add packed section into WRITABLE section list
				if (std::find(writable_section_list.begin(), writable_section_list.end(), section) == writable_section_list.end())
					writable_section_list.push_back(section);
			}
		}

		if ((ctx.options.flags & cpStripFixups) == 0) {
			for (i = 0; i < file->fixup_list()->count(); i++) {
				PEFixup *fixup = file->fixup_list()->item(i);
				if (fixup->is_deleted())
					continue;

				section = file->segment_list()->GetSectionByAddress(fixup->address());
				if (!section || std::find(packer_info_list.begin(), packer_info_list.end(), section) == packer_info_list.end())
					continue;

				loader_fixup_list.AddObject(fixup->Clone(&loader_fixup_list));
				fixup->set_deleted(true);

				// need add section into WRITABLE section list
				if (std::find(writable_section_list.begin(), writable_section_list.end(), section) == writable_section_list.end())
					writable_section_list.push_back(section);
			}
		}

		// packing sections
		j = 0;
		for (i = 0; i < packer_info_list.size(); i++) {
			j += packer_info_list[i].size;
		}
		if (file->resource_list()->size() > file->resource_list()->store_size())
			j += file->resource_list()->size() - file->resource_list()->store_size();
		file->StartProgress(string_format("%s...", language[lsPacking].c_str()), j);

		Data data;
		Packer packer;

		if (!packer.WriteProps(&data))
			throw std::runtime_error("Packer error");
		packer_props = AddCommand(data);
		packer_props->include_option(roCreateNewBlock);

		for (i = 0; i < packer_info_list.size(); i++) {
			packer_info = packer_info_list[i];
			if (!file->AddressSeek(packer_info.address))
				return false;

			if (!packer.Code(file, packer_info.size, &data))
				throw std::runtime_error("Packer error");

			command = AddCommand(data);
			command->include_option(roCreateNewBlock);
			packer_info_list[i].data = command;
		}

		if (file->resource_list()->size() > file->resource_list()->store_size()) {
			Data res_data;
			file->resource_list()->WritePackData(res_data);

			if (!packer.Code(file, &res_data, &data))
				return false;

			command = AddCommand(data);
			command->include_option(roCreateNewBlock);

			packer_info.address = 0;
			packer_info.size = res_data.size();
			packer_info.data = command;
			packer_info.section = NULL;
			packer_info_list.push_back(packer_info);
			pack_resources = true;
		}
		
		// remove packed sections from file
		uint32_t physical_offset = 0;
		for (i = 0; i < file->segment_list()->count(); i++) {
			section = file->segment_list()->item(i);
			if (section->physical_offset() > 0 && section->physical_size() > 0) {
				physical_offset = static_cast<uint32_t>(section->physical_offset());
				break;
			}
		}

		for (i = 0; i < file->segment_list()->count(); i++) {
			section = file->segment_list()->item(i);
			uint32_t physical_size = section->physical_size();
			bool is_packed = false;
			std::vector<PackerInfo>::iterator it = std::find(packer_info_list.begin(), packer_info_list.end(), section);
			if (it != packer_info_list.end()) {
				physical_size = static_cast<uint32_t>(it->address - section->address());
				is_packed = true;
			}

			if (physical_size > 0 && section->physical_offset() != physical_offset) {
				uint8_t *buff = new uint8_t[physical_size];
				file->Seek(section->physical_offset());
				file->Read(buff, physical_size);
				file->Seek(physical_offset);
				file->Write(buff, physical_size);
				delete [] buff;
			}

			section->set_physical_offset(physical_offset);
			section->set_physical_size(physical_size);

			if (is_packed) {
				j = physical_offset + physical_size;
				file->Seek(j);
				physical_offset = (uint32_t)AlignValue(j, file->file_alignment());
				for (k = j; k < physical_offset; k++) {
					file->WriteByte(0);
				}
			} else {
				physical_offset += physical_size;
			}
		}
		file->Resize(physical_offset);
	}

	// create packer info for loader
	std::vector<LoaderInfo> loader_info_list;
	index = count();
	if (packer_props) {
		command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
		link = command->AddLink(0, ltOffset, packer_props);
		link->set_sub_value(file->image_base());
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, packer_props->dump_size()));

		for (i = 0; i < packer_info_list.size(); i++) {
			command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
			link = command->AddLink(0, ltOffset, packer_info_list[i].data);
			link->set_sub_value(file->image_base());

			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, packer_info_list[i].address - file->image_base()));
		}
	}
	if (pack_resources) {
		resource_packer_info_ = item(count() - 1);
	} else {
		resource_packer_info_ = NULL;
	}
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create file CRC info for loader
	index = count();
	if (((ctx.options.flags | ctx.options.sdk_flags) & cpMemoryProtection) && file->image_type() != itDriver) {
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
		for (i = 0; i < 10; i++) {
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
		}
	}
	file_crc_entry_ = (count() == index) ? NULL : item(index);
	if (file_crc_entry_)
		file_crc_entry_->include_option(roCreateNewBlock);
	file_crc_size_ = (uint32_t)((count() - index) * OperandSizeToValue(osDWord));
	loader_info_list.push_back(LoaderInfo(file_crc_entry_, file_crc_size_));

	file_crc_size_entry_ = file_crc_entry_ ? AddCommand(cmDD, IntelOperand(otValue, osDWord)) : NULL;
	if (file_crc_size_entry_)
		file_crc_size_entry_->include_option(roCreateNewBlock);

	// create header and loader CRC info for loader
	index = count();
	if (((ctx.options.flags | ctx.options.sdk_flags) & cpMemoryProtection) || (ctx.options.flags & cpLoaderCRC)) {
		// calc CRC blocks count
		k = 30 + new_import_list.count();
		if ((ctx.options.flags & cpStripFixups) == 0) {
			std::vector<IFunction *> function_list = ctx.file->function_list()->processor_list();
			function_list.push_back(this);
			for (i = 0; i < runtime_function_list->count(); i++) {
				func = runtime_function_list->item(i);
				if (func->tag() != ftLoader)
					continue;

				if (func->compilation_type() == ctMutation)
					function_list.push_back(func);
			}

			for (i = 0; i < function_list.size(); i++) {
				func = reinterpret_cast<IntelFunction *>(function_list[i]);
				for (j = 0; j < func->count(); j++) {
					command = func->item(j);
					for (size_t c = 0; c < 3; c++) {
						IntelOperand operand = command->operand(c);
						if (operand.type == otNone)
							break;
						if (operand.fixup)
							k++;
					}
				}
			}
		}
		for (i = 0; i < k; i++) {
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
		}
	}
	loader_crc_entry_ = (count() == index) ? NULL : item(index);
	if (loader_crc_entry_)
		loader_crc_entry_->include_option(roCreateNewBlock);
	loader_crc_size_ = static_cast<uint32_t>((count() - index) * OperandSizeToValue(osDWord));
	loader_info_list.push_back(LoaderInfo(loader_crc_entry_, loader_crc_size_));

	loader_crc_size_entry_ = loader_crc_entry_ ? AddCommand(cmDD, IntelOperand(otValue, osDWord)) : NULL;
	if (loader_crc_size_entry_)
		loader_crc_size_entry_->include_option(roCreateNewBlock);
	loader_crc_hash_entry_ = loader_crc_entry_ ? AddCommand(cmDD, IntelOperand(otValue, osDWord)) : NULL;
	if (loader_crc_hash_entry_)
		loader_crc_hash_entry_->include_option(roCreateNewBlock);

	// create section info for loader
	bool skip_writable_sections = (file->image_type() != itDriver);
	index = count();
	for (i = 0; i < writable_section_list.size(); i++) {
		section = writable_section_list[i];
		if (skip_writable_sections && section->memory_type() & mtWritable)
			continue;

		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, section->address() - file->image_base()));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, section->size()));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, section->flags()));
	}
	// add runtime's WRITABLE sections
	for (i = 0; i < runtime->segment_list()->count(); i++) {
		section = runtime->segment_list()->item(i);
		if (section->memory_type() & mtWritable) {
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, section->address() - file->image_base()));
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, section->size()));
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, section->flags()));
		}
	}
	if (pack_resources) {
		resource_section_info_ = AddCommand(cmDD, IntelOperand(otValue, osDWord));
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
	} else {
		resource_section_info_ = NULL;
	}
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create fixup info for loader
	if (loader_fixup_list.count() > 0) {
		Data data;
		loader_fixup_list.WriteToData(data, file->image_base());
		command = AddCommand(data);
	} else {
		command = NULL;
	}
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (command) ? command->dump_size() : 0));

	// create relocation info for loader
	if (file->relocation_list()->count() > 0) {
		Data data;
		file->relocation_list()->WriteToData(data, file->image_base());
		command = AddCommand(data);
	} else {
		command = NULL;
	}
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (command) ? command->dump_size() : 0));

	// create IAT info for loader
	index = count();
	for (i = 0, import_index = 0; i < orig_dll_count; i++) {
		import = new_import_list.item(i);
		if (import->count() == 0)
			continue;

		if (ctx.options.flags & cpImportProtection) {
			for (j = 0; j < import->count(); j++, import_index++) {
				import_function = import->item(j);
				if ((import_function->options() & ioNative) == 0)
					continue;

				iat_command = intel_import->GetIATCommand(import_function);

				command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
				link = command->AddLink(0, ltOffset, import_function_info_list[import_index].thunk);
				link->set_sub_value(file->image_base());

				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, ((iat_command) ? iat_command->address() : import_function->address()) - file->image_base()));
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, OperandSizeToValue(cpu_address_size())));
			}
		} else {
			import_function = import->item(0);
			command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
			link = command->AddLink(0, ltOffset, import_function_info_list[import_index].thunk);
			link->set_sub_value(file->image_base());

			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, import_function->address() - file->image_base()));
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, import->count() * OperandSizeToValue(cpu_address_size())));

			import_index += import->count();
		}
	}
	if (security_cookie_) {
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, security_cookie_ - file->image_base()));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, file->load_config_directory()->security_cookie() - file->image_base()));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, OperandSizeToValue(cpu_address_size())));
	}
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create import info for loader
	index = count();
	if (ctx.options.flags & cpImportProtection) {
		for (i = 0, import_index = 0; i < orig_dll_count; i++) {
			import = new_import_list.item(i);
			if (import->count() == 0)
				continue;

			if (import_info_list[i].name == NULL) {
				// delay import
				import_index += import->count();
				continue;
			}

			// DLL name
			command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
			link = command->AddLink(0, ltOffset, import_info_list[i].loader_name);
			link->set_sub_value(file->image_base());

			for (j = 0; j < import->count(); j++, import_index++) {
				import_function = import->item(j);
				if (import_function->options() & ioNative)
					continue;

				if (import_function->IsInternal(ctx))
					continue;

				iat_command = intel_import->GetIATCommand(import_function);

				// API name
				if (import_function->is_ordinal()) {
					AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, IMAGE_ORDINAL_FLAG32 | import_function->ordinal()));
				} else {
					command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
					link = command->AddLink(0, ltOffset, import_function_info_list[import_index].loader_name);
					link->set_sub_value(file->image_base());
				}

				// IAT
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, ((iat_command) ? iat_command->address() : import_function->address()) - file->image_base()));

				// decrypt value
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, (iat_command) ? iat_command->operand(1).value : 0));
			}

			// end of DLL
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
		}
	}
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create internal import info for loader
	index = count();
	for (i = 0; i < orig_dll_count; i++) {
		import = new_import_list.item(i);
		for (j = 0; j < import->count(); j++) {
			import_function = import->item(j);

			if (!import_function->IsInternal(ctx))
				continue;

			iat_command = (intel_import) ? intel_import->GetIATCommand(import_function) : NULL;

			address = runtime->export_list()->GetAddressByType(import_function->type());
			func = reinterpret_cast<IntelFunction*>(file->function_list()->GetFunctionByAddress(address));
			if (func && func->entry())
				address = func->entry()->address();

			// address
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, address - file->image_base()));
			// IAT
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, ((iat_command) ? iat_command->address() : import_function->address()) - file->image_base()));
			// decrypt value
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, (iat_command) ? iat_command->operand(1).value : 0));
		}
	}
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create memory CRC info for loader
	if (intel_crc) {
		command = intel_crc->table_entry();
		i = static_cast<size_t>(intel_crc->size_entry()->operand(0).value);
	} else {
		command = NULL;
		i = 0;
	}
	loader_info_list.push_back(LoaderInfo(command, i));

	// create delay import info for loader
	index = count();
#ifdef ULTIMATE
	for (i = 0, import_index = 0; i < orig_dll_count; i++) {
		import = new_import_list.item(i);
		if (import->count() == 0)
			continue;

		if (import_info_list[i].name) {
			import_index += import->count();
			continue;
		}

		// DLL name
		command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
		link = command->AddLink(0, ltOffset, import_info_list[i].loader_name);
		link->set_sub_value(file->image_base());

		for (j = 0; j < import->count(); j++, import_index++) {
			import_function = import->item(j);
			if (import_function->options() & ioNative)
				continue;

			if (import_function->IsInternal(ctx))
				continue;

			iat_command = (intel_import) ? intel_import->GetIATCommand(import_function) : NULL;

			// API name
			if (import_function->is_ordinal()) {
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, IMAGE_ORDINAL_FLAG32 | import_function->ordinal()));
			} else {
				command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
				link = command->AddLink(0, ltOffset, import_function_info_list[import_index].loader_name);
				link->set_sub_value(file->image_base());
			}

			// IAT
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, ((iat_command) ? iat_command->address() : import_function->address()) - file->image_base()));

			// decrypt value
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, (iat_command) ? iat_command->operand(1).value : 0));
		}

		// end of DLL
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
	}
#endif
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create strings for loader
	std::map<uint32_t, IntelCommand *> loader_string_list;
	loader_string_list[FACE_FILE_CORRUPTED] = AddCommand(EncryptString((ctx.options.flags & cpMemoryProtection) ? os::FromUTF8(ctx.options.messages[MESSAGE_FILE_CORRUPTED]).c_str() : os::unicode_string().c_str(), string_key));
	loader_string_list[FACE_DEBUGGER_FOUND] = AddCommand(EncryptString(os::FromUTF8(ctx.options.messages[MESSAGE_DEBUGGER_FOUND]).c_str(), string_key));
	loader_string_list[FACE_VIRTUAL_MACHINE_FOUND] = AddCommand(EncryptString(os::FromUTF8(ctx.options.messages[MESSAGE_VIRTUAL_MACHINE_FOUND]).c_str(), string_key));
	loader_string_list[FACE_INITIALIZATION_ERROR] = AddCommand(EncryptString(os::FromUTF8("Initialization error %d").c_str(), string_key));
	VMProtectBeginVirtualization("Loader Strings");
	loader_string_list[FACE_UNREGISTERED_VERSION] = AddCommand(EncryptString(
#ifdef DEMO
		true
#else
		(ctx.options.flags & cpUnregisteredVersion)
#endif
		? os::FromUTF8(VMProtectDecryptStringA("This application is protected with unregistered version of VMProtect.")).c_str() : os::unicode_string().c_str(), string_key));
	VMProtectEnd();
	loader_string_list[FACE_SICE_NAME] = AddCommand(EncryptString("sice.sys", string_key));
	loader_string_list[FACE_SIWVID_NAME] = AddCommand(EncryptString("siwvid.sys", string_key));
	loader_string_list[FACE_NTICE_NAME] = AddCommand(EncryptString("ntice.sys", string_key));
	loader_string_list[FACE_ICEEXT_NAME] = AddCommand(EncryptString("iceext.sys", string_key));
	loader_string_list[FACE_SYSER_NAME] = AddCommand(EncryptString("syser.sys", string_key));
	if (file->image_type() == itDriver) {
		loader_string_list[FACE_PROC_NOT_FOUND] = AddCommand(EncryptString(os::FromUTF8("The procedure entry point %c could not be located in the module %c").c_str(), string_key));
		loader_string_list[FACE_ORDINAL_NOT_FOUND] = AddCommand(EncryptString(os::FromUTF8("The ordinal %d could not be located in the module %c").c_str(), string_key));
		loader_string_list[FACE_DRIVER_FORMAT_VALUE] = AddCommand("%ws\n");
		loader_string_list[FACE_NTOSKRNL_NAME] = AddCommand(EncryptString("ntoskrnl.exe", string_key));
		loader_string_list[FACE_HAL_NAME] = AddCommand(EncryptString("hal.dll", string_key));
	} else {
		loader_string_list[FACE_PROC_NOT_FOUND] = AddCommand(EncryptString(os::FromUTF8("The procedure entry point %c could not be located in the dynamic link library %c").c_str(), string_key));
		loader_string_list[FACE_ORDINAL_NOT_FOUND] = AddCommand(EncryptString(os::FromUTF8("The ordinal %d could not be located in the dynamic link library %c").c_str(), string_key));
		loader_string_list[FACE_USER32_NAME] = AddCommand(EncryptString("user32.dll", string_key));
		loader_string_list[FACE_MESSAGE_BOX_NAME] = AddCommand(EncryptString("MessageBoxW", string_key));
		loader_string_list[FACE_KERNEL32_NAME] = AddCommand(EncryptString("kernel32.dll", string_key));
		loader_string_list[FACE_CLOSE_HANDLE_NAME] = AddCommand(EncryptString("CloseHandle", string_key));
		loader_string_list[FACE_IS_WOW64_PROCESS_NAME] = AddCommand(EncryptString("IsWow64Process", string_key));
		loader_string_list[FACE_WINE_GET_VERSION_NAME] = AddCommand(EncryptString("wine_get_version", string_key));
		loader_string_list[FACE_WTSAPI32_NAME] = AddCommand(EncryptString("wtsapi32.dll", string_key));
		loader_string_list[FACE_WTS_SEND_MESSAGE_NAME] = AddCommand(EncryptString("WTSSendMessageW", string_key));
		loader_string_list[FACE_NTDLL_NAME] = AddCommand(EncryptString("ntdll.dll", string_key));
		loader_string_list[FACE_NT_QUERY_INFORMATION_NAME] = AddCommand(EncryptString("NtQuerySystemInformation", string_key));
		loader_string_list[FACE_NT_SET_INFORMATION_THREAD_NAME] = AddCommand(EncryptString("NtSetInformationThread", string_key));
		loader_string_list[FACE_NT_QUERY_INFORMATION_PROCESS_NAME] = AddCommand(EncryptString("NtQueryInformationProcess", string_key));
		loader_string_list[FACE_SBIEDLL_NAME] = AddCommand(EncryptString("sbiedll.dll", string_key));
		loader_string_list[FACE_QUERY_VIRTUAL_MEMORY_NAME] = AddCommand(EncryptString("NtQueryVirtualMemory", string_key));
		loader_string_list[FACE_ENUM_SYSTEM_FIRMWARE_NAME] = AddCommand(EncryptString("EnumSystemFirmwareTables", string_key));
		loader_string_list[FACE_GET_SYSTEM_FIRMWARE_NAME] = AddCommand(EncryptString("GetSystemFirmwareTable", string_key));
		loader_string_list[FACE_NT_VIRTUAL_PROTECT_NAME] = AddCommand(EncryptString("NtProtectVirtualMemory", string_key));
		loader_string_list[FACE_NT_OPEN_FILE_NAME] = AddCommand(EncryptString("NtOpenFile", string_key));
		loader_string_list[FACE_NT_CREATE_SECTION_NAME] = AddCommand(EncryptString("NtCreateSection", string_key));
		loader_string_list[FACE_NT_OPEN_SECTION_NAME] = AddCommand(EncryptString("NtOpenSection", string_key));
		loader_string_list[FACE_NT_MAP_VIEW_OF_SECTION] = AddCommand(EncryptString("NtMapViewOfSection", string_key));
		loader_string_list[FACE_NT_UNMAP_VIEW_OF_SECTION] = AddCommand(EncryptString("NtUnmapViewOfSection", string_key));
		loader_string_list[FACE_NT_CLOSE] = AddCommand(EncryptString("NtClose", string_key));
		loader_string_list[FACE_NT_SET_INFORMATION_PROCESS_NAME] = AddCommand(EncryptString("NtSetInformationProcess", string_key));
		loader_string_list[FACE_NT_RAISE_HARD_ERROR_NAME] = AddCommand(EncryptString("NtRaiseHardError", string_key));
	}
	for (std::map<uint32_t, IntelCommand *>::const_iterator it = loader_string_list.begin(); it != loader_string_list.end(); it++) {
		it->second->include_option(roCreateNewBlock);
	}

	cfg_check_function_entry_ = NULL;
	if (file->load_config_directory()->cfg_check_function()) {
		// work around check in LdrpCfgProcessLoadConfig
		PESegment *segment = file->segment_list()->GetSectionByAddress(file->load_config_directory()->cfg_check_function());
		if (segment && std::find(packer_info_list.begin(), packer_info_list.end(), segment) != packer_info_list.end()) {
			CommandBlock *block = AddBlock(count(), true);
			cfg_check_function_entry_ = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, file->load_config_directory()->cfg_check_function(), NEED_FIXUP));
			cfg_check_function_entry_->set_block(block);
		}
	}

	// append loader
	old_count = count();
	std::vector<IntelCommand*> internal_entry_list;
	for (size_t n = 0; n < 2; n++) {
		for (i = 0; i < runtime_function_list->count(); i++) {
			func = runtime_function_list->item(i);
			if (func->tag() != ftLoader)
				continue;

			if (func->compilation_type() == ctMutation) {
				if (n != 0)
					continue;
			} else {
				if (n != 1)
					continue;
			}

			func->Init(ctx);

			size_t orig_function_info_count = function_info_list()->count();
			for (j = 0; j < func->function_info_list()->count(); j++) {
				FunctionInfo *info = func->function_info_list()->item(j);
				function_info_list()->AddObject(info->Clone(function_info_list()));
			}
			for (j = 0; j < func->range_list()->count(); j++) {
				AddressRange *range = func->range_list()->item(j);
				range_list()->AddObject(range->Clone(range_list()));
			}

			bool is_internal = (func->compilation_type() != ctMutation && func->entry_type() == etNone);
			for (j = 0; j < func->link_list()->count(); j++) {
				src_link = func->link_list()->item(j);
				if (src_link->type() != ltMemSEHBlock)
					continue;

				src_link->from_command()->set_address(0);
				if (!is_internal || (src_link->from_command()->options() & roExternal) == 0)
					continue;

				src_command = func->GetCommandByAddress(src_link->to_address());
				if (!src_command)
					continue;

				for (k = func->IndexOf(src_command); k < func->count(); k++) {
					src_command = func->item(k);
					if (src_command->type() == cmRet) {
						src_command->include_option(roExternal);
						break;
					}
				}
			}

			for (j = 0; j < func->count(); j++) {
				src_command = func->item(j);
				dst_command = src_command->Clone(this);
				AddressRange *address_range = src_command->address_range();
				if (address_range) {
					FunctionInfo *info = function_info_list()->item(orig_function_info_count + func->function_info_list()->IndexOf(address_range->owner()));
					dst_command->set_address_range(info->item(address_range->owner()->IndexOf(address_range)));
				}

				AddObject(dst_command);
				if (is_internal) {
					if (j == 0)
						internal_entry_list.push_back(dst_command);
					if (dst_command->type() == cmRet && (dst_command->options() & roExternal) == 0)
						dst_command->include_option(roInternal);
				}

				src_link = src_command->link();
				if (src_link) {
					dst_link = src_link->Clone(link_list());
					dst_link->set_from_command(dst_command);
					link_list()->AddObject(dst_link);
				
					if (src_link->parent_command())
						dst_link->set_parent_command(GetCommandByAddress(src_link->parent_command()->address()));
				}

				std::map<uint64_t, PEImportFunction *>::const_iterator it_import = runtime_info_list.find(dst_command->address());
				if (it_import != runtime_info_list.end()) {
					if (dst_command->type() == cmCall) {
						IntelOperand operand = dst_command->operand(0);
						dst_command->Init(cmMov, IntelOperand(otRegistr, operand.size, regEAX), operand);

						command = new IntelCommand(this, cpu_address_size(), cmCall, IntelOperand(otRegistr, operand.size, regEAX));
						if (dst_command->link())
							dst_command->link()->set_from_command(command);
						AddObject(command);
					}
					dst_link = dst_command->AddLink((dst_command->operand(1).type != otNone) ? 1 : 0, ltOffset);
					std::vector<ImportFunctionInfo>::iterator it = std::find(import_function_info_list.begin(), import_function_info_list.end(), it_import->second);
					if (it != import_function_info_list.end())
						dst_link->set_to_command(it->thunk);
				}

				command = dst_command;
				for (k = 0; k < 3; k++) {
					IntelOperand operand = command->operand(k);
					if (operand.type == otNone)
						break;

					if ((operand.type & otValue) == 0)
						continue;

					if ((operand.value & 0xFFFF0000) == 0xFACE0000) {
						switch (static_cast<uint32_t>(operand.value)) {
						case FACE_LOADER_OPTIONS:
							operand.value = 0;
							if (ctx.options.flags & cpMemoryProtection)
								operand.value |= LOADER_OPTION_CHECK_PATCH;
							if (ctx.options.flags & cpCheckDebugger)
								operand.value |= LOADER_OPTION_CHECK_DEBUGGER;
							if (ctx.options.flags & cpCheckKernelDebugger)
								operand.value |= LOADER_OPTION_CHECK_KERNEL_DEBUGGER;
							if (ctx.options.flags & cpCheckVirtualMachine)
								operand.value |= LOADER_OPTION_CHECK_VIRTUAL_MACHINE;
							if (file->image_type() == itExe)
								operand.value |= LOADER_OPTION_EXIT_PROCESS;
							command->set_operand_value(k, operand.value);
							command->CompileToNative();
							break;
						case FACE_LOADER_DATA:
							command->set_operand_value(k, loader_data_address - file->image_base());
							command->CompileToNative();
							break;
						case FACE_RUNTIME_ENTRY:
							command->set_operand_value(k, runtime->segment_list()->count() ? runtime->entry_point() - file->image_base() : 0);
							command->CompileToNative();
							break;
						case FACE_STRING_DECRYPT_KEY:
							command->set_operand_value(k, string_key);
							command->CompileToNative();
							break;
						case FACE_PACKER_INFO:
						case FACE_FILE_CRC_INFO:
						case FACE_LOADER_CRC_INFO:
						case FACE_SECTION_INFO:
						case FACE_FIXUP_INFO:
						case FACE_RELOCATION_INFO:
						case FACE_IAT_INFO:
						case FACE_IMPORT_INFO:
						case FACE_INTERNAL_IMPORT_INFO:
						case FACE_MEMORY_CRC_INFO:
						case FACE_DELAY_IMPORT_INFO:
							dst_command = loader_info_list[(operand.value & 0xff) >> 1].data;
							if (dst_command) {
								link = command->AddLink((int)k, ltOffset, dst_command);
								link->set_sub_value(file->image_base());
							} else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_PACKER_INFO_SIZE:
						case FACE_SECTION_INFO_SIZE:
						case FACE_FIXUP_INFO_SIZE:
						case FACE_RELOCATION_INFO_SIZE:
						case FACE_IAT_INFO_SIZE:
						case FACE_IMPORT_INFO_SIZE:
						case FACE_INTERNAL_IMPORT_INFO_SIZE:
						case FACE_MEMORY_CRC_INFO_SIZE:
						case FACE_DELAY_IMPORT_INFO_SIZE:
							command->set_operand_value(k, loader_info_list[(operand.value & 0xff) >> 1].size);
							command->CompileToNative();
							break;
						case FACE_LOADER_CRC_INFO_SIZE:
							if (loader_crc_size_entry_) {
								link = command->AddLink((int)k, ltOffset, loader_crc_size_entry_);
								link->set_sub_value(file->image_base());
							} else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_LOADER_CRC_INFO_HASH:
							if (loader_crc_hash_entry_) {
								link = command->AddLink((int)k, ltOffset, loader_crc_hash_entry_);
								link->set_sub_value(file->image_base());
							} else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_FILE_CRC_INFO_SIZE:
							if (file_crc_size_entry_) {
								link = command->AddLink((int)k, ltOffset, file_crc_size_entry_);
								link->set_sub_value(file->image_base());
							} else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_MEMORY_CRC_INFO_HASH:
							command->set_operand_value(k, intel_crc ? intel_crc->hash_entry()->operand(0).value : 0);
							command->CompileToNative();
							break;
						case FACE_CRC_INFO_SALT:
							command->set_operand_value(k, file->function_list()->crc_cryptor()->item(0)->value());
							command->CompileToNative();
							break;
						case FACE_IMAGE_BASE:
							if (command->operand(0).size != cpu_address_size()) {
								IntelOperand first = command->operand(0);
								IntelOperand second = command->operand(1);
								first.size = cpu_address_size();
								second.size = cpu_address_size();
								command->Init(static_cast<IntelCommandType>(command->type()), first, second);
							}
							command->set_operand_value(k, file->image_base());
							command->set_operand_fixup(k, NEED_FIXUP);
							command->CompileToNative();
							break;
						case FACE_FILE_BASE:
							if (command->operand(0).size != cpu_address_size()) {
								IntelOperand first = command->operand(0);
								IntelOperand second = command->operand(1);
								first.size = cpu_address_size();
								second.size = cpu_address_size();
								command->Init(static_cast<IntelCommandType>(command->type()), first, second);
							}
							command->set_operand_value(k, file->image_base());
							command->CompileToNative();
							break;
						case FACE_TLS_INDEX_INFO:
							command->set_operand_value(k, tls_index_address ? tls_index_address - file->image_base() : 0);
							command->CompileToNative();
							break;
						case FACE_VAR_IS_PATCH_DETECTED:
						case FACE_VAR_IS_DEBUGGER_DETECTED:
						case FACE_VAR_LOADER_CRC_INFO:
						case FACE_VAR_LOADER_CRC_INFO_SIZE:
						case FACE_VAR_LOADER_CRC_INFO_HASH:
						case FACE_VAR_CPU_HASH:
						case FACE_VAR_CPU_COUNT:
						case FACE_VAR_SESSION_KEY:
						case FACE_VAR_DRIVER_UNLOAD:
						case FACE_VAR_CRC_IMAGE_SIZE:
						case FACE_VAR_LOADER_STATUS:
						case FACE_VAR_SERVER_DATE:
						case FACE_VAR_OS_BUILD_NUMBER:
							command->set_operand_value(k, ctx.runtime_var_index[(operand.value & 0xff) >> 4] * OperandSizeToValue(cpu_address_size()));
							command->CompileToNative();
							break;
						case FACE_VAR_IS_PATCH_DETECTED_SALT:
						case FACE_VAR_IS_DEBUGGER_DETECTED_SALT:
						case FACE_VAR_LOADER_CRC_INFO_SALT:
						case FACE_VAR_LOADER_CRC_INFO_SIZE_SALT:
						case FACE_VAR_LOADER_CRC_INFO_HASH_SALT:
						case FACE_VAR_CPU_HASH_SALT:
						case FACE_VAR_CPU_COUNT_SALT:
						case FACE_VAR_DRIVER_UNLOAD_SALT:
						case FACE_VAR_CRC_IMAGE_SIZE_SALT:
						case FACE_VAR_SERVER_DATE_SALT:
						case FACE_VAR_OS_BUILD_NUMBER_SALT:
							command->set_operand_value(k, ctx.runtime_var_salt[operand.value & 0xff]);
							command->CompileToNative();
							break;
						default:
							std::map<uint32_t, IntelCommand *>::const_iterator it = loader_string_list.find(static_cast<uint32_t>(operand.value));
							if (it != loader_string_list.end()) {
								if (command->type() == cmMov) {
									operand = command->operand(0);
									operand.size = cpu_address_size();
									if (operand.type == otRegistr) {
										command->Init(cmLea, operand, IntelOperand(otMemory | otValue, cpu_address_size(), 0, 0, (cpu_address_size() == osDWord) ? NEED_FIXUP : LARGE_VALUE));
									} else {
										command->Init(cmMov, operand, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
									}
								} else {
									command->Init(cmPush, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
								}
								command->AddLink((int)k, ltOffset, it->second); 
							} else {
								throw std::runtime_error(string_format("Unknown loader string: %X", static_cast<uint32_t>(operand.value)));
							}
						}
					}
				}
			}
		}
		if (n == 0) {
			// create native blocks
			for (j = 0; j < count(); j++) {
				item(j)->include_option(roNoProgress);
			}
			CompileToNative(ctx);
			for (j = 0; j < count(); j++) {
				item(j)->exclude_option(roNoProgress);
			}
		}
	}
	for (i = 0; i < function_info_list()->count(); i++) {
		FunctionInfo *info = function_info_list()->item(i);
		if (info->entry())
			info->set_entry(GetCommandByAddress(info->entry()->address()));
		for (j = 0; j < info->count(); j++) {
			AddressRange *dest = info->item(j);
			for (k = 0; k < range_list()->count(); k++) {
				AddressRange *range = range_list()->item(k);
				if (range->begin() <= dest->begin() && range->end() > dest->begin())
					dest->AddLink(range);
			}
		}
	}
	for (i = 0; i < range_list()->count(); i++) {
		AddressRange *range = range_list()->item(i);
		if (range->begin_entry())
			range->set_begin_entry(GetCommandByAddress(range->begin_entry()->address()));
		if (range->end_entry())
			range->set_end_entry(GetCommandByAddress(range->end_entry()->address()));
		if (range->size_entry())
			range->set_size_entry(GetCommandByAddress(range->size_entry()->address()));
	}
	for (i = old_count; i < count(); i++) {
		command = item(i);
		dst_link = command->link();
		if (!dst_link) {
			// search references to LoaderAlloc/LoaderFree/FreeImage
			for (k = 0; k < 2; k++) {
				IntelOperand operand = command->operand(k);
				if (operand.type == otNone)
					break;

				if (cpu_address_size() == osDWord) {
					if (!operand.fixup)
						continue;
				} else {
					if (!operand.is_large_value)
						continue;
				}

				dst_command = reinterpret_cast<IntelCommand *>(GetCommandByAddress(operand.value));
				if (dst_command) {
					dst_link = command->AddLink((int)k, dst_command->block() ? ltOffset : ltGateOffset, dst_command);
					break;
				}
			}
		} else {
			if (dst_link->to_address())
				dst_link->set_to_command(GetCommandByAddress(dst_link->to_address()));
		}
	}
	setup_image_entry = GetCommandByAddress(runtime->export_list()->GetAddressByType(atSetupImage));
	if (!setup_image_entry)
		return false;

	free_image_entry = GetCommandByAddress(runtime->export_list()->GetAddressByType(atFreeImage));
	if (!free_image_entry)
		return false;

/*
BOOL LoaderDllMain(HANDLE module, DWORD reason, LPVOID reserved)
{
	BOOL status;
	if (reason == DLL_PROCESS_ATTACH) {
		status = SetupImage();
		if (status == TRUE) {
			status = DllMain(module, reason, reserved);
		} else {
			FreeImage();
		}
	} else {
		status = DllMain(module, reason, reserved);
		if (reason == DLL_PROCESS_DETACH)
			FreeImage();
	}
	return status;
}

NTSTATUS LoaderDriverEntry(driver_object, registry_path)
{
	NTSTATUS status = SetupImage(true, driver_object);
	if (status == STATUS_SUCCESS) {
		status = DriverEntry(driver_object, registry_path);
		if (status == STATUS_SUCCESS) {
			SetupImage(false, driver_object);
		} else {
			FreeImage(driver_object);
		}
	} else {
		FreeImage(driver_object);
	}
	return status;
}
*/

	// create entry commands
	std::vector<IntelCommand *> end_command_list;
	old_count = count();
	size_t stack = 0x20;
	if (file->image_type() != itExe && cpu_address_size() == osQWord) {
		AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regESP, OperandSizeToValue(cpu_address_size()) * 1), IntelOperand(otRegistr, cpu_address_size(), regECX));
		AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regESP, OperandSizeToValue(cpu_address_size()) * 2), IntelOperand(otRegistr, cpu_address_size(), regEDX));
		AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regESP, OperandSizeToValue(cpu_address_size()) * 3), IntelOperand(otRegistr, cpu_address_size(), regR8));
	}
	AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEBP));
	if (cpu_address_size() == osDWord) {
		AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, stack));
		AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEBP), IntelOperand(otRegistr, cpu_address_size(), regESP));
	} else {
		AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size(), regEBP), IntelOperand(otMemory | otRegistr| otValue, cpu_address_size(), regESP,  0 - static_cast<uint64_t>(stack)));
		AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, stack + 0x20));
	}

	IntelCommand *skip_loader_command = NULL;
	if (file->image_type() == itLibrary) {
		// check DLL_PROCESS_ATTACH
		AddCommand(cmCmp, IntelOperand(otMemory | otRegistr | otValue, osDWord, regEBP, stack + OperandSizeToValue(cpu_address_size()) * 3), IntelOperand(otValue, osDWord, 0, DLL_PROCESS_ATTACH));
		skip_loader_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
		skip_loader_command->set_flags(fl_Z);
		skip_loader_command->include_option(roInverseFlag);
		skip_loader_command->AddLink(0, ltJmpWithFlag);
	}

	// call SetupImage
	if (file->image_type() == itDriver) {
		if (cpu_address_size() == osQWord) {
			AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEDX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 2));
			AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otValue, osDWord, 0, true));
		} else {
			AddCommand(cmPush, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 2));
			AddCommand(cmPush, IntelOperand(otValue, cpu_address_size(), 0, true));
		}
	}
	command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
	command->AddLink(0, ltCall, setup_image_entry);

	// check loader error code
	AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, (file->image_type() == itDriver) ? 0 : TRUE));
	IntelCommand *check_loader_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
	check_loader_command->set_flags(fl_Z);
	check_loader_command->AddLink(0, ltJmpWithFlag);

	switch (file->image_type()) {
	case itExe:
		// call FreeImage
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, free_image_entry);

		// need convert FALSE into exit code
		AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, 0xDEADC0DE));
		break;
	case itLibrary:
		// do nothing
		break;
	case itDriver:
		AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP), IntelOperand(otRegistr, cpu_address_size(), regEAX));

		// call FreeImage
		if (cpu_address_size() == osQWord) {
			AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regECX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 2));
		} else {
			AddCommand(cmPush, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 2));
		}
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, free_image_entry);

		AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEAX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP));
		break;
	}

	command = AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size()));
	command->AddLink(0, ltJmp);
	end_command_list.push_back(command);

	command = AddCommand(cmNop);
	check_loader_command->link()->set_to_command(command);
	if (skip_loader_command)
		skip_loader_command->link()->set_to_command(command);

	// call file EntryPoint
	IntelCommand *jmp_entry_point_command = NULL;
	if (file->entry_point()) {
		switch (file->image_type()) {
		case itExe:
			AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, stack + ((cpu_address_size() == osQWord) ? 0x20 : 0)));
			AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEBP));
			jmp_entry_point_command = AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size(), 0, file->entry_point()));
			jmp_entry_point_command->AddLink(0, ltJmp, file->entry_point());
			break;

		case itLibrary:
			{
			// check loader status
			AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEAX), IntelOperand(otMemory | otValue, cpu_address_size(), 0, loader_data_address, (cpu_address_size() == osDWord) ? NEED_FIXUP : LARGE_VALUE));
			AddCommand(cmOr, IntelOperand(otRegistr, cpu_address_size(), regEAX), IntelOperand(otRegistr, cpu_address_size(), regEAX));
			IntelCommand *jmp_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
			jmp_command->set_flags(fl_Z);
			jmp_command->AddLink(0, ltJmpWithFlag);

			AddCommand(cmCmp, IntelOperand(otMemory | otRegistr | otValue, osDWord, regEAX, ctx.runtime_var_index[VAR_LOADER_STATUS] * OperandSizeToValue(cpu_address_size())), IntelOperand(otValue, osDWord, 0, TRUE));
			IntelCommand *jmp_status_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
			jmp_status_command->set_flags(fl_Z);
			jmp_status_command->include_option(roInverseFlag);
			jmp_status_command->AddLink(0, ltJmpWithFlag);

			// call EntryPoint
			if (cpu_address_size() == osQWord) {
				AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regR8), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 4));
				AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEDX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 3));
				AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regECX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 2));
			} else {
				AddCommand(cmPush, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 4));
				AddCommand(cmPush, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 3));
				AddCommand(cmPush, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 2));
			}
			jmp_entry_point_command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size(), 0, file->entry_point()));
			jmp_entry_point_command->AddLink(0, ltCall, file->entry_point());

			command = AddCommand(cmNop);
			jmp_command->link()->set_to_command(command);
			jmp_status_command->link()->set_to_command(command);
			}
			break;

		case itDriver:
			if (cpu_address_size() == osQWord) {
				AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEDX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 3));
				AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regECX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 2));
			} else {
				AddCommand(cmPush, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 3));
				AddCommand(cmPush, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 2));
			}
			jmp_entry_point_command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size(), 0, file->entry_point()));
			jmp_entry_point_command->AddLink(0, ltCall, file->entry_point());

			// store error code
			AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP), IntelOperand(otRegistr, cpu_address_size(), regEAX));

			{
			// check error code
			AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, 0));
			command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
			command->set_flags(fl_Z);
			command->include_option(roInverseFlag);
			command->AddLink(0, ltJmpWithFlag);
			IntelCommand *cmp_command = command;

			// call SetupImage
			if (cpu_address_size() == osQWord) {
				AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEDX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 2));
				AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otValue, osDWord, 0, false));
			} else {
				AddCommand(cmPush, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 2));
				AddCommand(cmPush, IntelOperand(otValue, cpu_address_size(), 0, false));
			}
			command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
			command->AddLink(0, ltCall, setup_image_entry);

			IntelCommand *jmp_command = AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size(), 0, 0));
			jmp_command->AddLink(0, ltJmp);

			command = AddCommand(cmNop);
			cmp_command->link()->set_to_command(command);

			// call FreeImage
			if (cpu_address_size() == osQWord) {
				AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regECX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 2));
			} else {
				AddCommand(cmPush, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP, stack + OperandSizeToValue(cpu_address_size()) * 2));
			}
			command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
			command->AddLink(0, ltCall, free_image_entry);

			// restore error code
			command = AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEAX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEBP));
			jmp_command->link()->set_to_command(command);
			}
			break;
		}
	}

	if (file->image_type() == itLibrary) {
		// check DLL_PROCESS_DETACH
		AddCommand(cmCmp, IntelOperand(otMemory | otRegistr | otValue, osDWord, regEBP, stack + OperandSizeToValue(cpu_address_size()) * 3), IntelOperand(otValue, osDWord, 0, DLL_PROCESS_DETACH));
		command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
		command->set_flags(fl_Z);
		command->include_option(roInverseFlag);
		command->AddLink(0, ltJmpWithFlag);
		end_command_list.push_back(command);

		// call FreeImage
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, free_image_entry);

		AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, TRUE));
	}

	command = AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, stack + ((cpu_address_size() == osQWord) ? 0x20 : 0)));
	for (i = 0; i < end_command_list.size(); i++) {
		end_command_list[i]->link()->set_to_command(command);
	}
	AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEBP));

	IntelOperand ret_operand;
	if (cpu_address_size() == osDWord) {
		switch (file->image_type()) {
		case itDriver:
			ret_operand = IntelOperand(otValue, osWord, 0, 2 * OperandSizeToValue(cpu_address_size()));
			break;
		case itLibrary:
			ret_operand = IntelOperand(otValue, osWord, 0, 3 * OperandSizeToValue(cpu_address_size()));
			break;
		}
	}
	AddCommand(cmRet, ret_operand);
	if (jmp_entry_point_command && entry_point_command)
		jmp_entry_point_command->link()->set_to_command(entry_point_command);

	command = item(old_count);
	set_entry(command);

	if (tls_call_back_entry_) {
		index = count();

		AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEBP));
		if (cpu_address_size() == osDWord) {
			AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, stack));
			AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEBP), IntelOperand(otRegistr, cpu_address_size(), regESP));
		} else {
			AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size(), regEBP), IntelOperand(otMemory | otRegistr| otValue, cpu_address_size(), regESP, 0 - stack));
			AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, stack + 0x20));
		}

		// call loader
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, setup_image_entry);

		// check loader error code
		AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, (file->image_type() == itDriver) ? 0 : TRUE));
		IntelCommand *check_loader_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
		check_loader_command->set_flags(fl_Z);
		check_loader_command->AddLink(0, ltJmpWithFlag);

		// call FreeImage
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, free_image_entry);

		command = AddCommand(cmNop);
		check_loader_command->link()->set_to_command(command);

		AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, stack + ((cpu_address_size() == osQWord) ? 0x20 : 0)));
		AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEBP));

		IntelOperand ret_operand;
		if (cpu_address_size() == osDWord)
			ret_operand = IntelOperand(otValue, osWord, 0, 3 * OperandSizeToValue(cpu_address_size()));
		AddCommand(cmRet, ret_operand);

		tls_call_back_entry_->link()->set_to_command(item(index));
	}
	
	for (i = 0; i < count(); i++) {
		command = item(i);
		command->CompileToNative();
	}

	// search API calls
	for (i = 0; i < count(); i++) {
		command = item(i);
		if (command->block())
			continue;

		if (command->type() == cmCall) {
			if (command->operand(0).type == otValue)
				continue;
		} else if (command->type() != cmSyscall)
			continue;

		IntelCommand *next_command = item(i + 1);
		if (next_command->type() == cmAdd && next_command->operand(0).type == otRegistr && next_command->operand(0).registr == regESP)
			continue;

		k = 0;
		for (j = i; j > 0; j--) {
			IntelCommand *param_command = item(j - 1);

			switch (param_command->type()) {
			case cmPush:
				if (cpu_address_size() == osDWord) {
					k++;
				} else {
					param_command = NULL;
				}
				break;
			case cmMov: case cmLea: case cmXor: case cmMovsxd:
				if (cpu_address_size() == osQWord) {
					if (param_command->operand(0).type == otRegistr) {
						switch (param_command->operand(0).registr) {
						case regECX:
							k = std::max<size_t>(k, 1);
							break;
						case regEDX:
							k = std::max<size_t>(k, 2);
							break;
						case regR8:
							k = std::max<size_t>(k, 3);
							break;
						case regR9:
							k = std::max<size_t>(k, 4);
							break;
						}
					} else if (param_command->operand(0).type == (otMemory | otBaseRegistr | otValue) && param_command->operand(0).base_registr == regESP) {
						switch (param_command->operand(0).value) {
						case 0x20:
							k = std::max<size_t>(k, 5);
							break;
						case 0x28:
							k = std::max<size_t>(k, 6);
							break;
						case 0x30:
							k = std::max<size_t>(k, 7);
							break;
						case 0x38:
							k = std::max<size_t>(k, 8);
							break;
						case 0x40:
							k = std::max<size_t>(k, 9);
							break;
						case 0x48:
							k = std::max<size_t>(k, 10);
							break;
						default:
							if (param_command->operand(0).value >= 0x50)
								k = NOT_ID;
							break;
						}
					}
				}
				break;
			case cmCall: case cmJmp: case cmJmpWithFlag: case cmRet:
				param_command = NULL;
				break;
			}
			if (!param_command || link_list()->GetLinkByToAddress(ltNone, param_command->address()))
				break;
		}
		if (k == NOT_ID)
			continue;

		command->include_option(roInternal);
		command->set_operand_value(2, k);
	}

	if (entry_point_command && entry_point_command->block()->virtual_machine() && jmp_entry_point_command) {
		jmp_entry_point_command->include_option(roExternal);
		uint8_t id = entry_point_command->block()->virtual_machine()->id();
		IntelVirtualMachineList *virtual_machine_list = reinterpret_cast<IntelVirtualMachineList *>(ctx.file->virtual_machine_list());
		for (i = 0; i < virtual_machine_list->count(); i++) {
			IntelVirtualMachine *virtual_machine = virtual_machine_list->item(i);
			if (virtual_machine->processor()->cpu_address_size() == cpu_address_size())
				virtual_machine->AddExtJmpCommand(id);
		}
	}

	for (i = 0; i < link_list()->count(); i++) {
		CommandLink *link = link_list()->item(i);
		if (link->from_command()->type() == cmCall && std::find(internal_entry_list.begin(), internal_entry_list.end(), link->to_command()) != internal_entry_list.end())
			reinterpret_cast<IntelCommand*>(link->from_command())->include_option(roInternal);
		link->from_command()->PrepareLink(ctx);
	}

	return BaseIntelLoader::Prepare(ctx);
}

std::vector<uint64_t> PEIntelLoader::cfg_address_list() const
{
	std::vector<uint64_t> res;
	res.push_back(entry()->address());
	if (tls_call_back_entry_)
		res.push_back(tls_call_back_entry_->link()->to_command()->address());
	std::sort(res.begin(), res.end());
	return res;
}

/**
 * MacIntelFunctionList
 */

MacIntelFunctionList::MacIntelFunctionList(IArchitecture *owner)
	: IntelFunctionList(owner)
{

}

MacIntelFunctionList::MacIntelFunctionList(IArchitecture *owner, const MacIntelFunctionList &src)
	: IntelFunctionList(owner, src)
{

}

MacIntelFunctionList *MacIntelFunctionList::Clone(IArchitecture *owner) const
{
	MacIntelFunctionList *list = new MacIntelFunctionList(owner, *this);
	return list;
}

IntelSDK *MacIntelFunctionList::AddSDK(OperandSize cpu_address_size)
{
	IntelSDK *func = new MacIntelSDK(this, cpu_address_size);
	AddObject(func);
	return func;
}

bool MacIntelFunctionList::Prepare(const CompileContext &ctx)
{
	MacArchitecture *file = reinterpret_cast<MacArchitecture *>(owner());
	for (size_t i = 0; i < file->import_list()->count(); i++) {
		MacImport *import = file->import_list()->item(i);
		size_t old_count = import->count();
		for (size_t j = 0; j < old_count; j++) {
			MacImportFunction *import_func = import->item(j);
			IntelCommand *command = reinterpret_cast<IntelCommand *>(GetCommandByAddress(import_func->address(), true));
			if (!command)
				continue;

			import_func = import_func->Clone(import);
			import->AddObject(import_func);
			relocation_list_[import_func] = command;
		}
	}

	return IntelFunctionList::Prepare(ctx);
}

bool MacIntelFunctionList::Compile(const CompileContext &ctx)
{
	if (!IntelFunctionList::Compile(ctx))
		return false;

	MacArchitecture *file = reinterpret_cast<MacArchitecture *>(owner());
	for (std::map<MacImportFunction *, IntelCommand *>::const_iterator it = relocation_list_.begin(); it != relocation_list_.end(); it++) {
		MacImportFunction *import_func = it->first;
		IntelCommand *command = it->second;
		import_func->set_address(command->address());
	}

	return true;
}

/**
 * MacIntelSDK
 */

MacIntelSDK::MacIntelSDK(IFunctionList *parent, OperandSize cpu_address_size)
	: IntelSDK(parent, cpu_address_size)
{

}

/**
 * MacIntelLoader
 */

MacIntelLoader::MacIntelLoader(IntelFunctionList *owner, OperandSize cpu_address_size)
	: BaseIntelLoader(owner, cpu_address_size), import_entry_(NULL), import_size_(0), 
	jmp_table_entry_(NULL), jmp_table_size_(0), init_entry_(NULL), init_size_(0), term_entry_(NULL), term_size_(0), 
	file_crc_entry_(NULL), file_crc_size_(0), loader_crc_entry_(NULL), loader_crc_size_(0), file_entry_(NULL),
	patch_section_entry_(NULL), loader_crc_size_entry_(NULL), loader_crc_hash_entry_(NULL), file_crc_size_entry_(NULL),
	lazy_import_entry_(NULL), lazy_import_size_(0), thread_variables_entry_(NULL), thread_variables_size_(0),
	thread_data_entry_(NULL), thread_data_size_(0)
{

}

bool MacIntelLoader::Prepare(const CompileContext &ctx)
{
	MacArchitecture *file, *runtime;
	size_t i, j, k, index, orig_dll_count, old_count, start_index;
	IntelCommand *command, *src_command, *dst_command, *setup_image_entry, *free_image_entry;
	CommandLink *link, *src_link, *dst_link;
	IntelFunctionList *runtime_function_list;
	IntelFunction *func;
	MacImportFunction *import_function;
	MacImport *import;
	uint64_t address;
	std::map<uint64_t, MacImportFunction *> runtime_info_list;
	uint64_t loader_data_address;
	MacSegment *segment;

	file = reinterpret_cast<MacArchitecture *>(ctx.file);
	runtime = reinterpret_cast<MacArchitecture *>(ctx.runtime);
	IntelCRCTable *intel_crc = reinterpret_cast<IntelFunctionList *>(file->function_list())->crc_table();
	IntelLoaderData *loader_data = reinterpret_cast<IntelFunctionList*>(file->function_list())->loader_data();
	loader_data_address = (loader_data) ? loader_data->entry()->address() : runtime->export_list()->GetAddressByType(atLoaderData);
	if (!loader_data_address)
		return false;

	// create AV signature buffer
	AddAVBuffer(ctx);
	start_index = count();

	ICommand *entry_point_command = NULL;
	if (file->entry_point()) {
		IFunction *entry_point_func = ctx.file->function_list()->GetFunctionByAddress(file->entry_point());
		if (entry_point_func)
			entry_point_command = entry_point_func->entry();
	}

	segment = file->segment_list()->GetBaseSegment();
	uint64_t max_header_address = segment ? segment->address() + file->max_header_size() : 0;

	// parse objc segment
	Objc objc;
	std::vector<MacSegment *> objc_segment_list;
	if (objc.ReadFromFile(*file)) {
		objc_segment_list = objc.segment_list();
		for (i = 0; i < file->import_list()->count(); i++) {
			import = file->import_list()->item(i);
			for (j = 0; j < import->count(); j++) {
				import_function = import->item(j);
				MacSection *section = file->section_list()->GetSectionByAddress(import_function->address());
				if (section && find(objc_segment_list.begin(), objc_segment_list.end(), section->parent()) != objc_segment_list.end() && section->type() != S_NON_LAZY_SYMBOL_POINTERS)
					import_function->include_option(ioHasDirectReference);
			}
		}
	}

	// add loader import
	std::map<uint64_t, MacImportFunction *> import_map;
	MacImportList &new_import_list = *file->import_list();
	orig_dll_count = new_import_list.count();
	runtime_function_list = reinterpret_cast<IntelFunctionList *>(runtime->function_list());
	IntelCommandType value_command_type = (cpu_address_size() == osDWord) ? cmDD : cmDQ;
	index = count();
	int max_library_ordinal = 0;
	for (i = 0; i < new_import_list.count(); i++) {
		import = new_import_list.item(i);
		if (max_library_ordinal < import->library_ordinal())
			max_library_ordinal = import->library_ordinal();
	}
	for (i = 0; i < runtime_function_list->count(); i++) {
		func = runtime_function_list->item(i);
		if (func->tag() != ftLoader)
			continue;

		for (j = 0; j < func->count(); j++) {
			command = func->item(j);
			import_function = NULL;
			switch (command->type()) {
			case cmCall:
			case cmJmp:
			case cmMov:
				k = (command->type() == cmMov) ? 1 : 0;
				if (command->operand(k).type == (otMemory | otValue))
					import_function = runtime->import_list()->GetFunctionByAddress(command->operand(k).value);
				break;
			}
			if (!import_function)
				continue;

			std::map<uint64_t, MacImportFunction *>::const_iterator it = import_map.find(import_function->address());
			MacImportFunction *new_import_function = (it != import_map.end()) ? it->second : NULL;
			if (!new_import_function) {
				MacImport *src_import = reinterpret_cast<MacImport *>(import_function->owner());
				import = new_import_list.GetImportByName(src_import->name());
				if (!import) {
					import = new MacImport(&new_import_list, ++max_library_ordinal, src_import->name(), src_import->current_version(), src_import->compatibility_version());
					new_import_list.AddObject(import);
				}

				MacSymbol *symbol = import_function->symbol()->Clone(file->symbol_list());
				file->symbol_list()->AddObject(symbol);
				symbol->set_library_ordinal(import->library_ordinal());

				new_import_function = import->Add(0, BIND_TYPE_POINTER, 0, import_function->name(), 0, 0, false, symbol);
				import_map[import_function->address()] = new_import_function;
			}
			runtime_info_list[command->address()] = new_import_function;
		}
	}

	// create IAT
	old_count = file->indirect_symbol_list()->count();
	for (i = 0; i < file->import_list()->count(); i++) {
		import = file->import_list()->item(i);
		for (j = 0; j < import->count(); j++) {
			import_function = import->item(j);
			if (import_function->is_lazy() || (import_function->options() & ioHasDirectReference))
				continue;

			bool is_found = false;
			if (import_function->address()) {
				for (k = 0; k < old_count; k++) {
					MacIndirectSymbol *indirect_symbol = file->indirect_symbol_list()->item(k);
					if (indirect_symbol->symbol() == import_function->symbol()) {
						file->indirect_symbol_list()->AddObject(indirect_symbol->Clone(file->indirect_symbol_list()));
						indirect_symbol->set_symbol(NULL);
						indirect_symbol->set_value(INDIRECT_SYMBOL_ABS);
						is_found = true;
						break;
					}
				}
			}
			if (!is_found)
				file->indirect_symbol_list()->Add(0, 0, import_function->symbol());

			command = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size()));
			import_function_info_[import_function] = command;
		}
	}
	import_entry_ = item(start_index);
	import_entry_->set_operand_value(1, old_count);
	import_entry_->include_option(roCreateNewBlock);
	import_entry_->include_option(roDataSegment);
	import_entry_->set_alignment(OperandSizeToValue(cpu_address_size()));
	import_size_ = static_cast<uint32_t>((count() - start_index) * OperandSizeToValue(cpu_address_size()));

	// create jump table
	jmp_table_entry_ = NULL;
	jmp_table_size_ = 0;
	lazy_import_entry_ = NULL;
	lazy_import_size_ = 0;
	std::vector<MacImportFunction*> jmp_import_list;
	bool need_convert_runtime = (runtime->segment_list()->count() && !file->dyld_info()->cmd);
	for (i = 0; i < file->import_list()->count(); i++) {
		import = file->import_list()->item(i);
		for (j = 0; j < import->count(); j++) {
			import_function = import->item(j);
			if (import_function->options() & ioFromRuntime) {
				if (!need_convert_runtime || !import_function->is_lazy())
					continue;
			} else {
				if ((import_function->options() & ioIsRelative) == 0)
					continue;
			}

			jmp_import_list.push_back(import_function);
		}
	}
	if (!jmp_import_list.empty()) {
		index = count();
		size_t indirect_symbol_index = file->indirect_symbol_list()->count();
		address = ctx.manager->Alloc(jmp_import_list.size() * (cpu_address_size() == osDWord ? 5 : 6), mtReadable);

		CommandBlock *block = AddBlock(count(), true);
		block->set_address(address);

		for (i = 0; i < jmp_import_list.size(); i++) {
			import_function = jmp_import_list[i];

			file->indirect_symbol_list()->Add(0, 0, import_function->symbol());

			if (cpu_address_size() == osDWord) {
				command = AddCommand(cmJmp, IntelOperand(otValue, osDWord));
				command->CompileToNative();
				command->AddLink(0, ltJmp);
			}
			else {
				command = AddCommand(cmJmp, IntelOperand(otMemory | otValue, osQWord, 0, 0, LARGE_VALUE));
				command->CompileToNative();
				command->AddLink(0, ltOffset);
			}
			command->set_address(address);
			command->set_block(block);

			Data jmp;
			if (import_function->options() & ioIsRelative) {
				// jmp xxxx
				jmp.PushByte(0xe9);
				jmp.PushDWord(static_cast<uint32_t>(address - import_function->address() - 5));
			} else {
				// dd xxxx
				if (cpu_address_size() == osQWord)
					jmp.PushQWord(address);
				else
					jmp.PushDWord(static_cast<uint32_t>(address));

				segment = file->segment_list()->GetSectionByAddress(import_function->address());
				MacFixup *fixup = file->fixup_list()->AddDefault(cpu_address_size(), segment && (segment->memory_type() & mtExecutable) != 0);
				fixup->set_address(import_function->address());
			}

			file->AddressSeek(import_function->address());
			file->Write(jmp.data(), jmp.size());
			
			address += command->dump_size();
		}
		block->set_end_index(count() - 1);

		if (cpu_address_size() == osDWord) {
			old_count = count();
			Data data;
			data.resize(5, 0xf4);
			for (i = 0; i < jmp_import_list.size(); i++) {
				command = AddCommand(data);
				item(index + i)->link()->set_to_command(command);
			}

			jmp_table_entry_ = item(old_count);
			jmp_table_entry_->set_operand_value(1, indirect_symbol_index);
			jmp_table_entry_->include_option(roCreateNewBlock);
			jmp_table_entry_->include_option(roImportSegment);
			jmp_table_size_ = static_cast<uint32_t>(jmp_import_list.size() * data.size());
		} else {
			old_count = count();
			for (i = 0; i < jmp_import_list.size(); i++) {
				command = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
				command->AddLink(0, ltOffset);
				item(index + i)->link()->set_to_command(command);
			}

			lazy_import_entry_ = item(old_count);
			lazy_import_entry_->set_operand_value(1, indirect_symbol_index);
			lazy_import_entry_->include_option(roCreateNewBlock);
			lazy_import_entry_->include_option(roDataSegment);
			lazy_import_entry_->set_alignment(OperandSizeToValue(cpu_address_size()));
			lazy_import_size_ = static_cast<uint32_t>(jmp_import_list.size() * OperandSizeToValue(cpu_address_size()));

			address = 0;
			MacSegment *data_segment = file->segment_list()->GetSectionByName(SEG_DATA);
			if (data_segment) {
				MacSection *section = file->section_list()->GetSectionByName(data_segment, SECT_DYLD);
				if (section)
					address = section->address();
			}
			if (!address)
				throw std::runtime_error("Section \"__dyld\" not found");

			IntelCommand *dyld_entry = AddCommand(cmPush, IntelOperand(otRegistr, osQWord, regR11, 0));
			AddCommand(cmLea, IntelOperand(otRegistr, osQWord, regR11, 0), IntelOperand(otMemory | otValue, osQWord, 0, file->image_base(), LARGE_VALUE));
			AddCommand(cmPush, IntelOperand(otRegistr, osQWord, regR11, 0));
			AddCommand(cmJmp, IntelOperand(otMemory | otValue, osQWord, 0, address, LARGE_VALUE));

			index = old_count;
			old_count = count();
			for (i = 0; i < jmp_import_list.size(); i++) {
				command = AddCommand(cmLea, IntelOperand(otRegistr, osQWord, regR11, 0), IntelOperand(otMemory | otValue, osQWord, 0, 0, LARGE_VALUE));
				command->AddLink(1, ltOffset, item(index + i));
				item(index + i)->link()->set_to_command(command);
				command = AddCommand(cmJmp, IntelOperand(otValue, osQWord, 0, 0));
				command->AddLink(0, ltJmp, dyld_entry);
			}
		}
	}
	else {
		for (i = 0; i < file->import_list()->count(); i++) {
			import = file->import_list()->item(i);
			for (j = 0; j < import->count(); j++) {
				import_function = import->item(j);
				if ((import_function->options() & ioFromRuntime) && import_function->is_lazy())
					jmp_import_list.push_back(import_function);
			}
		}
		if (!jmp_import_list.empty()) {
			// move S_LAZY_SYMBOL_POINTERS to data segment
			std::vector<uint64_t> address_list;
			index = count();
			size_t indirect_symbol_index = file->indirect_symbol_list()->count();
			address = ctx.manager->Alloc(jmp_import_list.size() * (cpu_address_size() == osDWord ? 5 : 6), mtReadable);

			CommandBlock *block = AddBlock(count(), true);
			block->set_address(address);

			for (i = 0; i < jmp_import_list.size(); i++) {
				import_function = jmp_import_list[i];

				file->indirect_symbol_list()->Add(0, 0, import_function->symbol());

				if (cpu_address_size() == osDWord) {
					command = AddCommand(cmJmp, IntelOperand(otValue, osDWord));
					command->CompileToNative();
					command->AddLink(0, ltJmp);
				}
				else {
					command = AddCommand(cmJmp, IntelOperand(otMemory | otValue, cpu_address_size(), 0, 0, LARGE_VALUE));
					command->CompileToNative();
					command->AddLink(0, ltOffset);
				}

				command->set_address(address);
				command->set_block(block);

				file->AddressSeek(import_function->address());
				if (cpu_address_size() == osDWord) {
					address_list.push_back(file->ReadDWord());
					file->AddressSeek(import_function->address());
					file->WriteDWord(static_cast<uint32_t>(address));
				}
				else {
					address_list.push_back(file->ReadQWord());
					file->AddressSeek(import_function->address());
					file->WriteQWord(address);
				}
				
				address += command->dump_size();
			}
			block->set_end_index(count() - 1);

			if (cpu_address_size() == osDWord) {
				old_count = count();
				for (i = 0; i < jmp_import_list.size(); i++) {
					command = AddCommand(cmJmp, IntelOperand(otMemory | otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
					command->CompileToNative();
					command->AddLink(0, ltOffset);
					item(index + i)->link()->set_to_command(command);
				}
				index = old_count;
			}

			old_count = count();
			for (i = 0; i < jmp_import_list.size(); i++) {
				import_function = jmp_import_list[i];
				command = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, address_list[i], NEED_FIXUP));
				item(index + i)->link()->set_to_command(command);

				import_function->set_address(0);
				import_function_info_[import_function] = command;
			}

			lazy_import_entry_ = item(old_count);
			lazy_import_entry_->set_operand_value(1, indirect_symbol_index);
			lazy_import_entry_->include_option(roCreateNewBlock);
			lazy_import_entry_->include_option(roDataSegment);
			lazy_import_entry_->set_alignment(OperandSizeToValue(cpu_address_size()));
			lazy_import_size_ = static_cast<uint32_t>(jmp_import_list.size() * OperandSizeToValue(cpu_address_size()));
		}
	}

	// create init module function list
	index = count();
	AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
	for (i = 0; i < file->section_list()->count(); i++) {
		MacSection *section = file->section_list()->item(i);
		if (section->type() != S_MOD_INIT_FUNC_POINTERS)
			continue;

		file->AddressSeek(section->address());
		for (j = 0; j < section->size(); j += OperandSizeToValue(cpu_address_size())) {
			command = Add(section->address() + j);
			command->ReadValueFromFile(*file, cpu_address_size());
		}
	}
	init_entry_ = item(index);
	init_entry_->include_option(roCreateNewBlock);
	init_entry_->include_option(roDataSegment);
	init_entry_->set_alignment(OperandSizeToValue(cpu_address_size()));
	init_size_ = static_cast<uint32_t>((count() - index) * OperandSizeToValue(cpu_address_size()));

	// work around MacOSX >= 10.13 - init function must be point within __TEXT segment
	if (max_header_address) {
		max_header_address -= 5;
		CommandBlock *block = AddBlock(count(), true);
		block->set_address(max_header_address);
		command = AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size(), 0, 0));
		command->set_address(max_header_address);
		command->set_block(block);
		init_entry_->AddLink(0, ltOffset, command);
	}

	// create termination module function list
	index = count();
	AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
	for (i = 0; i < file->section_list()->count(); i++) {
		MacSection *section = file->section_list()->item(i);
		if (section->type() != S_MOD_TERM_FUNC_POINTERS)
			continue;

		file->AddressSeek(section->address());
		for (j = 0; j < section->size(); j += OperandSizeToValue(cpu_address_size())) {
			command = Add(section->address() + j);
			command->ReadValueFromFile(*file, cpu_address_size());
		}
	}
	term_entry_ = item(index);
	term_entry_->include_option(roCreateNewBlock);
	term_entry_->include_option(roDataSegment);
	term_entry_->set_alignment(OperandSizeToValue(cpu_address_size()));
	term_entry_->AddLink(0, ltGateOffset);
	term_size_ = (uint32_t)((count() - index) * OperandSizeToValue(cpu_address_size()));

	// create S_THREAD_LOCAL_VARIABLES section
	index = count();
	if (file->flags() & MH_HAS_TLV_DESCRIPTORS) {
		for (i = 0; i < file->section_list()->count(); i++) {
			MacSection *section = file->section_list()->item(i);
			if (section->type() != S_THREAD_LOCAL_VARIABLES)
				continue;

			if ((ctx.options.flags & cpPack) && !section->parent()->excluded_from_packing()) {
				file->AddressSeek(section->address());
				for (j = 0; j < section->size(); j += OperandSizeToValue(cpu_address_size())) {
					command = Add(section->address() + j);
					command->ReadValueFromFile(*file, cpu_address_size());
					if (j == 0)
						command->set_operand_value(1, section->size());
				}
			}
			else {
				for (j = 0; j < section->size(); j += OperandSizeToValue(cpu_address_size())) {
					import_function = file->import_list()->GetFunctionByAddress(section->address() + j);
					if (import_function) {
						std::map<MacImportFunction *, IntelCommand *>::const_iterator it = import_function_info_.find(import_function);
						if (it != import_function_info_.end())
							import_function_info_.erase(it);
					}
				}
			}
		}
	}
	thread_variables_entry_ = (count() == index) ? NULL : item(index);
	thread_variables_size_ = (uint32_t)((count() - index) * OperandSizeToValue(cpu_address_size()));
	if (thread_variables_entry_) {
		thread_variables_entry_->include_option(roCreateNewBlock);
		thread_variables_entry_->include_option(roDataSegment);
		thread_variables_entry_->set_alignment(OperandSizeToValue(cpu_address_size()));
	}

	// create S_THREAD_LOCAL_REGULAR section
	index = count();
	if (ctx.options.flags & cpPack) {
		address = 0;
		uint64_t end_address = 0;
		for (i = 0; i < file->section_list()->count(); i++) {
			MacSection *section = file->section_list()->item(i);
			if (section->type() == S_THREAD_LOCAL_REGULAR || section->type() == S_THREAD_LOCAL_ZEROFILL) {
				if (!address)
					address = section->address();
				end_address = section->address() + section->size();
			}
		}
		if (address) {
			segment = file->segment_list()->GetSectionByAddress(address);
			if (segment && !segment->excluded_from_packing()) {
				uint32_t size = static_cast<uint32_t>(end_address - address);
				uint32_t physical_size = std::min(static_cast<uint32_t>(segment->address() + segment->physical_size() - address), size);
				if (physical_size) {
					file->AddressSeek(address);
					Data data;
					data.resize(size);
					file->Read(&data[0], physical_size);
					AddCommand(data);
				}
			}
		}
	}
	thread_data_entry_ = (count() == index) ? NULL : item(index);
	thread_data_size_ = 0;
	if (thread_data_entry_) {
		for (i = index; i < count(); i++) {
			thread_data_size_ += static_cast<uint32_t>(item(i)->dump_size());
		}
		thread_data_entry_->include_option(roCreateNewBlock);
		thread_data_entry_->include_option(roDataSegment);
		thread_data_entry_->set_alignment(OperandSizeToValue(cpu_address_size()));
	}

	// create watermarks
	AddWatermark(ctx.options.watermark, 2);

	// create segment list for setting WRITABLE flag
	std::vector<MacSegment *> writable_segment_list;
	std::vector<PackerInfo> packer_info_list;
	MacFixupList loader_fixup_list;
	segment = file->segment_list()->GetSectionByAddress(loader_data_address);
	if (segment)
		writable_segment_list.push_back(segment);

	if ((file->runtime_functions_section() && file->runtime_functions_section()->name() == SECT_EH_FRAME) || file->unwind_info_section()) {
		segment = file->segment_list()->GetBaseSegment();
		if (segment)
			writable_segment_list.push_back(segment);
	}

	// parse objc load methods
	std::vector<IntelCommand *> load_command_list;
	if (!objc_segment_list.empty()) {
		size_t value_size = OperandSizeToValue(file->cpu_address_size());
		std::set<uint64_t> address_list;
		objc.GetLoadMethodReferences(address_list);
		for (std::set<uint64_t>::const_iterator it = address_list.begin(); it != address_list.end(); it++) {
			if (!file->AddressSeek(*it))
				continue;

			uint64_t pos = file->Tell();
			uint64_t value = 0;
			file->Read(&value, value_size);

			CommandBlock *block = AddBlock(count(), true);

			command = AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size(), 0, 0));
			command->AddLink(0, ltGateOffset);
			command->set_operand_value(1, value);
			command->set_block(block);
			command->CompileToNative();

			address = ctx.manager->Alloc(command->dump_size(), mtReadable);
			block->set_address(address);
			command->set_address(address);

			value = address;
			file->Seek(pos);
			file->Write(&value, value_size);

			load_command_list.push_back(command);
		}
	}

	IntelCommand *packer_props = NULL;
	if (ctx.options.flags & cpPack) {
		std::set<MacSegment *> skip_segment_list;
		for (i = 0; i < objc_segment_list.size(); i++) {
			skip_segment_list.insert(objc_segment_list[i]);
		}
		MacSegment *data_segment = file->segment_list()->GetSectionByName(SEG_DATA);
		if (data_segment) {
			// skip sections with vars
			if (file->section_list()->GetSectionByName(data_segment, SECT_DYLD) ||
				file->section_list()->GetSectionByName(data_segment, SECT_PROGRAM_VARS)) {
					skip_segment_list.insert(data_segment);
			}
		}

		PackerInfo packer_info;
		for (i = 0; i < file->segment_list()->count(); i++) {
			segment = file->segment_list()->item(i);
			if (segment->excluded_from_packing())
				continue;

			bool can_be_packed = true;
			if ((segment->memory_type() & (mtWritable | mtShared)) == (mtWritable | mtShared)) {
				can_be_packed = false;
			} else if (skip_segment_list.find(segment) != skip_segment_list.end()) {
				can_be_packed = false;
			}

			if (!can_be_packed) {
				//file->Notify(mtWarning, NULL, string_format(language[lsSegmentCanNotBePacked].c_str(), segment->name().c_str()));
				continue;
			}

			if (segment->physical_size()) {
				packer_info = PackerInfo(segment, segment->address(), static_cast<size_t>(segment->physical_size()));

				if (segment == data_segment) {
					ISection *section = file->section_list()->GetSectionByName(data_segment, SECT_DYLD);
					if (section && section->address() + section->size() >= packer_info.address) {
						size_t delta = static_cast<size_t>(section->address() + section->size() - packer_info.address);
						packer_info.address += delta;
						if (packer_info.size > delta) {
							packer_info.size -= delta;
						} else {
							packer_info.size = 0;
						}
					}
				} else if (segment == file->header_segment()) {
					size_t delta = file->max_header_size();
					packer_info.address += delta;
					if (packer_info.size > delta) {
						packer_info.size -= delta;
					} else {
						packer_info.size = 0;
					}
				}

				if (!packer_info.size)
					continue;

				packer_info_list.push_back(packer_info);
				packed_segment_list_.push_back(segment);

				// need add packed section into WRITABLE section list
				if (std::find(writable_segment_list.begin(), writable_segment_list.end(), segment) == writable_segment_list.end())
					writable_segment_list.push_back(segment);
			}
		}

		// parse objc structures
		if (!objc_segment_list.empty()) {
			size_t value_size = OperandSizeToValue(file->cpu_address_size());
			std::set<uint64_t> address_list;
			objc.GetStringReferences(address_list);
			for (i = 0; i < file->section_list()->count(); i++) {
				MacSection *section = file->section_list()->item(i);
				if (find(objc_segment_list.begin(), objc_segment_list.end(), section->parent()) != objc_segment_list.end()) {
					switch (section->type()) {
					case S_LITERAL_POINTERS:
						for (j = 0; j < section->size(); j += value_size) {
							address_list.insert(section->address() + j);
						}
						break;
					}
				}
			}

			index = count();
			for (std::set<uint64_t>::const_iterator it = address_list.begin(); it != address_list.end(); it++) {
				if (!file->AddressSeek(*it))
					continue;

				// move strings to loader segment
				uint64_t pos = file->Tell();
				uint64_t value = 0;
				file->Read(&value, value_size);
				segment = file->segment_list()->GetSectionByAddress(value);
				if (!segment || std::find(packer_info_list.begin(), packer_info_list.end(), segment) == packer_info_list.end())
					continue;

				command = NULL;
				for (i = index; i < count(); i++) {
					if (item(i)->operand(0).value == value) {
						command = item(i);
						break;
					}
				}
				if (!command) {
					file->AddressSeek(value);
					std::string str = file->ReadString();

					CommandBlock *block = AddBlock(count(), true);

					command = AddCommand(str);
					command->set_block(block);
					command->set_operand_value(0, value);

					address = ctx.manager->Alloc(command->dump_size(), mtReadable);
					block->set_address(address);
					command->set_address(address);
				}

				file->Seek(pos);
				value = command->address();
				file->Write(&value, value_size);
			}
		}

		// packing sections
		j = 0;
		for (i = 0; i < packer_info_list.size(); i++) {
			j += packer_info_list[i].size;
		}
		file->StartProgress(string_format("%s...", language[lsPacking].c_str()), j);

		Data data;
		Packer packer;

		if (!packer.WriteProps(&data))
			throw std::runtime_error("Packer error");
		packer_props = AddCommand(data);
		packer_props->include_option(roCreateNewBlock);

		for (i = 0; i < packer_info_list.size(); i++) {
			packer_info = packer_info_list[i];
			if (!file->AddressSeek(packer_info.address))
				return false;

			if (!packer.Code(file, packer_info.size, &data))
				throw std::runtime_error("Packer error");

			command = AddCommand(data);
			command->include_option(roCreateNewBlock);
			packer_info_list[i].data = command;
		}

		// remove packed sections from file
		uint32_t physical_offset = 0;
		for (i = 0; i < file->segment_list()->count(); i++) {
			segment = file->segment_list()->item(i);
			uint32_t physical_size = segment->physical_size();
			bool is_packed = false;
			std::vector<PackerInfo>::iterator it = std::find(packer_info_list.begin(), packer_info_list.end(), segment);
			if (it != packer_info_list.end()) {
				physical_size = static_cast<uint32_t>(it->address - segment->address());
				is_packed = true;
				if (segment == file->header_segment() && file->file_type() == MH_DYLIB) {
					file->Seek(physical_size);
					j = physical_size;
					physical_size = AlignValue(physical_size, file->segment_alignment());
					for (k = j; k < physical_size; k++) {
						file->WriteByte(0);
					}
				}
			}
			if (segment->physical_offset() != physical_offset) {
				size_t delta = static_cast<size_t>(physical_offset - segment->physical_offset());
				for (j = 0; j < file->section_list()->count(); j++) {
					MacSection *section = file->section_list()->item(j);
					if (section->parent() == segment && section->physical_offset())
						section->set_physical_offset(static_cast<uint32_t>(section->physical_offset() + delta));
				}
			}

			if (physical_size > 0 && segment->physical_offset() != physical_offset) {
				uint8_t *buff = new uint8_t[physical_size];
				file->Seek(segment->physical_offset());
				file->Read(buff, physical_size);
				file->Seek(physical_offset);
				file->Write(buff, physical_size);
				delete [] buff;
			}

			segment->set_physical_offset(physical_offset);
			segment->set_physical_size(physical_size);

			if (is_packed) {
				j = physical_offset + physical_size;
				file->Seek(j);
				physical_offset = (uint32_t)AlignValue(j, file->file_alignment());
				if (!physical_size && j == physical_offset)
					physical_offset += file->file_alignment();
				for (k = j; k < physical_offset; k++) {
					file->WriteByte(0);
				}
			} else {
				physical_offset += physical_size;
			}
		}
		file->Resize(physical_offset);
	}

	for (i = 0; i < file->fixup_list()->count(); i++) {
		MacFixup *fixup = file->fixup_list()->item(i);
		if (fixup->is_deleted())
			continue;

		segment = file->segment_list()->GetSectionByAddress(fixup->address());
		if (!segment)
			continue;

		if (std::find(packer_info_list.begin(), packer_info_list.end(), segment) == packer_info_list.end()) {
			if ((segment->memory_type() & (mtExecutable | mtWritable)) != mtExecutable || segment->name() == SEG_TEXT)
				continue;
		}

		if (fixup->symbol()) {
			// external relocation
			// FIXME
			continue;
			command = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size())); //-V779
			relocation_info_[fixup] = command;
		}
		else {
			// local relocation
			if (ctx.options.flags & cpStripFixups)
				continue;

			loader_fixup_list.AddObject(fixup->Clone(&loader_fixup_list));
			fixup->set_deleted(true);
		}

		// need add section into WRITABLE section list
		if (std::find(writable_segment_list.begin(), writable_segment_list.end(), segment) == writable_segment_list.end())
			writable_segment_list.push_back(segment);
	}

	// create packer info for loader
	std::vector<LoaderInfo> loader_info_list;
	index = count();
	if (packer_props) {
		command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
		link = command->AddLink(0, ltOffset, packer_props);
		link->set_sub_value(file->image_base());
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, packer_props->dump_size()));

		for (i = 0; i < packer_info_list.size(); i++) {
			command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
			link = command->AddLink(0, ltOffset, packer_info_list[i].data);
			link->set_sub_value(file->image_base());

			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, packer_info_list[i].address - file->image_base()));
		}
	}
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create file CRC info for loader
	index = count();
	if ((ctx.options.flags | ctx.options.sdk_flags) & cpMemoryProtection) {
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
		for (i = 0; i < 4; i++) {
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
		}
	}
	file_crc_entry_ = (count() == index) ? NULL : item(index);
	if (file_crc_entry_)
		file_crc_entry_->include_option(roCreateNewBlock);
	file_crc_size_ = static_cast<uint32_t>((count() - index) * OperandSizeToValue(osDWord));
	loader_info_list.push_back(LoaderInfo(file_crc_entry_, file_crc_size_));

	file_crc_size_entry_ = file_crc_entry_ ? AddCommand(cmDD, IntelOperand(otValue, osDWord)) : NULL;
	if (file_crc_size_entry_)
		file_crc_size_entry_->include_option(roCreateNewBlock);

	// create header and loader CRC info for loader
	index = count();
	if (((ctx.options.flags | ctx.options.sdk_flags) & cpMemoryProtection) || (ctx.options.flags & cpLoaderCRC)) {
		// calc CRC blocks count
		k = 30 + new_import_list.count();
		if ((ctx.options.flags & cpStripFixups) == 0) {
			std::vector<IFunction *> function_list = ctx.file->function_list()->processor_list();
			function_list.push_back(this);
			for (i = 0; i < runtime_function_list->count(); i++) {
				func = runtime_function_list->item(i);
				if (func->tag() != ftLoader)
					continue;

				if (func->compilation_type() == ctMutation)
					function_list.push_back(func);
			}

			for (i = 0; i < function_list.size(); i++) {
				func = reinterpret_cast<IntelFunction *>(function_list[i]);
				for (j = 0; j < func->count(); j++) {
					command = func->item(j);
					for (size_t c = 0; c < 3; c++) {
						IntelOperand operand = command->operand(c);
						if (operand.type == otNone)
							break;
						if (operand.fixup)
							k++;
					}
				}
			}
		}
		for (i = 0; i < k; i++) {
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
		}
	}
	loader_crc_entry_ = (count() == index) ? NULL : item(index);
	if (loader_crc_entry_)
		loader_crc_entry_->include_option(roCreateNewBlock);
	loader_crc_size_ = static_cast<uint32_t>((count() - index) * OperandSizeToValue(osDWord));
	loader_info_list.push_back(LoaderInfo(loader_crc_entry_, loader_crc_size_));

	loader_crc_size_entry_ = loader_crc_entry_ ? AddCommand(cmDD, IntelOperand(otValue, osDWord)) : NULL;
	if (loader_crc_size_entry_)
		loader_crc_size_entry_->include_option(roCreateNewBlock);
	loader_crc_hash_entry_ = loader_crc_entry_ ? AddCommand(cmDD, IntelOperand(otValue, osDWord)) : NULL;
	if (loader_crc_hash_entry_)
		loader_crc_hash_entry_->include_option(roCreateNewBlock);

	// create section info for loader
	index = count();
	for (i = 0; i < writable_segment_list.size(); i++) {
		segment = writable_segment_list[i];
		if ((segment->memory_type() & mtWritable) && ((segment->memory_type() & mtExecutable) == 0 || segment->physical_size()))
			continue;

		segment->include_maxprot(VM_PROT_WRITE);

		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, segment->address() - file->image_base()));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, segment->size()));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, segment->flags()));
	}
	// add runtime's WRITABLE sections
	for (i = 0; i < runtime->segment_list()->count(); i++) {
		segment = runtime->segment_list()->item(i);
		if (segment->memory_type() & mtWritable) {
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, segment->address() - file->image_base()));
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, segment->size()));
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, segment->flags()));
		}
	}
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create fixup info for loader
	if (loader_fixup_list.count() > 0) {
		Data data;
		loader_fixup_list.WriteToData(data, file->image_base());
		command = AddCommand(data);
	} else {
		command = NULL;
	}
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (command) ? command->dump_size() : 0));

	// create relocation info for loader
	loader_info_list.push_back(LoaderInfo(NULL, 0));
	
	// create IAT info for loader
	index = count();
	for (std::map<MacImportFunction *, IntelCommand *>::iterator it = import_function_info_.begin(); it != import_function_info_.end(); it++) {
		import_function = it->first;
		if (!import_function->address())
			continue;

		command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
		link = command->AddLink(0, ltOffset, it->second);
		link->set_sub_value(file->image_base());

		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, import_function->address() - file->image_base()));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, OperandSizeToValue(cpu_address_size())));
	}
	for (std::map<MacFixup *, IntelCommand *>::iterator it = relocation_info_.begin(); it != relocation_info_.end(); it++) {
		MacFixup *fixup = it->first;

		command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
		link = command->AddLink(0, ltOffset, it->second);
		link->set_sub_value(file->image_base());

		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, fixup->address() - file->image_base()));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, OperandSizeToValue(cpu_address_size())));
	}
	if (thread_variables_entry_) {
		size_t c = thread_variables_size_ / OperandSizeToValue(cpu_address_size());
		j = IndexOf(thread_variables_entry_);
		for (i = 0; i < c; i++) {
			src_command = item(j + i);
			if (!src_command->operand(1).value)
				continue;

			command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
			link = command->AddLink(0, ltOffset, src_command);
			link->set_sub_value(file->image_base());

			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, src_command->address() - file->image_base()));
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, src_command->operand(1).value));
		}
	}
	size_t patch_section_index = count();
	if (file->runtime_functions_section() && file->runtime_functions_section()->name() == SECT_EH_FRAME) {
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
	}
	if (file->unwind_info_section()) {
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
	}
	patch_section_entry_ = (count() == patch_section_index) ? NULL : item(patch_section_index);
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create import info for loader
	index = count();
	/*
	if (ctx.options.flags & cpImportProtection) {
		for (i = 0, import_index = 0; i < orig_dll_count; i++) {
			import = new_import_list.item(i);
			if (import->count() == 0)
				continue;

			// DLL name
			command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
			link = command->AddLink(0, ltOffset, import_info_list[i].loader_name);
			link->set_sub_value(file->image_base());

			for (j = 0; j < import->count(); j++, import_index++) {
				import_function = import->item(j);
				if (import_function->options() & ioNative)
					continue;

				if (ctx.options.flags & cpResourceProtection) {
					// internal API
					if ((import_function->options() & ioFromRuntime) == 0 && import_function->type() >= atLoadResource && import_function->type() <= atEnumResourceTypesW)
						continue;
				}

				iat_command = intel_import->GetIATCommand(import_function);

				// API name
				if (import_function->is_ordinal()) {
					AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, IMAGE_ORDINAL_FLAG32 | import_function->ordinal()));
				} else {
					command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
					link = command->AddLink(0, ltOffset, import_function_info_list[import_index].loader_name);
					link->set_sub_value(file->image_base());
				}

				// IAT
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, ((iat_command) ? iat_command->address() : import_function->address()) - file->image_base()));

				// decrypt value
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, (iat_command) ? iat_command->operand(1).value : 0));
			}

			// end of DLL
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
		}
	}
	*/
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create internal import info for loader
	index = count();
	/*
	if (ctx.options.flags & cpResourceProtection) {
		for (i = 0; i < orig_dll_count; i++) {
			import = new_import_list.item(i);
			for (j = 0; j < import->count(); j++) {
				import_function = import->item(j);

				if ((import_function->options() & ioFromRuntime) || import_function->type() < atLoadResource || import_function->type() > atEnumResourceTypesW)
					continue;

				iat_command = (intel_import) ? intel_import->GetIATCommand(import_function) : NULL;

				address = runtime->export_list()->GetAddressByType(import_function->type());
				func = reinterpret_cast<IntelFunction*>(file->function_list()->GetFunctionByAddress(address));
				if (func && func->entry())
					address = func->entry()->address();

				// address
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, address - file->image_base()));
				// IAT
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, ((iat_command) ? iat_command->address() : import_function->address()) - file->image_base()));
				// decrypt value
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, (iat_command) ? iat_command->operand(1).value : 0));
			}
		}
	}
	*/
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create memory CRC info for loader
	if (intel_crc) {
		command = intel_crc->table_entry();
		i = static_cast<size_t>(intel_crc->size_entry()->operand(0).value);
	} else {
		command = NULL;
		i = 0;
	}
	loader_info_list.push_back(LoaderInfo(command, i));

	// create delay import info for loader
	index = count();
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create strings for loader
	uint32_t string_key = rand32();
	std::map<uint32_t, IntelCommand *> loader_string_list;
	loader_string_list[FACE_FILE_CORRUPTED] = AddCommand(EncryptString((ctx.options.flags & cpMemoryProtection) ? ctx.options.messages[MESSAGE_FILE_CORRUPTED].c_str() : std::string().c_str(), string_key));
	loader_string_list[FACE_DEBUGGER_FOUND] = AddCommand(EncryptString(ctx.options.messages[MESSAGE_DEBUGGER_FOUND].c_str(), string_key));
	loader_string_list[FACE_VIRTUAL_MACHINE_FOUND] = AddCommand(EncryptString(ctx.options.messages[MESSAGE_VIRTUAL_MACHINE_FOUND].c_str(), string_key));
	loader_string_list[FACE_PROC_NOT_FOUND] = AddCommand(EncryptString("The procedure entry point %c could not be located in the module %c", string_key));
	loader_string_list[FACE_ORDINAL_NOT_FOUND] = AddCommand(EncryptString("The ordinal %d could not be located in the module %c", string_key));
	loader_string_list[FACE_INITIALIZATION_ERROR] = AddCommand(EncryptString("Initialization error %d", string_key));
	VMProtectBeginVirtualization("Loader Strings");
	loader_string_list[FACE_UNREGISTERED_VERSION] = AddCommand(EncryptString(
#ifdef DEMO
		true
#else
		(ctx.options.flags & cpUnregisteredVersion) 
#endif
		? VMProtectDecryptStringA("This application is protected with unregistered version of VMProtect.") : "", string_key));
	VMProtectEnd();
	loader_string_list[FACE_MACOSX_FORMAT_VALUE] = AddCommand("%s\n");
	loader_string_list[FACE_GNU_PTRACE] = AddCommand("ptrace");
	for (std::map<uint32_t, IntelCommand *>::const_iterator it = loader_string_list.begin(); it != loader_string_list.end(); it++) {
		it->second->include_option(roCreateNewBlock);
	}

	file_entry_ = NULL;
	if (file->entry_point() && max_header_address) {
		segment = file->segment_list()->GetSectionByAddress(file->entry_point());
		if (segment && std::find(packer_info_list.begin(), packer_info_list.end(), segment) != packer_info_list.end()) {
			// work around MacOSX >= 10.13 - entry point function must be point within __TEXT segment
			max_header_address -= 5;
			CommandBlock *block = AddBlock(count(), true);
			block->set_address(max_header_address);
			file_entry_ = AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size(), 0, file->entry_point()));
			file_entry_->set_address(max_header_address);
			file_entry_->set_block(block);
		}
	}

	// append loader
	old_count = count();
	std::vector<IntelCommand*> internal_entry_list;
	for (size_t n = 0; n < 2; n++) {
		for (i = 0; i < runtime_function_list->count(); i++) {
			func = runtime_function_list->item(i);
			if (func->tag() != ftLoader)
				continue;

			if (func->compilation_type() == ctMutation) {
				if (n != 0)
					continue;
			} else {
				if (n != 1)
					continue;
			}

			bool is_internal = (func->compilation_type() != ctMutation && func->entry_type() == etNone);
			for (j = 0; j < func->count(); j++) {
				src_command = func->item(j);

				dst_command = src_command->Clone(this);
				AddObject(dst_command);
				if (is_internal) {
					if (j == 0)
						internal_entry_list.push_back(dst_command);
					if (dst_command->type() == cmRet)
						dst_command->include_option(roInternal);
				}

				src_link = src_command->link();
				if (src_link) {
					dst_link = src_link->Clone(link_list());
					dst_link->set_from_command(dst_command);
					link_list()->AddObject(dst_link);
				
					if (src_link->parent_command())
						dst_link->set_parent_command(GetCommandByAddress(src_link->parent_command()->address()));
				}

				uint64_t ref_address = (dst_command->type() == cmCall && dst_command->operand(0).type == otValue && func->compilation_type() != ctMutation) ? dst_command->operand(0).value : dst_command->address();
				std::map<uint64_t, MacImportFunction *>::const_iterator it_import = runtime_info_list.find(ref_address);
				if (it_import != runtime_info_list.end()) {
					if (dst_command->type() == cmCall) {
						IntelOperand operand = dst_command->operand(0);
						if (operand.type == otValue) {
							command = GetCommandByAddress(dst_command->operand(0).value);
							operand = command->operand(0);
							delete dst_command->link();
							dst_command->AddLink(-1, ltCall);
						}
						dst_command->Init(cmMov, IntelOperand(otRegistr, operand.size, regEAX), operand);

						command = new IntelCommand(this, cpu_address_size(), cmCall, IntelOperand(otRegistr, operand.size, regEAX));
						if (dst_command->link())
							dst_command->link()->set_from_command(command);
						AddObject(command);
					}
					dst_link = dst_command->AddLink((dst_command->operand(1).type != otNone) ? 1 : 0, ltOffset);
					std::map<MacImportFunction *, IntelCommand *>::iterator it = import_function_info_.find(it_import->second);
					if (it != import_function_info_.end())
						dst_link->set_to_command(it->second);
				}

				if (!dst_command->is_data() && (dst_command->options() & roBreaked)) {
					// need add JMP after breaked commands
					IntelCommand *jmp_command = new IntelCommand(this, cpu_address_size(), cmJmp, IntelOperand(otValue, cpu_address_size(), 0, dst_command->next_address()));
					jmp_command->AddLink(0, ltJmp, dst_command->next_address());
					jmp_command->set_address_range(dst_command->address_range());
					jmp_command->CompileToNative();
					AddObject(jmp_command);
				}

				command = dst_command;
				for (k = 0; k < 3; k++) {
					IntelOperand operand = command->operand(k);
					if (operand.type == otNone)
						break;

					if ((operand.type & otValue) == 0)
						continue;

					if ((operand.value & 0xFFFF0000) == 0xFACE0000) {
						switch (static_cast<uint32_t>(operand.value)) {
						case FACE_LOADER_OPTIONS:
							operand.value = 0;
							if (ctx.options.flags & cpMemoryProtection)
								operand.value |= LOADER_OPTION_CHECK_PATCH;
							if (ctx.options.flags & cpCheckDebugger)
								operand.value |= LOADER_OPTION_CHECK_DEBUGGER;
							if (ctx.options.flags & cpCheckVirtualMachine)
								operand.value |= LOADER_OPTION_CHECK_VIRTUAL_MACHINE;
							command->set_operand_value(k, operand.value);
							command->CompileToNative();
							break;
						case FACE_LOADER_DATA:
							command->set_operand_value(k, loader_data_address - file->image_base());
							command->CompileToNative();
							break;
						case FACE_RUNTIME_ENTRY:
							if (runtime->segment_list()->count()) {
								uint64_t runtime_init_address = runtime->export_list()->GetAddressByType(atRuntimeInit);
								if (!runtime_init_address)
									return false;
								command->set_operand_value(k, runtime_init_address - file->image_base());
							} else {
								command->set_operand_value(k, 0);
							}
							command->CompileToNative();
							break;
						case FACE_STRING_DECRYPT_KEY:
							command->set_operand_value(k, string_key);
							command->CompileToNative();
							break;
						case FACE_PACKER_INFO:
						case FACE_FILE_CRC_INFO:
						case FACE_LOADER_CRC_INFO:
						case FACE_SECTION_INFO:
						case FACE_FIXUP_INFO:
						case FACE_RELOCATION_INFO:
						case FACE_IAT_INFO:
						case FACE_IMPORT_INFO:
						case FACE_INTERNAL_IMPORT_INFO:
						case FACE_MEMORY_CRC_INFO:
						case FACE_DELAY_IMPORT_INFO:
							dst_command = loader_info_list[(operand.value & 0xff) >> 1].data;
							if (dst_command) {
								link = command->AddLink((int)k, ltOffset, dst_command);
								link->set_sub_value(file->image_base());
							} else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_PACKER_INFO_SIZE:
						case FACE_SECTION_INFO_SIZE:
						case FACE_FIXUP_INFO_SIZE:
						case FACE_RELOCATION_INFO_SIZE:
						case FACE_IAT_INFO_SIZE:
						case FACE_IMPORT_INFO_SIZE:
						case FACE_INTERNAL_IMPORT_INFO_SIZE:
						case FACE_MEMORY_CRC_INFO_SIZE:
						case FACE_DELAY_IMPORT_INFO_SIZE:
							command->set_operand_value(k, loader_info_list[(operand.value & 0xff) >> 1].size);
							command->CompileToNative();
							break;
						case FACE_LOADER_CRC_INFO_SIZE:
							if (loader_crc_size_entry_) {
								link = command->AddLink((int)k, ltOffset, loader_crc_size_entry_);
								link->set_sub_value(file->image_base());
							} else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_LOADER_CRC_INFO_HASH:
							if (loader_crc_hash_entry_) {
								link = command->AddLink((int)k, ltOffset, loader_crc_hash_entry_);
								link->set_sub_value(file->image_base());
							} else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_FILE_CRC_INFO_SIZE:
							if (file_crc_size_entry_) {
								link = command->AddLink((int)k, ltOffset, file_crc_size_entry_);
								link->set_sub_value(file->image_base());
							} else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_MEMORY_CRC_INFO_HASH:
							command->set_operand_value(k, intel_crc ? intel_crc->hash_entry()->operand(0).value : 0);
							command->CompileToNative();
							break;
						case FACE_CRC_INFO_SALT:
							command->set_operand_value(k, file->function_list()->crc_cryptor()->item(0)->value());
							command->CompileToNative();
							break;
						case FACE_IMAGE_BASE:
							if (command->operand(0).size != cpu_address_size()) {
								IntelOperand first = command->operand(0);
								IntelOperand second = command->operand(1);
								first.size = cpu_address_size();
								second.size = cpu_address_size();
								command->Init(static_cast<IntelCommandType>(command->type()), first, second);
							}
							command->set_operand_value(k, file->image_base());
							command->set_operand_fixup(k, NEED_FIXUP);
							command->CompileToNative();
							break;
						case FACE_FILE_BASE:
							if (command->operand(0).size != cpu_address_size()) {
								IntelOperand first = command->operand(0);
								IntelOperand second = command->operand(1);
								first.size = cpu_address_size();
								second.size = cpu_address_size();
								command->Init(static_cast<IntelCommandType>(command->type()), first, second);
							}
							command->set_operand_value(k, file->image_base());
							command->CompileToNative();
							break;
						case FACE_VAR_IS_PATCH_DETECTED:
						case FACE_VAR_IS_DEBUGGER_DETECTED:
						case FACE_VAR_LOADER_CRC_INFO:
						case FACE_VAR_LOADER_CRC_INFO_SIZE:
						case FACE_VAR_LOADER_CRC_INFO_HASH:
						case FACE_VAR_CPU_HASH:
						case FACE_VAR_CPU_COUNT:
						case FACE_VAR_SESSION_KEY:
						case FACE_VAR_DRIVER_UNLOAD:
						case FACE_VAR_CRC_IMAGE_SIZE:
						case FACE_VAR_LOADER_STATUS:
						case FACE_VAR_SERVER_DATE:
							command->set_operand_value(k, ctx.runtime_var_index[(operand.value & 0xff) >> 4] * OperandSizeToValue(cpu_address_size()));
							command->CompileToNative();
							break;
						case FACE_VAR_IS_PATCH_DETECTED_SALT:
						case FACE_VAR_IS_DEBUGGER_DETECTED_SALT:
						case FACE_VAR_LOADER_CRC_INFO_SALT:
						case FACE_VAR_LOADER_CRC_INFO_SIZE_SALT:
						case FACE_VAR_LOADER_CRC_INFO_HASH_SALT:
						case FACE_VAR_CPU_HASH_SALT:
						case FACE_VAR_CPU_COUNT_SALT:
						case FACE_VAR_DRIVER_UNLOAD_SALT:
						case FACE_VAR_CRC_IMAGE_SIZE_SALT:
						case FACE_VAR_SERVER_DATE_SALT:
							command->set_operand_value(k, ctx.runtime_var_salt[operand.value & 0xff]);
							command->CompileToNative();
							break;
						case FACE_VAR_CPU_COUNT_SALT ^ 1:
							command->set_operand_value(k, ctx.runtime_var_salt[VAR_CPU_COUNT] ^ 1);
							command->CompileToNative();
							break;
						default:
							std::map<uint32_t, IntelCommand *>::const_iterator it = loader_string_list.find(static_cast<uint32_t>(operand.value));
							if (it != loader_string_list.end()) {
								if (command->type() == cmMov) {
									operand = command->operand(0);
									operand.size = cpu_address_size();
									if (operand.type == otRegistr) {
										command->Init(cmLea, operand, IntelOperand(otMemory | otValue, cpu_address_size(), 0, 0, (cpu_address_size() == osDWord) ? NEED_FIXUP : LARGE_VALUE));
									} else {
										command->Init(cmMov, operand, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
									}
								} else {
									command->Init(cmPush, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
								}
								command->AddLink((int)k, ltOffset, it->second); 
							} else {
								throw std::runtime_error(string_format("Unknown loader string: %X", static_cast<uint32_t>(operand.value)));
							}
						}
					}
				}
			}
		}
		if (n == 0) {
			// create native blocks
			for (j = 0; j < count(); j++) {
				item(j)->include_option(roNoProgress);
			}
			CompileToNative(ctx);
			for (j = 0; j < count(); j++) {
				item(j)->exclude_option(roNoProgress);
			}
		}
	}

	IntelOperand base_operand;
	uint64_t base_address = 0;
	for (i = old_count; i < count(); i++) {
		command = item(i);
		dst_link = command->link();

		// search references to LoaderAlloc/LoaderFree
		if (command->type() == cmRet) {
			base_operand.type = otNone;
		} else if (command->type() == cmCall && command->operand(0).type == otValue && command->operand(0).value == command->next_address()) {
			base_address = command->next_address();
			IntelCommand *next_command = item(i + 1);
			IntelCommand *next_command2 = item(i + 2);
			if (next_command->type() == cmPop && next_command->operand(0).type == otRegistr &&
				next_command2->type() == cmMov && next_command2->operand(1).type == otRegistr && next_command2->operand(1).registr == next_command->operand(0).registr) {
					base_operand = next_command2->operand(0);
			} else {
				base_operand.type = otNone;
			}

			if (command->block()) {
				command->Init(cmPush, IntelOperand(otValue, cpu_address_size(), 0, command->next_address(), NEED_FIXUP));
				command->CompileToNative();
				delete command->link();
				continue;
			}
		} else if (base_operand.type != otNone) {
			if (command->type() == cmMov && command->operand(1).type == base_operand.type && command->operand(1).value == base_operand.value) {
				uint8_t registr = command->operand(0).registr;
				for (j = i + 1; j < count(); j++) {
					IntelCommand *next_command = item(j);
					if (next_command->type() == cmLea && next_command->operand(1).type == (otMemory | otRegistr | otValue) && next_command->operand(1).registr == registr) {
						address = base_address + next_command->operand(1).value;
						ICommand *to_command = GetCommandByAddress(address);
						if (to_command) {
							CommandLink *link = next_command->AddLink(1, ltOffset, to_command);
							link->set_sub_value(base_address);
							if (next_command->operand(0).registr == registr)
								break;
						}
					}
				}
			}
		}
		if (!dst_link) {
			for (k = 0; k < 2; k++) {
				IntelOperand operand = command->operand(k);
				if (operand.type == otNone)
					break;

				if (cpu_address_size() == osDWord) {
					if (!operand.fixup)
						continue;
				} else {
					if (!operand.is_large_value)
						continue;
				}

				dst_command = reinterpret_cast<IntelCommand *>(GetCommandByAddress(operand.value));
				if (dst_command && !dst_command->is_data()) {
					dst_link = command->AddLink((int)k, ltOffset, dst_command);
					break;
				}
			}
		} else {
			if (dst_link->to_address())
				dst_link->set_to_command(GetCommandByAddress(dst_link->to_address()));
		}
	}
	setup_image_entry = GetCommandByAddress(runtime->export_list()->GetAddressByType(atSetupImage));
	if (!setup_image_entry)
		return false;

	free_image_entry = GetCommandByAddress(runtime->export_list()->GetAddressByType(atFreeImage));
	if (!free_image_entry)
		return false;

	// create entry commands
	load_command_list.push_back(NULL);
	for (i = 0; i < load_command_list.size(); i++) { 
		IntelCommand *load_command = load_command_list[i];

		old_count = count();
		size_t stack = 0x20;
		AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEBP));
		if (load_command && cpu_address_size() == osQWord) {
			AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEDI));
			AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regESI));
		}
		AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEBP), IntelOperand(otRegistr, cpu_address_size(), regESP));
		AddCommand(cmAnd, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, -0x10));
		AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, stack));

		// call SetupImage
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, setup_image_entry);

		// check loader error code
		AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, TRUE));
		IntelCommand *check_loader_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
		check_loader_command->set_flags(fl_Z);
		check_loader_command->AddLink(0, ltJmpWithFlag);

		// call FreeImage
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, free_image_entry);

		command = AddCommand(cmNop);
		check_loader_command->link()->set_to_command(command);

		AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otRegistr, cpu_address_size(), regEBP));
		if (load_command && cpu_address_size() == osQWord) {
			AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regESI));
			AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEDI));
		}
		AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEBP));

		if (load_command) {
			AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size(), 0, load_command->operand(1).value));
			load_command->link()->set_to_command(item(old_count));
		} else {
			AddCommand(cmRet);
			set_entry(item(old_count));
		}
	}

	// create term commands
	if (term_entry_) {
		old_count = count();

		AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEBP));
		AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEBP), IntelOperand(otRegistr, cpu_address_size(), regESP));
		AddCommand(cmAnd, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, -0x10));

		// call FreeImage
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, free_image_entry);

		AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otRegistr, cpu_address_size(), regEBP));
		AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEBP));
		AddCommand(cmRet);

		term_entry_->link()->set_to_command(item(old_count));
	}

	for (i = 0; i < count(); i++) {
		command = item(i);
		command->CompileToNative();
	}

	// search API calls
	for (i = 0; i < count(); i++) {
		command = item(i);
		if (command->block() || command->type() != cmCall || command->operand(0).type == otValue)
			continue;

		k = 0;
		for (j = i; j > 0; j--) {
			IntelCommand *param_command = item(j - 1);

			switch (param_command->type()) {
			case cmMov: case cmLea: case cmXor: case cmMovsxd:
				if (cpu_address_size() == osQWord) {
					if (param_command->operand(0).type == otRegistr) {
						switch (param_command->operand(0).registr) {
						case regEDI:
							k = std::max<size_t>(k, 1);
							break;
						case regESI:
							k = std::max<size_t>(k, 2);
							break;
						case regEDX:
							k = std::max<size_t>(k, 3);
							break;
						case regECX:
							k = std::max<size_t>(k, 4);
							break;
						case regR8:
							k = std::max<size_t>(k, 5);
							break;
						case regR9:
							k = std::max<size_t>(k, 6);
							break;
						}
					} else if ((param_command->operand(0).type & (otMemory | otBaseRegistr)) == (otMemory | otBaseRegistr) && param_command->operand(0).base_registr == regESP) {
						switch (param_command->operand(0).value) {
						case 0x00:
							k = std::max<size_t>(k, 7);
							break;
						case 0x04:
							k = std::max<size_t>(k, 8);
							break;
						case 0x08:
							k = std::max<size_t>(k, 9);
							break;
						case 0x0c:
							k = std::max<size_t>(k, 10);
							break;
						case 0x10:
							k = std::max<size_t>(k, 11);
							break;
						case 0x14:
							k = std::max<size_t>(k, 12);
							break;
						default:
							if (param_command->operand(0).value >= 0x18)
								k = NOT_ID;
							break;
						}
					}
				} else if ((param_command->operand(0).type & (otMemory | otBaseRegistr)) == (otMemory | otBaseRegistr) && param_command->operand(0).base_registr == regESP) {
					switch (param_command->operand(0).value) {
					case 0x00:
						k = std::max<size_t>(k, 1);
						break;
					case 0x04:
						k = std::max<size_t>(k, 2);
						break;
					case 0x08:
						k = std::max<size_t>(k, 3);
						break;
					case 0x0c:
						k = std::max<size_t>(k, 4);
						break;
					case 0x10:
						k = std::max<size_t>(k, 5);
						break;
					case 0x14:
						k = std::max<size_t>(k, 6);
						break;
					case 0x18:
						k = std::max<size_t>(k, 7);
						break;
					case 0x1c:
						k = std::max<size_t>(k, 8);
						break;
					case 0x20:
						k = std::max<size_t>(k, 9);
						break;
					case 0x24:
						k = std::max<size_t>(k, 10);
						break;
					case 0x28:
						k = std::max<size_t>(k, 11);
						break;
					case 0x2c:
						k = std::max<size_t>(k, 12);
						break;
					default:
						if (param_command->operand(0).value >= 0x30)
							k = NOT_ID;
						break;
					}
				}
				break;
			case cmCall: case cmJmp: case cmJmpWithFlag: case cmRet:
				param_command = NULL;
				break;
			}
			if (!param_command || link_list()->GetLinkByToAddress(ltNone, param_command->address()))
				break;
		}
		if (k == NOT_ID)
			continue;

		command->include_option(roInternal);
		command->set_operand_value(2, k);
	}


	for (i = 0; i < link_list()->count(); i++) {
		CommandLink *link = link_list()->item(i);
		if (link->from_command()->type() == cmCall && std::find(internal_entry_list.begin(), internal_entry_list.end(), link->to_command()) != internal_entry_list.end())
			reinterpret_cast<IntelCommand*>(link->from_command())->include_option(roInternal);
		link->from_command()->PrepareLink(ctx);
	}

	return BaseIntelLoader::Prepare(ctx);
}

bool MacIntelLoader::Compile(const CompileContext &ctx)
{
	if ((ctx.options.flags & cpStripFixups) == 0) {
		// convert fixups into PIC code
		size_t i, j, k;
		std::vector<IFunction *> function_list = ctx.file->function_list()->processor_list();
		function_list.push_back(this);
		for (i = 0; i < function_list.size(); i++) {
			IntelFunction *func = reinterpret_cast<IntelFunction *>(function_list[i]);
			OperandSize cpu_address_size = func->cpu_address_size();
			for (j = 0; j < func->count(); j++) {
				IntelCommand *src_command = func->item(j);
				CommandBlock *block = src_command->block();
				if (!block || (block->type() & mtExecutable) == 0 || (func->item(block->start_index())->options() & roDataSegment))
					continue;

				size_t fixup_index = NOT_ID;
				for (k = 0; k < 3; k++) {
					IntelOperand operand = src_command->operand(k);
					if (operand.type == otNone)
						break;

					if ((operand.type & otValue) && operand.fixup) {
						fixup_index = k;
						break;
					}
				}

				if (fixup_index != NOT_ID) {
					IntelCommand *command, *ref_command;

					bool is_case = src_command->link() && src_command->link()->type() == ltCase;
					if (is_case) {
						src_command->set_operand_fixup(0, NULL);
						command = reinterpret_cast<IntelCommand *>(src_command->link()->parent_command());
						if (command->link()->to_command() == src_command) {
							if (command->type() == cmJmp && (command->operand(0).type & otMemory))
								src_command = command;
							else {
								src_command = NULL;
								for (k = func->IndexOf(command); k < func->count(); k++) {
									command = func->item(k);
									if (command->type() == cmJmp && command->operand(0).type == otValue) {
										k = func->IndexOf(command->link()->to_command());
										if (k == NOT_ID)
											break;
										k--;
									} else if (command->link() && command->link()->type() == ltJmp && command->link()->operand_index() == -1) {
										src_command = command;
										break;
									} else if (command->type() == cmRet)
										break;
								}
								if (!src_command)
									throw std::runtime_error("Runtime error at MacIntelLoader::Compile");
							}
						}
						else
							continue;
					}

					block = func->AddBlock(func->count(), true);

					IntelRegistrList registr_list;
					registr_list.push_back(regEAX);
					registr_list.push_back(regECX);
					registr_list.push_back(regEDX);
					registr_list.push_back(regEBX);
					registr_list.push_back(regEBP);
					registr_list.push_back(regESI);
					registr_list.push_back(regEDI);

					IntelOperand new_operand[3];
					for (k = 0; k < 3; k++) {
						IntelOperand operand = src_command->operand(k);
						if (operand.type == otNone)
							break;

						if (operand.type & otRegistr)
							registr_list.remove(operand.registr);
						if (operand.type & otBaseRegistr)
							registr_list.remove(operand.base_registr);
						if (operand.fixup)
							operand.fixup = NULL;
						new_operand[k] = operand;
					}

					uint8_t reg1 = registr_list.GetRandom();
					uint8_t reg2 = registr_list.GetRandom();
					IntelCommand *link_command = NULL;
					CommandLink *src_link = src_command->link();

					func->AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, reg1));
					func->AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, reg2));
					if (cpu_address_size == osQWord) {
						ref_command = func->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otMemory | otValue, cpu_address_size, 0, 0, LARGE_VALUE));
						ref_command->AddLink(1, ltOffset, ref_command);
					}
					else {
						command = func->AddCommand(cmCall, IntelOperand(otValue, cpu_address_size));
						command->AddLink(0, ltCall);
						ref_command = func->AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size, reg1));
						command->link()->set_to_command(ref_command);
					}

					command = func->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg2), IntelOperand(otValue, cpu_address_size));
					command->AddLink(1, ltOffset, ref_command);
					command = func->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otRegistr, cpu_address_size, reg2));

					if (src_command->type() != cmLea && (new_operand[fixup_index].type & otMemory)) {
						IntelOperand mov_operand = new_operand[fixup_index];
						OperandSize mov_size = mov_operand.size;
						mov_operand.size = cpu_address_size;
						command = func->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, reg2), mov_operand);
						if (src_link) {
							link_command = command;
							if (src_link->operand_index() != -1)
								func->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, reg2), IntelOperand(otRegistr, cpu_address_size, reg1));
						}
						new_operand[fixup_index] = IntelOperand(otRegistr, mov_size, reg2);
						func->AddCommand(cmMov, new_operand[fixup_index], IntelOperand(otMemory | otRegistr, mov_size, reg2));
					}

					switch (src_command->type()) {
					case cmPush:
						command = func->AddCommand(link_command ? cmMov : cmAdd, IntelOperand(otRegistr, cpu_address_size, reg1), new_operand[0]);
						break;
					case cmJmp:
						command = func->AddCommand(link_command && !is_case ? cmMov : cmAdd, IntelOperand(otRegistr, cpu_address_size, reg1), new_operand[0]);
						break;
					default:
						command = func->AddCommand(static_cast<IntelCommandType>(src_command->type()), new_operand[0], new_operand[1]);
						if (!link_command)
							func->AddCommand(cmAdd, new_operand[0], IntelOperand(otRegistr, new_operand[0].size, reg1));
						break;
					}
					if (!link_command)
						link_command = command;

					if (src_link) {
						if (src_link->operand_index() == -1)
							src_link->set_from_command(link_command);
						else {
							link_command->AddLink(1, src_link->type(), src_link->to_command());
							delete src_link;
						}
					}

					func->AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size, reg2));

					switch (src_command->type()) {
					case cmPush:
						func->AddCommand(cmXchg, IntelOperand(otMemory | otRegistr, cpu_address_size, regESP), IntelOperand(otRegistr, cpu_address_size, reg1));
						break;
					case cmJmp:
						func->AddCommand(cmXchg, IntelOperand(otMemory | otRegistr, cpu_address_size, regESP), IntelOperand(otRegistr, cpu_address_size, reg1));
						func->AddCommand(cmRet);
						break;
					default:
						func->AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size, reg1));
						break;
					}

					if (src_command->type() != cmJmp) {
						command = func->AddCommand(cmJmp, IntelOperand(otValue, func->cpu_address_size()));
						command->AddLink(0, ltJmp, func->item(func->IndexOf(src_command) + 1));
					}
					src_command->Init(cmJmp, IntelOperand(otValue, cpu_address_size, 0));
					src_command->AddLink(0, ltJmp, func->item(block->start_index()));
					src_command->CompileToNative();
					for (k = block->start_index(); k < func->count(); k++) {
						command = func->item(k);
						command->set_block(block);
						command->CompileToNative();
						block->set_end_index(k);
					}
				}
			}
		}
	}

	if (!BaseIntelLoader::Compile(ctx))
		return false;

	IntelCommand *command = init_entry_->link() ? reinterpret_cast<IntelCommand *>(init_entry_->link()->to_command()) : init_entry_;
	command->set_operand_value(0, entry()->address());
	command->CompileToNative();

	for (std::map<MacImportFunction *, IntelCommand *>::iterator it = import_function_info_.begin(); it != import_function_info_.end(); it++) {
		MacImportFunction *import_function = it->first;
		IntelCommand *command = it->second;
		import_function->set_address(command->address());
	}

	for (std::map<MacFixup *, IntelCommand *>::iterator it = relocation_info_.begin(); it != relocation_info_.end(); it++) {
		MacFixup *fixup = it->first;
		IntelCommand *command = it->second;
		fixup->set_address(command->address());
	}

	return true;
}

/**
 * ELFIntelFunctionList
 */

ELFIntelFunctionList::ELFIntelFunctionList(IArchitecture *owner)
	: IntelFunctionList(owner)
{

}

ELFIntelFunctionList::ELFIntelFunctionList(IArchitecture *owner, const ELFIntelFunctionList &src)
	: IntelFunctionList(owner, src)
{

}

ELFIntelFunctionList *ELFIntelFunctionList::Clone(IArchitecture *owner) const
{
	ELFIntelFunctionList *list = new ELFIntelFunctionList(owner, *this);
	return list;
}

IntelSDK *ELFIntelFunctionList::AddSDK(OperandSize cpu_address_size)
{
	IntelSDK *func = new ELFIntelSDK(this, cpu_address_size);
	AddObject(func);
	return func;
}

void ELFIntelFunctionList::ReadFromBuffer(Buffer &buffer, IArchitecture &file)
{
	IntelFunctionList::ReadFromBuffer(buffer, file);

	std::vector<IntelCommand*> memory_ref_list;
	size_t i, j, k;
	IntelCommand *command, *mem_command;
	size_t c = count();
	OperandSize cpu_address_size = file.cpu_address_size();
	ELFDirectory *plt_got = reinterpret_cast<ELFArchitecture &>(file).command_list()->GetCommandByType(DT_PLTGOT);
	uint64_t plt_got_address = plt_got ? plt_got->value() : 0;
	for (i = 0; i < c; i++) {
		IntelFunction *func = item(i);
		if (func->tag() != ftLoader)
			continue;

		for (j = 0; j < func->count(); j++) {
			command = func->item(j);

			if (command->type() == cmMovaps) {
				for (k = 0; k < 3; k++) {
					IntelOperand operand = command->operand(k);
					if (operand.type == otNone)
						break;

					if ((operand.type & otValue) == 0)
						continue;

					if (operand.type == (otMemory | otValue)) {
						if (cpu_address_size == osQWord && operand.is_large_value) {
							memory_ref_list.push_back(command);
						}
					} else if (operand.type == (otMemory | otRegistr | otValue) && plt_got_address) {
						if (cpu_address_size == osDWord)
							memory_ref_list.push_back(command);
					}
				}
			}
		}
	}

	if (memory_ref_list.size()) {
		for (i = 0; i < memory_ref_list.size(); i++) {
			command = memory_ref_list[i];
			IntelFunction *func = reinterpret_cast<IntelFunction *>(command->owner());

			IntelOperand operand = command->operand(1);
			uint64_t address = operand.value;
			if (operand.type & otRegistr) {
				address += plt_got_address;
				if (cpu_address_size == osDWord)
					address = static_cast<uint32_t>(address);
			}
			if (!func->GetCommandByAddress(address)) {
				file.AddressSeek(address);
				mem_command = func->Add(address);
				mem_command->ReadArray(file, OperandSizeToValue(operand.size));
				mem_command->include_option(roCreateNewBlock);
				if (operand.size == osXMMWord)
					mem_command->set_alignment(0x10);
#ifdef CHECKED
				mem_command->update_hash();
#endif
			}
			CommandLink *link = command->AddLink(1, ltOffset, address);
			if (operand.type & otRegistr)
				link->set_sub_value(plt_got_address);
		}
	}
}

/**
 * ELFIntelSDK
 */

ELFIntelSDK::ELFIntelSDK(IFunctionList *parent, OperandSize cpu_address_size)
	: IntelSDK(parent, cpu_address_size)
{

}

/**
 * ELFIntelLoader
 */

ELFIntelLoader::ELFIntelLoader(IntelFunctionList *owner, OperandSize cpu_address_size)
	: BaseIntelLoader(owner, cpu_address_size), import_entry_(NULL), import_size_(0), file_crc_entry_(NULL),
	file_crc_size_(0), file_crc_size_entry_(NULL), loader_crc_entry_(NULL), loader_crc_size_(0), loader_crc_size_entry_(NULL),
	loader_crc_hash_entry_(NULL), term_entry_(NULL), preinit_entry_(NULL), preinit_size_(0), init_entry_(NULL), tls_entry_(NULL),
	relro_entry_(NULL)
{
	//set_compilation_type(ctMutation);
}

uint32_t ELFIntelLoader::GetPackedSize(ELFArchitecture *file) const
{
	size_t i;
	PackerInfo packer_info;
	ELFSegment *segment;
	std::vector<PackerInfo> packer_info_list;
	uint32_t physical_size;

	for (i = 0; i < file->segment_list()->count(); i++) {
		segment = file->segment_list()->item(i);
		if (segment->type() != PT_LOAD || segment->excluded_from_packing())
			continue;

		bool can_be_packed = true;
		if ((segment->memory_type() & (mtWritable | mtShared)) == (mtWritable | mtShared)) {
			can_be_packed = false;
		}

		if (!can_be_packed)
			continue;

		if (segment->physical_size()) {
			packer_info = PackerInfo(segment, segment->address(), static_cast<size_t>(segment->physical_size()));

			if (segment == file->header_segment()) {
				ELFSegment *interp = file->segment_list()->GetSectionByType(PT_INTERP);
				size_t delta = interp ? static_cast<uint32_t>(interp->address() + interp->size() - segment->address()) : file->max_header_size();
				packer_info.address += delta;
				if (packer_info.size > delta) {
					packer_info.size -= delta;
				}
				else {
					packer_info.size = 0;
				}
			}

			if (!packer_info.size)
				continue;

			packer_info_list.push_back(packer_info);
		}
	}

	uint32_t physical_offset = 0;
	for (i = 0; i < file->segment_list()->count(); i++) {
		segment = file->segment_list()->item(i);
		if (segment->type() != PT_LOAD)
			continue;

		std::vector<PackerInfo>::iterator it = std::find(packer_info_list.begin(), packer_info_list.end(), segment);
		if (it != packer_info_list.end()) {
			physical_size = static_cast<uint32_t>(it->address - segment->address());
			physical_offset = (uint32_t)AlignValue(physical_offset + physical_size, file->file_alignment());
		}
		else {
			physical_size = segment->physical_size();
			physical_offset += physical_size;
		}
	}
	return physical_offset;
}

bool ELFIntelLoader::Prepare(const CompileContext &ctx)
{
	ELFArchitecture *file, *runtime;
	size_t i, j, k, index, old_count, start_index;
	IntelCommand *command, *src_command, *dst_command, *setup_image_entry, *free_image_entry;
	CommandLink *link, *src_link, *dst_link;
	uint64_t loader_data_address;
	IntelFunctionList *runtime_function_list;
	IntelFunction *func;
	IntelCRCTable *intel_crc;
	ELFImport *import;
	ELFImportFunction *import_function;
	std::map<uint64_t, ELFImportFunction *> runtime_info_list;
	std::map<ELFImportFunction *, IntelCommand *> import_function_info;
	std::map<ELFRelocation *, IntelCommand *> iat_info;
	ELFRelocation *relocation;
	ELFSegment *segment;
	std::map<ELFRelocation *, IntelCommand *> relocation_info;

	file = reinterpret_cast<ELFArchitecture *>(ctx.file);
	runtime = reinterpret_cast<ELFArchitecture *>(ctx.runtime);
	intel_crc = reinterpret_cast<IntelFunctionList *>(file->function_list())->crc_table();
	IntelLoaderData *loader_data = reinterpret_cast<IntelFunctionList*>(file->function_list())->loader_data();
	loader_data_address = (loader_data) ? loader_data->entry()->address() : runtime->export_list()->GetAddressByType(atLoaderData);
	if (!loader_data_address)
		return false;

	// create AV signature buffer
	AddAVBuffer(ctx);
	start_index = count();

	ICommand *entry_point_command = NULL;
	if (file->entry_point()) {
		IFunction *entry_point_func = ctx.file->function_list()->GetFunctionByAddress(file->entry_point());
		if (entry_point_func)
			entry_point_command = entry_point_func->entry();
	}

	// add loader import
	std::map<uint64_t, ELFImportFunction *> import_map;
	ELFImportList &new_import_list = *file->import_list();
	runtime_function_list = reinterpret_cast<IntelFunctionList *>(runtime->function_list());
	IntelCommandType value_command_type = (cpu_address_size() == osDWord) ? cmDD : cmDQ;
	index = count();
	std::map<ELFRelocation *, ELFImportFunction *> relocation_map;
	ELFDirectory *plt_got = runtime->command_list()->GetCommandByType(DT_PLTGOT);
	uint64_t plt_got_address = plt_got ? plt_got->value() : 0;
	for (i = 0; i < runtime_function_list->count(); i++) {
		func = runtime_function_list->item(i);
		if (func->tag() != ftLoader)
			continue;

		for (j = 0; j < func->count(); j++) {
			command = func->item(j);
			import_function = NULL;
			switch (command->type()) {
			case cmCall:
			case cmJmp:
			case cmMov:
				k = (command->type() == cmMov) ? 1 : 0;
				if (command->operand(k).type == (otMemory | otValue))
					import_function = runtime->import_list()->GetFunctionByAddress(command->operand(k).value);
				else if (command->type() != cmMov && command->operand(k).type == (otMemory | otRegistr | otValue) && command->operand(k).registr == regEBX && plt_got_address)
					import_function = runtime->import_list()->GetFunctionByAddress(plt_got_address + command->operand(k).value);
				break;
			}
			if (!import_function)
				continue;

			std::map<uint64_t, ELFImportFunction *>::const_iterator it = import_map.find(import_function->address());
			ELFImportFunction *new_import_function = (it != import_map.end()) ? it->second : NULL;
			if (!new_import_function) {
				ELFImport *src_import = reinterpret_cast<ELFImport *>(import_function->owner());
				import = new_import_list.GetImportByName(src_import->name());
				if (!import) {
					import = new ELFImport(&new_import_list, src_import->name());
					new_import_list.AddObject(import);
				}

				ELFSymbol *symbol = import_function->symbol()->Clone(file->dynsymbol_list());
				symbol->set_version(0);
				file->dynsymbol_list()->AddObject(symbol);

				ELFRelocation *src_relocation = runtime->relocation_list()->GetRelocationByAddress(import_function->address());
				relocation = src_relocation->Clone(file->relocation_list());
				if (relocation->type() == R_386_JMP_SLOT)
					relocation->set_type(R_386_GLOB_DAT);
				relocation->set_address(0);
				relocation->set_symbol(symbol);
				file->relocation_list()->AddObject(relocation);

				new_import_function = import->Add(0, import_function->name(), symbol);
				import_map[import_function->address()] = new_import_function;
				relocation_map[relocation] = new_import_function;
			}
			runtime_info_list[command->address()] = new_import_function;
		}
	}

	// create IAT
	for (i = 0; i < new_import_list.count(); i++) {
		import = new_import_list.item(i);
		for (j = 0; j < import->count(); j++) {
			import_function = import->item(j);
			if (!import_function)
				continue;

			relocation = file->relocation_list()->GetRelocationByAddress(import_function->address());
			relocation_map[relocation] = import_function;
		}
	}
	AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size()));
	AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size()));
	AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size()));
	for (i = 0; i < file->relocation_list()->count(); i++) {
		relocation = file->relocation_list()->item(i);
		if (relocation->type() != R_386_JMP_SLOT)
			continue;

		command = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltOffset);
		command->set_operand_relocation(0, relocation);
		command->CompileToNative();

		import_function = relocation_map[relocation];
		if (import_function)
			import_function_info[import_function] = command;
	}
	import_entry_ = item(start_index);
	import_entry_->include_option(roCreateNewBlock);
	import_entry_->set_alignment(OperandSizeToValue(cpu_address_size()));
	import_size_ = static_cast<uint32_t>((count() - start_index) * OperandSizeToValue(cpu_address_size()));
	for (i = 0; i < file->relocation_list()->count(); i++) {
		relocation = file->relocation_list()->item(i);
		if (relocation->type() == R_386_JMP_SLOT)
			continue;

		if (relocation->address()) {
			if ((ctx.options.flags & cpPack) == 0)
				continue;
			if (cpu_address_size() == osDWord) {
				if (relocation->type() == R_386_IRELATIVE) {
					relocation_info[relocation] = NULL;
					continue;
				}
			}
			else {
				if (relocation->type() == R_X86_64_IRELATIVE) {
					relocation_info[relocation] = NULL;
					continue;
				}
			}
			segment = file->segment_list()->GetSectionByAddress(relocation->address());
			if (!segment || segment->excluded_from_packing() || segment->address() + segment->physical_size() <= relocation->address())
				continue;
		}

		command = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, (relocation->type() == R_386_PC32) ? 0 : relocation->value()));
		command->set_operand_relocation(0, relocation);
		command->CompileToNative();

		import_function = relocation_map[relocation];
		if (import_function)
			import_function_info[import_function] = command;

		if (relocation->address()) {
			if (relocation->type() == R_386_PC32)
				relocation_info[relocation] = command;
			else {
				iat_info[relocation] = command;
				if (relocation->type() == R_386_COPY && relocation->symbol()->size() > command->dump_size()) {
					Data data;
					data.resize(AlignValue(relocation->symbol()->size(), command->dump_size()) - command->dump_size());
					AddCommand(data);
				}
			}
		}
	}

	// create jump table
	IntelCommand *jmp_table_entry = AddCommand(cmPush, IntelOperand(otMemory | otValue, cpu_address_size(), 0, 0, (cpu_address_size() == osDWord) ? NEED_FIXUP : LARGE_VALUE));
	jmp_table_entry->AddLink(0, ltOffset, item(start_index + 1));
	command = AddCommand(cmJmp, IntelOperand(otMemory | otValue, cpu_address_size(), 0, 0, (cpu_address_size() == osDWord) ? NEED_FIXUP : LARGE_VALUE));
	command->AddLink(0, ltOffset, item(start_index + 2));
	k = 1;
	index = 0;
	for (i = 0; i < file->relocation_list()->count(); i++) {
		relocation = file->relocation_list()->item(i);
		if (relocation->type() != R_386_JMP_SLOT)
			continue;

		IntelCommand *iat_command = item(start_index + 3 + index);
		if (relocation->address()) {
			CommandBlock *block = AddBlock(count(), true);

			command = AddCommand(cmJmp, IntelOperand(otMemory | otValue, cpu_address_size(), 0, 0, (cpu_address_size() == osDWord) ? NEED_FIXUP : LARGE_VALUE));
			command->AddLink(0, ltOffset, iat_command);
			command->CompileToNative();
			command->set_block(block);

			uint64_t address = ctx.manager->Alloc(command->dump_size(), mtReadable);
			block->set_address(address);

			file->AddressSeek(relocation->address());
			if (cpu_address_size() == osDWord)
				file->WriteDWord(static_cast<uint32_t>(address));
			else
				file->WriteQWord(address);

			file->fixup_list()->Add(relocation->address(), cpu_address_size());
		}

		size_t offset = index * k;
		if (cpu_address_size() == osDWord)
			offset *= sizeof(Elf32_Rel);
		command = AddCommand(cmPush, IntelOperand(otValue, cpu_address_size(), 0, offset));
		iat_command->link()->set_to_command(command);

		command = AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltJmp, jmp_table_entry);

		index++;
	}

	ELFDirectory *dir = file->command_list()->GetCommandByType(DT_PREINIT_ARRAY);
	if (dir) {
		// create preinit module function list
		uint64_t address = dir->value();
		if (file->AddressSeek(address)) {
			dir = file->command_list()->GetCommandByType(DT_PREINIT_ARRAYSZ);
			if (dir) {
				index = count();
				AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
				for (j = 0; j < static_cast<size_t>(dir->value()); j += OperandSizeToValue(cpu_address_size())) {
					command = Add(address + j);
					command->ReadValueFromFile(*file, cpu_address_size());
				}
				preinit_entry_ = item(index);
				preinit_entry_->include_option(roCreateNewBlock);
				preinit_entry_->set_alignment(OperandSizeToValue(cpu_address_size()));
				preinit_entry_->AddLink(0, ltGateOffset);
				preinit_size_ = static_cast<uint32_t>((count() - index) * OperandSizeToValue(cpu_address_size()));
			}
		}
	}
	term_entry_ = AddCommand(value_command_type, IntelOperand(otValue, cpu_address_size()));
	term_entry_->include_option(roCreateNewBlock);
	term_entry_->AddLink(0, ltGateOffset);

	if (file->file_type() == ET_DYN) {
		init_entry_ = AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size()));
		init_entry_->AddLink(0, ltGateOffset);
	}

	// create watermarks
	AddWatermark(ctx.options.watermark, 2);

	// create segment list for setting WRITABLE flag
	std::vector<ELFSegment *> writable_segment_list;
	segment = file->segment_list()->GetSectionByAddress(loader_data_address);
	if (segment)
		writable_segment_list.push_back(segment);
	for (i = 0; i < file->relocation_list()->count(); i++) {
		ELFRelocation *relocation = file->relocation_list()->item(i);
		if (!relocation->address())
			continue;

		segment = file->segment_list()->GetSectionByAddress(relocation->address());
		if (!segment)
			continue;

		if (std::find(writable_segment_list.begin(), writable_segment_list.end(), segment) == writable_segment_list.end())
			writable_segment_list.push_back(segment);
	}

	std::vector<PackerInfo> packer_info_list;
	ELFFixupList loader_fixup_list;
	bool pack_resources = false;
	IntelCommand *packer_props = NULL;
	if (ctx.options.flags & cpPack) {
		ELFSegment *tls_segment = file->segment_list()->GetSectionByType(PT_TLS);
		if (tls_segment && tls_segment->physical_size()) {
			segment = file->segment_list()->GetSectionByAddress(tls_segment->address());
			if (segment && !segment->excluded_from_packing() && file->AddressSeek(tls_segment->address())) {
				Data data;
				for (i = 0; i < tls_segment->physical_size(); i++) {
					data.PushByte(file->ReadByte());
				}
				tls_entry_ = AddCommand(data);
				tls_entry_->include_option(roCreateNewBlock);
				tls_entry_->set_alignment(static_cast<uint32_t>(tls_segment->alignment()));
			}
		}

		PackerInfo packer_info;
		for (i = 0; i < file->segment_list()->count(); i++) {
			segment = file->segment_list()->item(i);
			if (segment->type() != PT_LOAD || segment->excluded_from_packing())
				continue;

			bool can_be_packed = true;
			if ((segment->memory_type() & (mtWritable | mtShared)) == (mtWritable | mtShared)) {
				can_be_packed = false;
			}

			if (!can_be_packed) {
				//file->Notify(mtWarning, NULL, string_format(language[lsSegmentCanNotBePacked].c_str(), section->name().c_str()));
				continue;
			}

			if (segment->physical_size()) {
				packer_info = PackerInfo(segment, segment->address(), static_cast<size_t>(segment->physical_size()));

				if (segment == file->header_segment()) {
					ELFSegment *interp = file->segment_list()->GetSectionByType(PT_INTERP);
					size_t delta = interp ? static_cast<uint32_t>(interp->address() + interp->size() - segment->address()) : file->max_header_size();
					packer_info.address += delta;
					if (packer_info.size > delta) {
						packer_info.size -= delta;
					} else {
						packer_info.size = 0;
					}
				}

				if (!packer_info.size)
					continue;

				packer_info_list.push_back(packer_info);

				// need add packed section into WRITABLE section list
				if (std::find(writable_segment_list.begin(), writable_segment_list.end(), segment) == writable_segment_list.end())
					writable_segment_list.push_back(segment);
			}
		}

		if ((ctx.options.flags & cpStripFixups) == 0) {
			for (i = 0; i < file->fixup_list()->count(); i++) {
				ELFFixup *fixup = file->fixup_list()->item(i);
				if (fixup->is_deleted())
					continue;

				segment = file->segment_list()->GetSectionByAddress(fixup->address());
				if (!segment || std::find(packer_info_list.begin(), packer_info_list.end(), segment) == packer_info_list.end())
					continue;

				loader_fixup_list.AddObject(fixup->Clone(&loader_fixup_list));
				fixup->set_deleted(true);

				// need add section into WRITABLE section list
				if (std::find(writable_segment_list.begin(), writable_segment_list.end(), segment) == writable_segment_list.end())
					writable_segment_list.push_back(segment);
			}
		}

		// packing sections
		j = 0;
		for (i = 0; i < packer_info_list.size(); i++) {
			j += packer_info_list[i].size;
		}
		file->StartProgress(string_format("%s...", language[lsPacking].c_str()), j);

		Data data;
		Packer packer;

		if (!packer.WriteProps(&data))
			throw std::runtime_error("Packer error");
		packer_props = AddCommand(data);
		packer_props->include_option(roCreateNewBlock);

		for (i = 0; i < packer_info_list.size(); i++) {
			packer_info = packer_info_list[i];
			if (!file->AddressSeek(packer_info.address))
				return false;

			if (!packer.Code(file, packer_info.size, &data))
				throw std::runtime_error("Packer error");

			command = AddCommand(data);
			command->include_option(roCreateNewBlock);
			packer_info_list[i].data = command;
		}

		// remove packed sections from file
		uint32_t physical_offset = 0;
		for (i = 0; i < file->segment_list()->count(); i++) {
			segment = file->segment_list()->item(i);
			if (segment->type() != PT_LOAD)
				continue;

			uint32_t physical_size = segment->physical_size();
			bool is_packed = false;
			std::vector<PackerInfo>::iterator it = std::find(packer_info_list.begin(), packer_info_list.end(), segment);
			if (it != packer_info_list.end()) {
				physical_size = static_cast<uint32_t>(it->address - segment->address());
				is_packed = true;
			}
			if (segment->physical_offset() != physical_offset) {
				size_t delta = static_cast<size_t>(physical_offset - segment->physical_offset());
				for (j = 0; j < file->section_list()->count(); j++) {
					ELFSection *section = file->section_list()->item(j);
					if (section->parent() == segment && section->physical_offset())
						section->set_physical_offset(static_cast<uint32_t>(section->physical_offset() + delta));
				}
			}

			if (physical_size > 0 && segment->physical_offset() != physical_offset) {
				uint8_t *buff = new uint8_t[physical_size];
				file->Seek(segment->physical_offset());
				file->Read(buff, physical_size);
				file->Seek(physical_offset);
				file->Write(buff, physical_size);
				delete [] buff;
			}

			if (segment->physical_offset() != physical_offset) {
				uint64_t delta = (static_cast<uint64_t>(physical_offset) & (segment->alignment() - 1)) - (segment->address() & (segment->alignment() - 1));
				segment->Rebase(delta);
				segment->set_size((static_cast<int64_t>(delta) > 0 && segment->size() < delta) ? 0 : segment->size() - delta);
			}
			segment->set_physical_offset(physical_offset);
			segment->set_physical_size(physical_size);

			if (is_packed) {
				j = physical_offset + physical_size;
				file->Seek(j);
				physical_offset = (uint32_t)AlignValue(j, file->file_alignment());
				for (k = j; k < physical_offset; k++) {
					file->WriteByte(0);
				}
			} else {
				physical_offset += physical_size;
			}
		}
		file->Resize(physical_offset);
	}

	// create packer info for loader
	std::vector<LoaderInfo> loader_info_list;
	index = count();
	if (packer_props) {
		command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
		link = command->AddLink(0, ltOffset, packer_props);
		link->set_sub_value(file->image_base());
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, packer_props->dump_size()));

		for (i = 0; i < packer_info_list.size(); i++) {
			command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
			link = command->AddLink(0, ltOffset, packer_info_list[i].data);
			link->set_sub_value(file->image_base());

			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, packer_info_list[i].address - file->image_base()));
		}
	}
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create file CRC info for loader
	index = count();
	if ((ctx.options.flags | ctx.options.sdk_flags) & cpMemoryProtection) {
		AddCommand(cmDD, IntelOperand(otValue, osDWord));
		for (i = 0; i < 4; i++) {
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
		}
	}
	file_crc_entry_ = (count() == index) ? NULL : item(index);
	if (file_crc_entry_)
		file_crc_entry_->include_option(roCreateNewBlock);
	file_crc_size_ = static_cast<uint32_t>((count() - index) * OperandSizeToValue(osDWord));
	loader_info_list.push_back(LoaderInfo(file_crc_entry_, file_crc_size_));

	file_crc_size_entry_ = file_crc_entry_ ? AddCommand(cmDD, IntelOperand(otValue, osDWord)) : NULL;
	if (file_crc_size_entry_)
		file_crc_size_entry_->include_option(roCreateNewBlock);

	// create header and loader CRC info for loader
	index = count();
	if (((ctx.options.flags | ctx.options.sdk_flags) & cpMemoryProtection) || (ctx.options.flags & cpLoaderCRC)) {
		// calc CRC blocks count
		k = 30;
		if ((ctx.options.flags & cpStripFixups) == 0) {
			std::vector<IFunction *> function_list = ctx.file->function_list()->processor_list();
			function_list.push_back(this);
			for (i = 0; i < runtime_function_list->count(); i++) {
				func = runtime_function_list->item(i);
				if (func->tag() != ftLoader)
					continue;

				if (func->compilation_type() == ctMutation)
					function_list.push_back(func);
			}

			for (i = 0; i < function_list.size(); i++) {
				func = reinterpret_cast<IntelFunction *>(function_list[i]);
				for (j = 0; j < func->count(); j++) {
					command = func->item(j);
					for (size_t c = 0; c < 3; c++) {
						IntelOperand operand = command->operand(c);
						if (operand.type == otNone)
							break;
						if (operand.fixup)
							k++;
					}
				}
			}
		}
		for (i = 0; i < k; i++) {
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
		}
	}
	loader_crc_entry_ = (count() == index) ? NULL : item(index);
	if (loader_crc_entry_)
		loader_crc_entry_->include_option(roCreateNewBlock);
	loader_crc_size_ = static_cast<uint32_t>((count() - index) * OperandSizeToValue(osDWord));
	loader_info_list.push_back(LoaderInfo(loader_crc_entry_, loader_crc_size_));

	loader_crc_size_entry_ = loader_crc_entry_ ? AddCommand(cmDD, IntelOperand(otValue, osDWord)) : NULL;
	if (loader_crc_size_entry_)
		loader_crc_size_entry_->include_option(roCreateNewBlock);
	loader_crc_hash_entry_ = loader_crc_entry_ ? AddCommand(cmDD, IntelOperand(otValue, osDWord)) : NULL;
	if (loader_crc_hash_entry_)
		loader_crc_hash_entry_->include_option(roCreateNewBlock);

	// create section info for loader
	index = count();
	for (i = 0; i < writable_segment_list.size(); i++) {
		segment = writable_segment_list[i];
		if (segment->memory_type() & mtWritable)
			continue;

		size_t page_offset = static_cast<size_t>(segment->address() & (ELF_PAGE_SIZE - 1));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, segment->address() - page_offset - file->image_base()));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, segment->size() + page_offset));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, segment->prot()));
	}
	// add runtime's WRITABLE sections
	for (i = 0; i < runtime->segment_list()->count(); i++) {
		segment = runtime->segment_list()->item(i);
		if ((segment->memory_type() & mtWritable) == 0)
			continue;

		size_t page_offset = static_cast<size_t>(segment->address() & (ELF_PAGE_SIZE - 1));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, segment->address() - page_offset - file->image_base()));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, segment->size() + page_offset));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, segment->prot()));
	}
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create fixup info for loader
	if (loader_fixup_list.count() > 0) {
		Data data;
		loader_fixup_list.WriteToData(data, file->image_base());
		command = AddCommand(data);
	} else {
		command = NULL;
	}
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (command) ? command->dump_size() : 0));

	// create relocation info for loader
	index = count();
	for (std::map<ELFRelocation *, IntelCommand *>::const_iterator it = relocation_info.begin(); it != relocation_info.end(); it++) {
		relocation = it->first;
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, relocation->address() - file->image_base()));
		switch (relocation->type()) {
		case R_386_PC32:
			command = AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, 0));
			link = command->AddLink(0, ltOffset, it->second);
			link->set_sub_value(file->image_base());
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, 1));
			relocation->set_type(R_386_32);
			break;
		default:
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, relocation->addend() - file->image_base()));
			AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, 0));
			delete relocation;
			break;
		}
	}
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));
	
	// create IAT info for loader
	index = count();
	for (std::map<ELFRelocation *, IntelCommand *>::iterator it = iat_info.begin(); it != iat_info.end(); it++) {
		relocation = it->first;

		command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
		link = command->AddLink(0, ltOffset, it->second);
		link->set_sub_value(file->image_base());

		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, relocation->address() - file->image_base()));
		AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, (relocation->type() == R_386_COPY) ? relocation->symbol()->size() : OperandSizeToValue(cpu_address_size())));
	}
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create import info for loader
	index = count();
	/*
	if (ctx.options.flags & cpImportProtection) {
		for (i = 0, import_index = 0; i < orig_dll_count; i++) {
			import = new_import_list.item(i);
			if (import->count() == 0)
				continue;

			// DLL name
			command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
			link = command->AddLink(0, ltOffset, import_info_list[i].loader_name);
			link->set_sub_value(file->image_base());

			for (j = 0; j < import->count(); j++, import_index++) {
				import_function = import->item(j);
				if (import_function->options() & ioNative)
					continue;

				if (ctx.options.flags & cpResourceProtection) {
					// internal API
					if ((import_function->options() & ioFromRuntime) == 0 && import_function->type() >= atLoadResource && import_function->type() <= atEnumResourceTypesW)
						continue;
				}

				iat_command = intel_import->GetIATCommand(import_function);

				// API name
				if (import_function->is_ordinal()) {
					AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, IMAGE_ORDINAL_FLAG32 | import_function->ordinal()));
				} else {
					command = AddCommand(cmDD, IntelOperand(otValue, osDWord));
					link = command->AddLink(0, ltOffset, import_function_info_list[import_index].loader_name);
					link->set_sub_value(file->image_base());
				}

				// IAT
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, ((iat_command) ? iat_command->address() : import_function->address()) - file->image_base()));

				// decrypt value
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, (iat_command) ? iat_command->operand(1).value : 0));
			}

			// end of DLL
			AddCommand(cmDD, IntelOperand(otValue, osDWord));
		}
	}
	*/
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create internal import info for loader
	index = count();
	/*
	if (ctx.options.flags & cpResourceProtection) {
		for (i = 0; i < orig_dll_count; i++) {
			import = new_import_list.item(i);
			for (j = 0; j < import->count(); j++) {
				import_function = import->item(j);

				if ((import_function->options() & ioFromRuntime) || import_function->type() < atLoadResource || import_function->type() > atEnumResourceTypesW)
					continue;

				iat_command = (intel_import) ? intel_import->GetIATCommand(import_function) : NULL;

				address = runtime->export_list()->GetAddressByType(import_function->type());
				func = reinterpret_cast<IntelFunction*>(file->function_list()->GetFunctionByAddress(address));
				if (func && func->entry())
					address = func->entry()->address();

				// address
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, address - file->image_base()));
				// IAT
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, ((iat_command) ? iat_command->address() : import_function->address()) - file->image_base()));
				// decrypt value
				AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, (iat_command) ? iat_command->operand(1).value : 0));
			}
		}
	}
	*/
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// create memory CRC info for loader
	if (intel_crc) {
		command = intel_crc->table_entry();
		i = static_cast<size_t>(intel_crc->size_entry()->operand(0).value);
	} else {
		command = NULL;
		i = 0;
	}
	loader_info_list.push_back(LoaderInfo(command, i));

	// create delay import info for loader
	index = count();
	command = (count() == index) ? NULL : item(index);
	if (command)
		command->include_option(roCreateNewBlock);
	loader_info_list.push_back(LoaderInfo(command, (count() - index) * OperandSizeToValue(osDWord)));

	// process PT_GNU_RELRO segments
	for (i = file->segment_list()->count(); i > 0; i--) {
		ELFSegment *read_only_segment = file->segment_list()->item(i - 1);
		if (read_only_segment->type() != PT_GNU_RELRO)
			continue;

		for (j = 0; j < writable_segment_list.size(); j++) {
			segment = writable_segment_list[j];
			if (std::max<uint64_t>(segment->address(), read_only_segment->address()) < std::min<uint64_t>(segment->address() + segment->size(), read_only_segment->address() + read_only_segment->size())) {
				if (!relro_entry_) {
					index = count();
					size_t page_offset = static_cast<size_t>(read_only_segment->address() & (ELF_PAGE_SIZE - 1));
					AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, read_only_segment->address() - page_offset - file->image_base()));
					AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, read_only_segment->size() + page_offset));
					AddCommand(cmDD, IntelOperand(otValue, osDWord, 0, PROT_READ));
					relro_entry_ = item(index);
					relro_entry_->include_option(roCreateNewBlock);
				}
				delete read_only_segment;
				break;
			}
		}
	}

	// create strings for loader
	uint32_t string_key = rand32();
	std::map<uint32_t, IntelCommand *> loader_string_list;
	loader_string_list[FACE_FILE_CORRUPTED] = AddCommand(EncryptString((ctx.options.flags & cpMemoryProtection) ? ctx.options.messages[MESSAGE_FILE_CORRUPTED].c_str() : std::string().c_str(), string_key));
	loader_string_list[FACE_DEBUGGER_FOUND] = AddCommand(EncryptString(ctx.options.messages[MESSAGE_DEBUGGER_FOUND].c_str(), string_key));
	loader_string_list[FACE_VIRTUAL_MACHINE_FOUND] = AddCommand(EncryptString(ctx.options.messages[MESSAGE_VIRTUAL_MACHINE_FOUND].c_str(), string_key));
	loader_string_list[FACE_PROC_NOT_FOUND] = AddCommand(EncryptString("The procedure entry point %c could not be located in the module %c", string_key));
	loader_string_list[FACE_ORDINAL_NOT_FOUND] = AddCommand(EncryptString("The ordinal %d could not be located in the module %c", string_key));
	loader_string_list[FACE_INITIALIZATION_ERROR] = AddCommand(EncryptString("Initialization error %d", string_key));
	VMProtectBeginVirtualization("Loader Strings");
	loader_string_list[FACE_UNREGISTERED_VERSION] = AddCommand(EncryptString(
#ifdef DEMO
		true
#else
		(ctx.options.flags & cpUnregisteredVersion) 
#endif
		? VMProtectDecryptStringA("This application is protected with unregistered version of VMProtect.") : "", string_key));
	VMProtectEnd();
	loader_string_list[FACE_MACOSX_FORMAT_VALUE] = AddCommand("%s\n");
	loader_string_list[FACE_GNU_PTRACE] = AddCommand("ptrace");
	for (std::map<uint32_t, IntelCommand *>::const_iterator it = loader_string_list.begin(); it != loader_string_list.end(); it++) {
		it->second->include_option(roCreateNewBlock);
	}

	// append loader
	old_count = count();
	std::vector<IntelCommand*> internal_entry_list;
	for (size_t n = 0; n < 2; n++) {
		for (i = 0; i < runtime_function_list->count(); i++) {
			func = runtime_function_list->item(i);
			if (func->tag() != ftLoader)
				continue;

			if (func->compilation_type() == ctMutation) {
				if (n != 0)
					continue;
			} else {
				if (n != 1)
					continue;
			}

			func->Init(ctx);

			bool is_internal = (func->compilation_type() != ctMutation && func->entry_type() == etNone);
			for (j = 0; j < func->link_list()->count(); j++) {
				src_link = func->link_list()->item(j);
				if (src_link->type() != ltMemSEHBlock)
					continue;

				src_link->from_command()->set_address(0);
			}

			for (j = 0; j < func->count(); j++) {
				src_command = func->item(j);

				dst_command = src_command->Clone(this);
				AddObject(dst_command);
				if (is_internal) {
					if (j == 0)
						internal_entry_list.push_back(dst_command);
					if (dst_command->type() == cmRet)
						dst_command->include_option(roInternal);
				}

				src_link = src_command->link();
				if (src_link) {
					dst_link = src_link->Clone(link_list());
					dst_link->set_from_command(dst_command);
					link_list()->AddObject(dst_link);
				
					if (src_link->parent_command())
						dst_link->set_parent_command(GetCommandByAddress(src_link->parent_command()->address()));
				}

				std::map<uint64_t, ELFImportFunction *>::const_iterator it_import = runtime_info_list.find(dst_command->address());
				if (it_import != runtime_info_list.end()) {
					if (dst_command->type() == cmCall) {
						IntelOperand operand = dst_command->operand(0);
						dst_command->Init(cmMov, IntelOperand(otRegistr, operand.size, regEAX), operand);

						command = new IntelCommand(this, cpu_address_size(), cmCall, IntelOperand(otRegistr, operand.size, regEAX));
						if (dst_command->link())
							dst_command->link()->set_from_command(command);
						AddObject(command);
					}
					k = (dst_command->operand(1).type != otNone) ? 1 : 0;
					dst_link = dst_command->AddLink((int)k, ltOffset);
					if (dst_command->operand(k).type & otRegistr)
						dst_link->set_sub_value(plt_got_address);
					std::map<ELFImportFunction *, IntelCommand *>::iterator it = import_function_info.find(it_import->second);
					if (it != import_function_info.end())
						dst_link->set_to_command(it->second);
				}

				if (dst_command->type() == cmCall && (dst_command->options() & roFar) == 0 && dst_command->operand(0).type == otValue) {
					uint64_t next_address = dst_command->address() + dst_command->original_dump_size();
					CompilerFunction *compiler_function = runtime->compiler_function_list()->GetFunctionByAddress(next_address);
					if (compiler_function && compiler_function->type() == cfBaseRegistr) {
						delete dst_command->link();
						IntelOperand operand;
						operand.decode(compiler_function->value(0));
						dst_command->Init(cmLea, operand, IntelOperand(otMemory | otValue, operand.size, 0, next_address, (cpu_address_size() == osDWord) ? NEED_FIXUP : LARGE_VALUE));
					}
				}
				if (!dst_command->is_data() && (dst_command->options() & roBreaked)) {
					// need add JMP after breaked commands
					IntelCommand *jmp_command = new IntelCommand(this, cpu_address_size(), cmJmp, IntelOperand(otValue, cpu_address_size(), 0, dst_command->next_address()));
					jmp_command->AddLink(0, ltJmp, dst_command->next_address());
					jmp_command->set_address_range(dst_command->address_range());
					jmp_command->CompileToNative();
					AddObject(jmp_command);
				}

				command = dst_command;
				for (k = 0; k < 3; k++) {
					IntelOperand operand = command->operand(k);
					if (operand.type == otNone)
						break;

					if ((operand.type & otValue) == 0)
						continue;

					if ((operand.value & 0xFFFF0000) == 0xFACE0000) {
						switch (static_cast<uint32_t>(operand.value)) {
						case FACE_LOADER_OPTIONS:
							operand.value = 0;
							if (ctx.options.flags & cpMemoryProtection)
								operand.value |= LOADER_OPTION_CHECK_PATCH;
							if (ctx.options.flags & cpCheckDebugger)
								operand.value |= LOADER_OPTION_CHECK_DEBUGGER;
							if (ctx.options.flags & cpCheckVirtualMachine)
								operand.value |= LOADER_OPTION_CHECK_VIRTUAL_MACHINE;
							command->set_operand_value(k, operand.value);
							command->CompileToNative();
							break;
						case FACE_LOADER_DATA:
							command->set_operand_value(k, loader_data_address - file->image_base());
							command->CompileToNative();
							break;
						case FACE_RUNTIME_ENTRY:
							if (runtime->segment_list()->count()) {
								uint64_t runtime_init_address = runtime->export_list()->GetAddressByType(atRuntimeInit);
								if (!runtime_init_address)
									return false;
								command->set_operand_value(k, runtime_init_address - file->image_base());
							} else {
								command->set_operand_value(k, 0);
							}
							command->CompileToNative();
							break;
						case FACE_STRING_DECRYPT_KEY:
							command->set_operand_value(k, string_key);
							command->CompileToNative();
							break;
						case FACE_PACKER_INFO:
						case FACE_FILE_CRC_INFO:
						case FACE_LOADER_CRC_INFO:
						case FACE_SECTION_INFO:
						case FACE_FIXUP_INFO:
						case FACE_RELOCATION_INFO:
						case FACE_IAT_INFO:
						case FACE_IMPORT_INFO:
						case FACE_INTERNAL_IMPORT_INFO:
						case FACE_MEMORY_CRC_INFO:
						case FACE_DELAY_IMPORT_INFO:
							dst_command = loader_info_list[(operand.value & 0xff) >> 1].data;
							if (dst_command) {
								link = command->AddLink((int)k, ltOffset, dst_command);
								link->set_sub_value(file->image_base());
							} else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_PACKER_INFO_SIZE:
						case FACE_SECTION_INFO_SIZE:
						case FACE_FIXUP_INFO_SIZE:
						case FACE_RELOCATION_INFO_SIZE:
						case FACE_IAT_INFO_SIZE:
						case FACE_IMPORT_INFO_SIZE:
						case FACE_INTERNAL_IMPORT_INFO_SIZE:
						case FACE_MEMORY_CRC_INFO_SIZE:
						case FACE_DELAY_IMPORT_INFO_SIZE:
							command->set_operand_value(k, loader_info_list[(operand.value & 0xff) >> 1].size);
							command->CompileToNative();
							break;
						case FACE_LOADER_CRC_INFO_SIZE:
							if (loader_crc_size_entry_) {
								link = command->AddLink((int)k, ltOffset, loader_crc_size_entry_);
								link->set_sub_value(file->image_base());
							} else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_LOADER_CRC_INFO_HASH:
							if (loader_crc_hash_entry_) {
								link = command->AddLink((int)k, ltOffset, loader_crc_hash_entry_);
								link->set_sub_value(file->image_base());
							} else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_FILE_CRC_INFO_SIZE:
							if (file_crc_size_entry_) {
								link = command->AddLink((int)k, ltOffset, file_crc_size_entry_);
								link->set_sub_value(file->image_base());
							} else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_MEMORY_CRC_INFO_HASH:
							command->set_operand_value(k, intel_crc ? intel_crc->hash_entry()->operand(0).value : 0);
							command->CompileToNative();
							break;
						case FACE_CRC_INFO_SALT:
							command->set_operand_value(k, file->function_list()->crc_cryptor()->item(0)->value());
							command->CompileToNative();
							break;
						case FACE_IMAGE_BASE:
							if (command->operand(0).size != cpu_address_size()) {
								IntelOperand first = command->operand(0);
								IntelOperand second = command->operand(1);
								first.size = cpu_address_size();
								second.size = cpu_address_size();
								command->Init(static_cast<IntelCommandType>(command->type()), first, second);
							}
							command->set_operand_value(k, file->image_base());
							command->set_operand_fixup(k, NEED_FIXUP);
							command->CompileToNative();
							break;
						case FACE_FILE_BASE:
							if (command->operand(0).size != cpu_address_size()) {
								IntelOperand first = command->operand(0);
								IntelOperand second = command->operand(1);
								first.size = cpu_address_size();
								second.size = cpu_address_size();
								command->Init(static_cast<IntelCommandType>(command->type()), first, second);
							}
							command->set_operand_value(k, file->image_base());
							command->CompileToNative();
							break;
						case FACE_GNU_RELRO_INFO:
							if (relro_entry_) {
								link = command->AddLink((int)k, ltOffset, relro_entry_);
								link->set_sub_value(file->image_base());
							}
							else {
								command->set_operand_value(k, 0);
								command->CompileToNative();
							}
							break;
						case FACE_VAR_IS_PATCH_DETECTED:
						case FACE_VAR_IS_DEBUGGER_DETECTED:
						case FACE_VAR_LOADER_CRC_INFO:
						case FACE_VAR_LOADER_CRC_INFO_SIZE:
						case FACE_VAR_LOADER_CRC_INFO_HASH:
						case FACE_VAR_CPU_HASH:
						case FACE_VAR_CPU_COUNT:
						case FACE_VAR_SESSION_KEY:
						case FACE_VAR_DRIVER_UNLOAD:
						case FACE_VAR_CRC_IMAGE_SIZE:
						case FACE_VAR_LOADER_STATUS:
						case FACE_VAR_SERVER_DATE:
							command->set_operand_value(k, ctx.runtime_var_index[(operand.value & 0xff) >> 4] * OperandSizeToValue(cpu_address_size()));
							command->CompileToNative();
							break;
						case FACE_VAR_IS_PATCH_DETECTED_SALT:
						case FACE_VAR_IS_DEBUGGER_DETECTED_SALT:
						case FACE_VAR_LOADER_CRC_INFO_SALT:
						case FACE_VAR_LOADER_CRC_INFO_SIZE_SALT:
						case FACE_VAR_LOADER_CRC_INFO_HASH_SALT:
						case FACE_VAR_CPU_HASH_SALT:
						case FACE_VAR_CPU_COUNT_SALT:
						case FACE_VAR_DRIVER_UNLOAD_SALT:
						case FACE_VAR_CRC_IMAGE_SIZE_SALT:
						case FACE_VAR_SERVER_DATE_SALT:
							command->set_operand_value(k, ctx.runtime_var_salt[operand.value & 0xff]);
							command->CompileToNative();
							break;
						case FACE_VAR_CPU_COUNT_SALT ^ 1:
							command->set_operand_value(k, ctx.runtime_var_salt[VAR_CPU_COUNT] ^ 1);
							command->CompileToNative();
							break;
						default:
							std::map<uint32_t, IntelCommand *>::const_iterator it = loader_string_list.find(static_cast<uint32_t>(operand.value));
							if (it != loader_string_list.end()) {
								if (command->type() == cmMov) {
									operand = command->operand(0);
									operand.size = cpu_address_size();
									if (operand.type == otRegistr) {
										command->Init(cmLea, operand, IntelOperand(otMemory | otValue, cpu_address_size(), 0, 0, (cpu_address_size() == osDWord) ? NEED_FIXUP : LARGE_VALUE));
									} else {
										command->Init(cmMov, operand, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
									}
								} else {
									command->Init(cmPush, IntelOperand(otValue, cpu_address_size(), 0, 0, NEED_FIXUP));
								}
								command->AddLink((int)k, ltOffset, it->second); 
							} else {
								throw std::runtime_error(string_format("Unknown loader string: %X", static_cast<uint32_t>(operand.value)));
							}
						}
					}
				}
			}
		}
		if (n == 0) {
			// create native blocks
			for (j = 0; j < count(); j++) {
				item(j)->include_option(roNoProgress);
			}
			CompileToNative(ctx);
			for (j = 0; j < count(); j++) {
				item(j)->exclude_option(roNoProgress);
			}
		}
	}

	for (i = old_count; i < count(); i++) {
		command = item(i);
		dst_link = command->link();

		if (command->type() == cmCall && command->operand(0).type == otValue && command->operand(0).value == command->next_address()) {
			uint64_t base_address = command->next_address();
			IntelCommand *next_command = item(i + 1);
			IntelCommand *next_command2 = item(i + 2);
			if (next_command->type() == cmPop && next_command->operand(0).type == otRegistr &&
				next_command2->type() == cmAdd && next_command2->operand(0).type == otRegistr && next_command2->operand(0).registr == next_command->operand(0).registr) {
				base_address += next_command2->operand(1).value;
			}
			else {
				base_address = 0;
			}
			if (base_address) {
				for (j = i + 1; j < count(); j++) {
					IntelCommand *next_command = item(j);
					if (next_command->type() == cmLea && next_command->operand(1).type == (otMemory | otRegistr | otValue) && (next_command->operand(1).registr == regEBX || next_command->operand(1).registr == regESI)) {
						uint64_t address = base_address + next_command->operand(1).value;
						ICommand *to_command = GetCommandByAddress(address);
						if (to_command) {
							link = next_command->AddLink(1, ltOffset, to_command);
							link->set_sub_value(base_address);
						}
					} else if (next_command->type() == cmMov && next_command->operand(1).type == (otMemory | otRegistr | otValue) && next_command->operand(1).registr == regEDI) {
						uint64_t address = base_address + next_command->operand(1).value;
						for (std::map<ELFRelocation *, IntelCommand *>::const_iterator it = iat_info.begin(); it != iat_info.end(); it++) {
							if (it->first->address() == address) {
								if (it->first->symbol()->bind() == STB_LOCAL) {
									next_command->Init(cmLea, next_command->operand(0), next_command->operand(1));
									link = next_command->AddLink(1, ltGateOffset, it->first->symbol()->value());
									link->set_sub_value(base_address);
								}
								break;
							}
						}
					} else if (command->type() == cmRet) {
						break;
					}
				}
			}
		}

		if (!dst_link) {
			// search references to LoaderAlloc/LoaderFree/FreeImage
			for (k = 0; k < 2; k++) {
				IntelOperand operand = command->operand(k);
				if (operand.type == otNone)
					break;

				if (cpu_address_size() == osDWord) {
					if (!operand.fixup)
						continue;
				} else {
					if (!operand.is_large_value)
						continue;
				}
				if (command->address() + command->original_dump_size() == operand.value)
					continue;

				dst_command = reinterpret_cast<IntelCommand *>(GetCommandByAddress(operand.value));
				if (dst_command && !dst_command->is_data()) {
					dst_link = command->AddLink((int)k, dst_command->block() ? ltOffset : ltGateOffset, dst_command);
					break;
				}
			}
		} else {
			if (dst_link->to_address())
				dst_link->set_to_command(GetCommandByAddress(dst_link->to_address()));
		}
	}
	setup_image_entry = GetCommandByAddress(runtime->export_list()->GetAddressByType(atSetupImage));
	if (!setup_image_entry)
		return false;

	free_image_entry = GetCommandByAddress(runtime->export_list()->GetAddressByType(atFreeImage));
	if (!free_image_entry)
		return false;

	// create entry command
	for (i = 0; i < 2; i++) {
		uint64_t jmp_address;
		if (i == 0)
			jmp_address = file->entry_point();
		 else {
			if (file->file_type() == ET_EXEC)
				continue;

			ELFDirectory *dir = file->command_list()->GetCommandByType(DT_INIT);
			jmp_address = dir ? dir->value() : 0;
		}

		old_count = count();
		AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEBP));
		AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEDX));
		AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEBP), IntelOperand(otRegistr, cpu_address_size(), regESP));
		AddCommand(cmAnd, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, -0x10));

		// call SetupImage
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, setup_image_entry);

		// check loader error code
		AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, TRUE));
		IntelCommand *check_loader_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
		check_loader_command->set_flags(fl_Z);
		check_loader_command->AddLink(0, ltJmpWithFlag);

		// call FreeImage
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, free_image_entry);

		command = AddCommand(cmNop);
		check_loader_command->link()->set_to_command(command);

		AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otRegistr, cpu_address_size(), regEBP));
		AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEDX));
		AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEBP));

		if (jmp_address) {
			command = AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size(), 0, jmp_address));
			command->AddLink(0, ltJmp, jmp_address);
		} else {
			AddCommand(cmRet);
		}

		if (i == 0)
			set_entry(item(old_count));
		else
			init_entry_->link()->set_to_command(item(old_count));
	}

	// create preinit command
	if (preinit_entry_) {
		old_count = count();
		AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEBP));
		AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEBP), IntelOperand(otRegistr, cpu_address_size(), regESP));
		AddCommand(cmAnd, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, -0x10));

		// call SetupImage
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, setup_image_entry);

		// check loader error code
		AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, TRUE));
		IntelCommand *check_loader_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
		check_loader_command->set_flags(fl_Z);
		check_loader_command->AddLink(0, ltJmpWithFlag);

		// call FreeImage
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, free_image_entry);

		command = AddCommand(cmNop);
		check_loader_command->link()->set_to_command(command);

		AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otRegistr, cpu_address_size(), regEBP));
		AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEBP));
		AddCommand(cmRet);

		preinit_entry_->link()->set_to_command(item(old_count));
	}

	// create term command
	if (term_entry_) {
		old_count = count();
		AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size(), regEBP));
		AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEBP), IntelOperand(otRegistr, cpu_address_size(), regESP));
		AddCommand(cmAnd, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otValue, cpu_address_size(), 0, -0x10));

		ELFDirectory *fini = file->command_list()->GetCommandByType(DT_FINI);
		if (fini) {
			command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size(), 0, fini->value()));
			command->AddLink(0, ltCall, fini->value());
		}

		// call FreeImage
		command = AddCommand(cmCall, IntelOperand(otValue, cpu_address_size()));
		command->AddLink(0, ltCall, free_image_entry);

		AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regESP), IntelOperand(otRegistr, cpu_address_size(), regEBP));
		AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size(), regEBP));
		AddCommand(cmRet);

		term_entry_->link()->set_to_command(item(old_count));
	}

	for (i = 0; i < count(); i++) {
		command = item(i);
		command->CompileToNative();
	}

	for (i = 0; i < link_list()->count(); i++) {
		CommandLink *link = link_list()->item(i);
		if (link->from_command()->type() == cmCall && std::find(internal_entry_list.begin(), internal_entry_list.end(), link->to_command()) != internal_entry_list.end())
			reinterpret_cast<IntelCommand*>(link->from_command())->include_option(roInternal);
		link->from_command()->PrepareLink(ctx);
	}

	return BaseIntelLoader::Prepare(ctx);
}

bool ELFIntelLoader::Compile(const CompileContext &ctx)
{
	if (!BaseIntelLoader::Compile(ctx))
		return false;

	return true;
}

/**
 * IntelVirtualMachine
 */

IntelVirtualMachine::IntelVirtualMachine(IntelVirtualMachineList *owner, VirtualMachineType type, uint8_t id, IntelVirtualMachineProcessor *processor)
	: BaseVirtualMachine(owner, id), type_(type), processor_(processor), entry_command_(NULL), init_command_(NULL), ext_jmp_command_(NULL), command_cryptor_(NULL),
		stack_registr_(0), pcode_registr_(0), jmp_registr_(0), crypt_registr_(0)
{
	backward_direction_ = (rand() & 1) == 0;
}

IntelVirtualMachine::~IntelVirtualMachine()
{
	delete ext_jmp_command_;
	delete command_cryptor_;
	for (size_t i = 0; i < cryptor_list_.size(); i++) {
		delete cryptor_list_[i];
	}
}

void IntelVirtualMachine::Init(const CompileContext &ctx, const IntelOpcodeList &visible_opcode_list)
{
	InitCommands(ctx, visible_opcode_list);

	opcode_stack_.clear();
	for (size_t i = 0; i < opcode_list_.count(); i++) {
		IntelOpcodeInfo *item = opcode_list_.item(i);
		opcode_stack_[item->Key()].push_back(item);
	}
}

void IntelVirtualMachine::Prepare(const CompileContext &ctx)
{
	size_t i;
	std::vector<IntelVirtualMachine *> virtual_machine_list;
	OperandSize cpu_address_size = processor_->cpu_address_size();
	for (i = 0; i < ctx.file->virtual_machine_list()->count(); i++) {
		IntelVirtualMachine *virtual_machine = reinterpret_cast<IntelVirtualMachineList *>(ctx.file->virtual_machine_list())->item(i);
		if (virtual_machine->processor()->cpu_address_size() == cpu_address_size)
			virtual_machine_list.push_back(virtual_machine);
	}

	// setup VMs cross references
	for (i = 0; i < vm_links_.size(); i++) {
		IntelVirtualMachine *virtual_machine = virtual_machine_list[i];

		IntelCommand *command = vm_links_[i];
		command->link()->set_to_command(virtual_machine->init_command());

		size_t j = processor_->IndexOf(command);
		uint8_t stack_registr = stack_registr_;
		uint8_t pcode_registr = processor_->item(j - 2)->operand(0).registr;
		if (virtual_machine->pcode_registr_ != pcode_registr) {
			if (virtual_machine->pcode_registr_ == stack_registr_) {
				command = new IntelCommand(processor_, cpu_address_size, cmXchg, IntelOperand(otRegistr, cpu_address_size, virtual_machine->pcode_registr_), IntelOperand(otRegistr, cpu_address_size, pcode_registr));
				stack_registr = pcode_registr;
			} else 
				command = new IntelCommand(processor_, cpu_address_size, cmMov, IntelOperand(otRegistr, cpu_address_size, virtual_machine->pcode_registr_), IntelOperand(otRegistr, cpu_address_size, pcode_registr));
			command->CompileToNative();
			processor_->InsertObject(j++, command);
		}
		if (virtual_machine->stack_registr_ != stack_registr) {
			command = new IntelCommand(processor_, cpu_address_size, cmMov, IntelOperand(otRegistr, cpu_address_size, virtual_machine->stack_registr_), IntelOperand(otRegistr, cpu_address_size, stack_registr));
			command->CompileToNative();
			processor_->InsertObject(j, command);
		}
	}
}

IntelCommand *IntelVirtualMachine::AddReadCommand(OperandSize size, OpcodeCryptor *command_cryptor, uint8_t registr)
{
	size_t c = processor_->count();
	OperandSize mov_size = (size < osDWord) ? osDWord : size;
	if (backward_direction_) {
		processor_->AddCommand(cmSub, IntelOperand(otRegistr, processor_->cpu_address_size(), pcode_registr_), IntelOperand(otValue, processor_->cpu_address_size(), 0, OperandSizeToValue(size)));
		processor_->AddCommand((mov_size == size) ? cmMov : cmMovzx, IntelOperand(otRegistr, mov_size, registr), IntelOperand(otMemory | otRegistr, size, pcode_registr_));
	}
	else {
		processor_->AddCommand((mov_size == size) ? cmMov : cmMovzx, IntelOperand(otRegistr, mov_size, registr), IntelOperand(otMemory | otRegistr, size, pcode_registr_));
		processor_->AddCommand(cmAdd, IntelOperand(otRegistr, processor_->cpu_address_size(), pcode_registr_), IntelOperand(otValue, processor_->cpu_address_size(), 0, OperandSizeToValue(size)));
	}

	if (command_cryptor) {
		IntelCommandType command_type = CryptorCommandToIntel(command_cryptor->type());
		OperandSize size = command_cryptor->size();

		processor_->AddCommand(command_type, IntelOperand(otRegistr, size, registr), IntelOperand(otRegistr, size, crypt_registr_));
		for (size_t i = 0; i < command_cryptor->count(); i++) {
			AddValueCommand(*command_cryptor->item(i), false, registr);
		}
		if (processor_->cpu_address_size() == osQWord && size == osDWord) {
			processor_->AddCommand(cmPush, IntelOperand(otRegistr, osQWord, crypt_registr_));
			processor_->AddCommand(command_type, IntelOperand(otMemory | otRegistr, size, regESP), IntelOperand(otRegistr, size, registr));
			processor_->AddCommand(cmPop, IntelOperand(otRegistr, osQWord, crypt_registr_));
		}
		else {
			processor_->AddCommand(command_type, IntelOperand(otRegistr, size, crypt_registr_), IntelOperand(otRegistr, size, registr));
		}
	}

	return processor_->item(c);
}

void IntelVirtualMachine::AddValueCommand(ValueCommand &value_command, bool is_decrypt, uint8_t registr)
{
	IntelCommandType command_type = CryptorCommandToIntel(value_command.type(is_decrypt));
	IntelOperand second_operand;
	if (command_type == cmAdd || command_type == cmSub || command_type == cmXor || command_type == cmRol || command_type == cmRor)
		second_operand = IntelOperand(otValue, (command_type == cmRol || command_type == cmRor) ? osByte : value_command.size(), 0, value_command.value());
	processor_->AddCommand(command_type, IntelOperand(otRegistr, value_command.size(), registr), second_operand);
}

void IntelVirtualMachine::AddEndHandlerCommands(IntelCommand *to_command, OpcodeCryptor *command_cryptor)
{
	IntelCommand *command;
	if (type_ == vtAdvanced) {
		IntelRegistrList registr_list = free_registr_list_;
		uint8_t reg1 = registr_list.GetRandom();
		AddReadCommand(osDWord, command_cryptor, reg1);
		if (processor_->cpu_address_size() == osQWord)
			processor_->AddCommand(cmMovsxd, IntelOperand(otRegistr, processor_->cpu_address_size(), reg1), IntelOperand(otRegistr, osDWord, reg1));
		processor_->AddCommand(cmAdd, IntelOperand(otRegistr, processor_->cpu_address_size(), jmp_registr_), IntelOperand(otRegistr, processor_->cpu_address_size(), reg1));
		if (to_command) {
			command = processor_->AddCommand(cmJmp, IntelOperand(otValue, processor_->cpu_address_size()));
			command->AddLink(0, ltJmp, to_command);
		}
		else {
			command = processor_->AddCommand(cmJmp, IntelOperand(otRegistr, processor_->cpu_address_size(), jmp_registr_));
			command->AddLink(-1, ltJmp);
		}
	}
	else {
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, processor_->cpu_address_size()));
		command->AddLink(0, ltJmp, to_command);
	}
}

IntelCommand *IntelVirtualMachine::CloneHandler(IntelCommand *handler)
{
	size_t i, c, j;
	std::map<ICommand *, ICommand *> command_map;

	c = processor_->count();
	j = processor_->IndexOf(handler);
	for (i = j; i < c; i++) {
		IntelCommand *src_command = processor_->item(i);
		IntelCommand *dst_command = src_command->Clone(processor_);
		processor_->AddObject(dst_command);

		command_map[src_command] = dst_command;

		CommandLink *src_link = src_command->link();
		if (src_link) {
			CommandLink *dst_link = src_link->Clone(processor_->link_list());
			dst_link->set_from_command(dst_command);
			dst_link->set_to_command(src_link->to_command());
			processor_->link_list()->AddObject(dst_link);
		}

		if (src_command->type() == cmJmp && src_link && src_link->to_command()) {
			if (j > processor_->IndexOf(src_link->to_command()))
				break;
		}
		else if (src_command->is_end())
			break;
	}

	for (i = c; i < processor_->count(); i++) {
		IntelCommand *command = processor_->item(i);
		CommandLink *link = command->link();
		if (!link || !link->to_command())
			continue;

		std::map<ICommand *, ICommand *>::const_iterator it = command_map.find(link->to_command());
		if (it != command_map.end())
			link->set_to_command(it->second);
	}

	return processor_->item(c);
}

void IntelVirtualMachine::AddCallCommands(CallingConvention calling_convention, IntelCommand *call_entry, uint8_t registr)
{
	std::vector<uint8_t> registr_list;
	IntelCommand *command;
	size_t i;

	OperandSize cpu_address_size = processor_->cpu_address_size();
	OperandSize arg_address_size = (calling_convention == ccStdcallToMSx64) ? osDWord : processor_->cpu_address_size();

	switch (calling_convention) { //-V719
	case ccMSx64:
	case ccStdcallToMSx64:
		registr_list.push_back(regECX);
		registr_list.push_back(regEDX);
		registr_list.push_back(regR8);
		registr_list.push_back(regR9);
		break;
	case ccABIx64:
		registr_list.push_back(regEDI);
		registr_list.push_back(regESI);
		registr_list.push_back(regEDX);
		registr_list.push_back(regECX);
		registr_list.push_back(regR8);
		registr_list.push_back(regR9);
		break;
	}

	// push common registers
	processor_->AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, pcode_registr_));
	if (jmp_registr_)
		processor_->AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, jmp_registr_));
	if (crypt_registr_)
		processor_->AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, crypt_registr_));
	if (stack_registr_ != regEBP)
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regEBP), IntelOperand(otRegistr, cpu_address_size, stack_registr_));

	if (registr != regEBX)
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regEBX), IntelOperand(otRegistr, osDWord, registr));
	processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regEDX), IntelOperand(otRegistr, osDWord, regEBX));
	if (!registr_list.empty()) {
		processor_->AddCommand(cmXor, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regECX));
		processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regEBX), IntelOperand(otValue, osDWord, 0, registr_list.size()));
		IntelCommand *jmp_no_stack_args = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_no_stack_args->set_flags(fl_C | fl_Z);
		jmp_no_stack_args->AddLink(0, ltJmpWithFlag);
		if (calling_convention != ccStdcallToMSx64)
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regEDX), IntelOperand(otValue, osDWord, 0, registr_list.size()));
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otRegistr | otValue, osDWord, regEBX, 0 - registr_list.size()));
		command = processor_->AddCommand(cmShl, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otValue, osByte, 0, cpu_address_size == osDWord ? 2 : 3));
		jmp_no_stack_args->link()->set_to_command(command);
	}
	processor_->AddCommand(cmShl, IntelOperand(otRegistr, osDWord, regEDX), IntelOperand(otValue, osByte, 0, arg_address_size == osDWord ? 2 : 3));
	if (calling_convention != ccCdecl) {
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regEAX), IntelOperand(otRegistr, cpu_address_size, regEBP));
		processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, regEAX), IntelOperand(otRegistr, cpu_address_size, regEDX));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, cpu_address_size, regEAX));
	}
	if (calling_convention != ccStdcall) {
		// align stack
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 2), IntelOperand(otRegistr, cpu_address_size, regESP));
		processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otRegistr, cpu_address_size, registr_list.empty() ? regEDX : regECX));
		processor_->AddCommand(cmAnd, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otValue, cpu_address_size, 0, -16));
		processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otRegistr, cpu_address_size, registr_list.empty() ? regEDX : regECX));
	} else if (call_entry)
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 2), IntelOperand(otRegistr, cpu_address_size, regESP));

	processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regEBX), IntelOperand(otRegistr, osDWord, regEBX));
	IntelCommand *jmp_end_store = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
	jmp_end_store->set_flags(fl_Z);
	jmp_end_store->AddLink(0, ltJmpWithFlag);

	IntelCommand *load_arg = processor_->AddCommand(cmMov, IntelOperand(otRegistr, arg_address_size, regEAX), IntelOperand(otMemory | otBaseRegistr | otRegistr | otValue, arg_address_size, (regEBP << 4) | regEBX));
	load_arg->set_operand_scale(1, arg_address_size == osDWord ? 2 : 3);

	std::vector<IntelCommand *> jmp_loop_arg;
	IntelCommand *jmp_arg_command = NULL;
	if (!registr_list.empty()) {
		// store arg in register
		for (i = 0; i < registr_list.size(); i++) {
			command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regEBX), IntelOperand(otValue, osDWord, 0, i + 1));
			if (jmp_arg_command)
				jmp_arg_command->link()->set_to_command(command);

			jmp_arg_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
			jmp_arg_command->set_flags(fl_Z);
			jmp_arg_command->include_option(roInverseFlag);
			jmp_arg_command->AddLink(0, ltJmpWithFlag);

			processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, registr_list[i]), IntelOperand(otRegistr, cpu_address_size, regEAX));
			command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
			command->AddLink(0, ltJmp);
			jmp_loop_arg.push_back(command);
		}
	}

	// store arg in stack
	if (calling_convention == ccMSx64) {
		command = processor_->AddCommand(cmPush, IntelOperand(otMemory | otBaseRegistr | otRegistr | otValue, cpu_address_size, (regEBP << 4) | regEBX, 0x20));
		command->set_operand_scale(0, 3);
	} else
		command = processor_->AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, regEAX));
	if (jmp_arg_command)
		jmp_arg_command->link()->set_to_command(command);

	// loop arg
	command = processor_->AddCommand(cmSub, IntelOperand(otRegistr, osDWord, regEBX), IntelOperand(otValue, osDWord, 0, 1));
	for (i = 0; i < jmp_loop_arg.size(); i++) {
		jmp_loop_arg[i]->link()->set_to_command(command);
	}
	command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
	command->set_flags(fl_Z);
	command->include_option(roInverseFlag);
	command->AddLink(0, ltJmpWithFlag, load_arg);

	// end store
	command = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regEAX), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0));
	jmp_end_store->link()->set_to_command(command);

	if (calling_convention == ccStdcallToMSx64) {
		// convert input args
		std::vector<IntelCommand *> jmp_end_convert;
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otRegistr, osDWord, regEAX));
		processor_->AddCommand(cmShr, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otValue, osByte, 0, 24));
		IntelCommand *jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		jmp_end_convert.push_back(jmp_command);

		// NtProtectVirtualMemory
		processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 1));
		IntelCommand *cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otValue, osDWord, 0, (uint32_t)-1)); // NtCurrentProcess
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->include_option(roInverseFlag);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmMovsxd, IntelOperand(otRegistr, osQWord, regECX), IntelOperand(otRegistr, osDWord, regECX));

		command = processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regEDX), IntelOperand(otRegistr, osDWord, regEDX));
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 3));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regEDX), IntelOperand(otMemory | otRegistr, osDWord, regEDX));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, cpu_address_size, regR10), IntelOperand(otRegistr, cpu_address_size, regEDX));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regEDX), IntelOperand(otRegistr, cpu_address_size, regR10));

		command = processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regR8), IntelOperand(otRegistr, osDWord, regR8));
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 4));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR8), IntelOperand(otMemory | otRegistr, osDWord, regR8));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, cpu_address_size, regR10), IntelOperand(otRegistr, cpu_address_size, regR8));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regR8), IntelOperand(otRegistr, cpu_address_size, regR10));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		// NtSetInformationThread
		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 2));
		cmp_command->link()->set_to_command(command);
		cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otValue, osDWord, 0, (uint32_t)-2)); // NtCurrentThread
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->include_option(roInverseFlag);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmMovsxd, IntelOperand(otRegistr, osQWord, regECX), IntelOperand(otRegistr, osDWord, regECX));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		// NtQueryInformationProcess
		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 3));
		cmp_command->link()->set_to_command(command);
		cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otValue, osDWord, 0, (uint32_t)-1)); // NtCurrentProcess
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->include_option(roInverseFlag);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmMovsxd, IntelOperand(otRegistr, osQWord, regECX), IntelOperand(otRegistr, osDWord, regECX));

		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regEDX), IntelOperand(otValue, osDWord, 0, 0x7)); // ProcessDebugPort
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->include_option(roInverseFlag);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 3));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regR8), IntelOperand(otRegistr, cpu_address_size, regR10));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR9), IntelOperand(otValue, osDWord, 0, OperandSizeToValue(cpu_address_size)));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regEDX), IntelOperand(otValue, osDWord, 0, 0x1e)); // ProcessDebugObjectHandle
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->include_option(roInverseFlag);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 3));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regR8), IntelOperand(otRegistr, cpu_address_size, regR10));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR9), IntelOperand(otValue, osDWord, 0, OperandSizeToValue(cpu_address_size)));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		// NtMapViewOfSection
		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 4));
		cmp_command->link()->set_to_command(command);
		cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regEDX), IntelOperand(otValue, osDWord, 0, (uint32_t)-1)); // NtCurrentProcess
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->include_option(roInverseFlag);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmMovsxd, IntelOperand(otRegistr, osQWord, regEDX), IntelOperand(otRegistr, osDWord, regEDX));

		command = processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regR8), IntelOperand(otRegistr, osDWord, regR8));
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 3));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR8), IntelOperand(otMemory | otRegistr, osDWord, regR8));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, cpu_address_size, regR10), IntelOperand(otRegistr, cpu_address_size, regR8));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regR8), IntelOperand(otRegistr, cpu_address_size, regR10));

		command = processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, OperandSizeToValue(cpu_address_size) * 2));
		processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otRegistr, osDWord, regR11));
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 4));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otMemory | otRegistr, osDWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, cpu_address_size, regR10), IntelOperand(otRegistr, cpu_address_size, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, OperandSizeToValue(cpu_address_size) * 2), IntelOperand(otRegistr, cpu_address_size, regR10));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		// NtUnmapViewOfSection
		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 5));
		cmp_command->link()->set_to_command(command);
		cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otValue, osDWord, 0, (uint32_t)-1)); // NtCurrentProcess
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->include_option(roInverseFlag);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmMovsxd, IntelOperand(otRegistr, osQWord, regECX), IntelOperand(otRegistr, osDWord, regECX));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		// NtOpenFile
		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 6));
		cmp_command->link()->set_to_command(command);
		cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		command = processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regECX));
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 3));

		command = processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regR9), IntelOperand(otRegistr, osDWord, regR9));
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regR9), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 5));

		command = processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regR8), IntelOperand(otRegistr, osDWord, regR8));
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 10));
		processor_->AddCommand(cmAnd, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otValue, cpu_address_size, 0, (uint64_t)-16));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otValue, osDWord, 0, 0x30));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osQWord, regR10), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmXor, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otRegistr, osDWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR10, 0x08), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR10, 0x10), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR10, 0x20), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR10, 0x28), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otMemory | otRegistr | otValue, osDWord, regR8, 0x0c));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR10, 0x18), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otMemory | otRegistr | otValue, osDWord, regR8, 0x08));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regR8), IntelOperand(otRegistr, cpu_address_size, regR10));

		processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otRegistr, osDWord, regR11));
		IntelCommand *jmp_command2 = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command2->set_flags(fl_Z);
		jmp_command2->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otRegistr, osDWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR8, 0 - OperandSizeToValue(cpu_address_size) * 2), IntelOperand(otRegistr, osQWord, regR10));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otRegistr | otValue, osDWord, regR11, 4));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR8, 0 - OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, osQWord, regR10));
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regR8, 0 - OperandSizeToValue(cpu_address_size) * 2));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR8, 0x10), IntelOperand(otRegistr, osQWord, regR10));

		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		jmp_command2->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		// NtCreateSection
		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 7));
		cmp_command->link()->set_to_command(command);
		cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		command = processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regECX));
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 3));

		command = processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regR8), IntelOperand(otRegistr, osDWord, regR8));
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 8));
		processor_->AddCommand(cmAnd, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otValue, cpu_address_size, 0, (uint64_t)-16));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otValue, osDWord, 0, 0x30));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osQWord, regR10), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmXor, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otRegistr, osDWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR10, 0x08), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR10, 0x10), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR10, 0x20), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR10, 0x28), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otMemory | otRegistr | otValue, osDWord, regR8, 0x0c));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR10, 0x18), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otMemory | otRegistr | otValue, osDWord, regR8, 0x08));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regR8), IntelOperand(otRegistr, cpu_address_size, regR10));

		processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otRegistr, osDWord, regR11));
		jmp_command2 = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command2->set_flags(fl_Z);
		jmp_command2->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otRegistr, osDWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR8, 0 - OperandSizeToValue(cpu_address_size) * 2), IntelOperand(otRegistr, osQWord, regR10));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otRegistr | otValue, osDWord, regR11, 4));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR8, 0 - OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, osQWord, regR10));
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regR8, 0 - OperandSizeToValue(cpu_address_size) * 2));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regR8, 0x10), IntelOperand(otRegistr, osQWord, regR10));

		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		jmp_command2->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		// NtQueryVirtualMemory
		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 8));
		cmp_command->link()->set_to_command(command);
		cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otValue, osDWord, 0, (uint32_t)-1)); // NtCurrentProcess
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->include_option(roInverseFlag);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmMovsxd, IntelOperand(otRegistr, osQWord, regECX), IntelOperand(otRegistr, osDWord, regECX));

		command = processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regR9), IntelOperand(otRegistr, osDWord, regR9));
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 8));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regR9), IntelOperand(otRegistr, cpu_address_size, regR10));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osDWord, regESP), IntelOperand(otValue, osDWord, 0, 0x30));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		command = processor_->AddCommand(cmAnd, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, WOW64_FLAG - 1));
		cmp_command->link()->set_to_command(command);
		for (i = 0; i < jmp_end_convert.size(); i++) {
			jmp_end_convert[i]->link()->set_to_command(command);
		}
	}

	if (calling_convention == ccMSx64 || calling_convention == ccStdcallToMSx64)
		processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otValue, cpu_address_size, 0, 0x20));
	if (call_entry) {
		command = processor_->AddCommand(cmCall, IntelOperand(otValue, cpu_address_size));
		command->AddLink(0, ltCall, call_entry);
	} else
		processor_->AddCommand(cmCall, IntelOperand(otRegistr, cpu_address_size, regEAX));

	if (calling_convention == ccStdcallToMSx64) {
		// convert output args
		std::vector<IntelCommand *> jmp_end_convert;
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, osDWord, regEBP << 4, 0));
		processor_->AddCommand(cmShr, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otValue, osByte, 0, 24));
		IntelCommand *jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		jmp_end_convert.push_back(jmp_command);

		// NtProtectVirtualMemory
		processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 1));
		IntelCommand *cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size) * 2));
		processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regECX));
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, osDWord, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 3));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regR10));

		command = processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size) * 3));
		jmp_command->link()->set_to_command(command);
		processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regECX));
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, osDWord, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 4));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regR10));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		// NtQueryInformationProcess
		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 3));
		cmp_command->link()->set_to_command(command);
		cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		command = processor_->AddCommand(cmCmp, IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size) * 2), IntelOperand(otValue, osDWord, 0, 0x7));  // ProcessDebugPort
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->include_option(roInverseFlag);
		jmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size) * 3));
		processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size) * 5));
		IntelCommand *jmp_command2 = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command2->set_flags(fl_Z);
		jmp_command2->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, osDWord, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 3));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regR10));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command2->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		command = processor_->AddCommand(cmCmp, IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size) * 2), IntelOperand(otValue, osDWord, 0, 0x1e));  // ProcessDebugObjectHandle
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->include_option(roInverseFlag);
		jmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size) * 3));
		processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size) * 5));
		jmp_command2 = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command2->set_flags(fl_Z);
		jmp_command2->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, osDWord, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 3));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regR10));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		jmp_command2->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		// NtMapViewOfSection
		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 4));
		cmp_command->link()->set_to_command(command);
		cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size) * 3));
		processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regECX));
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, osDWord, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 3));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regR10));

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size) * 7));
		jmp_command->link()->set_to_command(command);
		processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regECX));
		jmp_command->link()->set_to_command(command);
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, osDWord, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 4));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regR10));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		// NtOpenFile
		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 6));
		cmp_command->link()->set_to_command(command);
		cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size)));
		processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regECX));
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, osDWord, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 3));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regR10));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		// NtCreateSection
		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 7));
		cmp_command->link()->set_to_command(command);
		cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size)));
		processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regECX));
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, osDWord, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 3));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regR10));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		// NtQueryVirtualMemory
		command = processor_->AddCommand(cmCmp, IntelOperand(otRegistr, osByte, regR10), IntelOperand(otValue, osByte, 0, 8));
		cmp_command->link()->set_to_command(command);
		cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		cmp_command->set_flags(fl_Z);
		cmp_command->include_option(roInverseFlag);
		cmp_command->AddLink(0, ltJmpWithFlag);

		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, OperandSizeToValue(arg_address_size) * 4));
		processor_->AddCommand(cmTest, IntelOperand(otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regECX));
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_Z);
		jmp_command->AddLink(0, ltJmpWithFlag);
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, osDWord, regR10), IntelOperand(otMemory | otBaseRegistr | otValue, osDWord, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 8));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otMemory | otRegistr, osDWord, regR10));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osDWord, regECX), IntelOperand(otRegistr, osDWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otMemory | otRegistr | otValue, osDWord, regR10, OperandSizeToValue(cpu_address_size)));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osDWord, regECX, OperandSizeToValue(arg_address_size)), IntelOperand(otRegistr, osDWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otMemory | otRegistr | otValue, osDWord, regR10, OperandSizeToValue(cpu_address_size) * 2));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osDWord, regECX, OperandSizeToValue(arg_address_size) * 2), IntelOperand(otRegistr, osDWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otMemory | otRegistr | otValue, osDWord, regR10, OperandSizeToValue(cpu_address_size) * 3));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osDWord, regECX, OperandSizeToValue(arg_address_size) * 3), IntelOperand(otRegistr, osDWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osQWord, regR11), IntelOperand(otMemory | otRegistr | otValue, osQWord, regR10, OperandSizeToValue(cpu_address_size) * 4));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osQWord, regECX, OperandSizeToValue(arg_address_size) * 4), IntelOperand(otRegistr, osQWord, regR11));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regR11), IntelOperand(otMemory | otRegistr | otValue, osDWord, regR10, OperandSizeToValue(cpu_address_size) * 5));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osDWord, regECX, OperandSizeToValue(arg_address_size) * 6), IntelOperand(otRegistr, osDWord, regR11));

		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		jmp_command->link()->set_to_command(command);
		command->AddLink(0, ltJmp);
		jmp_end_convert.push_back(command);

		command = processor_->AddCommand(cmNop);
		cmp_command->link()->set_to_command(command);
		for (i = 0; i < jmp_end_convert.size(); i++) {
			jmp_end_convert[i]->link()->set_to_command(command);
		}
	}

	// correct stack
	if (calling_convention != ccStdcall)
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 2));
	else if (call_entry)
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size) * 2));
	if (calling_convention != ccCdecl)
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regEBP), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, regEBP << 4, 0 - OperandSizeToValue(cpu_address_size)));

	// save result
	processor_->AddCommand(cmMov, IntelOperand(otMemory | otBaseRegistr | otValue, arg_address_size, regEBP << 4, 0), IntelOperand(otRegistr, arg_address_size, regEAX));

	// pop common registers
	if (stack_registr_ != regEBP)
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otRegistr, cpu_address_size, regEBP));
	if (crypt_registr_)
		processor_->AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size, crypt_registr_));
	if (jmp_registr_)
		processor_->AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size, jmp_registr_));
	processor_->AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size, pcode_registr_));
}

bool IntelVirtualMachine::IsRegistrUsed(uint8_t registr)
{
	return (registr == stack_registr_ || registr == pcode_registr_ || (jmp_registr_ && registr == jmp_registr_) || (crypt_registr_ && registr == crypt_registr_));
}

void IntelVirtualMachine::InitCommands(const CompileContext &ctx, const IntelOpcodeList &visible_opcode_list)
{
	IntelCommand *command, *read_opcode, *check_stack, *opcode_entry, *switch_entry, *jmp_command;
	uint8_t seg, s, reg1, reg2, reg3, reg4;
	OperandSize size, mov_size;
	size_t i, operand_size, result_size, j, c;
	IntelCommandType command_type;
	OpcodeCryptor *value_cryptor, *registr_cryptor, *end_cryptor;
	IntelOpcodeInfo *opcode;
	OperandSize cpu_address_size = processor_->cpu_address_size();
	IntelFunctionList *function_list = reinterpret_cast<IntelFunctionList *>(processor_->owner());

	IntelRegistrList wrong_registr_list;
	switch (ctx.file->calling_convention()) {
	case ccMSx64:
	case ccABIx64:
		wrong_registr_list.push_back(regR12);
		wrong_registr_list.push_back(regR13);
		wrong_registr_list.push_back(regR14);
		wrong_registr_list.push_back(regR15);
		break;
	}

	// init registers
	if 
#ifdef DEMO
		(true)
#else
		(ctx.options.flags & cpUnregisteredVersion)
#endif	
	{
		crypt_registr_ = (ctx.options.flags & cpEncryptBytecode) ? regEBX : 0;
		pcode_registr_ = regESI;
		stack_registr_ = regEBP;
		if (type_ == vtAdvanced)
			jmp_registr_ = regEDI;
		else if (cpu_address_size == osQWord)
			jmp_registr_ = regR11;
		else
			jmp_registr_ = 0;
	}
	else {
		IntelRegistrList work_registr_list;
		work_registr_list.push_back(regEBX);
		work_registr_list.push_back(regEBP);
		work_registr_list.push_back(regESI);
		work_registr_list.push_back(regEDI);
		if (cpu_address_size == osQWord) {
			for (i = 8; i < 16; i++) {
				work_registr_list.push_back((uint8_t)i);
			}
		}
		work_registr_list.remove(wrong_registr_list);

		crypt_registr_ = 0;
		if (ctx.options.flags & cpEncryptBytecode) {
			if (cpu_address_size == osDWord) {
				crypt_registr_ = regEBX;
				work_registr_list.remove(crypt_registr_);
			}
			else
				crypt_registr_ = work_registr_list.GetRandom();
		}
		pcode_registr_ = work_registr_list.GetRandom();
		stack_registr_ = work_registr_list.GetRandom();
		jmp_registr_ = (type_ == vtAdvanced || cpu_address_size == osQWord) ? work_registr_list.GetRandom() : 0;
	}

	free_registr_list_.push_back(regEAX);
	free_registr_list_.push_back(regECX);
	free_registr_list_.push_back(regEDX);
	free_registr_list_.push_back(regEBX);
	free_registr_list_.push_back(regEBP);
	free_registr_list_.push_back(regESI);
	free_registr_list_.push_back(regEDI);
	if (cpu_address_size == osQWord) {
		for (i = 8; i < 16; i++) {
			free_registr_list_.push_back((uint8_t)i);
		}
	}
	free_registr_list_.remove(wrong_registr_list);
	free_registr_list_.remove(pcode_registr_);
	free_registr_list_.remove(stack_registr_);
	if (jmp_registr_)
		free_registr_list_.remove(jmp_registr_);
	if (crypt_registr_)
		free_registr_list_.remove(crypt_registr_);

	// init cryptors
	entry_cryptor_.Init(osDWord);
	if (ctx.options.flags & cpEncryptBytecode) {
		command_cryptor_ = new OpcodeCryptor();
		command_cryptor_->Init((type_ == vtAdvanced) ? osDWord : osByte);
	}
	value_cryptor = NULL;
	registr_cryptor = NULL;
	end_cryptor = NULL;

	// init registr list
	registr_order_.clear();
	registr_order_.push_back(regEFX);
	registr_order_.push_back(regEAX);
	registr_order_.push_back(regECX);
	registr_order_.push_back(regEDX);
	registr_order_.push_back(regEBX);
	registr_order_.push_back(regEBP);
	registr_order_.push_back(regESI);
	registr_order_.push_back(regEDI);
	if (cpu_address_size == osQWord) {
		for (i = 8; i < 16; i++) {
			registr_order_.push_back((uint8_t)i);
		}
	}
	for (i = 0; i < registr_order_.size(); i++) {
		std::swap(registr_order_[i], registr_order_[rand() % registr_order_.size()]);
	}

	// create commands
	c = processor_->count();
	for (i = 0; i < registr_order_.size(); i++) {
		uint8_t reg = registr_order_[i];
		if (reg == regEFX) {
			processor_->AddCommand(cmPushf);
		}
		else {
			processor_->AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, reg));
		}
	}
	entry_command_ = processor_->item(c);
	entry_command_->include_section_option(rtLinkedToInt);

	size_t context_registr_count = (cpu_address_size == osQWord) ? 24 : 16;
	if (ctx.file->runtime_function_list() && ctx.file->runtime_function_list()->count())
		context_registr_count += 8;
	{
		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom();
	}
	if (ctx.file->cpu_address_size() != cpu_address_size && cpu_address_size == osQWord)
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otMemory | otValue, cpu_address_size, 0, 0, LARGE_VALUE));
	else
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otValue, cpu_address_size, 0, 0, NEED_FIXUP));
	processor_->AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, reg1));
	processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, pcode_registr_), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, (registr_order_.size() + 2) * OperandSizeToValue(cpu_address_size)));
	for (i = entry_cryptor_.count(); i > 0; i--) {
		AddValueCommand(*entry_cryptor_.item(i - 1), true, pcode_registr_);
	}
	processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, pcode_registr_), IntelOperand(otRegistr, cpu_address_size, reg1));
	if (cpu_address_size == osQWord) {
		if (ctx.file->image_base() >> 32) {
			IntelRegistrList registr_list = free_registr_list_;
			reg1 = registr_list.GetRandom();
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otValue, cpu_address_size, 0, ctx.file->image_base() & 0xffffffff00000000ull));
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, pcode_registr_), IntelOperand(otRegistr, cpu_address_size, reg1));
		}
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otRegistr, cpu_address_size, regESP));
		processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otValue, cpu_address_size, 0, 128 + context_registr_count * OperandSizeToValue(cpu_address_size)));
		processor_->AddCommand(cmAnd, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otValue, cpu_address_size, 0, -16));
	}
	else {
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otRegistr, cpu_address_size, regESP));
		processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otValue, cpu_address_size, 0, 128 + context_registr_count * OperandSizeToValue(cpu_address_size)));
	}

	c = processor_->count();
	if (crypt_registr_) {
		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom();
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, crypt_registr_), IntelOperand(otRegistr, cpu_address_size, pcode_registr_));
		if (ctx.file->cpu_address_size() != cpu_address_size && cpu_address_size == osQWord)
			processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otMemory | otValue, cpu_address_size, 0, 0, LARGE_VALUE));
		else
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otValue, cpu_address_size, 0, 0, NEED_FIXUP));
		processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, crypt_registr_), IntelOperand(otRegistr, cpu_address_size, reg1));
	}
	if (type_ == vtAdvanced) {
		opcode_entry = processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, jmp_registr_), IntelOperand(otMemory | otValue, cpu_address_size, 0, 0, (cpu_address_size == osDWord) ? NEED_FIXUP : LARGE_VALUE));
		opcode_entry->AddLink(1, ltOffset, opcode_entry);
		AddEndHandlerCommands(NULL, command_cryptor_);
		opcode_list_.Add(cmNop, otNone, cpu_address_size, 0, opcode_entry, NULL, command_cryptor_);
	}
	else if (cpu_address_size == osQWord) {
		command = processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, jmp_registr_), IntelOperand(otMemory | otValue, cpu_address_size, 0, 0, LARGE_VALUE));
		command->AddLink(1, ltOffset);
		switch_entry = command;
	}
	else if (c == processor_->count())
		processor_->AddCommand(cmNop);
	init_command_ = processor_->item(c);

	read_opcode = NULL;
	if (type_ == vtAdvanced) {
		command = processor_->AddCommand(cmJmp, IntelOperand(otRegistr, cpu_address_size, jmp_registr_));
		command->AddLink(-1, ltJmp);
	}
	else {
		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom(cpu_address_size == osDWord);
		read_opcode = AddReadCommand(osByte, command_cryptor_, reg1);
		if (cpu_address_size == osQWord) {
			command = processor_->AddCommand(cmJmp, IntelOperand(otMemory | otBaseRegistr | otRegistr, cpu_address_size, (jmp_registr_ << 4) | reg1, 0));
			command->set_operand_scale(0, 3);
			command->AddLink(-1, ltJmp);
		}
		else {
			command = processor_->AddCommand(cmJmp, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, reg1, 0, NEED_FIXUP));
			command->set_operand_scale(0, 2);
			command->AddLink(0, ltSwitch);
			switch_entry = command;
		}
	}

	// check stack
	{
		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom();
		check_stack = processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, regESP, (context_registr_count + 8) * OperandSizeToValue(cpu_address_size)));
		processor_->AddCommand(cmCmp, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otRegistr, cpu_address_size, reg1));
		jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
		jmp_command->set_flags(fl_C | fl_Z);
		jmp_command->include_option(roInverseFlag);
		jmp_command->AddLink(0, ltJmpWithFlag);

		registr_list = free_registr_list_;
		registr_list.remove(regESI);
		registr_list.remove(regEDI);
		registr_list.remove(regECX);
		reg1 = registr_list.GetRandom();
		reg2 = registr_list.GetRandom();
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg2), IntelOperand(otRegistr, cpu_address_size, regESP));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regECX), IntelOperand(otValue, cpu_address_size, 0, context_registr_count * OperandSizeToValue(cpu_address_size)));
		processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otMemory | otBaseRegistr | otValue, cpu_address_size, stack_registr_ << 4, -128));
		processor_->AddCommand(cmAnd, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otValue, cpu_address_size, 0, (cpu_address_size == osQWord) ? -16 : -4));
		processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otRegistr, cpu_address_size, regECX));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otRegistr, cpu_address_size, reg1));
		if (IsRegistrUsed(regEDI))
			processor_->AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, regEDI));
		if (IsRegistrUsed(regESI))
			processor_->AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, regESI));
		processor_->AddCommand(cmPushf);
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regESI), IntelOperand(otRegistr, cpu_address_size, reg2));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regEDI), IntelOperand(otRegistr, cpu_address_size, reg1));
		processor_->AddCommand(cmCld);
		command = processor_->AddCommand(cmMovs, IntelOperand(otRegistr, osByte));
		command->set_preffix_command(cmRep);
		processor_->AddCommand(cmPopf);
		if (IsRegistrUsed(regESI))
			processor_->AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size, regESI));
		if (IsRegistrUsed(regEDI))
			processor_->AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size, regEDI));
		if (type_ == vtAdvanced) {
			command = processor_->AddCommand(cmJmp, IntelOperand(otRegistr, cpu_address_size, jmp_registr_));
			command->AddLink(-1, ltJmp);
			jmp_command->link()->set_to_command(command);
		}
		else {
			command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
			command->AddLink(0, ltJmp, read_opcode);
			jmp_command->link()->set_to_command(read_opcode);
		}
	}

	// push registr
	for (s = osByte; s <= cpu_address_size; s++) {
		size = static_cast<OperandSize>(s);
		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom(cpu_address_size == osDWord);
		reg2 = registr_list.GetRandom();
		mov_size = (size == osByte) ? osWord : size;
		if (ctx.options.flags & cpEncryptBytecode) {
			registr_cryptor = new OpcodeCryptor();
			cryptor_list_.push_back(registr_cryptor);
			registr_cryptor->Init(osByte);
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = AddReadCommand(osByte, registr_cryptor, reg1);
		processor_->AddCommand((mov_size == size) ? cmMov : cmMovzx, IntelOperand(otRegistr, mov_size, reg2), IntelOperand(otMemory | otBaseRegistr | otRegistr, size, (regESP << 4) | reg1));
		operand_size = 0;
		result_size = OperandSizeToValue(mov_size);
		if (result_size > operand_size)
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size) //-V547
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, mov_size, stack_registr_), IntelOperand(otRegistr, mov_size, reg2));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
		opcode_list_.Add(cmPush, otRegistr, size, 0, opcode_entry, registr_cryptor, end_cryptor);
	}

	// pop registr
	for (s = osByte; s <= cpu_address_size; s++) {
		size = static_cast<OperandSize>(s);
		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
		reg2 = registr_list.GetRandom(cpu_address_size == osDWord);
		mov_size = (size == osByte) ? osWord : size;
		if (ctx.options.flags & cpEncryptBytecode) {
			registr_cryptor = new OpcodeCryptor();
			cryptor_list_.push_back(registr_cryptor);
			registr_cryptor->Init(osByte);
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, mov_size, reg1), IntelOperand(otMemory | otRegistr, mov_size, stack_registr_));
		operand_size = OperandSizeToValue(mov_size);
		result_size = 0;
		if (result_size > operand_size) //-V547
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size)
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		AddReadCommand(osByte, registr_cryptor, reg2);
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otBaseRegistr | otRegistr, size, (regESP << 4) | reg2), IntelOperand(otRegistr, size, reg1));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor); //-V547
		opcode_list_.Add(cmPop, otRegistr, size, 0, opcode_entry, registr_cryptor, end_cryptor);
	}

	// push value
	for (s = osByte; s <= cpu_address_size; s++) {
		size = static_cast<OperandSize>(s);
		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
		if (ctx.options.flags & cpEncryptBytecode) {
			value_cryptor = new OpcodeCryptor();
			cryptor_list_.push_back(value_cryptor);
			value_cryptor->Init(size);
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = AddReadCommand(size, value_cryptor, reg1);
		mov_size = (size == osByte) ? osWord : size;
		operand_size = 0;
		result_size = OperandSizeToValue(mov_size);
		if (result_size > operand_size)
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size) //-V547
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, mov_size, stack_registr_), IntelOperand(otRegistr, mov_size, reg1));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
		opcode_list_.Add(cmPush, otValue, size, 0, opcode_entry, value_cryptor, end_cryptor);
	}

	// push [address]
	for (s = osByte; s <= cpu_address_size; s++) {
		size = static_cast<OperandSize>(s);
		mov_size = (size == osByte) ? osWord : size;
		for (seg = segES; seg <= segGS; seg++) {
			if (seg != segDS && seg != segSS && !visible_opcode_list.GetOpcodeInfo(cmPush, otMemory, size, seg))
				continue;

			IntelRegistrList registr_list = free_registr_list_;
			reg1 = registr_list.GetRandom();
			reg2 = registr_list.GetRandom();
			if (ctx.options.flags & cpEncryptBytecode) {
				if (type_ == vtAdvanced) {
					end_cryptor = new OpcodeCryptor();
					cryptor_list_.push_back(end_cryptor);
					end_cryptor->Init(osDWord);
				}
			}
			opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
			command = processor_->AddCommand((mov_size == size) ? cmMov : cmMovzx, IntelOperand(otRegistr, mov_size, reg2), IntelOperand(otMemory | otRegistr, size, reg1));
			if (seg != segDS)
				command->set_base_segment(static_cast<IntelSegment>(seg));
			operand_size = OperandSizeToValue(cpu_address_size);
			result_size = OperandSizeToValue(mov_size);
			if (result_size > operand_size)
				processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
			else if (result_size < operand_size)
				processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
			processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, mov_size, stack_registr_), IntelOperand(otRegistr, mov_size, reg2));
			AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
			opcode_list_.Add(cmPush, otMemory, size, seg, opcode_entry, NULL, end_cryptor);
		}
	}

	// pop [address]
	for (s = osByte; s <= cpu_address_size; s++) {
		size = static_cast<OperandSize>(s);
		mov_size = (size == osByte) ? osWord : size;
		for (seg = segES; seg <= segGS; seg++) {
			if (seg != segDS && seg != segSS && !visible_opcode_list.GetOpcodeInfo(cmPop, otMemory, size, seg))
				continue;

			IntelRegistrList registr_list = free_registr_list_;
			reg1 = registr_list.GetRandom();
			reg2 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
			if (ctx.options.flags & cpEncryptBytecode) {
				if (type_ == vtAdvanced) {
					end_cryptor = new OpcodeCryptor();
					cryptor_list_.push_back(end_cryptor);
					end_cryptor->Init(osDWord);
				}
			}
			opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, reg2), IntelOperand(otMemory | otRegistr | otValue, size, stack_registr_, OperandSizeToValue(cpu_address_size)));
			operand_size = OperandSizeToValue(cpu_address_size) + OperandSizeToValue(mov_size);
			result_size = 0;
			if (result_size > operand_size) //-V547
				processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
			else if (result_size < operand_size)
				processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
			command = processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, size, reg1), IntelOperand(otRegistr, size, reg2));
			if (seg != segDS)
				command->set_base_segment(static_cast<IntelSegment>(seg));
			AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor); //-V547
			opcode_list_.Add(cmPop, otMemory, size, seg, opcode_entry, NULL, end_cryptor);
		}
	}

	// push segment registr
	for (seg = segES; seg <= segGS; seg++) {
		if (!visible_opcode_list.GetOpcodeInfo(cmPush, otSegmentRegistr, osWord, seg))
			continue;

		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom();
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, osWord, reg1), IntelOperand(otSegmentRegistr, osWord, seg));
		operand_size = 0;
		result_size = OperandSizeToValue(osWord);
		if (result_size > operand_size)
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size) //-V547
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osWord, stack_registr_), IntelOperand(otRegistr, osWord, reg1));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
		opcode_list_.Add(cmPush, otSegmentRegistr, osWord, seg, opcode_entry, NULL, end_cryptor);
	}

	// pop segment registr
	for (seg = segES; seg <= segGS; seg++) {
		if (seg == segCS || !visible_opcode_list.GetOpcodeInfo(cmPop, otSegmentRegistr, osWord, seg))
			continue;

		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom();
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, osWord, reg1), IntelOperand(otMemory | otRegistr, osWord, stack_registr_));
		operand_size = OperandSizeToValue(osWord);
		result_size = 0;
		if (result_size > operand_size) //-V547
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size)
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmMov, IntelOperand(otSegmentRegistr, osWord, seg), IntelOperand(otRegistr, osWord, reg1));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor); //-V547
		opcode_list_.Add(cmPop, otSegmentRegistr, osWord, seg, opcode_entry, NULL, end_cryptor);
	}

	size_t debug_reg_count = 8;

	// push debug registr
	for (i = 0; i < debug_reg_count; i++) {
		if (!visible_opcode_list.GetOpcodeInfo(cmPush, otDebugRegistr, cpu_address_size, (uint8_t)i))
			continue;

		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom();
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otDebugRegistr, cpu_address_size, (uint8_t)i));
		operand_size = 0;
		result_size = OperandSizeToValue(cpu_address_size);
		if (result_size > operand_size)
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size) //-V547
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_), IntelOperand(otRegistr, cpu_address_size, reg1));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
		opcode_list_.Add(cmPush, otDebugRegistr, cpu_address_size, (uint8_t)i, opcode_entry, NULL, end_cryptor);
	}

	// pop debug registr
	for (i = 0; i < debug_reg_count; i++) {
		if (!visible_opcode_list.GetOpcodeInfo(cmPop, otDebugRegistr, cpu_address_size, (uint8_t)i))
			continue;

		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom();
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
		operand_size = OperandSizeToValue(cpu_address_size);
		result_size = 0;
		if (result_size > operand_size) //-V547
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size)
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		command = processor_->AddCommand(cmMov, IntelOperand(otDebugRegistr, cpu_address_size, (uint8_t)i), IntelOperand(otRegistr, cpu_address_size, reg1));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor); //-V547
		opcode_list_.Add(cmPop, otDebugRegistr, cpu_address_size, (uint8_t)i, opcode_entry, NULL, end_cryptor);
	}

	size_t control_reg_count = cpu_address_size == osDWord ? 8 : 9;

	// push control registr
	for (i = 0; i < control_reg_count; i++) {
		if (!visible_opcode_list.GetOpcodeInfo(cmPush, otControlRegistr, cpu_address_size, (uint8_t)i))
			continue;

		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom();
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otControlRegistr, cpu_address_size, (uint8_t)i));
		operand_size = 0;
		result_size = OperandSizeToValue(cpu_address_size);
		if (result_size > operand_size)
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size) //-V547
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_), IntelOperand(otRegistr, cpu_address_size, reg1));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
		opcode_list_.Add(cmPush, otControlRegistr, cpu_address_size, (uint8_t)i, opcode_entry, NULL, end_cryptor);
	}

	// pop control registr
	for (i = 0; i < control_reg_count; i++) {
		if (!visible_opcode_list.GetOpcodeInfo(cmPop, otControlRegistr, cpu_address_size, (uint8_t)i))
			continue;

		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom();
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
		operand_size = OperandSizeToValue(cpu_address_size);
		result_size = 0;
		if (result_size > operand_size) //-V547
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size)
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		command = processor_->AddCommand(cmMov, IntelOperand(otControlRegistr, cpu_address_size, (uint8_t)i), IntelOperand(otRegistr, cpu_address_size, reg1));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor); //-V547
		opcode_list_.Add(cmPop, otControlRegistr, cpu_address_size, (uint8_t)i, opcode_entry, NULL, end_cryptor);
	}

	// push ESP
	for (s = osWord; s <= cpu_address_size; s++) {
		size = static_cast<OperandSize>(s);
		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom();
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otRegistr, cpu_address_size, stack_registr_));
		operand_size = 0;
		result_size = OperandSizeToValue(size);
		if (result_size > operand_size)
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size) //-V547
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, size, stack_registr_), IntelOperand(otRegistr, size, reg1));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
		opcode_list_.Add(cmPush, otRegistr, size, 0xFF, opcode_entry, NULL, end_cryptor);
	}

	// pop ESP
	for (s = osWord; s <= cpu_address_size; s++) {
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		size = static_cast<OperandSize>(s);
		opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, stack_registr_), IntelOperand(otMemory | otRegistr, size, stack_registr_));
		AddEndHandlerCommands(check_stack, end_cryptor);
		opcode_list_.Add(cmPop, otRegistr, size, 0xFF, opcode_entry, NULL, end_cryptor);
	}

	// add
	for (s = osByte; s <= cpu_address_size; s++) {
		size = static_cast<OperandSize>(s);
		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
		reg2 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		mov_size = (size == osByte) ? osWord : size;
		opcode_entry = processor_->AddCommand((mov_size == size) ? cmMov : cmMovzx, IntelOperand(otRegistr, mov_size, reg1), IntelOperand(otMemory | otRegistr, size, stack_registr_));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, reg2), IntelOperand(otMemory | otRegistr | otValue, size, stack_registr_, OperandSizeToValue(mov_size)));
		operand_size = OperandSizeToValue(mov_size);
		result_size = OperandSizeToValue(cpu_address_size);
		if (result_size > operand_size)
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size)
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmAdd, IntelOperand(otRegistr, size, reg1), IntelOperand(otRegistr, size, reg2));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, mov_size, stack_registr_, OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, mov_size, reg1));
		processor_->AddCommand(cmPushf, IntelOperand(otNone, cpu_address_size));
		processor_->AddCommand(cmPop, IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
		opcode_list_.Add(cmAdd, otNone, size, true, opcode_entry, NULL, end_cryptor);
	}

	// nor
	for (s = osByte; s <= cpu_address_size; s++) {
		size = static_cast<OperandSize>(s);
		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
		reg2 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		mov_size = (size == osByte) ? osWord : size;
		opcode_entry = processor_->AddCommand((mov_size == size) ? cmMov : cmMovzx, IntelOperand(otRegistr, mov_size, reg1), IntelOperand(otMemory | otRegistr, size, stack_registr_));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, reg2), IntelOperand(otMemory | otRegistr | otValue, size, stack_registr_, OperandSizeToValue(mov_size)));
		operand_size = OperandSizeToValue(mov_size);
		result_size = OperandSizeToValue(cpu_address_size);
		if (result_size > operand_size)
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size)
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmNot, IntelOperand(otRegistr, size, reg1));
		processor_->AddCommand(cmNot, IntelOperand(otRegistr, size, reg2));
		processor_->AddCommand(cmAnd, IntelOperand(otRegistr, size, reg1), IntelOperand(otRegistr, size, reg2));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, mov_size, stack_registr_, OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, mov_size, reg1));
		processor_->AddCommand(cmPushf, IntelOperand(otNone, cpu_address_size));
		processor_->AddCommand(cmPop, IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
		opcode_list_.Add(cmNor, otNone, size, true, opcode_entry, NULL, end_cryptor);
	}

	// nand
	for (s = osByte; s <= cpu_address_size; s++) {
		size = static_cast<OperandSize>(s);
		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
		reg2 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		mov_size = (size == osByte) ? osWord : size;
		opcode_entry = processor_->AddCommand((mov_size == size) ? cmMov : cmMovzx, IntelOperand(otRegistr, mov_size, reg1), IntelOperand(otMemory | otRegistr, size, stack_registr_));
		processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, reg2), IntelOperand(otMemory | otRegistr | otValue, size, stack_registr_, OperandSizeToValue(mov_size)));
		operand_size = OperandSizeToValue(mov_size);
		result_size = OperandSizeToValue(cpu_address_size);
		if (result_size > operand_size)
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size)
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmNot, IntelOperand(otRegistr, size, reg1));
		processor_->AddCommand(cmNot, IntelOperand(otRegistr, size, reg2));
		processor_->AddCommand(cmOr, IntelOperand(otRegistr, size, reg1), IntelOperand(otRegistr, size, reg2));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, mov_size, stack_registr_, OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, mov_size, reg1));
		processor_->AddCommand(cmPushf, IntelOperand(otNone, cpu_address_size));
		processor_->AddCommand(cmPop, IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
		opcode_list_.Add(cmNand, otNone, size, true, opcode_entry, NULL, end_cryptor);
	}

	// shl, shr
	for (i = 0; i < 2; i++) {
		command_type = (i == 0) ? cmShl : cmShr;
		for (s = osByte; s <= cpu_address_size; s++) {
			size = static_cast<OperandSize>(s);
			IntelRegistrList registr_list = free_registr_list_;
			registr_list.remove(regECX);
			reg1 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
			if (ctx.options.flags & cpEncryptBytecode) {
				if (type_ == vtAdvanced) {
					end_cryptor = new OpcodeCryptor();
					cryptor_list_.push_back(end_cryptor);
					end_cryptor->Init(osDWord);
				}
			}
			mov_size = (size == osByte) ? osWord : size;
			opcode_entry = processor_->AddCommand((mov_size == size) ? cmMov : cmMovzx, IntelOperand(otRegistr, mov_size, reg1), IntelOperand(otMemory | otRegistr, size, stack_registr_));
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, osByte, regECX), IntelOperand(otMemory | otRegistr | otValue, osByte, stack_registr_, OperandSizeToValue(mov_size)));
			operand_size = OperandSizeToValue(osWord);
			result_size = OperandSizeToValue(cpu_address_size);
			if (result_size > operand_size)
				processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
			else if (result_size < operand_size)
				processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
			processor_->AddCommand(command_type, IntelOperand(otRegistr, size, reg1), IntelOperand(otRegistr, osByte, regECX));
			processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, mov_size, stack_registr_, OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, mov_size, reg1));
			processor_->AddCommand(cmPushf, IntelOperand(otNone, cpu_address_size));
			processor_->AddCommand(cmPop, IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
			AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
			opcode_list_.Add(command_type, otNone, size, true, opcode_entry, NULL, end_cryptor);
		}
	}

	// rcl, rcr
	for (i = 0; i < 2; i++) {
		command_type = (i == 0) ? cmRcl : cmRcr;
		for (s = osByte; s <= cpu_address_size; s++) {
			size = static_cast<OperandSize>(s);
			if (!visible_opcode_list.GetOpcodeInfo(command_type, otNone, size, true))
				continue;

			IntelRegistrList registr_list = free_registr_list_;
			registr_list.remove(regECX);
			reg1 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
			if (ctx.options.flags & cpEncryptBytecode) {
				if (type_ == vtAdvanced) {
					end_cryptor = new OpcodeCryptor();
					cryptor_list_.push_back(end_cryptor);
					end_cryptor->Init(osDWord);
				}
			}
			mov_size = (size == osByte) ? osWord : size;
			opcode_entry = processor_->AddCommand((mov_size == size) ? cmMov : cmMovzx, IntelOperand(otRegistr, mov_size, reg1), IntelOperand(otMemory | otRegistr, size, stack_registr_));
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, osWord, regECX), IntelOperand(otMemory | otRegistr | otValue, osWord, stack_registr_, OperandSizeToValue(mov_size)));
			operand_size = OperandSizeToValue(osWord);
			result_size = OperandSizeToValue(cpu_address_size);
			if (result_size > operand_size)
				processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
			else if (result_size < operand_size)
				processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
			processor_->AddCommand(cmShr, IntelOperand(otHiPartRegistr, osByte, regECX), IntelOperand(otValue, osByte, 0, 1));
			processor_->AddCommand(command_type, IntelOperand(otRegistr, size, reg1), IntelOperand(otRegistr, osByte, regECX));
			processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, mov_size, stack_registr_, OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, mov_size, reg1));
			processor_->AddCommand(cmPushf, IntelOperand(otNone, cpu_address_size));
			processor_->AddCommand(cmPop, IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
			AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
			opcode_list_.Add(command_type, otNone, size, true, opcode_entry, NULL, end_cryptor);
		}
	}

	// shld, shrd
	for (i = 0; i < 2; i++) {
		command_type = (i == 0) ? cmShld : cmShrd;
		for (s = osDWord; s <= cpu_address_size; s++) {
			size = static_cast<OperandSize>(s);
			IntelRegistrList registr_list = free_registr_list_;
			registr_list.remove(regECX);
			reg1 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
			reg2 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
			if (ctx.options.flags & cpEncryptBytecode) {
				if (type_ == vtAdvanced) {
					end_cryptor = new OpcodeCryptor();
					cryptor_list_.push_back(end_cryptor);
					end_cryptor->Init(osDWord);
				}
			}
			opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, reg1), IntelOperand(otMemory | otRegistr, size, stack_registr_));
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, reg2), IntelOperand(otMemory | otRegistr | otValue, size, stack_registr_, OperandSizeToValue(size)));
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, osByte, regECX), IntelOperand(otMemory | otRegistr | otValue, osByte, stack_registr_, OperandSizeToValue(size) * 2));
			operand_size = OperandSizeToValue(size) + OperandSizeToValue(osWord);
			result_size = OperandSizeToValue(cpu_address_size);
			if (result_size > operand_size)
				processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
			else if (result_size < operand_size)
				processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
			processor_->AddCommand(command_type, IntelOperand(otRegistr, size, reg1), IntelOperand(otRegistr, size, reg2), IntelOperand(otRegistr, osByte, regECX));
			processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, size, stack_registr_, OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, size, reg1));
			processor_->AddCommand(cmPushf, IntelOperand(otNone, cpu_address_size));
			processor_->AddCommand(cmPop, IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
			AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
			opcode_list_.Add(command_type, otNone, size, true, opcode_entry, NULL, end_cryptor);
		}
	}

	// div, idiv
	for (i = 0; i < 2; i++) {
		command_type = (i == 0) ? cmDiv : cmIdiv;
		for (s = osByte; s <= cpu_address_size; s++) {
			size = static_cast<OperandSize>(s);
			if (!visible_opcode_list.GetOpcodeInfo(command_type, otNone, size, true))
				continue;

			if (ctx.options.flags & cpEncryptBytecode) {
				if (type_ == vtAdvanced) {
					end_cryptor = new OpcodeCryptor();
					cryptor_list_.push_back(end_cryptor);
					end_cryptor->Init(osDWord);
				}
			}
			mov_size = (size == osByte) ? osWord : size;
			if (size == osByte) {
				opcode_entry = processor_->AddCommand(cmMovzx, IntelOperand(otRegistr, mov_size, regEAX), IntelOperand(otMemory | otRegistr, size, stack_registr_));
				processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, regECX), IntelOperand(otMemory | otRegistr | otValue, size, stack_registr_, OperandSizeToValue(mov_size)));
			}
			else {
				opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, regEAX), IntelOperand(otMemory | otRegistr | otValue, size, stack_registr_, OperandSizeToValue(size)));
				processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, regEDX), IntelOperand(otMemory | otRegistr, size, stack_registr_));
				processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, regECX), IntelOperand(otMemory | otRegistr | otValue, size, stack_registr_, OperandSizeToValue(size) * 2));
			}
			operand_size = OperandSizeToValue(mov_size);
			result_size = OperandSizeToValue(cpu_address_size);
			if (result_size > operand_size)
				processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
			else if (result_size < operand_size)
				processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
			processor_->AddCommand(command_type, IntelOperand(otRegistr, size, regECX));
			if (size == osByte) {
				processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, mov_size, stack_registr_, OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, mov_size, regEAX));
			}
			else {
				processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, mov_size, stack_registr_, OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, size, regEDX));
				processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, mov_size, stack_registr_, OperandSizeToValue(cpu_address_size) + OperandSizeToValue(mov_size)), IntelOperand(otRegistr, size, regEAX));
			}
			processor_->AddCommand(cmPushf, IntelOperand(otNone, cpu_address_size));
			processor_->AddCommand(cmPop, IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
			AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
			opcode_list_.Add(command_type, otNone, size, true, opcode_entry, NULL, end_cryptor);
		}
	}

	// mul, imul
	for (i = 0; i < 2; i++) {
		command_type = (i == 0) ? cmMul : cmImul;
		for (s = osByte; s <= cpu_address_size; s++) {
			size = static_cast<OperandSize>(s);
			if (!visible_opcode_list.GetOpcodeInfo(command_type, otNone, size, true))
				continue;

			if (ctx.options.flags & cpEncryptBytecode) {
				if (type_ == vtAdvanced) {
					end_cryptor = new OpcodeCryptor();
					cryptor_list_.push_back(end_cryptor);
					end_cryptor->Init(osDWord);
				}
			}
			mov_size = (size == osByte) ? osWord : size;
			opcode_entry = processor_->AddCommand((mov_size == size) ? cmMov : cmMovzx, IntelOperand(otRegistr, mov_size, regEAX), IntelOperand(otMemory | otRegistr | otValue, size, stack_registr_, OperandSizeToValue(mov_size)));
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, regEDX), IntelOperand(otMemory | otRegistr, size, stack_registr_));
			operand_size = (size == osByte) ? OperandSizeToValue(mov_size) : 0;
			result_size = OperandSizeToValue(cpu_address_size);
			if (result_size > operand_size)
				processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
			else if (result_size < operand_size)
				processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
			processor_->AddCommand(command_type, IntelOperand(otRegistr, size, regEDX));
			if (size == osByte) {
				processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, mov_size, stack_registr_, OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, mov_size, regEAX));
			}
			else {
				processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, mov_size, stack_registr_, OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, mov_size, regEDX));
				processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, mov_size, stack_registr_, OperandSizeToValue(cpu_address_size) + OperandSizeToValue(mov_size)), IntelOperand(otRegistr, mov_size, regEAX));
			}
			processor_->AddCommand(cmPushf, IntelOperand(otNone, cpu_address_size));
			processor_->AddCommand(cmPop, IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
			AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
			opcode_list_.Add(command_type, otNone, size, true, opcode_entry, NULL, end_cryptor);
		}
	}

	// fild, fld, fadd, fsub, fsubr, fstp, fst, fist, fistp, fdiv, fmul, fcomp, fstcw, fldcw, fstsw
	for (i = 0; i < 33; i++) {
		switch (i) {
		case 0:
			command_type = cmFild;
			size = osWord;
			break;
		case 1:
			command_type = cmFild;
			size = osDWord;
			break;
		case 2:
			command_type = cmFild;
			size = osQWord;
			break;
		case 3:
			command_type = cmFld;
			size = osDWord;
			break;
		case 4:
			command_type = cmFld;
			size = osQWord;
			break;
		case 5:
			command_type = cmFld;
			size = osTByte;
			break;
		case 6:
			command_type = cmFadd;
			size = osDWord;
			break;
		case 7:
			command_type = cmFadd;
			size = osQWord;
			break;
		case 8:
			command_type = cmFsub;
			size = osDWord;
			break;
		case 9:
			command_type = cmFsub;
			size = osQWord;
			break;
		case 10:
			command_type = cmFsubr;
			size = osDWord;
			break;
		case 11:
			command_type = cmFsubr;
			size = osQWord;
			break;
		case 12:
			command_type = cmFstp;
			size = osDWord;
			break;
		case 13:
			command_type = cmFstp;
			size = osQWord;
			break;
		case 14:
			command_type = cmFstp;
			size = osTByte;
			break;
		case 15:
			command_type = cmFst;
			size = osDWord;
			break;
		case 16:
			command_type = cmFst;
			size = osQWord;
			break;
		case 17:
			command_type = cmFist;
			size = osWord;
			break;
		case 18:
			command_type = cmFist;
			size = osDWord;
			break;
		case 19:
			command_type = cmFistp;
			size = osWord;
			break;
		case 20:
			command_type = cmFistp;
			size = osDWord;
			break;
		case 21:
			command_type = cmFistp;
			size = osQWord;
			break;
		case 22:
			command_type = cmFisub;
			size = osWord;
			break;
		case 23:
			command_type = cmFisub;
			size = osDWord;
			break;
		case 24:
			command_type = cmFdiv;
			size = osDWord;
			break;
		case 25:
			command_type = cmFdiv;
			size = osQWord;
			break;
		case 26:
			command_type = cmFmul;
			size = osDWord;
			break;
		case 27:
			command_type = cmFmul;
			size = osQWord;
			break;
		case 28:
			command_type = cmFcomp;
			size = osDWord;
			break;
		case 29:
			command_type = cmFcomp;
			size = osQWord;
			break;
		case 30:
			command_type = cmFstcw;
			size = osWord;
			break;
		case 31:
			command_type = cmFldcw;
			size = osWord;
			break;
		case 32:
			command_type = cmFstsw;
			size = osWord;
			break;
		}
		if (!visible_opcode_list.GetOpcodeInfo(command_type, otNone, size, 0))
			continue;

		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(command_type, IntelOperand(otMemory | otRegistr, size, stack_registr_));
		AddEndHandlerCommands(read_opcode, end_cryptor);
		opcode_list_.Add(command_type, otNone, size, 0, opcode_entry, NULL, end_cryptor);
	}

	// wait, fchs, fsqrt, f2xm1, fabs, fclex, fcos, fdecstp, fincstp, finit, fldln2, fldz, fld1, fldpi, fpatan, fprem, fprem1, fptan, frndint, fsin, ftst, fyl2x, fldlg2
	for (i = 0; i < 24; i++) {
		switch (i) {
		case 0:
			command_type = cmWait;
			break;
		case 1:
			command_type = cmFchs;
			break;
		case 2:
			command_type = cmFsqrt;
			break;
		case 3:
			command_type = cmF2xm1;
			break;
		case 4:
			command_type = cmFabs;
			break;
		case 5:
			command_type = cmFclex;
			break;
		case 6:
			command_type = cmFcos;
			break;
		case 7:
			command_type = cmFdecstp;
			break;
		case 8:
			command_type = cmFincstp;
			break;
		case 9:
			command_type = cmFinit;
			break;
		case 10:
			command_type = cmFldln2;
			break;
		case 12:
			command_type = cmFldz;
			break;
		case 13:
			command_type = cmFld1;
			break;
		case 14:
			command_type = cmFldpi;
			break;
		case 15:
			command_type = cmFpatan;
			break;
		case 16:
			command_type = cmFprem;
			break;
		case 17:
			command_type = cmFprem1;
			break;
		case 18:
			command_type = cmFptan;
			break;
		case 19:
			command_type = cmFrndint;
			break;
		case 20:
			command_type = cmFsin;
			break;
		case 21:
			command_type = cmFtst;
			break;
		case 22:
			command_type = cmFyl2x;
			break;
		case 23:
			command_type = cmFldlg2;
			break;
		}
		if (!visible_opcode_list.GetOpcodeInfo(command_type, otNone, cpu_address_size, 0))
			continue;

		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(command_type);
		AddEndHandlerCommands(read_opcode, end_cryptor);
		opcode_list_.Add(command_type, otNone, cpu_address_size, 0, opcode_entry, NULL, end_cryptor);
	}

	// ret, iret
	for (j = 0; j < 3; j++) {
		command_type = (j == 1) ? cmIret : cmRet;
		if (j > 0 && !visible_opcode_list.GetOpcodeInfo(command_type, otNone, cpu_address_size, (j == 2) ? 1 : 0))
			continue;

		opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regESP), IntelOperand(otRegistr, cpu_address_size, stack_registr_));

		for (i = registr_order_.size(); i > 0; i--) {
			uint8_t reg = registr_order_[i - 1];
			if (reg == regEFX) {
				processor_->AddCommand(cmPopf);
			}
			else {
				processor_->AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size, reg));
			}
		}

		command = processor_->AddCommand(command_type);
		if (j == 2)
			command->include_option(roFar);
		opcode_list_.Add(command_type, otNone, cpu_address_size, (command->options() & roFar) ? 1 : 0, opcode_entry);
	}

	// popf
	{
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(cmPush, IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
		operand_size = OperandSizeToValue(cpu_address_size);
		result_size = 0;
		if (result_size > operand_size) //-V547
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size)
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmPopf, IntelOperand(otNone, cpu_address_size));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor); //-V547
		opcode_list_.Add(cmPopf, otNone, cpu_address_size, 0, opcode_entry, NULL, end_cryptor);
	}

	// jmp
	for (i = 0; i < ctx.options.vm_count; i++) {
		IntelRegistrList registr_list = free_registr_list_;
		reg1 = registr_list.GetRandom();
		opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
		processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, OperandSizeToStack(cpu_address_size)));
		command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
		command->AddLink(0, ltJmp);
		vm_links_.push_back(command);

		opcode_list_.Add(cmJmp, otNone, cpu_address_size, (uint8_t)i + 1, opcode_entry);
	}

	// rdtsc
	if (visible_opcode_list.GetOpcodeInfo(cmRdtsc, otNone, cpu_address_size, 0)) {
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(cmRdtsc);
		operand_size = 0;
		result_size = OperandSizeToValue(osDWord) * 2;
		if (result_size > operand_size)
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size) //-V547
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osDWord, stack_registr_), IntelOperand(otRegistr, osDWord, regEDX));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osDWord, stack_registr_, OperandSizeToValue(osDWord)), IntelOperand(otRegistr, osDWord, regEAX));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
		opcode_list_.Add(cmRdtsc, otNone, cpu_address_size, 0, opcode_entry, NULL, end_cryptor);
	}

	// cpuid
	if (visible_opcode_list.GetOpcodeInfo(cmCpuid, otNone, cpu_address_size, 0)) {
		if (stack_registr_ == regEBX) {
			IntelRegistrList registr_list = free_registr_list_;
			registr_list.remove(regEAX);
			registr_list.remove(regEBX);
			registr_list.remove(regECX);
			registr_list.remove(regEDX);
			reg1 = registr_list.GetRandom();
		}
		else
			reg1 = stack_registr_;
		if (ctx.options.flags & cpEncryptBytecode) {
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otMemory | otRegistr, osDWord, stack_registr_));
		if (reg1 != stack_registr_)
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otRegistr, cpu_address_size, stack_registr_));
		if (IsRegistrUsed(regEBX))
			processor_->AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, regEBX));
		processor_->AddCommand(cmCpuid);
		operand_size = OperandSizeToValue(osDWord);
		result_size = OperandSizeToValue(osDWord) * 4;
		if (result_size > operand_size)
			processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
		else if (result_size < operand_size)
			processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osDWord, reg1, OperandSizeToValue(osDWord) * 3), IntelOperand(otRegistr, osDWord, regEAX));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osDWord, reg1, OperandSizeToValue(osDWord) * 2), IntelOperand(otRegistr, osDWord, regEBX));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, osDWord, reg1, OperandSizeToValue(osDWord)), IntelOperand(otRegistr, osDWord, regECX));
		processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osDWord, reg1), IntelOperand(otRegistr, osDWord, regEDX));
		if (IsRegistrUsed(regEBX))
			processor_->AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size, regEBX));
		if (reg1 != stack_registr_)
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otRegistr, cpu_address_size, reg1));
		AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
		opcode_list_.Add(cmCpuid, otNone, cpu_address_size, 0, opcode_entry, NULL, end_cryptor);
	}

	// call
	if (visible_opcode_list.GetOpcodeInfo(cmCall, otNone, cpu_address_size, 0)) {
		IntelRegistrList registr_list = free_registr_list_;
		registr_list.remove(regEBP);
		reg1 = registr_list.GetRandom(cpu_address_size == osDWord);
		if (ctx.options.flags & cpEncryptBytecode) {
			value_cryptor = new OpcodeCryptor();
			cryptor_list_.push_back(value_cryptor);
			value_cryptor->Init(osByte);
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		opcode_entry = AddReadCommand(osByte, value_cryptor, reg1);
		AddCallCommands(ctx.file->calling_convention(), NULL, reg1);
		AddEndHandlerCommands(read_opcode, end_cryptor);
		opcode_list_.Add(cmCall, otNone, cpu_address_size, 0, opcode_entry, value_cryptor, end_cryptor);
	}

	// syscall
	if (visible_opcode_list.GetOpcodeInfo(cmSyscall, otNone, cpu_address_size, 0)) {
		IntelRegistrList registr_list = free_registr_list_;
		registr_list.remove(regEBP);
		reg1 = registr_list.GetRandom(cpu_address_size == osDWord);
		if (ctx.options.flags & cpEncryptBytecode) {
			value_cryptor = new OpcodeCryptor();
			cryptor_list_.push_back(value_cryptor);
			value_cryptor->Init(osByte);
			if (type_ == vtAdvanced) {
				end_cryptor = new OpcodeCryptor();
				cryptor_list_.push_back(end_cryptor);
				end_cryptor->Init(osDWord);
			}
		}
		c = processor_->count();
		if (cpu_address_size == osDWord) {
			// x32
			IntelVirtualMachineProcessor *new_processor = function_list->AddProcessor(osDWord);
			new_processor->set_compilation_type(ctVirtualization);

			command = new_processor->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regEDX), IntelOperand(otRegistr, cpu_address_size, regESP));
			new_processor->AddCommand(cmSysenter);
			new_processor->AddCommand(cmRet);

			IntelCommand *sysenter_entry = new_processor->AddCommand(cmCall, IntelOperand(otValue, cpu_address_size));
			sysenter_entry->AddLink(0, ltCall, command);
			new_processor->AddCommand(cmRet);

			IntelVirtualMachineProcessor *old_processor = processor_;
			processor_ = new_processor;

			opcode_entry = AddReadCommand(osByte, value_cryptor, reg1);
			processor_->AddCommand(cmTest, IntelOperand(otMemory | otRegistr, osDWord, stack_registr_), IntelOperand(otValue, osDWord, 0, WOW64_FLAG));
			IntelCommand *cmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size));
			cmp_command->set_flags(fl_Z);
			cmp_command->include_option(roInverseFlag);
			cmp_command->AddLink(0, ltJmpWithFlag);
			AddCallCommands(ctx.file->calling_convention(), sysenter_entry, reg1);
			AddEndHandlerCommands(read_opcode, end_cryptor);

			jmp_command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
			jmp_command->AddLink(0, ltJmp);
			cmp_command->link()->set_to_command(jmp_command);

			size_t old_count = processor_->count();
			command = processor_->AddCommand(cmPush, IntelOperand(otSegmentRegistr, cpu_address_size, segCS, 0));
			jmp_command->link()->set_to_command(command);
			IntelCommand *ret_offset_command = processor_->AddCommand(cmPush, IntelOperand(otValue, cpu_address_size, 0, 0, NEED_FIXUP));
			ret_offset_command->AddLink(0, ltOffset);
			IntelCommand *far_call = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size, 0, 0, NEED_FIXUP), IntelOperand(otValue, osWord, 0, 0x33));
			far_call->AddLink(0, ltGateOffset);
			far_call->include_option(roFar);
			command = processor_->AddCommand(cmNop);
			ret_offset_command->link()->set_to_command(command);

			// AMD bug
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, osWord, regECX), IntelOperand(otSegmentRegistr, osWord, segSS));
			processor_->AddCommand(cmMov, IntelOperand(otSegmentRegistr, osWord, segSS), IntelOperand(otRegistr, osWord, regECX));
			jmp_command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
			jmp_command->AddLink(0, ltGateOffset);

			CommandBlock *block = NULL;
			for (i = old_count; i < processor_->count(); i++) {
				if (!block)
					block = processor_->AddBlock(i, true);
				command = processor_->item(i);
				command->set_block(block);
				block->set_end_index(i);
				if (command->is_end())
					block = NULL;
			}

			old_count = processor_->count();
			AddEndHandlerCommands(read_opcode, end_cryptor);
			jmp_command->link()->set_to_command(processor_->item(old_count));

			// x64
			new_processor = function_list->AddProcessor(osQWord);
			new_processor->set_compilation_type(ctVirtualization);

			IntelCommand *syscall_entry = new_processor->AddCommand(cmMov, IntelOperand(otRegistr, osQWord, regR10), IntelOperand(otRegistr, osQWord, regECX));
			new_processor->AddCommand(cmSyscall);
			new_processor->AddCommand(cmRet);

			processor_ = new_processor;

			old_count = new_processor->count();
			AddCallCommands(ccStdcallToMSx64, syscall_entry, reg1);
			command = processor_->AddCommand(cmRet);
			command->include_option(roFar);
			far_call->link()->set_to_command(processor_->item(old_count));

			processor_ = old_processor;

			jmp_command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
			jmp_command->AddLink(0, ltJmp, opcode_entry);
			opcode_entry = jmp_command;
		}
		else {
			IntelVirtualMachineProcessor *new_processor = function_list->AddProcessor(osQWord);
			new_processor->set_compilation_type(ctVirtualization);
			IntelVirtualMachineProcessor *old_processor = processor_;
			processor_ = new_processor;

			IntelCommand *call_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, regR10), IntelOperand(otRegistr, cpu_address_size, regECX));
			processor_->AddCommand(cmSyscall);
			processor_->AddCommand(cmRet);

			opcode_entry = AddReadCommand(osByte, value_cryptor, reg1);
			AddCallCommands(ctx.file->calling_convention(), call_entry, reg1);
			AddEndHandlerCommands(read_opcode, end_cryptor);

			processor_ = old_processor;

			jmp_command = processor_->AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size));
			jmp_command->AddLink(0, ltJmp, opcode_entry);
			opcode_entry = jmp_command;
		}
		opcode_list_.Add(cmSyscall, otNone, cpu_address_size, 0, opcode_entry, value_cryptor, end_cryptor);
	}

	// crc
	if (visible_opcode_list.GetOpcodeInfo(cmCrc, otNone, cpu_address_size, 0)) {
		c = (type_ == vtAdvanced) ? 10 : 1;
		for (size_t k = 0; k < c; k++) {
			j = processor_->count();
			uint32_t crc_table_salt = rand32();
			for (i = 0; i < _countof(crc32_table); i++) {
				command = processor_->AddCommand(osDWord, crc32_table[i] ^ crc_table_salt);
				command->include_option(roNeedCRC);
			}
			IntelCommand *crc_table_entry = processor_->item(j);
			crc_table_entry->include_option(roCreateNewBlock);
			crc_table_entry->set_alignment(OperandSizeToValue(cpu_address_size));

			IntelRegistrList registr_list = free_registr_list_;
			registr_list.remove(regESI);
			reg1 = registr_list.GetRandom();
			reg2 = registr_list.GetRandom();
			reg3 = registr_list.GetRandom();
			reg4 = 0;
			if (ctx.options.flags & cpEncryptBytecode) {
				if (type_ == vtAdvanced) {
					end_cryptor = new OpcodeCryptor();
					cryptor_list_.push_back(end_cryptor);
					end_cryptor->Init(osDWord);
				}
			}

			opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
			processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg2), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size, stack_registr_, OperandSizeToValue(cpu_address_size)));
			operand_size = OperandSizeToValue(cpu_address_size) * 2;
			result_size = OperandSizeToValue(osDWord);
			if (result_size > operand_size)
				processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
			else if (result_size < operand_size)
				processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));

			//processor_->AddCommand(cmInt, IntelOperand(otValue, osWord, 0, 3));

			processor_->AddCommand(cmXor, IntelOperand(otRegistr, osDWord, reg3), IntelOperand(otRegistr, osDWord, reg3));
			processor_->AddCommand(cmTest, IntelOperand(otRegistr, cpu_address_size, reg2), IntelOperand(otRegistr, cpu_address_size, reg2));
			IntelCommand *jmp_command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size, 0, 0));
			jmp_command->set_flags(fl_Z);
			jmp_command->AddLink(0, ltJmpWithFlag);

			if (cpu_address_size == osQWord) {
				reg4 = registr_list.GetRandom();
				command = processor_->AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size, reg4), IntelOperand(otMemory | otValue, cpu_address_size, 0, 0, LARGE_VALUE));
				command->AddLink(1, ltOffset, crc_table_entry);
			}
			if (IsRegistrUsed(regESI))
				processor_->AddCommand(cmPush, IntelOperand(otRegistr, cpu_address_size, regESI));

			IntelCommand *loop_command = processor_->AddCommand(cmMovzx, IntelOperand(otRegistr, osDWord, regESI), IntelOperand(otMemory | otRegistr, osByte, reg1));
			processor_->AddCommand(cmXor, IntelOperand(otRegistr, osDWord, regESI), IntelOperand(otRegistr, osDWord, reg3));
			processor_->AddCommand(cmAnd, IntelOperand(otRegistr, osDWord, regESI), IntelOperand(otValue, osDWord, 0, 0xff));

			if (cpu_address_size == osQWord) {
				command = processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regESI), IntelOperand(otMemory | otBaseRegistr | otRegistr, osDWord, (reg4 << 4) | regESI, 0));
				command->set_operand_scale(1, 2);
			}
			else {
				command = processor_->AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regESI), IntelOperand(otMemory | otRegistr | otValue, osDWord, regESI, 0, NEED_FIXUP));
				command->set_operand_scale(1, 2);
				command->AddLink(1, ltOffset, crc_table_entry);
			}

			processor_->AddCommand(cmShr, IntelOperand(otRegistr, osDWord, reg3), IntelOperand(otValue, osByte, 0, 8));
			processor_->AddCommand(cmXor, IntelOperand(otRegistr, osDWord, reg3), IntelOperand(otRegistr, osDWord, regESI));
			processor_->AddCommand(cmInc, IntelOperand(otRegistr, cpu_address_size, reg1));
			processor_->AddCommand(cmXor, IntelOperand(otRegistr, osDWord, reg3), IntelOperand(otValue, osDWord, 0, crc_table_salt));
			processor_->AddCommand(cmDec, IntelOperand(otRegistr, cpu_address_size, reg2));

			command = processor_->AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size, 0, 0));
			command->set_flags(fl_Z);
			command->include_option(roInverseFlag);
			command->AddLink(0, ltJmpWithFlag, loop_command);

			if (IsRegistrUsed(regESI))
				processor_->AddCommand(cmPop, IntelOperand(otRegistr, cpu_address_size, regESI));

			command = processor_->AddCommand(cmNot, IntelOperand(otRegistr, osDWord, reg3));
			jmp_command->link()->set_to_command(command);

			processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, osDWord, stack_registr_), IntelOperand(otRegistr, osDWord, reg3));

			AddEndHandlerCommands(read_opcode, end_cryptor);
			opcode_list_.Add(cmCrc, otNone, cpu_address_size, 0, opcode_entry, NULL, end_cryptor);
		}
	}

	if (ctx.options.flags & cpMemoryProtection) {
		for (i = 0; i < opcode_list_.count(); i++) {
			IntelOpcodeInfo *opcode = opcode_list_.item(i);
			if (opcode->command_type() == cmCpuid || opcode->command_type() == cmRdtsc || opcode->command_type() == cmCrc || opcode->command_type() == cmSyscall) {
				for (j = processor_->IndexOf(opcode->entry()); j < processor_->count(); j++) {
					command = processor_->item(j);
					bool need_crc = true;
					if ((ctx.options.flags & cpStripFixups) == 0) {
						for (c = 0; c < 3; c++) {
							IntelOperand operand = command->operand(c);
							if (operand.type == otNone)
								break;

							if ((operand.type & otValue) && operand.fixup) {
								need_crc = false;
								break;
							}
						}
					}

					if (need_crc)
						command->include_option(roNeedCRC);
					if (command->type() == cmJmp || command->type() == cmRet || command->type() == cmIret)
						break;
				}
			}
		}
	}

	// lock
	for (i = 0; i < 7; i++) {
		switch (i) {
		case 0:
			command_type = cmAdd;
			break;
		case 1:
			command_type = cmSub;
			break;
		case 2:
			command_type = cmAnd;
			break;
		case 3:
			command_type = cmXor;
			break;
		case 4:
			command_type = cmOr;
			break;
		case 5:
			command_type = cmXchg;
			break;
		case 6:
			command_type = cmXadd;
			break;
		}
		for (s = osByte; s <= cpu_address_size; s++) {
			size = static_cast<OperandSize>(s);
			mov_size = (size == osByte) ? osWord : size;
			for (seg = segES; seg <= segGS; seg++) {
				if (!visible_opcode_list.GetOpcodeInfo(command_type, otMemory, size, seg))
					continue;

				IntelRegistrList registr_list = free_registr_list_;
				reg1 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
				reg2 = registr_list.GetRandom(size == osByte && cpu_address_size == osDWord);
				if (ctx.options.flags & cpEncryptBytecode) {
					if (type_ == vtAdvanced) {
						end_cryptor = new OpcodeCryptor();
						cryptor_list_.push_back(end_cryptor);
						end_cryptor->Init(osDWord);
					}
				}

				opcode_entry = processor_->AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size, reg1), IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
				processor_->AddCommand(cmMov, IntelOperand(otRegistr, size, reg2), IntelOperand(otMemory | otRegistr | otValue, size, stack_registr_, OperandSizeToValue(cpu_address_size)));
				operand_size = OperandSizeToValue(cpu_address_size) + OperandSizeToValue(mov_size);
				result_size = (command_type == cmXchg) ? 0 : OperandSizeToValue(cpu_address_size);
				if (command_type == cmXchg || command_type == cmXadd)
					result_size += OperandSizeToValue(mov_size);
				if (result_size > operand_size)
					processor_->AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, result_size - operand_size));
				else if (result_size < operand_size)
					processor_->AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size, stack_registr_), IntelOperand(otValue, cpu_address_size, 0, operand_size - result_size));
				command = processor_->AddCommand(command_type, IntelOperand(otMemory | otRegistr, size, reg1), IntelOperand(otRegistr, size, reg2));
				command->include_option(roLockPrefix);
				if (seg != segDS)
					command->set_base_segment(static_cast<IntelSegment>(seg));
				if (command_type == cmXchg)
					processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr, mov_size, stack_registr_), IntelOperand(otRegistr, mov_size, reg2));
				else {
					if (command_type == cmXadd)
						processor_->AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, mov_size, stack_registr_, OperandSizeToValue(cpu_address_size)), IntelOperand(otRegistr, mov_size, reg2));
					processor_->AddCommand(cmPushf, IntelOperand(otNone, cpu_address_size));
					processor_->AddCommand(cmPop, IntelOperand(otMemory | otRegistr, cpu_address_size, stack_registr_));
				}
				AddEndHandlerCommands((result_size > operand_size) ? check_stack : read_opcode, end_cryptor);
				opcode_list_.Add(command_type, otMemory, size, seg, opcode_entry, NULL, end_cryptor);
			}
		}
	}

	// randomize opcodes
	if (type_ == vtAdvanced) {
		c = opcode_list_.count();
		for (i = 0; i < c; i++) {
			opcode = opcode_list_.item(i);
			if (opcode->command_type() == cmNop || opcode->command_type() == cmJmp || opcode->command_type() == cmCrc)
				continue;

			for (j = 0; j < 10; j++) {
				opcode_list_.Add(opcode->command_type(), opcode->operand_type(), opcode->size(), opcode->value(), CloneHandler(opcode->entry()), opcode->value_cryptor(), opcode->end_cryptor());
			}
		}
	}
	else {
		c = opcode_list_.count();
		for (i = 0; i < opcode_list_.count(); i++) {
			opcode_list_.SwapObjects(i, rand() % c);
		}
		for (i = opcode_list_.count(); i < 0x100; i++) {
			opcode = opcode_list_.item(rand() % i);
			opcode_list_.Add(opcode->command_type(), opcode->operand_type(), opcode->size(), opcode->value(), (opcode->command_type() == cmJmp) ? opcode->entry() : CloneHandler(opcode->entry()), opcode->value_cryptor(), opcode->end_cryptor());
		}

		// CASEs
		c = processor_->count();
		command_type = (cpu_address_size == osDWord) ? cmDD : cmDQ;
		for (i = 0; i < opcode_list_.count(); i++) {
			IntelOpcodeInfo *opcode = opcode_list_.item(i);
			opcode->set_opcode(static_cast<uint8_t>(i));
			command = processor_->AddCommand(command_type, IntelOperand(otValue, cpu_address_size, 0, 0, NEED_FIXUP));
			CommandLink *link = command->AddLink(0, ltCase, opcode->entry());
			link->set_parent_command(switch_entry);
		}
		command = processor_->item(c);
		command->set_alignment(OperandSizeToValue(cpu_address_size));
		switch_entry->link()->set_to_command(command);
	}
}

IntelOpcodeInfo *IntelVirtualMachine::GetOpcode(IntelCommandType command_type, OperandType operand_type, OperandSize size, uint8_t value)
{
	IntelOpcodeInfo *res = NULL;
	uint64_t key = IntelOpcodeInfo::Key(command_type, operand_type, size, value);
	auto it = opcode_stack_.find(key);
	if (it != opcode_stack_.end()) 
		res = it->second.Next();
	return res;
}

static void EncryptBuffer(uint32_t *buffer, uint64_t key)
{
	uint32_t key0 = static_cast<uint32_t>(key >> 32);
	uint32_t key1 = static_cast<uint32_t>(key);
	buffer[0] = _rotr32(buffer[0] - key0, 7) ^ key1;
	buffer[1] = _rotr32(buffer[1] - key0, 11) ^ key1;
	buffer[2] = _rotr32(buffer[2] - key0, 17) ^ key1;
	buffer[3] = _rotr32(buffer[3] - key0, 23) ^ key1;
}

void IntelVirtualMachine::CompileCommand(IntelVMCommand &vm_command)
{
	IntelCommandType command_type = vm_command.command_type();
	OperandType operand_type = vm_command.operand_type();
	uint8_t registr = vm_command.registr();
	OperandSize size = vm_command.size();
	uint64_t value = vm_command.value();
	CommandBlock *block = vm_command.owner()->block();
	Data dump;
	bool backward_direction = (vm_command.owner()->section_options() & rtBackwardDirection) != 0;
	IntelOpcodeInfo *opcode = NULL;

	switch (command_type) {
	case cmPush:
		switch (operand_type) {
		case otRegistr: 
			if (registr == regESP && (size == osWord || size == osDWord || size == osQWord)) {
				opcode = GetOpcode(cmPush, otRegistr, size, 0xFF);
			} else {
				opcode = GetOpcode(cmPush, otRegistr, size, 0);
				dump.PushByte(block->GetRegistr(size, registr, false));
			}
			break;
		case otHiPartRegistr:
			opcode = GetOpcode(cmPush, otRegistr, size, 0);
			dump.PushByte((uint8_t)(block->GetRegistr(size, registr, false) + OperandSizeToValue(size)));
			break;
   		case otMemory:
			opcode = GetOpcode(cmPush, otMemory, size, vm_command.base_segment());
			break;
   		case otSegmentRegistr:
			opcode = GetOpcode(cmPush, otSegmentRegistr, size, registr);
			break;
   		case otDebugRegistr:
			opcode = GetOpcode(cmPush, otDebugRegistr, size, registr);
			break;
		case otControlRegistr:
			opcode = GetOpcode(cmPush, otControlRegistr, size, registr);
			break;
		case otValue:
			opcode = GetOpcode(cmPush, otValue, size, 0);

			uint64_t new_value;
			if (vm_command.crypt_command() == cmXadd) {
				uint32_t crypted_value[4];
				size_t i;
				for (i = 0; i < _countof(crypted_value); i++) {
					crypted_value[i] = rand32();
				}
				switch (vm_command.crypt_size()) {
				case osDWord:
					crypted_value[3] = static_cast<uint32_t>(value);
					break;
				case osQWord:
					*reinterpret_cast<uint64_t*>(&crypted_value[2]) = value;
					break;
				}
				uint32_t dw = 0;
				for (i = 1; i < 4; i++) {
					dw += crypted_value[i];
				}
				crypted_value[0] = 0 - dw;
				EncryptBuffer(crypted_value, vm_command.crypt_key());
				IntelVMCommand *link_command = vm_command.link_command();
				for (i = 3; i > 0; i--) {
					link_command->set_value(crypted_value[i - 1]);
					link_command->Compile();
					link_command = link_command->link_command();
				}
				new_value = crypted_value[3];
			} else {
				new_value = value;
			}

			new_value -= vm_command.sub_value();
				
			switch (size) {
			case osByte:
				dump.PushByte(static_cast<uint8_t>(new_value));
				break;
			case osWord:
				dump.PushWord(backward_direction ? __builtin_bswap16(static_cast<uint16_t>(new_value)) : static_cast<uint16_t>(new_value));
				break;
			case osDWord:
				dump.PushDWord(backward_direction ? __builtin_bswap32(static_cast<uint32_t>(new_value)) : static_cast<uint32_t>(new_value));
				break;
			case osQWord:
				dump.PushQWord(backward_direction ? __builtin_bswap64(new_value) : new_value);
				break;
			}
			break;
		}
		break;

	case cmPop:
		switch (operand_type) {
		case otRegistr: 
			if (registr == regESP && (size == osWord || size == osDWord || size == osQWord)) {
				opcode = GetOpcode(cmPop, otRegistr, size, 0xFF);
			} else {
				opcode = GetOpcode(cmPop, otRegistr, size, 0);
				dump.PushByte(block->GetRegistr(size, registr, true));
			}
			break;
		case otHiPartRegistr:
			opcode = GetOpcode(cmPop, otRegistr, size, 0);
			dump.PushByte((uint8_t)(block->GetRegistr(size, registr, true) + OperandSizeToValue(size)));
			break;
   		case otMemory:
			opcode = GetOpcode(cmPop, otMemory, size, vm_command.base_segment());
			break;
   		case otSegmentRegistr:
			opcode = GetOpcode(cmPop, otSegmentRegistr, size, registr);
			break;
   		case otDebugRegistr:
			opcode = GetOpcode(cmPop, otDebugRegistr, size, registr);
			break;
		case otControlRegistr:
			opcode = GetOpcode(cmPop, otControlRegistr, size, registr);
			break;
		}
		break;

	case cmCall:
		opcode = GetOpcode(cmCall, otNone, size, 0);
		dump.PushByte(vm_command.subtype());
		break;

	case cmSyscall:
		opcode = GetOpcode(cmSyscall, otNone, size, 0);
		dump.PushByte(vm_command.subtype());
		break;

	case cmJmp:
		if (vm_command.subtype())
			opcode = GetOpcode(command_type, otNone, size, vm_command.subtype());
		else
			opcode = GetOpcode(command_type, otNone, size, (vm_command.value() == 0) ? id() : static_cast<uint8_t>(vm_command.value()));
		break;

	case cmAdd: case cmSub: case cmXor: case cmOr: case cmXchg: case cmAnd: case cmXadd:
		if (vm_command.operand_type() == otMemory)
			opcode = GetOpcode(command_type, otMemory, size, vm_command.base_segment());
		else
			opcode = GetOpcode(command_type, otNone, size, vm_command.subtype());
		break;

	case cmNor: case cmNand: case cmCrc: case cmShld: case cmShrd: case cmShl: case cmShr: case cmDiv: 
	case cmIdiv: case cmMul: case cmImul: case cmRcl: case cmRcr:
	case cmPopf: case cmIret: case cmRet:
	case cmFadd: case cmFsub: case cmFisub: case cmFsubr: case cmFdiv: case cmFmul: case cmFcomp:
	case cmFstp: case cmFst: case cmFild: case cmFld: case cmFstcw: case cmFldcw: case cmFistp: case cmFist:
	case cmWait: case cmFstsw: case cmFchs: case cmFsqrt: case cmRdtsc: case cmCpuid:
	case cmF2xm1: case cmFabs: case cmFclex: case cmFcos: case cmFdecstp: case cmFincstp:
	case cmFinit: case cmFldln2: case cmFldlg2: case cmFprem: case cmFprem1: case cmFptan:
	case cmFrndint: case cmFsin: case cmFtst: case cmFyl2x: case cmFpatan: case cmFldz: case cmFld1: case cmFldpi:
		opcode = GetOpcode(command_type, otNone, size, vm_command.subtype());
		break;

	case cmDD:
		dump.PushDWord(static_cast<uint32_t>(value));
		break;

	case cmDQ:
		dump.PushQWord(value);
		break;

	default:
		opcode = NULL;
		break;
	}

	if (opcode) {
		vm_command.set_opcode(opcode);
		if (type() == vtAdvanced) {
			size_t i = vm_command.owner()->IndexOf(&vm_command);
			bool need_begin_offset;
			if (i == 0) {
				need_begin_offset = (vm_command.owner()->section_options() & (rtLinkedToInt | rtLinkedToExt)) != 0;
			} else {
				IntelVMCommand *prev_command = reinterpret_cast<IntelVMCommand *>(vm_command.owner()->item(i - 1));
				need_begin_offset = prev_command->is_end() || (prev_command->options() & voInitOffset);
			}

			if (need_begin_offset) {
				vm_command.include_option(voBeginOffset);
				uint32_t value = 0;
				dump.InsertBuff(0, &value, sizeof(value));
			}

			if (!vm_command.is_end()) {
				vm_command.include_option(voEndOffset);
				dump.PushDWord(0);
			}
		} else {
			dump.InsertByte(0, opcode->opcode());
		}
	} else if (!vm_command.is_data()) {
		throw std::runtime_error("Runtime error at CompileToVM: " + std::string(intel_command_name[command_type]));
	}

	vm_command.set_dump(dump);
}

std::vector<OpcodeCryptor *> IntelVirtualMachine::GetOpcodeCryptorList(IntelVMCommand *command)
{
	std::vector<OpcodeCryptor *> res;
	if (type_ == vtAdvanced) {
		if (command->options() & voBeginOffset)
			res.push_back(command_cryptor_);
	}
	else {
		res.push_back(command_cryptor_);
	}
	if (command->opcode()->value_cryptor())
		res.push_back(command->opcode()->value_cryptor());
	if (command->opcode()->end_cryptor())
		res.push_back(command->opcode()->end_cryptor());
	return res;
}

void IntelVirtualMachine::CompileBlock(CommandBlock &block, bool need_encrypt)
{
	size_t i, j, k, d, c;
	IntelFunction *func = reinterpret_cast<IntelFunction *>(block.function());
	if (type() == vtAdvanced) {
		IntelVMCommand *prev_command = NULL;
		IntelOpcodeInfo *nop_opcode = GetOpcode(cmNop, otNone, processor_->cpu_address_size(), 0);
		if (nop_opcode == NULL)
			throw std::runtime_error("Runtime error at CompileBlock/nop_opcode");

		for (i = block.start_index(); i <= block.end_index(); i++) {
			IntelCommand *command = func->item(i);
			for (j = 0; j < command->count(); j++) {
				IntelVMCommand *vm_command = command->item(j);
				if (vm_command->is_data())
					continue;

				if (prev_command && (prev_command->options() & voEndOffset)) {
					IntelOpcodeInfo *opcode = (prev_command->options() & voInitOffset) ? nop_opcode : vm_command->opcode();
					prev_command->set_dump_value(osDWord, prev_command->dump_size() - 4, static_cast<uint32_t>(opcode->entry()->address() - prev_command->opcode()->entry()->address()));
				}
				if (vm_command->options() & voBeginOffset)
					vm_command->set_dump_value(osDWord, 0, static_cast<uint32_t>(vm_command->opcode()->entry()->address() - nop_opcode->entry()->address()));
				prev_command = vm_command;
			}
		}
	}

	if (!need_encrypt)
		return;

	struct CRC {
		uint64_t Value;
		CRC()
			: Value(0)
		{

		}
		uint64_t GetValue(OperandSize size) const 
		{
			uint64_t res = 0;
			memcpy(&res, &Value, OperandSizeToValue(size));
			return res;
		}
		void SetValue(OperandSize size, uint64_t value) 
		{
			memcpy(&Value, &value, OperandSizeToValue(size));
		}
	};

	CRC crc, crc2;
	OperandSize os;
	OpcodeCryptor *cryptor;
	std::vector<OpcodeCryptor *> cryptor_list;
	std::vector<IVMCommand *> correct_command_list = block.correct_command_list();
	for (i = 0; i < correct_command_list.size(); i++) {
		IntelVMCommand *vm_command = reinterpret_cast<IntelVMCommand *>(correct_command_list[i]);
		IntelCommand *command = reinterpret_cast<IntelCommand *>(vm_command->owner());
		IntelVMCommand *ext_vm_entry = command->ext_vm_entry();
		bool use_ext_entry = ext_vm_entry && command->IndexOf(vm_command) < command->IndexOf(ext_vm_entry);

		size_t n = func->IndexOf(command) + 1;
		for (size_t r = n; r > block.start_index(); r--) {
			IntelCommand *cur_command = func->item(r - 1);
			if ((cur_command->section_options() & rtBeginSection) == 0)
				continue;

			crc.Value = cur_command->vm_address();
			crc2.Value = use_ext_entry ? command->ext_vm_address() : func->item(n)->vm_address();

			for (j = r - 1; j < n ; j++) {
				IntelCommand *tmp_command = func->item(j);
				for (k = 0; k < tmp_command->count(); k++) {
					IntelVMCommand *cur_vm_command = tmp_command->item(k);

					cryptor_list = GetOpcodeCryptorList(cur_vm_command);
					d = 0;
					for (c = 0; c < cryptor_list.size(); c++) {
						cryptor = cryptor_list[c];
						os = cryptor->size();
						crc.SetValue(os, cryptor->EncryptOpcode(crc.GetValue(os), cur_vm_command->dump_value(os, d)));
						d += OperandSizeToValue(os);
					}

					if (vm_command == cur_vm_command)
						break;
				}
			}

			size_t e = use_ext_entry ? command->IndexOf(ext_vm_entry) : command->count();

			for (k = e; k > 0; k--) {
				IntelVMCommand *cur_vm_command = command->item(k - 1);
				if (vm_command == cur_vm_command)
					break;

				cryptor_list = GetOpcodeCryptorList(cur_vm_command);
				d = cur_vm_command->dump_size();
				for (c = cryptor_list.size(); c > 0; c--) {
					cryptor = cryptor_list[c - 1];
					os = cryptor->size();
					crc2.SetValue(os, cryptor->DecryptOpcode(crc2.GetValue(os), cur_vm_command->dump_value(os, d - OperandSizeToValue(os))));
					d -= OperandSizeToValue(os);
				}
			}

			break;
		}

		if (type() == vtAdvanced) {
			j = (vm_command->options() & voBeginOffset) ? 4 : 0;
		} else {
			j = 1;
		}
		cryptor = vm_command->opcode()->value_cryptor();
		vm_command->set_dump_value(vm_command->size(), j, cryptor->EncryptOpcode(cryptor->DecryptOpcode(vm_command->dump_value(vm_command->size(), j), crc.Value), crc2.Value));
	}

	for (i = block.start_index(); i <= block.end_index(); i++) {
		IntelCommand *command = func->item(i);
		uint64_t address = command->vm_address();
		if (command->section_options() & rtBeginSection)
			crc.Value = command->vm_address();
		for (j = 0; j < command->count(); j++) {
			IntelVMCommand *vm_command = command->item(j);
			if (vm_command->is_data())
				continue;

			cryptor_list = GetOpcodeCryptorList(vm_command);
			d = 0;
			for (c = 0; c < cryptor_list.size(); c++) {
				cryptor = cryptor_list[c];
				os = cryptor->size();
				uint64_t old_value = vm_command->dump_value(os, d);
				vm_command->set_dump_value(os, d, cryptor->DecryptOpcode(cryptor->Decrypt(old_value), crc.Value));
				crc.SetValue(os, cryptor->EncryptOpcode(crc.Value, old_value));
				d += OperandSizeToValue(os);
			}

			if (vm_command->is_end()) {
				if (command->section_options() & rtBackwardDirection) {
					crc.Value = address - vm_command->dump_size();
				} else {
					crc.Value = address + vm_command->dump_size();
				}
			}

			if (command->section_options() & rtBackwardDirection) {
				address -= vm_command->dump_size();
			} else {
				address += vm_command->dump_size();
			}
		}
	}
}

void IntelVirtualMachine::AddExtJmpCommand(uint8_t id)
{
	IntelOpcodeInfo *opcode = GetOpcode(cmJmp, otNone, processor_->cpu_address_size(), id);
	if (!opcode)
		throw std::runtime_error("Runtime error at AddExtJmpCommand");
	if (type_ == vtAdvanced) {
		ext_jmp_command_ = new IntelCommand(NULL, processor_->cpu_address_size());
		ext_jmp_command_->set_address(opcode->entry()->address());
	}
	IntelOpcodeInfo *ext_jmp_opcode = opcode_list_.Add(cmJmp, otNone, processor_->cpu_address_size(), 0xff, (type() == vtAdvanced) ? ext_jmp_command_ : opcode->entry());
	ext_jmp_opcode->set_opcode(opcode->opcode());
	opcode_stack_[ext_jmp_opcode->Key()].push_back(ext_jmp_opcode);
}

/**
 * IntelVirtualMachineList
 */

IntelVirtualMachineList::IntelVirtualMachineList()
	: IVirtualMachineList()
{
	crc_manager_ = new MemoryManager(NULL);
}

IntelVirtualMachineList::~IntelVirtualMachineList()
{
	delete crc_manager_;
}

IntelVirtualMachineList *IntelVirtualMachineList::Clone() const
{
	IntelVirtualMachineList *list = new IntelVirtualMachineList();
	return list;
}

void IntelVirtualMachineList::Prepare(const CompileContext &ctx)
{
	size_t i;
	IntelOpcodeList visible_opcode_list;
	OperandSize cpu_address_size = ctx.file->cpu_address_size();

	VirtualMachineType type =
#ifdef DEMO
		true
#else
		((ctx.options.flags & cpUnregisteredVersion) != 0 || ((ctx.options.vm_flags & 1) != 0))
#endif	
		? vtClassic : vtAdvanced;

	if (ctx.runtime) {
		visible_opcode_list.Add(cmCall, otNone, cpu_address_size, 0);
		visible_opcode_list.Add(cmCpuid, otNone, cpu_address_size, 0);
		visible_opcode_list.Add(cmCrc, otNone, cpu_address_size, 0);
	}

	if (ctx.options.flags & cpMemoryProtection) {
		visible_opcode_list.Add(cmRdtsc, otNone, cpu_address_size, 0);
		visible_opcode_list.Add(cmDiv, otNone, osDWord, true);
		visible_opcode_list.Add(cmMul, otNone, osDWord, true);
	}

	IntelCommandInfoList command_info_list(cpu_address_size);

	size_t n = ctx.runtime ? 2 : 1;
	for (size_t k = 0; k < n; k++) {
		IntelFunctionList *function_list = (k == 0) ? reinterpret_cast<IntelFunctionList *>(ctx.file->function_list()) : reinterpret_cast<IntelFunctionList *>(ctx.runtime->function_list());

		for (size_t i = 0; i < function_list->count(); i++) {
			IntelFunction *func = function_list->item(i);

			if (func->compilation_type() == ctMutation || (k == 1 && func->tag() != ftLoader))
				continue;

			if (func->compilation_options() & coLockToKey)
				visible_opcode_list.Add(cmCall, otNone, cpu_address_size, 0);

			for (size_t j = 0; j < func->count(); j++) {
				IntelCommand *command = func->item(j);
				if (command->link() && command->link()->type() == ltNative)
					continue;

				if ((command->options() & roLockPrefix) && command->type() != cmXchg) {
					if (type == vtAdvanced) { //-V547
						bool native_found = true;
						switch (command->type()) {
						case cmAdd: case cmSub: case cmAnd: case cmOr: case cmXor: case cmXadd:
							if (command->operand(0).type & otMemory)
								native_found = false;
							break;
						}
						if (!native_found) {
							command->include_option(roNoNative);
							size_t n = (command->operand(0).type & otMemory) ? 0 : 1;
							visible_opcode_list.Add(static_cast<IntelCommandType>(command->type()), otMemory, command->operand(0).size, command->operand(n).effective_base_segment(command->base_segment()));
						}
					}
					continue;
				}
				else
					switch (command->type()) {
					case cmWait: case cmFchs: case cmFsqrt: case cmF2xm1:
					case cmFabs: case cmFclex: case cmFcos: case cmFdecstp:
					case cmFincstp: case cmFinit: case cmFldln2: case cmFldz:
					case cmFld1: case cmFldpi: case cmFpatan: case cmFprem:
					case cmFprem1: case cmFptan: case cmFrndint: case cmFsin:
					case cmFtst: case cmFyl2x: case cmFldlg2:
					case cmRdtsc: case cmPopf: case cmIret:
						visible_opcode_list.Add(static_cast<IntelCommandType>(command->type()), otNone, cpu_address_size, 0);
						break;

					case cmFild: case cmFld: case cmFadd: case cmFsub: case cmFsubr:
					case cmFstp: case cmFst: case cmFdiv: case cmFmul: case cmFcomp:
					case cmFistp: case cmFist: case cmFisub:
					case cmFstsw: case cmFldcw: case cmFstcw:
						visible_opcode_list.Add(static_cast<IntelCommandType>(command->type()), otNone, command->operand(0).size, 0);
						break;

					case cmDiv: case cmIdiv: case cmMul: case cmImul: case cmRcl: case cmRcr:
						visible_opcode_list.Add(static_cast<IntelCommandType>(command->type()), otNone, command->operand(0).size, true);
						break;

					case cmRet:
						if (command->options() & roFar)
							visible_opcode_list.Add(static_cast<IntelCommandType>(command->type()), otNone, cpu_address_size, 1);
						break;

					case cmCpuid:
						if (k == 1)
							visible_opcode_list.Add(static_cast<IntelCommandType>(command->type()), otNone, cpu_address_size, 0);
						break;

					case cmSyscall:
						if (k == 1)
							visible_opcode_list.Add(static_cast<IntelCommandType>(command->type()), otNone, cpu_address_size, 0);
						break;

					case cmXchg:
						if (((command->operand(0).type | command->operand(1).type) & otMemory) && type == vtAdvanced) {
							command->include_option(roNoNative);
							size_t n = (command->operand(0).type & otMemory) ? 0 : 1;
							visible_opcode_list.Add(static_cast<IntelCommandType>(command->type()), otMemory, command->operand(0).size, command->operand(n).effective_base_segment(command->base_segment()));
						}
						break;
					}

				if (command->GetCommandInfo(command_info_list)) {
					for (size_t n = 0; n < command_info_list.count(); n++) {
						CommandInfo *command_info = command_info_list.item(n);
						IntelCommandType command_type = (command_info->type() == atRead) ? cmPush : cmPop;

						switch (command_info->operand_type()) {
						case otSegmentRegistr:
							visible_opcode_list.Add(command_type, command_info->operand_type(), osWord, command_info->value());
							break;
						case otControlRegistr:
						case otDebugRegistr:
							visible_opcode_list.Add(command_type, command_info->operand_type(), cpu_address_size, command_info->value());
							break;
						case otMemory:
							if (command_info->size() > cpu_address_size) {
								visible_opcode_list.Add(command_type, command_info->operand_type(), cpu_address_size, command_info->value());
								if (command_info->size() == osTByte)
									visible_opcode_list.Add(command_type, command_info->operand_type(), osWord, command_info->value());
							}
							else {
								visible_opcode_list.Add(command_type, command_info->operand_type(), command_info->size(), command_info->value());
							}
							break;
						}
					}
				}
			}
		}
	}

	IntelFunctionList *function_list = reinterpret_cast<IntelFunctionList *>(ctx.file->function_list());
	IntelVirtualMachineProcessor *processor = function_list->AddProcessor(cpu_address_size);
	for (i = 0; i < ctx.options.vm_count; i++) {
		IntelVirtualMachine *virtual_machine = new IntelVirtualMachine(this, type, (uint8_t)i + 1, processor);
		AddObject(virtual_machine);
		virtual_machine->Init(ctx, visible_opcode_list);
	}

	std::vector<IFunction *> processor_list = function_list->processor_list();
	for (i = 0; i < processor_list.size(); i++) {
		IFunction *func = processor_list[i];
		if (func->compilation_type() != ctMutation && func->cpu_address_size() != cpu_address_size) {
			IntelVirtualMachineProcessor *new_processor = function_list->AddProcessor(func->cpu_address_size());
			IntelVirtualMachine *virtual_machine = new IntelVirtualMachine(this, type, 1, new_processor);
			AddObject(virtual_machine);
			CompileContext new_ctx;
			new_ctx.options.vm_count = 1;
#ifndef DEMO
			new_ctx.options.flags = ctx.options.flags & (cpUnregisteredVersion | cpEncryptBytecode);
#endif
			new_ctx.file = ctx.file;
			visible_opcode_list.clear();
			visible_opcode_list.Add(cmRet, otNone, osQWord, 1);
			if (ctx.options.flags & cpMemoryProtection) {
				visible_opcode_list.Add(cmRdtsc, otNone, osQWord, 0);
				visible_opcode_list.Add(cmDiv, otNone, osDWord, true);
				visible_opcode_list.Add(cmMul, otNone, osDWord, true);
				visible_opcode_list.Add(cmCrc, otNone, osQWord, 0);
			}
			virtual_machine->Init(new_ctx, visible_opcode_list);
			break;
		}
	}
	
	for (i = 0; i < count(); i++) {
		item(i)->Prepare(ctx);
	}
}

uint64_t IntelVirtualMachineList::GetCRCValue(uint64_t &crc_address, size_t size)
{
	size_t i, j;

	if (map_.empty()) {
		std::set<IntelFunction *> processor_list;
		for (i = 0; i < count(); i++) {
			IntelFunction *processor = item(i)->processor();
			if (processor_list.find(processor) != processor_list.end())
				continue;

			processor_list.insert(processor);
			for (j = 0; j < processor->count(); j++) {
				IntelCommand *command = processor->item(j);
				if (command->options() & roNeedCRC)
					map_[command->address()] = command;
			}
		}
	}

	crc_address = crc_manager_->Alloc(size, mtReadable);
	if (!crc_address) {
		crc_manager_->clear();
		for (std::map<uint64_t, ICommand *>::const_iterator it = map_.begin(); it != map_.end(); it++) {
			ICommand *command = it->second;
			crc_manager_->Add(command->address(), command->dump_size(), mtReadable);
		}
		crc_manager_->Pack();
		crc_address = crc_manager_->Alloc(size, mtReadable);
	}

	if (crc_address) {
		std::map<uint64_t, ICommand *>::const_iterator it = map_.upper_bound(crc_address);
		if (it != map_.begin())
			it--;

		uint64_t address = crc_address;
		uint64_t value = 0;
		uint8_t *ptr = reinterpret_cast<uint8_t *>(&value);
		uint8_t *ptr_end = ptr + size;
		while (it != map_.end()) {
			ICommand *command = it->second;
			if (command->address() <= address && command->next_address() > address) {
				for (j = static_cast<size_t>(address - command->address()); j < command->dump_size(); j++) {
					*ptr = command->dump(j);
					ptr++;
					address++;
					if (ptr == ptr_end)
						return value;
				}
			}
			it++;
		}
	}

	throw std::runtime_error("Runtime error at GetCRCValue");
}

void IntelVirtualMachineList::ClearCRCMap()
{
	map_.clear();
	crc_manager_->clear();
}

/**
 * IntelOpcodeInfo
 */

IntelOpcodeInfo::IntelOpcodeInfo(IntelOpcodeList *owner, IntelCommandType command_type, OperandType operand_type, OperandSize size, uint8_t value, 
	IntelCommand *entry, OpcodeCryptor *value_cryptor, OpcodeCryptor *end_cryptor)
	: IObject(), owner_(owner), command_type_(command_type), operand_type_(operand_type), size_(size), value_(value), entry_(entry), 
	value_cryptor_(value_cryptor), end_cryptor_(end_cryptor), opcode_(0)
{

}

IntelOpcodeInfo::~IntelOpcodeInfo()
{
	if (owner_)
		owner_->RemoveObject(this);
}

uint64_t IntelOpcodeInfo::Key()
{
	return Key(command_type(), operand_type(), size(), value_);
}

uint64_t IntelOpcodeInfo::Key(IntelCommandType command_type, OperandType operand_type, OperandSize size, uint8_t value)
{
	union
	{
		uint64_t result;
		struct  
		{
			uint32_t
				command_type:	10,
				operand_type:	14,
				value:			 8;
			uint32_t
				size:	 3,
				unused:	29;
		};
	} key;

	key.result = 0;

	assert(command_type < (1 << 10));
	key.command_type = command_type;
	assert(operand_type < (1 << 14));
	key.operand_type = operand_type;
	key.value = value;
	
	assert(size < (1 << 3));
	key.size = size;

	return key.result;
}

IntelOpcodeInfo *IntelOpcodeInfo::circular_queue::Next()
{
	IntelOpcodeInfo *res = NULL;
	if (size())
		res = this->operator[](position_++ % size());
	return res;
}

/**
 * IntelOpcodeInfoList
 */

IntelOpcodeList::IntelOpcodeList()
	: ObjectList<IntelOpcodeInfo>()
{

}

IntelOpcodeInfo *IntelOpcodeList::Add(IntelCommandType command_type, OperandType operand_type, OperandSize size, uint8_t value, IntelCommand *entry, OpcodeCryptor *value_cryptor, OpcodeCryptor *end_cryptor)
{
	if (!entry && GetOpcodeInfo(command_type, operand_type, size, value))
		return NULL;

	IntelOpcodeInfo *opcode = new IntelOpcodeInfo(this, command_type, operand_type, size, value, entry, value_cryptor, end_cryptor);
	AddObject(opcode);
	return opcode;
}

IntelOpcodeInfo *IntelOpcodeList::GetOpcodeInfo(IntelCommandType command_type, OperandType operand_type, OperandSize size, uint8_t value) const
{
	for (size_t i = 0; i < count(); i++) {
		IntelOpcodeInfo *opcode = item(i);
		if (opcode->command_type() == command_type && opcode->operand_type() == operand_type && opcode->size() == size && opcode->value() == value)
			return opcode;
	}
	return NULL;
}

/**
 * IntelVirtualMachineProcessor
 */

IntelVirtualMachineProcessor::IntelVirtualMachineProcessor(IntelFunctionList *owner, OperandSize cpu_address_size)
	: IntelFunction(owner, cpu_address_size)
{
	set_compilation_type(ctMutation);
	set_tag(ftProcessor);
}

bool IntelVirtualMachineProcessor::Prepare(const CompileContext &ctx)
{
	if (cpu_address_size() == ctx.file->cpu_address_size() && ctx.file->runtime_function_list())
		AddExceptionHandler(ctx);

	for (size_t i = 0; i < count(); i++) {
		IntelCommand *command = item(i);
		command->CompileToNative();
	}

	return IntelFunction::Prepare(ctx);
}

void IntelVirtualMachineProcessor::AddExceptionHandler(const CompileContext &ctx)
{
	size_t c = count();
	if (c == 0)
		return;

	switch (ctx.file->calling_convention()) {
	case ccMSx64:
		{
			// RCX: ExceptionRecord
			// RDX: EstablisherFrame
			// R8: ContextRecord
			// R9: DispatcherContext

			IntelCommand *command;
			size_t i, k;
			size_t context_registr_count = ((cpu_address_size() == osQWord) ? 24 : 16) + 8;

			IntelCommand *empty_unwind_command = AddCommand(cmRet);
			empty_unwind_command->include_option(roCreateNewBlock);

			IntelCommand *handler_entry = AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEAX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEDX, (context_registr_count - 8 + 0) * OperandSizeToValue(cpu_address_size())));
			AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regECX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regEDX, (context_registr_count - 8 + 1) * OperandSizeToValue(cpu_address_size())));

			AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size(), regECX), IntelOperand(otValue, cpu_address_size(), 0, 8));
			AddCommand(cmMov, IntelOperand(otMemory | otRegistr, cpu_address_size(), regECX), IntelOperand(otRegistr, cpu_address_size(), regEAX));

			command = AddCommand(cmAdd, IntelOperand(otRegistr, cpu_address_size(), regEDX), IntelOperand(otValue, cpu_address_size(), 0, (context_registr_count - 8 + 6) * OperandSizeToValue(cpu_address_size())));
			command = AddCommand(cmLea, IntelOperand(otRegistr, cpu_address_size(), regEAX), IntelOperand(otMemory | otValue, cpu_address_size(), 0, 0, LARGE_VALUE));
			command->AddLink(1, ltOffset, empty_unwind_command);
			IntelCommand *cmp_command = AddCommand(cmCmp, IntelOperand(otRegistr, cpu_address_size(), regECX), IntelOperand(otRegistr, cpu_address_size(), regEDX));
			IntelCommand *jmp_command = AddCommand(cmJmpWithFlag, IntelOperand(otValue, cpu_address_size()));
			jmp_command->set_flags(fl_C | fl_Z);
			jmp_command->AddLink(0, ltJmpWithFlag);
			AddCommand(cmSub, IntelOperand(otRegistr, cpu_address_size(), regECX), IntelOperand(otValue, cpu_address_size(), 0, 8));
			AddCommand(cmMov, IntelOperand(otMemory | otRegistr, cpu_address_size(), regECX), IntelOperand(otRegistr, cpu_address_size(), regEAX));
			command = AddCommand(cmJmp, IntelOperand(otValue, cpu_address_size()));
			command->AddLink(0, ltJmp, cmp_command);

			command = AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regECX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regR9, 0x28)); // DISPATCHER_CONTEXT.ContextRecord
			jmp_command->link()->set_to_command(command);
			AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEAX), IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regECX, offsetof(CONTEXT64, Rsp)));
			AddCommand(cmMov, IntelOperand(otRegistr, cpu_address_size(), regEAX), IntelOperand(otMemory | otRegistr, cpu_address_size(), regEAX));
			AddCommand(cmMov, IntelOperand(otMemory | otRegistr | otValue, cpu_address_size(), regECX, offsetof(CONTEXT64, Rip)), IntelOperand(otRegistr, cpu_address_size(), regEAX));

			command = AddCommand(cmMov, IntelOperand(otRegistr, osDWord, regEAX), IntelOperand(otValue, osDWord, 0, ExceptionContinueSearch));
			AddCommand(cmRet);

			k = count();

			UNWIND_CODE unwind_code;
			std::vector<UNWIND_CODE> unwind_code_list;

			unwind_code.CodeOffset = 5;
			unwind_code.UnwindOp = UWOP_ALLOC_LARGE;
			unwind_code.OpInfo = 0;
			unwind_code_list.push_back(unwind_code);

			unwind_code.FrameOffset = (USHORT)(context_registr_count - 8 + 2);
			unwind_code_list.push_back(unwind_code);

			unwind_code.CodeOffset = 4;
			unwind_code.UnwindOp = UWOP_PUSH_NONVOL;
			unwind_code.OpInfo = regEBP;
			unwind_code_list.push_back(unwind_code);

			unwind_code.CodeOffset = 3;
			unwind_code.UnwindOp = UWOP_PUSH_NONVOL;
			unwind_code.OpInfo = regESI;
			unwind_code_list.push_back(unwind_code);

			unwind_code.CodeOffset = 2;
			unwind_code.UnwindOp = UWOP_PUSH_NONVOL;
			unwind_code.OpInfo = regEDI;
			unwind_code_list.push_back(unwind_code);

			unwind_code.CodeOffset = 1;
			unwind_code.UnwindOp = UWOP_PUSH_NONVOL;
			unwind_code.OpInfo = regEBX;
			unwind_code_list.push_back(unwind_code);

			UNWIND_INFO unwind_info = UNWIND_INFO();
			unwind_info.Version = 1;
			unwind_info.Flags = UNW_FLAG_EHANDLER;
			unwind_info.CountOfCodes = static_cast<uint8_t>(unwind_code_list.size());

			union UNWIND_INFO_HELPER {
				UNWIND_INFO info;
				uint32_t value;
			};

			UNWIND_INFO_HELPER unwind_info_helper;
			unwind_info_helper.info = unwind_info;

			// unwind data
			IntelCommand *unwind_data_command = AddCommand(osDWord, unwind_info_helper.value);
			unwind_data_command->include_option(roCreateNewBlock);
			unwind_data_command->set_alignment(OperandSizeToValue(osDWord));
			for (i = 0; i < unwind_code_list.size(); i++) {
				AddCommand(osWord, unwind_code_list[i].FrameOffset);
			}
			if (unwind_code_list.size() & 1)
				AddCommand(osWord, 0);

			// handler
			command = AddCommand(osDWord, 0);
			CommandLink *link = command->AddLink(0, ltOffset, handler_entry);
			link->set_sub_value(ctx.file->image_base());
			// handler data
			AddCommand(osDWord, 0);

			uint64_t info_address = owner()->IndexOf(this) * 10;
			FunctionInfo *info = function_info_list()->Add(info_address, info_address, btImageBase, 0, 0, unwind_info.FrameRegister, 0, unwind_data_command);
			AddressRange *address_range = info->Add(0, 0, NULL, NULL, NULL);
			for (i = 0; i < c; i++) {
				item(i)->set_address_range(address_range);
			}

			unwind_info = UNWIND_INFO();
			unwind_info.Version = 1;
			unwind_info.Flags = UNW_FLAG_NHANDLER;

			unwind_info_helper.info = unwind_info;
			unwind_data_command = AddCommand(osDWord, unwind_info_helper.value);
			unwind_data_command->include_option(roCreateNewBlock);
			unwind_data_command->set_alignment(OperandSizeToValue(osDWord));

			info = function_info_list()->Add(info_address + 1, info_address + 1, btImageBase, 0, 0, 0, 0, unwind_data_command);
			address_range = info->Add(0, 0, NULL, NULL, NULL);
			empty_unwind_command->set_address_range(address_range);

			unwind_info = UNWIND_INFO();
			unwind_info.Version = 1;
			unwind_info.Flags = UNW_FLAG_NHANDLER;

			unwind_info_helper.info = unwind_info;
			unwind_data_command = AddCommand(osDWord, unwind_info_helper.value);
			unwind_data_command->include_option(roCreateNewBlock);
			unwind_data_command->set_alignment(OperandSizeToValue(osDWord));

			info = function_info_list()->Add(info_address + 2, info_address + 2, btImageBase, 0, 0, 0, 0, unwind_data_command);
			address_range = info->Add(0, 0, NULL, NULL, NULL);
			for (i = IndexOf(handler_entry); i < k; i++) {
				item(i)->set_address_range(address_range);
			}
		}
		break;
	}
}

/**
 * IntelVMCommand
 */

IntelVMCommand::IntelVMCommand(IntelCommand *owner, IntelCommandType command_type, OperandType operand_type, OperandSize size, uint64_t value, uint32_t options)
	: BaseVMCommand(owner), address_(0), command_type_(command_type), operand_type_(operand_type), size_(size), value_(0), registr_(0), subtype_(0), base_segment_(segDefault), options_(options),
	crypt_command_(cmUnknown), crypt_size_(osDefault), crypt_key_(0), link_command_(NULL), opcode_(NULL), sub_value_(0), fixup_(NULL)
{
	switch (operand_type_) { //-V719
	case otBaseRegistr:
	case otRegistr:
	case otHiPartRegistr:
	case otSegmentRegistr:
	case otDebugRegistr:
	case otControlRegistr:
		registr_ = static_cast<uint8_t>(value);
		break;
	case otValue:
		value_ = value;
		break;
	case otMemory:
		base_segment_ = static_cast<IntelSegment>(value);
		break;
	case otNone:
		subtype_ = static_cast<uint8_t>(value);
		break;
	}
};

IntelVMCommand::IntelVMCommand(IntelCommand *owner, const IntelVMCommand &src)
	: BaseVMCommand(owner), address_(0), link_command_(NULL)
{
	command_type_ = src.command_type_;
	operand_type_ = src.operand_type_;
	size_ = src.size_;
	value_ = src.value_;
	registr_ = src.registr_;
	subtype_ = src.subtype_;
	base_segment_ = src.base_segment_;
	options_ = src.options_;
	crypt_command_ = src.crypt_command_;
	crypt_size_ = src.crypt_size_;
	crypt_key_ = src.crypt_key_;
	dump_ = src.dump_;
	opcode_ = src.opcode_;
	sub_value_ = src.sub_value_;
	fixup_ = src.fixup_;
}

IntelVMCommand *IntelVMCommand::Clone(IntelCommand *owner)
{
	IntelVMCommand *vm_command = new IntelVMCommand(owner, *this);
	return vm_command;
}

void IntelVMCommand::WriteToFile(IArchitecture &file)
{
	if (!dump_.size())
		return;

	if (fixup_) {
		if (fixup_ == NEED_FIXUP) {
			ISection *segment = file.segment_list()->GetSectionByAddress(address_);
			fixup_ = file.fixup_list()->AddDefault(file.cpu_address_size(), segment && (segment->memory_type() & mtExecutable) != 0);
		}
		fixup_->set_address(address_);
	}

	if (owner()->section_options() & rtBackwardDirection) {
		for (size_t i = dump_.size(); i > 0; i--) {
			file.WriteByte(dump_[i - 1]);
		}
	} else {
		file.Write(dump_.data(), dump_.size());
	}
}

int IntelVMCommand::GetStackLevel() const
{
	int res = 0;
	OperandSize cpu_address_size = reinterpret_cast<IntelCommand *>(owner())->size();

	switch (command_type_) {
	case cmPush:
		if (operand_type_ == otMemory)
			res -= OperandSizeToStack(cpu_address_size);
		res += OperandSizeToStack(size_);
		break;
	case cmPop:
		if (operand_type_ == otMemory)
			res -= OperandSizeToStack(cpu_address_size);
		res -= OperandSizeToStack(size_);
		break;
	case cmJmp:
		res -= OperandSizeToStack(size_);
		break;
	case cmNor: case cmNand:
		res -= OperandSizeToStack(size_);
		res += OperandSizeToStack(cpu_address_size);
		break;
	case cmShl: case cmShr: case cmRcl: case cmRcr:
		res -= OperandSizeToStack(osWord);
		res += OperandSizeToStack(cpu_address_size);
		break;
	case cmPopf:
		res -= OperandSizeToStack(cpu_address_size);
		break;
	case cmShld: case cmShrd:
		res -= OperandSizeToStack(size_);
		res -= OperandSizeToStack(osWord);
		res += OperandSizeToStack(cpu_address_size);
		break;
	case cmDiv: case cmIdiv: case cmMul: case cmImul:
		if (size_ == osByte)
			res -= OperandSizeToStack(size_);
		res += OperandSizeToStack(cpu_address_size);
		break;
	case cmRdtsc:
		res -= OperandSizeToStack(osDWord) * 2;
		break;
	case cmCpuid:
		res -= OperandSizeToStack(osDWord);
		res += OperandSizeToStack(osDWord) * 4;
		break;
	case cmCall: case cmSyscall:
		res -= OperandSizeToStack(cpu_address_size) * subtype_;
		break;
	case cmCrc:
		res -= OperandSizeToStack(cpu_address_size) * 2;
		res += OperandSizeToStack(osDWord);
		break;
	case cmAnd: case cmSub: case cmAdd: case cmOr: case cmXor: case cmXchg: case cmXadd:
		if (operand_type_ == otMemory) {
			res -= OperandSizeToStack(size_);
			res -= OperandSizeToStack(cpu_address_size);
			if (command_type_ == cmXchg)
				res += OperandSizeToStack(size_);
			else {
				res += OperandSizeToStack(cpu_address_size);
				if (command_type_ == cmXadd)
					res += OperandSizeToStack(size_);
			}
		} else {
			res -= OperandSizeToStack(size_);
			res += OperandSizeToStack(cpu_address_size);
		}
		break;
	}

	return res;
}

void IntelVMCommand::Compile()
{
	reinterpret_cast<IntelVirtualMachine *>(owner()->block()->virtual_machine())->CompileCommand(*this);
}

uint64_t IntelVMCommand::CorrectDumpValue(OperandSize size, uint64_t value) const
{
	if (owner()->section_options() & rtBackwardDirection) {
		switch (size) {
		case osWord:
			value = __builtin_bswap16(static_cast<uint16_t>(value));
			break;
		case osDWord:
			value = __builtin_bswap32(static_cast<uint32_t>(value));
			break;
		case osQWord:
			value = __builtin_bswap64(value);
			break;
		}
	}

	return value;
}

uint64_t IntelVMCommand::dump_value(OperandSize size, size_t pos) const
{
	if (pos + OperandSizeToValue(size) > dump_.size())
		throw std::runtime_error("Index out of bounds");
	uint64_t res = 0;
	memcpy(&res, &dump_[pos], OperandSizeToValue(size));
	return CorrectDumpValue(size, res);
}

void IntelVMCommand::set_dump_value(OperandSize size, size_t pos, uint64_t value)
{
	if (pos + OperandSizeToValue(size) > dump_.size())
		throw std::runtime_error("Index out of bounds");
	value = CorrectDumpValue(size, value);
	memcpy(&dump_[pos], &value, OperandSizeToValue(size));
}

bool IntelVMCommand::can_merge(CommandInfoList &command_info_list) const
{
	CommandInfo *command_info;
	switch (command_type_) {
	case cmPush:
		switch (operand_type_) {
		case otRegistr:
			if (registr_ != regEmpty) {
				if (command_info_list.GetInfo(atWrite, otRegistr, registr_))
					return false;

				command_info = command_info_list.GetInfo(atWrite, otHiPartRegistr, registr_);
				if (command_info && size_ > command_info->size())
					return false;
			}
			break;

		case otHiPartRegistr:
			if (registr_ != regEmpty) {
				command_info = command_info_list.GetInfo(atWrite, otRegistr, registr_);
				if (command_info && size_ < command_info->size())
					return false;

				command_info = command_info_list.GetInfo(atWrite, otHiPartRegistr, registr_);
				if (command_info && size_ == command_info->size())
					return false;
			}
			break;

		case otSegmentRegistr: case otControlRegistr: case otDebugRegistr:
			if (command_info_list.GetInfo(atWrite, operand_type_, registr_))
				return false;
			break;

		case otMemory:
			if (base_segment_ == segFS || base_segment_ == segGS)
				return false;

			if (command_info_list.GetInfo(atWrite, otMemory))
				return false;

			break;
		}
		break;

	case cmPop:
		switch (operand_type_) {
		case otRegistr:
			if (registr_ == regESP || (registr_ & regExtended))
				return false;
			if (registr_ != regEmpty) {
				for (size_t i = 0; i < command_info_list.count(); i++) {
					command_info = command_info_list.item(i);
					if (command_info->operand_type() == otRegistr && command_info->value() == registr_) {
						return false;
					} else  if (command_info->operand_type() == otHiPartRegistr && command_info->value() == registr_) {
						if (size_ > command_info->size())
							return false;
					}
				}
			}
			break;

		case otHiPartRegistr:
			if (registr_ == regESP)
				return false;
			if (registr_ != regEmpty) {
				for (size_t i = 0; i < command_info_list.count(); i++) {
					command_info = command_info_list.item(i);
					if (command_info->operand_type() == otRegistr && command_info->value() == registr_) {
						if (size_ < command_info->size())
							return false;
					} else if (command_info->operand_type() == otHiPartRegistr && command_info->value() == registr_) {
						if (size_ == command_info->size())
							return false;
					}
				}
			}
			break;

		case otSegmentRegistr: case otControlRegistr: case otDebugRegistr:
			return false;
			break;

		case otMemory:
			if (base_segment_ == segFS || base_segment_ == segGS)
				return false;

			if (command_info_list.GetInfo(otMemory))
				return false;

			break;
		}

		break;

	case cmPopf:
		if (command_info_list.GetInfo(atWrite, otRegistr, regEFX))
			return false;
		break;

	case cmF2xm1: case cmFabs: case cmFclex: case cmFcos: case cmFdecstp: case cmFincstp:
	case cmFinit: case cmFldln2: case cmFldlg2: case cmFprem: case cmFprem1: case cmFptan:
	case cmFrndint: case cmFsin: case cmFtst: case cmFyl2x: case cmFpatan: case cmFldz: case cmFld1: case cmFldpi:
	case cmWait: case cmFchs: case cmFsqrt: case cmFstsw: 
	case cmFistp: case cmFstp: case cmFst: case cmFist: case cmFadd: case cmFsub: case cmFisub: case cmFsubr: case cmFdiv: case cmFmul: case cmFcomp:
	case cmFild: case cmFld:
		if (command_info_list.GetInfo(otFPURegistr))
			return false;
		break;

	case cmAdd: case cmSub: case cmAnd: case cmXor: case cmOr: case cmXchg: case cmXadd:
		if (operand_type_ == otMemory) {
			if (base_segment_ == segFS || base_segment_ == segGS)
				return false;

			if (command_info_list.GetInfo(otMemory))
				return false;
		}
		break;
	}

	return true;
}

bool IntelVMCommand::is_end() const
{
	return (command_type_ == cmJmp || command_type_ == cmRet || command_type_ == cmIret);
}

IntelOperand::IntelOperand(uint32_t type_, OperandSize size_, uint8_t registr_ /*= 0*/, uint64_t value_ /*= 0*/, IFixup *fixup_ /*= NULL*/)
{
	Clear();

	if (type_ == (otMemory | otRegistr) && registr_ == regEBP) {
		type_ = otMemory | otBaseRegistr |otValue;
		registr_ <<= 4;
	}

	type = type_;
	size = size_;
	registr = registr_ & 0x0f;
	base_registr = (registr_ & 0xf0) >> 4;
	value = value_;
	if (fixup_ == LARGE_VALUE) {
		is_large_value = true;
		value_size = osDWord;
	} else if (fixup_) {
		fixup = fixup_;
		value_size = (fixup == NEED_FIXUP) ? size_ : fixup->size();
	} else if ((type & (otMemory | otValue)) == (otMemory | otValue) && (type & (otRegistr | otBaseRegistr))) {
		value_size = (ByteToInt64(static_cast<uint8_t>(value)) == value) ? osByte : osDWord;
	} else {
		value_size = size_;
	}
}// SPDX-License-Identifier: GPL-2.0+
/*
 * Module-based torture test facility for locking
 *
 * Copyright (C) IBM Corporation, 2014
 *
 * Authors: Paul E. McKenney <paulmck@linux.ibm.com>
 *          Davidlohr Bueso <dave@stgolabs.net>
 *	Based on kernel/rcu/torture.c.
 */

#define pr_fmt(fmt) fmt

#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/kthread.h>
#include <linux/sched/rt.h>
#include <linux/spinlock.h>
#include <linux/mutex.h>
#include <linux/rwsem.h>
#include <linux/smp.h>
#include <linux/interrupt.h>
#include <linux/sched.h>
#include <uapi/linux/sched/types.h>
#include <linux/rtmutex.h>
#include <linux/atomic.h>
#include <linux/moduleparam.h>
#include <linux/delay.h>
#include <linux/slab.h>
#include <linux/torture.h>
#include <linux/reboot.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Paul E. McKenney <paulmck@linux.ibm.com>");

torture_param(int, acq_writer_lim, 0, "Write_acquisition time limit (jiffies).");
torture_param(int, call_rcu_chains, 0, "Self-propagate call_rcu() chains during test (0=disable).");
torture_param(int, long_hold, 100, "Do occasional long hold of lock (ms), 0=disable");
torture_param(int, nested_locks, 0, "Number of nested locks (max = 8)");
torture_param(int, nreaders_stress, -1, "Number of read-locking stress-test threads");
torture_param(int, nwriters_stress, -1, "Number of write-locking stress-test threads");
torture_param(int, onoff_holdoff, 0, "Time after boot before CPU hotplugs (s)");
torture_param(int, onoff_interval, 0, "Time between CPU hotplugs (s), 0=disable");
torture_param(int, rt_boost, 2,
		   "Do periodic rt-boost. 0=Disable, 1=Only for rt_mutex, 2=For all lock types.");
torture_param(int, rt_boost_factor, 50, "A factor determining how often rt-boost happens.");
torture_param(int, shuffle_interval, 3, "Number of jiffies between shuffles, 0=disable");
torture_param(int, shutdown_secs, 0, "Shutdown time (j), <= zero to disable.");
torture_param(int, stat_interval, 60, "Number of seconds between stats printk()s");
torture_param(int, stutter, 5, "Number of jiffies to run/halt test, 0=disable");
torture_param(int, verbose, 1, "Enable verbose debugging printk()s");
torture_param(int, writer_fifo, 0, "Run writers at sched_set_fifo() priority");
/* Going much higher trips "BUG: MAX_LOCKDEP_CHAIN_HLOCKS too low!" errors */
#define MAX_NESTED_LOCKS 8

static char *torture_type = IS_ENABLED(CONFIG_PREEMPT_RT) ? "raw_spin_lock" : "spin_lock";
module_param(torture_type, charp, 0444);
MODULE_PARM_DESC(torture_type,
		 "Type of lock to torture (spin_lock, spin_lock_irq, mutex_lock, ...)");

static cpumask_var_t bind_readers; // Bind the readers to the specified set of CPUs.
static cpumask_var_t bind_writers; // Bind the writers to the specified set of CPUs.

// Parse a cpumask kernel parameter.  If there are more users later on,
// this might need to got to a more central location.
static int param_set_cpumask(const char *val, const struct kernel_param *kp)
{
	cpumask_var_t *cm_bind = kp->arg;
	int ret;
	char *s;

	if (!alloc_cpumask_var(cm_bind, GFP_KERNEL)) {
		s = "Out of memory";
		ret = -ENOMEM;
		goto out_err;
	}
	ret = cpulist_parse(val, *cm_bind);
	if (!ret)
		return ret;
	s = "Bad CPU range";
out_err:
	pr_warn("%s: %s, all CPUs set\n", kp->name, s);
	cpumask_setall(*cm_bind);
	return ret;
}

// Output a cpumask kernel parameter.
static int param_get_cpumask(char *buffer, const struct kernel_param *kp)
{
	cpumask_var_t *cm_bind = kp->arg;

	return sprintf(buffer, "%*pbl", cpumask_pr_args(*cm_bind));
}

static bool cpumask_nonempty(cpumask_var_t mask)
{
	return cpumask_available(mask) && !cpumask_empty(mask);
}

static const struct kernel_param_ops lt_bind_ops = {
	.set = param_set_cpumask,
	.get = param_get_cpumask,
};

module_param_cb(bind_readers, &lt_bind_ops, &bind_readers, 0644);
module_param_cb(bind_writers, &lt_bind_ops, &bind_writers, 0644);

long torture_sched_setaffinity(pid_t pid, const struct cpumask *in_mask);

static struct task_struct *stats_task;
static struct task_struct **writer_tasks;
static struct task_struct **reader_tasks;

static bool lock_is_write_held;
static atomic_t lock_is_read_held;
static unsigned long last_lock_release;

struct lock_stress_stats {
	long n_lock_fail;
	long n_lock_acquired;
};

struct call_rcu_chain {
	struct rcu_head crc_rh;
	bool crc_stop;
};
struct call_rcu_chain *call_rcu_chain;

/* Forward reference. */
static void lock_torture_cleanup(void);

/*
 * Operations vector for selecting different types of tests.
 */
struct lock_torture_ops {
	void (*init)(void);
	void (*exit)(void);
	int (*nested_lock)(int tid, u32 lockset);
	int (*writelock)(int tid);
	void (*write_delay)(struct torture_random_state *trsp);
	void (*task_boost)(struct torture_random_state *trsp);
	void (*writeunlock)(int tid);
	void (*nested_unlock)(int tid, u32 lockset);
	int (*readlock)(int tid);
	void (*read_delay)(struct torture_random_state *trsp);
	void (*readunlock)(int tid);

	unsigned long flags; /* for irq spinlocks */
	const char *name;
};

struct lock_torture_cxt {
	int nrealwriters_stress;
	int nrealreaders_stress;
	bool debug_lock;
	bool init_called;
	atomic_t n_lock_torture_errors;
	struct lock_torture_ops *cur_ops;
	struct lock_stress_stats *lwsa; /* writer statistics */
	struct lock_stress_stats *lrsa; /* reader statistics */
};
static struct lock_torture_cxt cxt = { 0, 0, false, false,
				       ATOMIC_INIT(0),
				       NULL, NULL};
/*
 * Definitions for lock torture testing.
 */

static int torture_lock_busted_write_lock(int tid __maybe_unused)
{
	return 0;  /* BUGGY, do not use in real life!!! */
}

static void torture_lock_busted_write_delay(struct torture_random_state *trsp)
{
	/* We want a long delay occasionally to force massive contention.  */
	if (long_hold && !(torture_random(trsp) % (cxt.nrealwriters_stress * 2000 * long_hold)))
		mdelay(long_hold);
	if (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))
		torture_preempt_schedule();  /* Allow test to be preempted. */
}

static void torture_lock_busted_write_unlock(int tid __maybe_unused)
{
	  /* BUGGY, do not use in real life!!! */
}

static void __torture_rt_boost(struct torture_random_state *trsp)
{
	const unsigned int factor = rt_boost_factor;

	if (!rt_task(current)) {
		/*
		 * Boost priority once every rt_boost_factor operations. When
		 * the task tries to take the lock, the rtmutex it will account
		 * for the new priority, and do any corresponding pi-dance.
		 */
		if (trsp && !(torture_random(trsp) %
			      (cxt.nrealwriters_stress * factor))) {
			sched_set_fifo(current);
		} else /* common case, do nothing */
			return;
	} else {
		/*
		 * The task will remain boosted for another 10 * rt_boost_factor
		 * operations, then restored back to its original prio, and so
		 * forth.
		 *
		 * When @trsp is nil, we want to force-reset the task for
		 * stopping the kthread.
		 */
		if (!trsp || !(torture_random(trsp) %
			       (cxt.nrealwriters_stress * factor * 2))) {
			sched_set_normal(current, 0);
		} else /* common case, do nothing */
			return;
	}
}

static void torture_rt_boost(struct torture_random_state *trsp)
{
	if (rt_boost != 2)
		return;

	__torture_rt_boost(trsp);
}

static struct lock_torture_ops lock_busted_ops = {
	.writelock	= torture_lock_busted_write_lock,
	.write_delay	= torture_lock_busted_write_delay,
	.task_boost     = torture_rt_boost,
	.writeunlock	= torture_lock_busted_write_unlock,
	.readlock       = NULL,
	.read_delay     = NULL,
	.readunlock     = NULL,
	.name		= "lock_busted"
};

static DEFINE_SPINLOCK(torture_spinlock);

static int torture_spin_lock_write_lock(int tid __maybe_unused)
__acquires(torture_spinlock)
{
	spin_lock(&torture_spinlock);
	return 0;
}

static void torture_spin_lock_write_delay(struct torture_random_state *trsp)
{
	const unsigned long shortdelay_us = 2;
	unsigned long j;

	/* We want a short delay mostly to emulate likely code, and
	 * we want a long delay occasionally to force massive contention.
	 */
	if (long_hold && !(torture_random(trsp) % (cxt.nrealwriters_stress * 2000 * long_hold))) {
		j = jiffies;
		mdelay(long_hold);
		pr_alert("%s: delay = %lu jiffies.\n", __func__, jiffies - j);
	}
	if (!(torture_random(trsp) % (cxt.nrealwriters_stress * 200 * shortdelay_us)))
		udelay(shortdelay_us);
	if (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))
		torture_preempt_schedule();  /* Allow test to be preempted. */
}

static void torture_spin_lock_write_unlock(int tid __maybe_unused)
__releases(torture_spinlock)
{
	spin_unlock(&torture_spinlock);
}

static struct lock_torture_ops spin_lock_ops = {
	.writelock	= torture_spin_lock_write_lock,
	.write_delay	= torture_spin_lock_write_delay,
	.task_boost     = torture_rt_boost,
	.writeunlock	= torture_spin_lock_write_unlock,
	.readlock       = NULL,
	.read_delay     = NULL,
	.readunlock     = NULL,
	.name		= "spin_lock"
};

static int torture_spin_lock_write_lock_irq(int tid __maybe_unused)
__acquires(torture_spinlock)
{
	unsigned long flags;

	spin_lock_irqsave(&torture_spinlock, flags);
	cxt.cur_ops->flags = flags;
	return 0;
}

static void torture_lock_spin_write_unlock_irq(int tid __maybe_unused)
__releases(torture_spinlock)
{
	spin_unlock_irqrestore(&torture_spinlock, cxt.cur_ops->flags);
}

static struct lock_torture_ops spin_lock_irq_ops = {
	.writelock	= torture_spin_lock_write_lock_irq,
	.write_delay	= torture_spin_lock_write_delay,
	.task_boost     = torture_rt_boost,
	.writeunlock	= torture_lock_spin_write_unlock_irq,
	.readlock       = NULL,
	.read_delay     = NULL,
	.readunlock     = NULL,
	.name		= "spin_lock_irq"
};

static DEFINE_RAW_SPINLOCK(torture_raw_spinlock);

static int torture_raw_spin_lock_write_lock(int tid __maybe_unused)
__acquires(torture_raw_spinlock)
{
	raw_spin_lock(&torture_raw_spinlock);
	return 0;
}

static void torture_raw_spin_lock_write_unlock(int tid __maybe_unused)
__releases(torture_raw_spinlock)
{
	raw_spin_unlock(&torture_raw_spinlock);
}

static struct lock_torture_ops raw_spin_lock_ops = {
	.writelock	= torture_raw_spin_lock_write_lock,
	.write_delay	= torture_spin_lock_write_delay,
	.task_boost	= torture_rt_boost,
	.writeunlock	= torture_raw_spin_lock_write_unlock,
	.readlock	= NULL,
	.read_delay	= NULL,
	.readunlock	= NULL,
	.name		= "raw_spin_lock"
};

static int torture_raw_spin_lock_write_lock_irq(int tid __maybe_unused)
__acquires(torture_raw_spinlock)
{
	unsigned long flags;

	raw_spin_lock_irqsave(&torture_raw_spinlock, flags);
	cxt.cur_ops->flags = flags;
	return 0;
}

static void torture_raw_spin_lock_write_unlock_irq(int tid __maybe_unused)
__releases(torture_raw_spinlock)
{
	raw_spin_unlock_irqrestore(&torture_raw_spinlock, cxt.cur_ops->flags);
}

static struct lock_torture_ops raw_spin_lock_irq_ops = {
	.writelock	= torture_raw_spin_lock_write_lock_irq,
	.write_delay	= torture_spin_lock_write_delay,
	.task_boost	= torture_rt_boost,
	.writeunlock	= torture_raw_spin_lock_write_unlock_irq,
	.readlock	= NULL,
	.read_delay	= NULL,
	.readunlock	= NULL,
	.name		= "raw_spin_lock_irq"
};

static DEFINE_RWLOCK(torture_rwlock);

static int torture_rwlock_write_lock(int tid __maybe_unused)
__acquires(torture_rwlock)
{
	write_lock(&torture_rwlock);
	return 0;
}

static void torture_rwlock_write_delay(struct torture_random_state *trsp)
{
	const unsigned long shortdelay_us = 2;

	/* We want a short delay mostly to emulate likely code, and
	 * we want a long delay occasionally to force massive contention.
	 */
	if (long_hold && !(torture_random(trsp) % (cxt.nrealwriters_stress * 2000 * long_hold)))
		mdelay(long_hold);
	else
		udelay(shortdelay_us);
}

static void torture_rwlock_write_unlock(int tid __maybe_unused)
__releases(torture_rwlock)
{
	write_unlock(&torture_rwlock);
}

static int torture_rwlock_read_lock(int tid __maybe_unused)
__acquires(torture_rwlock)
{
	read_lock(&torture_rwlock);
	return 0;
}

static void torture_rwlock_read_delay(struct torture_random_state *trsp)
{
	const unsigned long shortdelay_us = 10;

	/* We want a short delay mostly to emulate likely code, and
	 * we want a long delay occasionally to force massive contention.
	 */
	if (long_hold && !(torture_random(trsp) % (cxt.nrealreaders_stress * 2000 * long_hold)))
		mdelay(long_hold);
	else
		udelay(shortdelay_us);
}

static void torture_rwlock_read_unlock(int tid __maybe_unused)
__releases(torture_rwlock)
{
	read_unlock(&torture_rwlock);
}

static struct lock_torture_ops rw_lock_ops = {
	.writelock	= torture_rwlock_write_lock,
	.write_delay	= torture_rwlock_write_delay,
	.task_boost     = torture_rt_boost,
	.writeunlock	= torture_rwlock_write_unlock,
	.readlock       = torture_rwlock_read_lock,
	.read_delay     = torture_rwlock_read_delay,
	.readunlock     = torture_rwlock_read_unlock,
	.name		= "rw_lock"
};

static int torture_rwlock_write_lock_irq(int tid __maybe_unused)
__acquires(torture_rwlock)
{
	unsigned long flags;

	write_lock_irqsave(&torture_rwlock, flags);
	cxt.cur_ops->flags = flags;
	return 0;
}

static void torture_rwlock_write_unlock_irq(int tid __maybe_unused)
__releases(torture_rwlock)
{
	write_unlock_irqrestore(&torture_rwlock, cxt.cur_ops->flags);
}

static int torture_rwlock_read_lock_irq(int tid __maybe_unused)
__acquires(torture_rwlock)
{
	unsigned long flags;

	read_lock_irqsave(&torture_rwlock, flags);
	cxt.cur_ops->flags = flags;
	return 0;
}

static void torture_rwlock_read_unlock_irq(int tid __maybe_unused)
__releases(torture_rwlock)
{
	read_unlock_irqrestore(&torture_rwlock, cxt.cur_ops->flags);
}

static struct lock_torture_ops rw_lock_irq_ops = {
	.writelock	= torture_rwlock_write_lock_irq,
	.write_delay	= torture_rwlock_write_delay,
	.task_boost     = torture_rt_boost,
	.writeunlock	= torture_rwlock_write_unlock_irq,
	.readlock       = torture_rwlock_read_lock_irq,
	.read_delay     = torture_rwlock_read_delay,
	.readunlock     = torture_rwlock_read_unlock_irq,
	.name		= "rw_lock_irq"
};

static DEFINE_MUTEX(torture_mutex);
static struct mutex torture_nested_mutexes[MAX_NESTED_LOCKS];
static struct lock_class_key nested_mutex_keys[MAX_NESTED_LOCKS];

static void torture_mutex_init(void)
{
	int i;

	for (i = 0; i < MAX_NESTED_LOCKS; i++)
		__mutex_init(&torture_nested_mutexes[i], __func__,
			     &nested_mutex_keys[i]);
}

static int torture_mutex_nested_lock(int tid __maybe_unused,
				     u32 lockset)
{
	int i;

	for (i = 0; i < nested_locks; i++)
		if (lockset & (1 << i))
			mutex_lock(&torture_nested_mutexes[i]);
	return 0;
}

static int torture_mutex_lock(int tid __maybe_unused)
__acquires(torture_mutex)
{
	mutex_lock(&torture_mutex);
	return 0;
}

static void torture_mutex_delay(struct torture_random_state *trsp)
{
	/* We want a long delay occasionally to force massive contention.  */
	if (long_hold && !(torture_random(trsp) % (cxt.nrealwriters_stress * 2000 * long_hold)))
		mdelay(long_hold * 5);
	if (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))
		torture_preempt_schedule();  /* Allow test to be preempted. */
}

static void torture_mutex_unlock(int tid __maybe_unused)
__releases(torture_mutex)
{
	mutex_unlock(&torture_mutex);
}

static void torture_mutex_nested_unlock(int tid __maybe_unused,
					u32 lockset)
{
	int i;

	for (i = nested_locks - 1; i >= 0; i--)
		if (lockset & (1 << i))
			mutex_unlock(&torture_nested_mutexes[i]);
}

static struct lock_torture_ops mutex_lock_ops = {
	.init		= torture_mutex_init,
	.nested_lock	= torture_mutex_nested_lock,
	.writelock	= torture_mutex_lock,
	.write_delay	= torture_mutex_delay,
	.task_boost     = torture_rt_boost,
	.writeunlock	= torture_mutex_unlock,
	.nested_unlock	= torture_mutex_nested_unlock,
	.readlock       = NULL,
	.read_delay     = NULL,
	.readunlock     = NULL,
	.name		= "mutex_lock"
};

#include <linux/ww_mutex.h>
/*
 * The torture ww_mutexes should belong to the same lock class as
 * torture_ww_class to avoid lockdep problem. The ww_mutex_init()
 * function is called for initialization to ensure that.
 */
static DEFINE_WD_CLASS(torture_ww_class);
static struct ww_mutex torture_ww_mutex_0, torture_ww_mutex_1, torture_ww_mutex_2;
static struct ww_acquire_ctx *ww_acquire_ctxs;

static void torture_ww_mutex_init(void)
{
	ww_mutex_init(&torture_ww_mutex_0, &torture_ww_class);
	ww_mutex_init(&torture_ww_mutex_1, &torture_ww_class);
	ww_mutex_init(&torture_ww_mutex_2, &torture_ww_class);

	ww_acquire_ctxs = kmalloc_array(cxt.nrealwriters_stress,
					sizeof(*ww_acquire_ctxs),
					GFP_KERNEL);
	if (!ww_acquire_ctxs)
		VERBOSE_TOROUT_STRING("ww_acquire_ctx: Out of memory");
}

static void torture_ww_mutex_exit(void)
{
	kfree(ww_acquire_ctxs);
}

static int torture_ww_mutex_lock(int tid)
__acquires(torture_ww_mutex_0)
__acquires(torture_ww_mutex_1)
__acquires(torture_ww_mutex_2)
{
	LIST_HEAD(list);
	struct reorder_lock {
		struct list_head link;
		struct ww_mutex *lock;
	} locks[3], *ll, *ln;
	struct ww_acquire_ctx *ctx = &ww_acquire_ctxs[tid];

	locks[0].lock = &torture_ww_mutex_0;
	list_add(&locks[0].link, &list);

	locks[1].lock = &torture_ww_mutex_1;
	list_add(&locks[1].link, &list);

	locks[2].lock = &torture_ww_mutex_2;
	list_add(&locks[2].link, &list);

	ww_acquire_init(ctx, &torture_ww_class);

	list_for_each_entry(ll, &list, link) {
		int err;

		err = ww_mutex_lock(ll->lock, ctx);
		if (!err)
			continue;

		ln = ll;
		list_for_each_entry_continue_reverse(ln, &list, link)
			ww_mutex_unlock(ln->lock);

		if (err != -EDEADLK)
			return err;

		ww_mutex_lock_slow(ll->lock, ctx);
		list_move(&ll->link, &list);
	}

	return 0;
}

static void torture_ww_mutex_unlock(int tid)
__releases(torture_ww_mutex_0)
__releases(torture_ww_mutex_1)
__releases(torture_ww_mutex_2)
{
	struct ww_acquire_ctx *ctx = &ww_acquire_ctxs[tid];

	ww_mutex_unlock(&torture_ww_mutex_0);
	ww_mutex_unlock(&torture_ww_mutex_1);
	ww_mutex_unlock(&torture_ww_mutex_2);
	ww_acquire_fini(ctx);
}

static struct lock_torture_ops ww_mutex_lock_ops = {
	.init		= torture_ww_mutex_init,
	.exit		= torture_ww_mutex_exit,
	.writelock	= torture_ww_mutex_lock,
	.write_delay	= torture_mutex_delay,
	.task_boost     = torture_rt_boost,
	.writeunlock	= torture_ww_mutex_unlock,
	.readlock       = NULL,
	.read_delay     = NULL,
	.readunlock     = NULL,
	.name		= "ww_mutex_lock"
};

#ifdef CONFIG_RT_MUTEXES
static DEFINE_RT_MUTEX(torture_rtmutex);
static struct rt_mutex torture_nested_rtmutexes[MAX_NESTED_LOCKS];
static struct lock_class_key nested_rtmutex_keys[MAX_NESTED_LOCKS];

static void torture_rtmutex_init(void)
{
	int i;

	for (i = 0; i < MAX_NESTED_LOCKS; i++)
		__rt_mutex_init(&torture_nested_rtmutexes[i], __func__,
				&nested_rtmutex_keys[i]);
}

static int torture_rtmutex_nested_lock(int tid __maybe_unused,
				       u32 lockset)
{
	int i;

	for (i = 0; i < nested_locks; i++)
		if (lockset & (1 << i))
			rt_mutex_lock(&torture_nested_rtmutexes[i]);
	return 0;
}

static int torture_rtmutex_lock(int tid __maybe_unused)
__acquires(torture_rtmutex)
{
	rt_mutex_lock(&torture_rtmutex);
	return 0;
}

static void torture_rtmutex_delay(struct torture_random_state *trsp)
{
	const unsigned long shortdelay_us = 2;

	/*
	 * We want a short delay mostly to emulate likely code, and
	 * we want a long delay occasionally to force massive contention.
	 */
	if (long_hold && !(torture_random(trsp) % (cxt.nrealwriters_stress * 2000 * long_hold)))
		mdelay(long_hold);
	if (!(torture_random(trsp) %
	      (cxt.nrealwriters_stress * 200 * shortdelay_us)))
		udelay(shortdelay_us);
	if (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))
		torture_preempt_schedule();  /* Allow test to be preempted. */
}

static void torture_rtmutex_unlock(int tid __maybe_unused)
__releases(torture_rtmutex)
{
	rt_mutex_unlock(&torture_rtmutex);
}

static void torture_rt_boost_rtmutex(struct torture_random_state *trsp)
{
	if (!rt_boost)
		return;

	__torture_rt_boost(trsp);
}

static void torture_rtmutex_nested_unlock(int tid __maybe_unused,
					  u32 lockset)
{
	int i;

	for (i = nested_locks - 1; i >= 0; i--)
		if (lockset & (1 << i))
			rt_mutex_unlock(&torture_nested_rtmutexes[i]);
}

static struct lock_torture_ops rtmutex_lock_ops = {
	.init		= torture_rtmutex_init,
	.nested_lock	= torture_rtmutex_nested_lock,
	.writelock	= torture_rtmutex_lock,
	.write_delay	= torture_rtmutex_delay,
	.task_boost     = torture_rt_boost_rtmutex,
	.writeunlock	= torture_rtmutex_unlock,
	.nested_unlock	= torture_rtmutex_nested_unlock,
	.readlock       = NULL,
	.read_delay     = NULL,
	.readunlock     = NULL,
	.name		= "rtmutex_lock"
};
#endif

static DECLARE_RWSEM(torture_rwsem);
static int torture_rwsem_down_write(int tid __maybe_unused)
__acquires(torture_rwsem)
{
	down_write(&torture_rwsem);
	return 0;
}

static void torture_rwsem_write_delay(struct torture_random_state *trsp)
{
	/* We want a long delay occasionally to force massive contention.  */
	if (long_hold && !(torture_random(trsp) % (cxt.nrealwriters_stress * 2000 * long_hold)))
		mdelay(long_hold * 10);
	if (!(torture_random(trsp) % (cxt.nrealwriters_stress * 20000)))
		torture_preempt_schedule();  /* Allow test to be preempted. */
}

static void torture_rwsem_up_write(int tid __maybe_unused)
__releases(torture_rwsem)
{
	up_write(&torture_rwsem);
}

static int torture_rwsem_down_read(int tid __maybe_unused)
__acquires(torture_rwsem)
{
	down_read(&torture_rwsem);
	return 0;
}

static void torture_rwsem_read_delay(struct torture_random_state *trsp)
{
	/* We want a long delay occasionally to force massive contention.  */
	if (long_hold && !(torture_random(trsp) % (cxt.nrealreaders_stress * 2000 * long_hold)))
		mdelay(long_hold * 2);
	else
		mdelay(long_hold / 2);
	if (!(torture_random(trsp) % (cxt.nrealreaders_stress * 20000)))
		torture_preempt_schedule();  /* Allow test to be preempted. */
}

static void torture_rwsem_up_read(int tid __maybe_unused)
__releases(torture_rwsem)
{
	up_read(&torture_rwsem);
}

static struct lock_torture_ops rwsem_lock_ops = {
	.writelock	= torture_rwsem_down_write,
	.write_delay	= torture_rwsem_write_delay,
	.task_boost     = torture_rt_boost,
	.writeunlock	= torture_rwsem_up_write,
	.readlock       = torture_rwsem_down_read,
	.read_delay     = torture_rwsem_read_delay,
	.readunlock     = torture_rwsem_up_read,
	.name		= "rwsem_lock"
};

#include <linux/percpu-rwsem.h>
static struct percpu_rw_semaphore pcpu_rwsem;

static void torture_percpu_rwsem_init(void)
{
	BUG_ON(percpu_init_rwsem(&pcpu_rwsem));
}

static void torture_percpu_rwsem_exit(void)
{
	percpu_free_rwsem(&pcpu_rwsem);
}

static int torture_percpu_rwsem_down_write(int tid __maybe_unused)
__acquires(pcpu_rwsem)
{
	percpu_down_write(&pcpu_rwsem);
	return 0;
}

static void torture_percpu_rwsem_up_write(int tid __maybe_unused)
__releases(pcpu_rwsem)
{
	percpu_up_write(&pcpu_rwsem);
}

static int torture_percpu_rwsem_down_read(int tid __maybe_unused)
__acquires(pcpu_rwsem)
{
	percpu_down_read(&pcpu_rwsem);
	return 0;
}

static void torture_percpu_rwsem_up_read(int tid __maybe_unused)
__releases(pcpu_rwsem)
{
	percpu_up_read(&pcpu_rwsem);
}

static struct lock_torture_ops percpu_rwsem_lock_ops = {
	.init		= torture_percpu_rwsem_init,
	.exit		= torture_percpu_rwsem_exit,
	.writelock	= torture_percpu_rwsem_down_write,
	.write_delay	= torture_rwsem_write_delay,
	.task_boost     = torture_rt_boost,
	.writeunlock	= torture_percpu_rwsem_up_write,
	.readlock       = torture_percpu_rwsem_down_read,
	.read_delay     = torture_rwsem_read_delay,
	.readunlock     = torture_percpu_rwsem_up_read,
	.name		= "percpu_rwsem_lock"
};

/*
 * Lock torture writer kthread.  Repeatedly acquires and releases
 * the lock, checking for duplicate acquisitions.
 */
static int lock_torture_writer(void *arg)
{
	unsigned long j;
	unsigned long j1;
	u32 lockset_mask;
	struct lock_stress_stats *lwsp = arg;
	DEFINE_TORTURE_RANDOM(rand);
	bool skip_main_lock;
	int tid = lwsp - cxt.lwsa;

	VERBOSE_TOROUT_STRING("lock_torture_writer task started");
	if (!rt_task(current))
		set_user_nice(current, MAX_NICE);

	do {
		if ((torture_random(&rand) & 0xfffff) == 0)
			schedule_timeout_uninterruptible(1);

		lockset_mask = torture_random(&rand);
		/*
		 * When using nested_locks, we want to occasionally
		 * skip the main lock so we can avoid always serializing
		 * the lock chains on that central lock. By skipping the
		 * main lock occasionally, we can create different
		 * contention patterns (allowing for multiple disjoint
		 * blocked trees)
		 */
		skip_main_lock = (nested_locks &&
				 !(torture_random(&rand) % 100));

		cxt.cur_ops->task_boost(&rand);
		if (cxt.cur_ops->nested_lock)
			cxt.cur_ops->nested_lock(tid, lockset_mask);

		if (!skip_main_lock) {
			if (acq_writer_lim > 0)
				j = jiffies;
			cxt.cur_ops->writelock(tid);
			if (WARN_ON_ONCE(lock_is_write_held))
				lwsp->n_lock_fail++;
			lock_is_write_held = true;
			if (WARN_ON_ONCE(atomic_read(&lock_is_read_held)))
				lwsp->n_lock_fail++; /* rare, but... */
			if (acq_writer_lim > 0) {
				j1 = jiffies;
				WARN_ONCE(time_after(j1, j + acq_writer_lim),
					  "%s: Lock acquisition took %lu jiffies.\n",
					  __func__, j1 - j);
			}
			lwsp->n_lock_acquired++;

			cxt.cur_ops->write_delay(&rand);

			lock_is_write_held = false;
			WRITE_ONCE(last_lock_release, jiffies);
			cxt.cur_ops->writeunlock(tid);
		}
		if (cxt.cur_ops->nested_unlock)
			cxt.cur_ops->nested_unlock(tid, lockset_mask);

		stutter_wait("lock_torture_writer");
	} while (!torture_must_stop());

	cxt.cur_ops->task_boost(NULL); /* reset prio */
	torture_kthread_stopping("lock_torture_writer");
	return 0;
}

/*
 * Lock torture reader kthread.  Repeatedly acquires and releases
 * the reader lock.
 */
static int lock_torture_reader(void *arg)
{
	struct lock_stress_stats *lrsp = arg;
	int tid = lrsp - cxt.lrsa;
	DEFINE_TORTURE_RANDOM(rand);

	VERBOSE_TOROUT_STRING("lock_torture_reader task started");
	set_user_nice(current, MAX_NICE);

	do {
		if ((torture_random(&rand) & 0xfffff) == 0)
			schedule_timeout_uninterruptible(1);

		cxt.cur_ops->readlock(tid);
		atomic_inc(&lock_is_read_held);
		if (WARN_ON_ONCE(lock_is_write_held))
			lrsp->n_lock_fail++; /* rare, but... */

		lrsp->n_lock_acquired++;
		cxt.cur_ops->read_delay(&rand);
		atomic_dec(&lock_is_read_held);
		cxt.cur_ops->readunlock(tid);

		stutter_wait("lock_torture_reader");
	} while (!torture_must_stop());
	torture_kthread_stopping("lock_torture_reader");
	return 0;
}

/*
 * Create an lock-torture-statistics message in the specified buffer.
 */
static void __torture_print_stats(char *page,
				  struct lock_stress_stats *statp, bool write)
{
	long cur;
	bool fail = false;
	int i, n_stress;
	long max = 0, min = statp ? data_race(statp[0].n_lock_acquired) : 0;
	long long sum = 0;

	n_stress = write ? cxt.nrealwriters_stress : cxt.nrealreaders_stress;
	for (i = 0; i < n_stress; i++) {
		if (data_race(statp[i].n_lock_fail))
			fail = true;
		cur = data_race(statp[i].n_lock_acquired);
		sum += cur;
		if (max < cur)
			max = cur;
		if (min > cur)
			min = cur;
	}
	page += sprintf(page,
			"%s:  Total: %lld  Max/Min: %ld/%ld %s  Fail: %d %s\n",
			write ? "Writes" : "Reads ",
			sum, max, min,
			!onoff_interval && max / 2 > min ? "???" : "",
			fail, fail ? "!!!" : "");
	if (fail)
		atomic_inc(&cxt.n_lock_torture_errors);
}

/*
 * Print torture statistics.  Caller must ensure that there is only one
 * call to this function at a given time!!!  This is normally accomplished
 * by relying on the module system to only have one copy of the module
 * loaded, and then by giving the lock_torture_stats kthread full control
 * (or the init/cleanup functions when lock_torture_stats thread is not
 * running).
 */
static void lock_torture_stats_print(void)
{
	int size = cxt.nrealwriters_stress * 200 + 8192;
	char *buf;

	if (cxt.cur_ops->readlock)
		size += cxt.nrealreaders_stress * 200 + 8192;

	buf = kmalloc(size, GFP_KERNEL);
	if (!buf) {
		pr_err("lock_torture_stats_print: Out of memory, need: %d",
		       size);
		return;
	}

	__torture_print_stats(buf, cxt.lwsa, true);
	pr_alert("%s", buf);
	kfree(buf);

	if (cxt.cur_ops->readlock) {
		buf = kmalloc(size, GFP_KERNEL);
		if (!buf) {
			pr_err("lock_torture_stats_print: Out of memory, need: %d",
			       size);
			return;
		}

		__torture_print_stats(buf, cxt.lrsa, false);
		pr_alert("%s", buf);
		kfree(buf);
	}
}

/*
 * Periodically prints torture statistics, if periodic statistics printing
 * was specified via the stat_interval module parameter.
 *
 * No need to worry about fullstop here, since this one doesn't reference
 * volatile state or register callbacks.
 */
static int lock_torture_stats(void *arg)
{
	VERBOSE_TOROUT_STRING("lock_torture_stats task started");
	do {
		schedule_timeout_interruptible(stat_interval * HZ);
		lock_torture_stats_print();
		torture_shutdown_absorb("lock_torture_stats");
	} while (!torture_must_stop());
	torture_kthread_stopping("lock_torture_stats");
	return 0;
}


static inline void
lock_torture_print_module_parms(struct lock_torture_ops *cur_ops,
				const char *tag)
{
	static cpumask_t cpumask_all;
	cpumask_t *rcmp = cpumask_nonempty(bind_readers) ? bind_readers : &cpumask_all;
	cpumask_t *wcmp = cpumask_nonempty(bind_writers) ? bind_writers : &cpumask_all;

	cpumask_setall(&cpumask_all);
	pr_alert("%s" TORTURE_FLAG
		 "--- %s%s: acq_writer_lim=%d bind_readers=%*pbl bind_writers=%*pbl call_rcu_chains=%d long_hold=%d nested_locks=%d nreaders_stress=%d nwriters_stress=%d onoff_holdoff=%d onoff_interval=%d rt_boost=%d rt_boost_factor=%d shuffle_interval=%d shutdown_secs=%d stat_interval=%d stutter=%d verbose=%d writer_fifo=%d\n",
		 torture_type, tag, cxt.debug_lock ? " [debug]": "",
		 acq_writer_lim, cpumask_pr_args(rcmp), cpumask_pr_args(wcmp),
		 call_rcu_chains, long_hold, nested_locks, cxt.nrealreaders_stress,
		 cxt.nrealwriters_stress, onoff_holdoff, onoff_interval, rt_boost,
		 rt_boost_factor, shuffle_interval, shutdown_secs, stat_interval, stutter,
		 verbose, writer_fifo);
}

// If requested, maintain call_rcu() chains to keep a grace period always
// in flight.  These increase the probability of getting an RCU CPU stall
// warning and associated diagnostics when a locking primitive stalls.

static void call_rcu_chain_cb(struct rcu_head *rhp)
{
	struct call_rcu_chain *crcp = container_of(rhp, struct call_rcu_chain, crc_rh);

	if (!smp_load_acquire(&crcp->crc_stop)) {
		(void)start_poll_synchronize_rcu(); // Start one grace period...
		call_rcu(&crcp->crc_rh, call_rcu_chain_cb); // ... and later start another.
	}
}

// Start the requested number of call_rcu() chains.
static int call_rcu_chain_init(void)
{
	int i;

	if (call_rcu_chains <= 0)
		return 0;
	call_rcu_chain = kcalloc(call_rcu_chains, sizeof(*call_rcu_chain), GFP_KERNEL);
	if (!call_rcu_chain)
		return -ENOMEM;
	for (i = 0; i < call_rcu_chains; i++) {
		call_rcu_chain[i].crc_stop = false;
		call_rcu(&call_rcu_chain[i].crc_rh, call_rcu_chain_cb);
	}
	return 0;
}

// Stop all of the call_rcu() chains.
static void call_rcu_chain_cleanup(void)
{
	int i;

	if (!call_rcu_chain)
		return;
	for (i = 0; i < call_rcu_chains; i++)
		smp_store_release(&call_rcu_chain[i].crc_stop, true);
	rcu_barrier();
	kfree(call_rcu_chain);
	call_rcu_chain = NULL;
}

static void lock_torture_cleanup(void)
{
	int i;

	if (torture_cleanup_begin())
		return;

	/*
	 * Indicates early cleanup, meaning that the test has not run,
	 * such as when passing bogus args when loading the module.
	 * However cxt->cur_ops.init() may have been invoked, so beside
	 * perform the underlying torture-specific cleanups, cur_ops.exit()
	 * will be invoked if needed.
	 */
	if (!cxt.lwsa && !cxt.lrsa)
		goto end;

	if (writer_tasks) {
		for (i = 0; i < cxt.nrealwriters_stress; i++)
			torture_stop_kthread(lock_torture_writer, writer_tasks[i]);
		kfree(writer_tasks);
		writer_tasks = NULL;
	}

	if (reader_tasks) {
		for (i = 0; i < cxt.nrealreaders_stress; i++)
			torture_stop_kthread(lock_torture_reader,
					     reader_tasks[i]);
		kfree(reader_tasks);
		reader_tasks = NULL;
	}

	torture_stop_kthread(lock_torture_stats, stats_task);
	lock_torture_stats_print();  /* -After- the stats thread is stopped! */

	if (atomic_read(&cxt.n_lock_torture_errors))
		lock_torture_print_module_parms(cxt.cur_ops,
						"End of test: FAILURE");
	else if (torture_onoff_failures())
		lock_torture_print_module_parms(cxt.cur_ops,
						"End of test: LOCK_HOTPLUG");
	else
		lock_torture_print_module_parms(cxt.cur_ops,
						"End of test: SUCCESS");

	kfree(cxt.lwsa);
	cxt.lwsa = NULL;
	kfree(cxt.lrsa);
	cxt.lrsa = NULL;

	call_rcu_chain_cleanup();

end:
	if (cxt.init_called) {
		if (cxt.cur_ops->exit)
			cxt.cur_ops->exit();
		cxt.init_called = false;
	}
	torture_cleanup_end();
}

static int __init lock_torture_init(void)
{
	int i, j;
	int firsterr = 0;
	static struct lock_torture_ops *torture_ops[] = {
		&lock_busted_ops,
		&spin_lock_ops, &spin_lock_irq_ops,
		&raw_spin_lock_ops, &raw_spin_lock_irq_ops,
		&rw_lock_ops, &rw_lock_irq_ops,
		&mutex_lock_ops,
		&ww_mutex_lock_ops,
#ifdef CONFIG_RT_MUTEXES
		&rtmutex_lock_ops,
#endif
		&rwsem_lock_ops,
		&percpu_rwsem_lock_ops,
	};

	if (!torture_init_begin(torture_type, verbose))
		return -EBUSY;

	/* Process args and tell the world that the torturer is on the job. */
	for (i = 0; i < ARRAY_SIZE(torture_ops); i++) {
		cxt.cur_ops = torture_ops[i];
		if (strcmp(torture_type, cxt.cur_ops->name) == 0)
			break;
	}
	if (i == ARRAY_SIZE(torture_ops)) {
		pr_alert("lock-torture: invalid torture type: \"%s\"\n",
			 torture_type);
		pr_alert("lock-torture types:");
		for (i = 0; i < ARRAY_SIZE(torture_ops); i++)
			pr_alert(" %s", torture_ops[i]->name);
		pr_alert("\n");
		firsterr = -EINVAL;
		goto unwind;
	}

	if (nwriters_stress == 0 &&
	    (!cxt.cur_ops->readlock || nreaders_stress == 0)) {
		pr_alert("lock-torture: must run at least one locking thread\n");
		firsterr = -EINVAL;
		goto unwind;
	}

	if (nwriters_stress >= 0)
		cxt.nrealwriters_stress = nwriters_stress;
	else
		cxt.nrealwriters_stress = 2 * num_online_cpus();

	if (cxt.cur_ops->init) {
		cxt.cur_ops->init();
		cxt.init_called = true;
	}

#ifdef CONFIG_DEBUG_MUTEXES
	if (str_has_prefix(torture_type, "mutex"))
		cxt.debug_lock = true;
#endif
#ifdef CONFIG_DEBUG_RT_MUTEXES
	if (str_has_prefix(torture_type, "rtmutex"))
		cxt.debug_lock = true;
#endif
#ifdef CONFIG_DEBUG_SPINLOCK
	if ((str_has_prefix(torture_type, "spin")) ||
	    (str_has_prefix(torture_type, "rw_lock")))
		cxt.debug_lock = true;
#endif

	/* Initialize the statistics so that each run gets its own numbers. */
	if (nwriters_stress) {
		lock_is_write_held = false;
		cxt.lwsa = kmalloc_array(cxt.nrealwriters_stress,
					 sizeof(*cxt.lwsa),
					 GFP_KERNEL);
		if (cxt.lwsa == NULL) {
			VERBOSE_TOROUT_STRING("cxt.lwsa: Out of memory");
			firsterr = -ENOMEM;
			goto unwind;
		}

		for (i = 0; i < cxt.nrealwriters_stress; i++) {
			cxt.lwsa[i].n_lock_fail = 0;
			cxt.lwsa[i].n_lock_acquired = 0;
		}
	}

	if (cxt.cur_ops->readlock) {
		if (nreaders_stress >= 0)
			cxt.nrealreaders_stress = nreaders_stress;
		else {
			/*
			 * By default distribute evenly the number of
			 * readers and writers. We still run the same number
			 * of threads as the writer-only locks default.
			 */
			if (nwriters_stress < 0) /* user doesn't care */
				cxt.nrealwriters_stress = num_online_cpus();
			cxt.nrealreaders_stress = cxt.nrealwriters_stress;
		}

		if (nreaders_stress) {
			cxt.lrsa = kmalloc_array(cxt.nrealreaders_stress,
						 sizeof(*cxt.lrsa),
						 GFP_KERNEL);
			if (cxt.lrsa == NULL) {
				VERBOSE_TOROUT_STRING("cxt.lrsa: Out of memory");
				firsterr = -ENOMEM;
				kfree(cxt.lwsa);
				cxt.lwsa = NULL;
				goto unwind;
			}

			for (i = 0; i < cxt.nrealreaders_stress; i++) {
				cxt.lrsa[i].n_lock_fail = 0;
				cxt.lrsa[i].n_lock_acquired = 0;
			}
		}
	}

	firsterr = call_rcu_chain_init();
	if (torture_init_error(firsterr))
		goto unwind;

	lock_torture_print_module_parms(cxt.cur_ops, "Start of test");

	/* Prepare torture context. */
	if (onoff_interval > 0) {
		firsterr = torture_onoff_init(onoff_holdoff * HZ,
					      onoff_interval * HZ, NULL);
		if (torture_init_error(firsterr))
			goto unwind;
	}
	if (shuffle_interval > 0) {
		firsterr = torture_shuffle_init(shuffle_interval);
		if (torture_init_error(firsterr))
			goto unwind;
	}
	if (shutdown_secs > 0) {
		firsterr = torture_shutdown_init(shutdown_secs,
						 lock_torture_cleanup);
		if (torture_init_error(firsterr))
			goto unwind;
	}
	if (stutter > 0) {
		firsterr = torture_stutter_init(stutter, stutter);
		if (torture_init_error(firsterr))
			goto unwind;
	}

	if (nwriters_stress) {
		writer_tasks = kcalloc(cxt.nrealwriters_stress,
				       sizeof(writer_tasks[0]),
				       GFP_KERNEL);
		if (writer_tasks == NULL) {
			TOROUT_ERRSTRING("writer_tasks: Out of memory");
			firsterr = -ENOMEM;
			goto unwind;
		}
	}

	/* cap nested_locks to MAX_NESTED_LOCKS */
	if (nested_locks > MAX_NESTED_LOCKS)
		nested_locks = MAX_NESTED_LOCKS;

	if (cxt.cur_ops->readlock) {
		reader_tasks = kcalloc(cxt.nrealreaders_stress,
				       sizeof(reader_tasks[0]),
				       GFP_KERNEL);
		if (reader_tasks == NULL) {
			TOROUT_ERRSTRING("reader_tasks: Out of memory");
			kfree(writer_tasks);
			writer_tasks = NULL;
			firsterr = -ENOMEM;
			goto unwind;
		}
	}

	/*
	 * Create the kthreads and start torturing (oh, those poor little locks).
	 *
	 * TODO: Note that we interleave writers with readers, giving writers a
	 * slight advantage, by creating its kthread first. This can be modified
	 * for very specific needs, or even let the user choose the policy, if
	 * ever wanted.
	 */
	for (i = 0, j = 0; i < cxt.nrealwriters_stress ||
		    j < cxt.nrealreaders_stress; i++, j++) {
		if (i >= cxt.nrealwriters_stress)
			goto create_reader;

		/* Create writer. */
		firsterr = torture_create_kthread_cb(lock_torture_writer, &cxt.lwsa[i],
						     writer_tasks[i],
						     writer_fifo ? sched_set_fifo : NULL);
		if (torture_init_error(firsterr))
			goto unwind;
		if (cpumask_nonempty(bind_writers))
			torture_sched_setaffinity(writer_tasks[i]->pid, bind_writers);

	create_reader:
		if (cxt.cur_ops->readlock == NULL || (j >= cxt.nrealreaders_stress))
			continue;
		/* Create reader. */
		firsterr = torture_create_kthread(lock_torture_reader, &cxt.lrsa[j],
						  reader_tasks[j]);
		if (torture_init_error(firsterr))
			goto unwind;
		if (cpumask_nonempty(bind_readers))
			torture_sched_setaffinity(reader_tasks[j]->pid, bind_readers);
	}
	if (stat_interval > 0) {
		firsterr = torture_create_kthread(lock_torture_stats, NULL,
						  stats_task);
		if (torture_init_error(firsterr))
			goto unwind;
	}
	torture_init_end();
	return 0;

unwind:
	torture_init_end();
	lock_torture_cleanup();
	if (shutdown_secs) {
		WARN_ON(!IS_MODULE(CONFIG_LOCK_TORTURE_TEST));
		kernel_power_off();
	}
	return firsterr;
}

module_init(lock_torture_init);
module_exit(lock_torture_cleanup);
/* SPDX-License-Identifier: GPL-2.0 */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * Authors: Waiman Long <waiman.long@hpe.com>
 */

/*
 * Collect locking event counts
 */
#include <linux/debugfs.h>
#include <linux/sched.h>
#include <linux/sched/clock.h>
#include <linux/fs.h>

#include "lock_events.h"

#undef  LOCK_EVENT
#define LOCK_EVENT(name)	[LOCKEVENT_ ## name] = #name,

#define LOCK_EVENTS_DIR		"lock_event_counts"

/*
 * When CONFIG_LOCK_EVENT_COUNTS is enabled, event counts of different
 * types of locks will be reported under the <debugfs>/lock_event_counts/
 * directory. See lock_events_list.h for the list of available locking
 * events.
 *
 * Writing to the special ".reset_counts" file will reset all the above
 * locking event counts. This is a very slow operation and so should not
 * be done frequently.
 *
 * These event counts are implemented as per-cpu variables which are
 * summed and computed whenever the corresponding debugfs files are read. This
 * minimizes added overhead making the counts usable even in a production
 * environment.
 */
static const char * const lockevent_names[lockevent_num + 1] = {

#include "lock_events_list.h"

	[LOCKEVENT_reset_cnts] = ".reset_counts",
};

/*
 * Per-cpu counts
 */
DEFINE_PER_CPU(unsigned long, lockevents[lockevent_num]);

/*
 * The lockevent_read() function can be overridden.
 */
ssize_t __weak lockevent_read(struct file *file, char __user *user_buf,
			      size_t count, loff_t *ppos)
{
	char buf[64];
	int cpu, id, len;
	u64 sum = 0;

	/*
	 * Get the counter ID stored in file->f_inode->i_private
	 */
	id = (long)file_inode(file)->i_private;

	if (id >= lockevent_num)
		return -EBADF;

	for_each_possible_cpu(cpu)
		sum += per_cpu(lockevents[id], cpu);
	len = snprintf(buf, sizeof(buf) - 1, "%llu\n", sum);

	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
}

/*
 * Function to handle write request
 *
 * When idx = reset_cnts, reset all the counts.
 */
static ssize_t lockevent_write(struct file *file, const char __user *user_buf,
			   size_t count, loff_t *ppos)
{
	int cpu;

	/*
	 * Get the counter ID stored in file->f_inode->i_private
	 */
	if ((long)file_inode(file)->i_private != LOCKEVENT_reset_cnts)
		return count;

	for_each_possible_cpu(cpu) {
		int i;
		unsigned long *ptr = per_cpu_ptr(lockevents, cpu);

		for (i = 0 ; i < lockevent_num; i++)
			WRITE_ONCE(ptr[i], 0);
	}
	return count;
}

/*
 * Debugfs data structures
 */
static const struct file_operations fops_lockevent = {
	.read = lockevent_read,
	.write = lockevent_write,
	.llseek = default_llseek,
};

#ifdef CONFIG_PARAVIRT_SPINLOCKS
#include <asm/paravirt.h>

static bool __init skip_lockevent(const char *name)
{
	static int pv_on __initdata = -1;

	if (pv_on < 0)
		pv_on = !pv_is_native_spin_unlock();
	/*
	 * Skip PV qspinlock events on bare metal.
	 */
	if (!pv_on && !memcmp(name, "pv_", 3))
		return true;
	return false;
}
#else
static inline bool skip_lockevent(const char *name)
{
	return false;
}
#endif

/*
 * Initialize debugfs for the locking event counts.
 */
static int __init init_lockevent_counts(void)
{
	struct dentry *d_counts = debugfs_create_dir(LOCK_EVENTS_DIR, NULL);
	int i;

	if (IS_ERR(d_counts))
		goto out;

	/*
	 * Create the debugfs files
	 *
	 * As reading from and writing to the stat files can be slow, only
	 * root is allowed to do the read/write to limit impact to system
	 * performance.
	 */
	for (i = 0; i < lockevent_num; i++) {
		if (skip_lockevent(lockevent_names[i]))
			continue;
		if (IS_ERR(debugfs_create_file(lockevent_names[i], 0400, d_counts,
					 (void *)(long)i, &fops_lockevent)))
			goto fail_undo;
	}

	if (IS_ERR(debugfs_create_file(lockevent_names[LOCKEVENT_reset_cnts], 0200,
				 d_counts, (void *)(long)LOCKEVENT_reset_cnts,
				 &fops_lockevent)))
		goto fail_undo;

	return 0;
fail_undo:
	debugfs_remove_recursive(d_counts);
out:
	pr_warn("Could not create '%s' debugfs entries\n", LOCK_EVENTS_DIR);
	return -ENOMEM;
}
fs_initcall(init_lockevent_counts);
/* SPDX-License-Identifier: GPL-2.0 */
/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * Authors: Waiman Long <longman@redhat.com>
 */

#ifndef __LOCKING_LOCK_EVENTS_H
#define __LOCKING_LOCK_EVENTS_H

enum lock_events {

#include "lock_events_list.h"

	lockevent_num,	/* Total number of lock event counts */
	LOCKEVENT_reset_cnts = lockevent_num,
};

#ifdef CONFIG_LOCK_EVENT_COUNTS
/*
 * Per-cpu counters
 */
DECLARE_PER_CPU(unsigned long, lockevents[lockevent_num]);

/*
 * Increment the statistical counters. use raw_cpu_inc() because of lower
 * overhead and we don't care if we loose the occasional update.
 */
static inline void __lockevent_inc(enum lock_events event, bool cond)
{
	if (cond)
		raw_cpu_inc(lockevents[event]);
}

#define lockevent_inc(ev)	  __lockevent_inc(LOCKEVENT_ ##ev, true)
#define lockevent_cond_inc(ev, c) __lockevent_inc(LOCKEVENT_ ##ev, c)

static inline void __lockevent_add(enum lock_events event, int inc)
{
	raw_cpu_add(lockevents[event], inc);
}

#define lockevent_add(ev, c)	__lockevent_add(LOCKEVENT_ ##ev, c)

#else  /* CONFIG_LOCK_EVENT_COUNTS */

#define lockevent_inc(ev)
#define lockevent_add(ev, c)
#define lockevent_cond_inc(ev, c)

#endif /* CONFIG_LOCK_EVENT_COUNTS */

ssize_t lockevent_read(struct file *file, char __user *user_buf,
		       size_t count, loff_t *ppos);

#endif /* __LOCKING_LOCK_EVENTS_H */
/* SPDX-License-Identifier: GPL-2.0 */
/*
 * MCS lock defines
 *
 * This file contains the main data structure and API definitions of MCS lock.
 *
 * The MCS lock (proposed by Mellor-Crummey and Scott) is a simple spin-lock
 * with the desirable properties of being fair, and with each cpu trying
 * to acquire the lock spinning on a local variable.
 * It avoids expensive cache bounces that common test-and-set spin-lock
 * implementations incur.
 */
#ifndef __LINUX_MCS_SPINLOCK_H
#define __LINUX_MCS_SPINLOCK_H

#include <asm/mcs_spinlock.h>

struct mcs_spinlock {
	struct mcs_spinlock *next;
	int locked; /* 1 if lock acquired */
	int count;  /* nesting count, see qspinlock.c */
};

#ifndef arch_mcs_spin_lock_contended
/*
 * Using smp_cond_load_acquire() provides the acquire semantics
 * required so that subsequent operations happen after the
 * lock is acquired. Additionally, some architectures such as
 * ARM64 would like to do spin-waiting instead of purely
 * spinning, and smp_cond_load_acquire() provides that behavior.
 */
#define arch_mcs_spin_lock_contended(l)					\
do {									\
	smp_cond_load_acquire(l, VAL);					\
} while (0)
#endif

#ifndef arch_mcs_spin_unlock_contended
/*
 * smp_store_release() provides a memory barrier to ensure all
 * operations in the critical section has been completed before
 * unlocking.
 */
#define arch_mcs_spin_unlock_contended(l)				\
	smp_store_release((l), 1)
#endif

/*
 * Note: the smp_load_acquire/smp_store_release pair is not
 * sufficient to form a full memory barrier across
 * cpus for many architectures (except x86) for mcs_unlock and mcs_lock.
 * For applications that need a full barrier across multiple cpus
 * with mcs_unlock and mcs_lock pair, smp_mb__after_unlock_lock() should be
 * used after mcs_lock.
 */

/*
 * In order to acquire the lock, the caller should declare a local node and
 * pass a reference of the node to this function in addition to the lock.
 * If the lock has already been acquired, then this will proceed to spin
 * on this node->locked until the previous lock holder sets the node->locked
 * in mcs_spin_unlock().
 */
static inline
void mcs_spin_lock(struct mcs_spinlock **lock, struct mcs_spinlock *node)
{
	struct mcs_spinlock *prev;

	/* Init node */
	node->locked = 0;
	node->next   = NULL;

	/*
	 * We rely on the full barrier with global transitivity implied by the
	 * below xchg() to order the initialization stores above against any
	 * observation of @node. And to provide the ACQUIRE ordering associated
	 * with a LOCK primitive.
	 */
	prev = xchg(lock, node);
	if (likely(prev == NULL)) {
		/*
		 * Lock acquired, don't need to set node->locked to 1. Threads
		 * only spin on its own node->locked value for lock acquisition.
		 * However, since this thread can immediately acquire the lock
		 * and does not proceed to spin on its own node->locked, this
		 * value won't be used. If a debug mode is needed to
		 * audit lock status, then set node->locked value here.
		 */
		return;
	}
	WRITE_ONCE(prev->next, node);

	/* Wait until the lock holder passes the lock down. */
	arch_mcs_spin_lock_contended(&node->locked);
}

/*
 * Releases the lock. The caller should pass in the corresponding node that
 * was used to acquire the lock.
 */
static inline
void mcs_spin_unlock(struct mcs_spinlock **lock, struct mcs_spinlock *node)
{
	struct mcs_spinlock *next = READ_ONCE(node->next);

	if (likely(!next)) {
		/*
		 * Release the lock by setting it to NULL
		 */
		if (likely(cmpxchg_release(lock, node, NULL) == node))
			return;
		/* Wait until the next pointer is set */
		while (!(next = READ_ONCE(node->next)))
			cpu_relax();
	}

	/* Pass lock to next waiter. */
	arch_mcs_spin_unlock_contended(&next->locked);
}

#endif /* __LINUX_MCS_SPINLOCK_H */
#include "AES.h"

AES::AES(const AESKeyLength keyLength) {
  switch (keyLength) {
    case AESKeyLength::AES_128:
      this->Nk = 4;
      this->Nr = 10;
      break;
    case AESKeyLength::AES_192:
      this->Nk = 6;
      this->Nr = 12;
      break;
    case AESKeyLength::AES_256:
      this->Nk = 8;
      this->Nr = 14;
      br